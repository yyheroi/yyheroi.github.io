{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/imgs/image-20230913154437526.png","path":"imgs/image-20230913154437526.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20230913154510439.png","path":"imgs/image-20230913154510439.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20230913154524492.png","path":"imgs/image-20230913154524492.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20230913154559571.png","path":"imgs/image-20230913154559571.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20230913161638961.png","path":"imgs/image-20230913161638961.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20230913161842174.png","path":"imgs/image-20230913161842174.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/gov.png","path":"img/gov.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/titleTip.js","path":"js/titleTip.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","path":"css/fonts/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"source/img/84b0b5e31bb246c0a970ace7c71a3f82.png","path":"img/84b0b5e31bb246c0a970ace7c71a3f82.png","modified":0,"renderable":0},{"_id":"source/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","path":"img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","modified":0,"renderable":0},{"_id":"source/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png","path":"img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png","modified":0,"renderable":0},{"_id":"source/imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png","path":"imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png","modified":0,"renderable":0},{"_id":"source/imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","path":"imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","modified":0,"renderable":0},{"_id":"source/back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","path":"back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","modified":0,"renderable":0},{"_id":"source/back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png","path":"back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png","modified":0,"renderable":0},{"_id":"source/back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png","path":"back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png","modified":0,"renderable":0},{"_id":"source/img/1894089-20230211102247487-1038132289.png","path":"img/1894089-20230211102247487-1038132289.png","modified":0,"renderable":0},{"_id":"source/imgs/1894089-20230211102247487-1038132289.png","path":"imgs/1894089-20230211102247487-1038132289.png","modified":0,"renderable":0},{"_id":"source/imgs/1894089-20230211102659035-421863408.png","path":"imgs/1894089-20230211102659035-421863408.png","modified":0,"renderable":0},{"_id":"source/imgs/1894089-20230211102807063-1324567688.png","path":"imgs/1894089-20230211102807063-1324567688.png","modified":0,"renderable":0},{"_id":"source/imgs/1894089-20230211102825164-1230499662.png","path":"imgs/1894089-20230211102825164-1230499662.png","modified":0,"renderable":0},{"_id":"source/imgs/1894089-20230211104108634-1740893276.png","path":"imgs/1894089-20230211104108634-1740893276.png","modified":0,"renderable":0},{"_id":"source/imgs/1894089-20230211102841861-1500251037.png","path":"imgs/1894089-20230211102841861-1500251037.png","modified":0,"renderable":0},{"_id":"source/imgs/1894089-20230211104238842-2069324840.png","path":"imgs/1894089-20230211104238842-2069324840.png","modified":0,"renderable":0},{"_id":"source/imgs/1894089-20230211104310444-38131101.png","path":"imgs/1894089-20230211104310444-38131101.png","modified":0,"renderable":0},{"_id":"source/imgs/1894089-20230211104336300-896542684.png","path":"imgs/1894089-20230211104336300-896542684.png","modified":0,"renderable":0},{"_id":"source/imgs/image2019-5-10_14-22-29.png","path":"imgs/image2019-5-10_14-22-29.png","modified":0,"renderable":0},{"_id":"source/imgs/image2019-5-10_14-24-0.png","path":"imgs/image2019-5-10_14-24-0.png","modified":0,"renderable":0},{"_id":"source/imgs/image2019-5-10_14-24-58.png","path":"imgs/image2019-5-10_14-24-58.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240517154457324-17159319055301.png","path":"imgs/image-20240517154457324-17159319055301.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240517154457324.png","path":"imgs/image-20240517154457324.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240517171503577.png","path":"imgs/image-20240517171503577.png","modified":0,"renderable":0},{"_id":"source/imgs/10679e86d7d5de085f10f418602d3fc0.png","path":"imgs/10679e86d7d5de085f10f418602d3fc0.png","modified":0,"renderable":0},{"_id":"source/imgs/38433cbf3936910bd982dbe3edad457f.png","path":"imgs/38433cbf3936910bd982dbe3edad457f.png","modified":0,"renderable":0},{"_id":"source/imgs/8191070c413a2f5053f4fa1fff32375d.png","path":"imgs/8191070c413a2f5053f4fa1fff32375d.png","modified":0,"renderable":0},{"_id":"source/imgs/675b07d51113aeaf1b18b08b1fda130b.png","path":"imgs/675b07d51113aeaf1b18b08b1fda130b.png","modified":0,"renderable":0},{"_id":"source/imgs/9a41a7910eae90cbc4133263b56065b4.png","path":"imgs/9a41a7910eae90cbc4133263b56065b4.png","modified":0,"renderable":0},{"_id":"source/imgs/84fe4ccf655091b45ffcad9c61def517.png","path":"imgs/84fe4ccf655091b45ffcad9c61def517.png","modified":0,"renderable":0},{"_id":"source/imgs/a1e47db6d3e144affe47566fed629e9e.png","path":"imgs/a1e47db6d3e144affe47566fed629e9e.png","modified":0,"renderable":0},{"_id":"source/imgs/b5509514fe3ed5e171527650e89113df.png","path":"imgs/b5509514fe3ed5e171527650e89113df.png","modified":0,"renderable":0},{"_id":"source/back_posts/count_file.sh","path":"back_posts/count_file.sh","modified":0,"renderable":0},{"_id":"source/imgs/0a6cf9231486414a8095f6dd113a2c7d.png","path":"imgs/0a6cf9231486414a8095f6dd113a2c7d.png","modified":0,"renderable":0},{"_id":"source/imgs/2a8ad08662864bc293b3c520e486c473.png","path":"imgs/2a8ad08662864bc293b3c520e486c473.png","modified":0,"renderable":0},{"_id":"source/imgs/2ef32c1ce3654484b236af25368bdab1.png","path":"imgs/2ef32c1ce3654484b236af25368bdab1.png","modified":0,"renderable":0},{"_id":"source/imgs/325ec497200142f98be97ec17d2c9cf3.png","path":"imgs/325ec497200142f98be97ec17d2c9cf3.png","modified":0,"renderable":0},{"_id":"source/imgs/36d83bdde0524001a910df7a8c9c3083.png","path":"imgs/36d83bdde0524001a910df7a8c9c3083.png","modified":0,"renderable":0},{"_id":"source/imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png","path":"imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png","modified":0,"renderable":0},{"_id":"source/imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png","path":"imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png","modified":0,"renderable":0},{"_id":"source/imgs/efcc46bc1fb845e898a37da989107ef9.png","path":"imgs/efcc46bc1fb845e898a37da989107ef9.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240530170508734.png","path":"imgs/image-20240530170508734.png","modified":0,"renderable":0},{"_id":"source/imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif","path":"imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif","modified":0,"renderable":0},{"_id":"source/imgs/2704972-20220410142315999-1415044429.jpg","path":"imgs/2704972-20220410142315999-1415044429.jpg","modified":0,"renderable":0},{"_id":"source/imgs/2b8686c61a24478a8112e4b83228f177.png","path":"imgs/2b8686c61a24478a8112e4b83228f177.png","modified":0,"renderable":0},{"_id":"source/imgs/d32faea7d5004b979cc98527aa0973e8.png","path":"imgs/d32faea7d5004b979cc98527aa0973e8.png","modified":0,"renderable":0},{"_id":"source/imgs/82c684268ac443d191e73eb73b60aec4.png","path":"imgs/82c684268ac443d191e73eb73b60aec4.png","modified":0,"renderable":0},{"_id":"source/imgs/cce3ff865e6348cb9da8625fe5b92fe0.png","path":"imgs/cce3ff865e6348cb9da8625fe5b92fe0.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702211605888.png","path":"imgs/image-20240702211605888.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702212534790.png","path":"imgs/image-20240702212534790.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702214224123.png","path":"imgs/image-20240702214224123.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702220340059.png","path":"imgs/image-20240702220340059.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702220502413.png","path":"imgs/image-20240702220502413.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702220828261.png","path":"imgs/image-20240702220828261.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702220705763.png","path":"imgs/image-20240702220705763.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702220932130.png","path":"imgs/image-20240702220932130.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702221037900.png","path":"imgs/image-20240702221037900.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702221620487.png","path":"imgs/image-20240702221620487.png","modified":0,"renderable":0},{"_id":"source/imgs/image-20240702222853017.png","path":"imgs/image-20240702222853017.png","modified":0,"renderable":0},{"_id":"source/imgs/xiaoaiui.png","path":"imgs/xiaoaiui.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702211605888.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702211605888.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702214224123.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702214224123.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702212534790.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702212534790.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220340059.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702220340059.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220502413.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702220502413.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220705763.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702220705763.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220828261.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702220828261.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702221037900.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702221037900.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220932130.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702220932130.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702222853017.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702222853017.png","modified":0,"renderable":0},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702221620487.png","path":"back_posts/小爱同学控制电脑开关.assets/image-20240702221620487.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/00-rust学习网站.md","hash":"ef43232f54b328d6331469557c4e0102a30dd417","modified":1715754396420},{"_id":"source/_posts/01-rust环境搭建.md","hash":"4c0f2bf37246a6be0f2a1b4c50da3722a42cc2a9","modified":1714288418745},{"_id":"source/_posts/03-rust复合类型.md","hash":"a685e502e9b04520bf35f50947f30836ed21c045","modified":1714288418746},{"_id":"source/_posts/02-rust基本类型.md","hash":"dd43f2a740d88aa19ed009ea66180206718fbe9e","modified":1714288418746},{"_id":"source/_posts/Hexo在多台电脑上提交和更新.md","hash":"e12a758b512c7cbc53fdca37286bdd057047f592","modified":1714288676763},{"_id":"source/_posts/cpufreq.md","hash":"212808c45db59127f44516bfecd5fb278e50a0dd","modified":1717673983154},{"_id":"source/_posts/github+hexo博客搭建.md","hash":"85bd7eb698db516682385515b622694385fc8e14","modified":1714288418769},{"_id":"source/_posts/hello-world.md","hash":"abfe52bd7857c6997069eef12c9cc7bf35918421","modified":1714288418770},{"_id":"source/imgs/image-20230913154437526.png","hash":"9693caf3cc21eae7a101d17fa3773fd662a67458","modified":1714288418811},{"_id":"source/imgs/image-20230913154524492.png","hash":"93e1edcb969e6ab1b921e40c4181a41a35df6626","modified":1714288418813},{"_id":"source/imgs/image-20230913154510439.png","hash":"51bd7ce03a392ca543c2600eed536a3e681fe4e1","modified":1714288418812},{"_id":"source/imgs/image-20230913154559571.png","hash":"ffeb7e12c2271cca2c1e9e4bf26b513add8096fd","modified":1714288418814},{"_id":"source/imgs/image-20230913161842174.png","hash":"618c9c7b1bf25a26b97352bbd1b5b74d8a0f99e1","modified":1714288418816},{"_id":"source/imgs/image-20230913161638961.png","hash":"14a58ce37072ca0e819bae203a82aae720546ebc","modified":1714288418815},{"_id":"themes/3-hexo/.gitignore","hash":"86a50fa08e69cab561892aa5edef24f9081bbde1","modified":1714288418819},{"_id":"themes/3-hexo/_config.yml","hash":"55af6e6ec98d5400290267ea9f7edc71482a0d4f","modified":1717380601788},{"_id":"themes/3-hexo/LICENSE","hash":"b04140c5f682db2b300428f97bb164fd7f5f18bd","modified":1714288418820},{"_id":"themes/3-hexo/languages/en.yml","hash":"53ae29ae1237fc7822df85a6d2f8da6f0078625e","modified":1714288418822},{"_id":"themes/3-hexo/README.md","hash":"d2c42534ceabcb7cd2e58ed994bf7d6f734d1f3b","modified":1714288418820},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"d2c6d86fe2ff03e6ee9bbc16dff8efe5b47ac297","modified":1714288418823},{"_id":"themes/3-hexo/layout/index.ejs","hash":"27ea3dac053d501b79bbef5117b4f3aff063d8cd","modified":1714288418839},{"_id":"themes/3-hexo/layout/post.ejs","hash":"4abd16c0f5e3f51103d23b73710d695dc7fdc5d2","modified":1714288418840},{"_id":"themes/3-hexo/layout/indexs.md","hash":"9aba38b192c510e94f34b37347f120475604a088","modified":1714288418839},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"516844c4a0e13d6773f6029849f51c59613b6f69","modified":1714288418825},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"0ebb17d001cb7bb7606c616c380049a2e7124496","modified":1714288418825},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1714288418826},{"_id":"themes/3-hexo/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0e662956cbfcaf6c1666e5c30a1fe03461de685e","modified":1714288418818},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"f66939a8c9d5258948b47842b8b4495e6ec45988","modified":1714288418831},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"bc94eee27701b67d238f328737b578e8270989eb","modified":1714288418832},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"d11092791e5c140ff81f2aefa0d1b051f403239d","modified":1714288418834},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"ed479aa9affee3b02a76da06de45a7c40a97a706","modified":1714288418833},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"a734c26d86da6697003ed27672c1b9b82b216c82","modified":1714288418834},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"76768204853a8a5e030a96d605a247f9686cf994","modified":1714288418835},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1714288418836},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"8a9e93f9cbe80763264018290da0b14b4bbe8ac5","modified":1714288418836},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"cbad17074f7a44520b4c7dad5a515d6aaf5e1e14","modified":1714288418837},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"e205f9bb61fd4403d24d863693d4a34ea31b8539","modified":1714288418837},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"3cf8ba0c6112dfa8089603b8df3e31f70a272715","modified":1714288418838},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1714288418838},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1714288418856},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1714288418869},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"59a4abd36cc8ff2107f1fcb3c0fe48d0492c9030","modified":1714288418867},{"_id":"themes/3-hexo/source/css/style.styl","hash":"7090b81f34e26172670c68da6a366ca186523779","modified":1714288418868},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1714288418871},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1714288418871},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1714288418873},{"_id":"themes/3-hexo/source/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1714288418873},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1714288418872},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1714288418881},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1714288418882},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"f16442568b43d034faaa8e3507f5ae8da34c7b72","modified":1714288418830},{"_id":"themes/3-hexo/source/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1714288418883},{"_id":"themes/3-hexo/source/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1714288418884},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"fbd3c7d72c8354d700918390c6cbfc0a11408277","modified":1714288418829},{"_id":"themes/3-hexo/layout/_partial/comments/livere.ejs","hash":"e820aa16b5ed4e024616b5e2d424925820d43e56","modified":1714288418830},{"_id":"themes/3-hexo/source/js/script.js","hash":"61e8ba1228d8441144fa7a655aa02ec546bd1f02","modified":1714288418883},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"fa6675230f8c313236604e26926b142f4f418bdd","modified":1714288418827},{"_id":"themes/3-hexo/layout/_partial/comments/utteranc.ejs","hash":"c76773b96860940083baf16470b7b80ac098e645","modified":1714288418831},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c68d6942ed62f9cce8a9042f5a59055a0ee5441c","modified":1714288418843},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1714288418842},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"2a9b5ffb759be85545a89f6d1194579a800f51a5","modified":1714288418841},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1714288418828},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"d35df7f5e68880d1f1ebec541b816f8257fd42cb","modified":1714288418844},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1714288418843},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1714288418846},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"0143711c1221cb4e70a3db866754d79c8a81d253","modified":1714288418844},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"36b47f4221e9bccae8e6f1685ea8942e601766d6","modified":1714288418845},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1714288418846},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1714288418857},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"0dd8d208081b92e05d6db3361743c520a2816828","modified":1714288418847},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"553987211d3323a7dfc0b08786b183a3435978c9","modified":1714288418858},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1714288418860},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1714288418859},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1714288418858},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1714288418859},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1714288418863},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1714288418861},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1714288418864},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1714288418861},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1714288418862},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1714288418864},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1714288418866},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1714288418863},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1714288418867},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1714288418848},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1714288418851},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1714288418851},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1714288418865},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1714288418849},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1714288418850},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1714288418852},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1714288418853},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1714288418854},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1714288418855},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1714288418854},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1714288418875},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1714288418881},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"26ba4841dcb4b178f730f53a8d1f4a7c89442b4f","modified":1714288418879},{"_id":"public/search.xml","hash":"569114f34db4564c1df722b0949f3cc4b38e9d00","modified":1719931255898},{"_id":"public/2024/04/28/cpufreq/index.html","hash":"39f7084539daa1b60916de6cad6339c6fc98b3c0","modified":1719931747442},{"_id":"public/2023/09/13/Hexo在多台电脑上提交和更新/index.html","hash":"0a2b45c17d82b8b275fc074d1a0ad0a7433055c8","modified":1719931747442},{"_id":"public/2023/08/28/03-rust复合类型/index.html","hash":"0f3164176c07d16aa6e43aa0d7734b3067f2b0a0","modified":1719931747442},{"_id":"public/2023/08/26/02-rust基本类型/index.html","hash":"005036432b0c65fdbe9121d4c9b6b7dad040c89e","modified":1719931747442},{"_id":"public/2023/08/26/01-rust环境搭建/index.html","hash":"413615e224c7ff16f7e5421c6ca059bdd32e40f7","modified":1719931747442},{"_id":"public/2023/08/26/00-rust学习网站/index.html","hash":"39b9728077441408caa5663a479b4b08b701eceb","modified":1719931747442},{"_id":"public/2023/08/25/github+hexo博客搭建/index.html","hash":"4d4cdda9e48200df7ccf7fa74081b64be289b7aa","modified":1719931747442},{"_id":"public/2023/08/25/hello-world/index.html","hash":"25381b52f1d5b623516913ff860fc51a7e71bc70","modified":1719931747442},{"_id":"public/archives/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/archives/2023/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/archives/2023/08/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/archives/2023/09/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/archives/2024/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/archives/2024/04/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/categories/rust/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/categories/test/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/学习网站/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/categories/kernel/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/power/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/rust/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/rust环境搭建/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/test/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/cpufreq/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/rust基本类型/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/rust复合类型/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/imgs/image-20230913154510439.png","hash":"51bd7ce03a392ca543c2600eed536a3e681fe4e1","modified":1716614526786},{"_id":"public/imgs/image-20230913154559571.png","hash":"ffeb7e12c2271cca2c1e9e4bf26b513add8096fd","modified":1716614526786},{"_id":"public/imgs/image-20230913154524492.png","hash":"93e1edcb969e6ab1b921e40c4181a41a35df6626","modified":1716614526786},{"_id":"public/imgs/image-20230913154437526.png","hash":"9693caf3cc21eae7a101d17fa3773fd662a67458","modified":1716614526786},{"_id":"public/imgs/image-20230913161842174.png","hash":"618c9c7b1bf25a26b97352bbd1b5b74d8a0f99e1","modified":1716614526786},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1716614526786},{"_id":"public/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1716614526786},{"_id":"public/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1716614526786},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1716614526786},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1716614526786},{"_id":"public/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1716614526786},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1716614526786},{"_id":"public/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1716614526786},{"_id":"public/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1716614526786},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1716614526786},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1716614526786},{"_id":"public/css/fonts/iconfont.svg","hash":"13974fe35fca836e870a960ecb11b7eca2e036f8","modified":1716614526786},{"_id":"public/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1716614526786},{"_id":"public/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1716614526786},{"_id":"public/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1716614526786},{"_id":"public/imgs/image-20230913161638961.png","hash":"14a58ce37072ca0e819bae203a82aae720546ebc","modified":1716614526786},{"_id":"public/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1716614526786},{"_id":"public/css/mobile.css","hash":"5998f6fc27998596beb1e40e4bc3c43be2ed764c","modified":1716614526786},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1716614526786},{"_id":"public/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1716614526786},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1716614526786},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1716614526786},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1716614526786},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1716614526786},{"_id":"public/css/hl_theme/atom-light.css","hash":"d31edb9816dae6b01410028bceb91757a962f780","modified":1716614526786},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1716614526786},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1716614526786},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1716614526786},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1716614526786},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1716614526786},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1716614526786},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1716614526786},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1716614526786},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1716614526786},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1716614526786},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1716614526786},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1716614526786},{"_id":"public/css/style.css","hash":"c7adbb2af0e65ecd85f8c06851f34d377d4b834c","modified":1716614526786},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1716614526786},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1716614526786},{"_id":"public/js/script.js","hash":"61e8ba1228d8441144fa7a655aa02ec546bd1f02","modified":1716614526786},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1716614526786},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1716614526786},{"_id":"public/js/gitalk.js","hash":"26ba4841dcb4b178f730f53a8d1f4a7c89442b4f","modified":1716614526786},{"_id":"source/_posts/uboot-fdt.md","hash":"000f5314305a9fa5cc319b3ea7d6d978289b2a53","modified":1715754303532},{"_id":"source/_posts/OSTEP-40-文件系统实现.md","hash":"454c27352e2830ccfab8138969d18de95f9ec800","modified":1715754500891},{"_id":"source/_posts/linux块设备驱动.md","hash":"b8a1c65e95a7601d9b1ab7232a0cbfb5ae11b13b","modified":1715754470467},{"_id":"source/back_posts/00-rust学习网站.md","hash":"ef43232f54b328d6331469557c4e0102a30dd417","modified":1715756060707},{"_id":"source/back_posts/02-rust基本类型.md","hash":"dd43f2a740d88aa19ed009ea66180206718fbe9e","modified":1715753468980},{"_id":"source/back_posts/03-rust复合类型.md","hash":"a685e502e9b04520bf35f50947f30836ed21c045","modified":1715753468981},{"_id":"source/back_posts/01-rust环境搭建.md","hash":"4c0f2bf37246a6be0f2a1b4c50da3722a42cc2a9","modified":1715753468969},{"_id":"source/back_posts/Hexo在多台电脑上提交和更新.md","hash":"e12a758b512c7cbc53fdca37286bdd057047f592","modified":1715753468981},{"_id":"source/back_posts/OSTEP-40-文件系统实现.md","hash":"dbd3f4f4675948185f284fa0d0242db82c715cfc","modified":1715753468982},{"_id":"source/back_posts/cpufreq.md","hash":"212808c45db59127f44516bfecd5fb278e50a0dd","modified":1717674085795},{"_id":"source/back_posts/github+hexo博客搭建.md","hash":"85bd7eb698db516682385515b622694385fc8e14","modified":1715753468990},{"_id":"source/back_posts/linux块设备驱动.md","hash":"86323d12a2c1fd3ebbbaa19e899ff55db6c6be8a","modified":1715753468991},{"_id":"source/back_posts/uboot之fdt.md","hash":"4e5aa13f6525b5806f06572124fd91a69e46222a","modified":1715753468992},{"_id":"source/back_posts/hello-world.md","hash":"abfe52bd7857c6997069eef12c9cc7bf35918421","modified":1715753468991},{"_id":"public/back_posts/02-rust基本类型.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/03-rust复合类型.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/cpufreq.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/01-rust环境搭建.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/github+hexo博客搭建.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/hello-world.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/Hexo在多台电脑上提交和更新.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/00-rust学习网站.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/linux块设备驱动.html","hash":"c250cf48bf57f618adaf83a28012e5e119bddce9","modified":1719931747442},{"_id":"public/back_posts/OSTEP-40-文件系统实现.html","hash":"236aa70290b0dde3e1613dcba7ca2ef6d6d2d590","modified":1719931747442},{"_id":"public/back_posts/uboot之fdt.html","hash":"53b4fab2657e8414ac83c7a8222912688153a90a","modified":1719931747442},{"_id":"public/2024/05/15/uboot-fdt/index.html","hash":"b45e62ab6025c01b0d35f0aab1ea2f1c0288e49f","modified":1715754726255},{"_id":"public/2024/05/15/linux块设备驱动/index.html","hash":"a4b89b703bdae8e886367625233bbe0c4a8b2b1f","modified":1715754726255},{"_id":"public/2024/05/06/OSTEP-40-文件系统实现/index.html","hash":"afdb3efa53aa5268ec6ec038c5f956af4cac9685","modified":1715754112053},{"_id":"public/archives/page/2/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/archives/2024/05/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/page/2/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/2024/05/15/OSTEP-40-文件系统实现/index.html","hash":"ee5d6ebf7e825f29064ded1e4f562f8b771c7843","modified":1715754726255},{"_id":"source/_posts/U-Boot-fdt-GPT.md","hash":"4b6af68d08a516b2460136c6ee1e564bf62f6274","modified":1715755822548},{"_id":"source/_posts/OSTEP-40-VSFS.md","hash":"e72a9f32ba2fa96b4f7d5ff4c3a4b2bea60cf516","modified":1715755972721},{"_id":"source/_posts/linux-block.md","hash":"2addf204e4bb8415357f5714032592f65022de7e","modified":1715755916921},{"_id":"public/2024/05/15/OSTEP-40-VSFS/index.html","hash":"4dabf9e96acc4c070c5a58c6b1d24f1df0f695c5","modified":1719931747442},{"_id":"public/2024/05/15/U-Boot-fdt-GPT/index.html","hash":"44d2ceb2dbbc2a031357cae0d1155160833e3fa3","modified":1719931747442},{"_id":"public/2024/05/15/linux-block/index.html","hash":"949576ae944e90bb76922c29f4fd8a938379f79a","modified":1719931747442},{"_id":"public/categories/OSTEP/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/categories/linux/index.html","hash":"6e861d6ec883b0a74b061167ca3830acebe62c56","modified":1715755545023},{"_id":"public/tags/block/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/uboot/index.html","hash":"6e861d6ec883b0a74b061167ca3830acebe62c56","modified":1715755545023},{"_id":"public/tags/fdt/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/rk3588/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/GPT/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/categories/uboot/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/categories/driver/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/vsfs/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"source/back_posts/OSTEP-40-VSFS.md","hash":"e72a9f32ba2fa96b4f7d5ff4c3a4b2bea60cf516","modified":1715756060710},{"_id":"source/back_posts/U-Boot-fdt-GPT.md","hash":"4b6af68d08a516b2460136c6ee1e564bf62f6274","modified":1715756060711},{"_id":"source/back_posts/linux-block.md","hash":"2addf204e4bb8415357f5714032592f65022de7e","modified":1715756060713},{"_id":"public/back_posts/OSTEP-40-VSFS.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/linux-block.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/U-Boot-fdt-GPT.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"source/_posts/uboot-01-概念.md","hash":"1187308c94ad8375469d649f544a5cb1067f11d2","modified":1715837496959},{"_id":"public/2024/05/15/uboot-01-概念/index.html","hash":"bdfdbec1e3f8b8751e4b96744d3aa13bae1d5d69","modified":1719931747442},{"_id":"public/tags/uboot概念/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"source/_posts/cgroup.md","hash":"7a7cc20e8a798798b392e2d49084a9a1c49357b8","modified":1715853613008},{"_id":"source/_posts/pinctrl.md","hash":"6b3e746052651223d86dc6c855664adad6585921","modified":1717480648917},{"_id":"public/2024/05/16/pinctrl/index.html","hash":"a9f37c5e0eaf339186b9b725015024fcc966511c","modified":1719931747442},{"_id":"public/2024/05/16/cgroup/index.html","hash":"f33c0e91d19569b511b2cea2f04f7476d8f176df","modified":1719931747442},{"_id":"public/tags/cgroup/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/pinctrl/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"source/back_posts/uboot-01-概念.md","hash":"1187308c94ad8375469d649f544a5cb1067f11d2","modified":1715844943760},{"_id":"source/back_posts/pinctrl.md","hash":"6b3e746052651223d86dc6c855664adad6585921","modified":1717480711119},{"_id":"source/_posts/PHY芯片.md","hash":"3a7b16b2c0c62d8dc7f503f751c80622f0591da3","modified":1715860371715},{"_id":"source/back_posts/cgroup.md","hash":"7a7cc20e8a798798b392e2d49084a9a1c49357b8","modified":1715857286743},{"_id":"public/back_posts/cgroup.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/uboot-01-概念.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/pinctrl.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/2024/05/16/PHY芯片/index.html","hash":"8e238d5619d4552bb3a244e35ce8a0cbf03d21dd","modified":1719931747442},{"_id":"public/tags/PHY芯片/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"source/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png","hash":"7e3789d8fb2bcf7e4dad182a698dc8625735002a","modified":1715859649660},{"_id":"source/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","hash":"28af7bbe758244cd040a7763b86d29bc51a755e5","modified":1715860641553},{"_id":"source/back_posts/PHY芯片.md","hash":"3a7b16b2c0c62d8dc7f503f751c80622f0591da3","modified":1715860399725},{"_id":"source/imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png","hash":"9c9e454c3032a583f0d7449a8f21818f3b3cd35f","modified":1715859075855},{"_id":"source/_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png","hash":"9c9e454c3032a583f0d7449a8f21818f3b3cd35f","modified":1715859066327},{"_id":"source/_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png","hash":"9c9e454c3032a583f0d7449a8f21818f3b3cd35f","modified":1715858910742},{"_id":"source/img/84b0b5e31bb246c0a970ace7c71a3f82.png","hash":"ddf5bc08e2bcc4f354513360a3afbc09465a71c6","modified":1715859145462},{"_id":"source/imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","hash":"28af7bbe758244cd040a7763b86d29bc51a755e5","modified":1715859046341},{"_id":"source/_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","hash":"28af7bbe758244cd040a7763b86d29bc51a755e5","modified":1715859015033},{"_id":"public/back_posts/PHY芯片.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png","hash":"9c9e454c3032a583f0d7449a8f21818f3b3cd35f","modified":1716614526786},{"_id":"public/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png","hash":"7e3789d8fb2bcf7e4dad182a698dc8625735002a","modified":1716614526786},{"_id":"public/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","hash":"28af7bbe758244cd040a7763b86d29bc51a755e5","modified":1716614526786},{"_id":"public/img/84b0b5e31bb246c0a970ace7c71a3f82.png","hash":"ddf5bc08e2bcc4f354513360a3afbc09465a71c6","modified":1716614526786},{"_id":"public/imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","hash":"28af7bbe758244cd040a7763b86d29bc51a755e5","modified":1716614526786},{"_id":"source/back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png","hash":"9c9e454c3032a583f0d7449a8f21818f3b3cd35f","modified":1715859797810},{"_id":"source/back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png","hash":"9c9e454c3032a583f0d7449a8f21818f3b3cd35f","modified":1715859797809},{"_id":"source/back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","hash":"28af7bbe758244cd040a7763b86d29bc51a755e5","modified":1715859797811},{"_id":"public/back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png","hash":"9c9e454c3032a583f0d7449a8f21818f3b3cd35f","modified":1716614526786},{"_id":"public/back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png","hash":"9c9e454c3032a583f0d7449a8f21818f3b3cd35f","modified":1716614526786},{"_id":"public/back_posts/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png","hash":"28af7bbe758244cd040a7763b86d29bc51a755e5","modified":1716614526786},{"_id":"source/_posts/Clion202204-破解.md","hash":"23126721c2a5592a74e9a1cceb4bd76295d2f470","modified":1715912107580},{"_id":"source/img/1894089-20230211102247487-1038132289.png","hash":"749daada526a12cb78fd83232e2ae809954df822","modified":1715911897893},{"_id":"source/imgs/1894089-20230211102247487-1038132289.png","hash":"749daada526a12cb78fd83232e2ae809954df822","modified":1715911930290},{"_id":"source/imgs/1894089-20230211102659035-421863408.png","hash":"8d0e308b35c8a83509be2df48ef62bc173622ac3","modified":1715911955346},{"_id":"source/imgs/1894089-20230211102807063-1324567688.png","hash":"1fcdc845ec0398af9eae2298c2e04bcb0d24ef04","modified":1715911967821},{"_id":"source/imgs/1894089-20230211102825164-1230499662.png","hash":"36465ed9a4350ec4ac9d6eddf44a616e2998c14e","modified":1715911980700},{"_id":"source/imgs/1894089-20230211104108634-1740893276.png","hash":"77cecf9488c61f256638742f93b48fe3475ac76f","modified":1715912039044},{"_id":"source/imgs/1894089-20230211102841861-1500251037.png","hash":"157e64012e0aea95de9cde4ea31953d3c3a8d500","modified":1715911996164},{"_id":"source/imgs/1894089-20230211104238842-2069324840.png","hash":"b15920961a728ee394ae96a40cdc8a1381a07c6a","modified":1715912053674},{"_id":"source/imgs/1894089-20230211104336300-896542684.png","hash":"e4c7a69f636093ddefb405f938acd966ff488b94","modified":1715912075284},{"_id":"source/imgs/1894089-20230211104310444-38131101.png","hash":"c9c241f06eacd70fd9052eca1cba0db0d6608a86","modified":1715912060939},{"_id":"public/2024/05/17/Clion202204-破解/index.html","hash":"31732352ae46fb2052519e1395a3d0374932fb95","modified":1719931747442},{"_id":"public/tags/Clion/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/img/1894089-20230211102247487-1038132289.png","hash":"749daada526a12cb78fd83232e2ae809954df822","modified":1716614526786},{"_id":"public/imgs/1894089-20230211102807063-1324567688.png","hash":"1fcdc845ec0398af9eae2298c2e04bcb0d24ef04","modified":1716614526786},{"_id":"public/imgs/1894089-20230211102659035-421863408.png","hash":"8d0e308b35c8a83509be2df48ef62bc173622ac3","modified":1716614526786},{"_id":"public/imgs/1894089-20230211102247487-1038132289.png","hash":"749daada526a12cb78fd83232e2ae809954df822","modified":1716614526786},{"_id":"public/imgs/1894089-20230211102825164-1230499662.png","hash":"36465ed9a4350ec4ac9d6eddf44a616e2998c14e","modified":1716614526786},{"_id":"public/imgs/1894089-20230211104108634-1740893276.png","hash":"77cecf9488c61f256638742f93b48fe3475ac76f","modified":1716614526786},{"_id":"public/imgs/1894089-20230211102841861-1500251037.png","hash":"157e64012e0aea95de9cde4ea31953d3c3a8d500","modified":1716614526786},{"_id":"public/imgs/1894089-20230211104238842-2069324840.png","hash":"b15920961a728ee394ae96a40cdc8a1381a07c6a","modified":1716614526786},{"_id":"public/imgs/1894089-20230211104336300-896542684.png","hash":"e4c7a69f636093ddefb405f938acd966ff488b94","modified":1716614526786},{"_id":"public/imgs/1894089-20230211104310444-38131101.png","hash":"c9c241f06eacd70fd9052eca1cba0db0d6608a86","modified":1716614526786},{"_id":"source/imgs/image2019-5-10_14-24-0.png","hash":"01423550e6b62f1d34c49e5193afee5471cceb28","modified":1715928999772},{"_id":"source/imgs/image2019-5-10_14-24-58.png","hash":"111b363b9b6208d4726b9baf9089b1be1d4b1161","modified":1715929062810},{"_id":"source/_posts/ARMv8架构-内存虚拟化.md","hash":"4510bfc884c24c8be9ba62e4830114e855a5972d","modified":1715929103667},{"_id":"source/back_posts/Clion202204-破解.md","hash":"23126721c2a5592a74e9a1cceb4bd76295d2f470","modified":1715912141294},{"_id":"source/imgs/image2019-5-10_14-22-29.png","hash":"0ec4fd02514d8e181a72cd686a8101f1ce472f4e","modified":1715928935602},{"_id":"public/back_posts/Clion202204-破解.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/2024/05/17/ARMv8架构-内存虚拟化/index.html","hash":"48c1a300680a00ca8e686b49a7ef225846e32b52","modified":1719931747442},{"_id":"public/imgs/image2019-5-10_14-24-0.png","hash":"01423550e6b62f1d34c49e5193afee5471cceb28","modified":1716614526786},{"_id":"public/imgs/image2019-5-10_14-24-58.png","hash":"111b363b9b6208d4726b9baf9089b1be1d4b1161","modified":1716614526786},{"_id":"public/imgs/image2019-5-10_14-22-29.png","hash":"0ec4fd02514d8e181a72cd686a8101f1ce472f4e","modified":1716614526786},{"_id":"source/_posts/vscode-安装-卸载.md","hash":"41a7edd944686cec44190b042d87fa51ac22d85a","modified":1715932115852},{"_id":"source/back_posts/ARMv8架构-内存虚拟化.md","hash":"4510bfc884c24c8be9ba62e4830114e855a5972d","modified":1715929150584},{"_id":"source/imgs/image-20240517154457324-17159319055301.png","hash":"49ca06e7f8c96a4109325adc1a23e9bf1afa0cdd","modified":1715931905534},{"_id":"source/imgs/image-20240517154457324.png","hash":"49ca06e7f8c96a4109325adc1a23e9bf1afa0cdd","modified":1715931897340},{"_id":"public/back_posts/ARMv8架构-内存虚拟化.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/2024/05/17/vscode-安装-卸载/index.html","hash":"b99d2ae77b186132a983e6c9e444001b3afe51a2","modified":1719931747442},{"_id":"public/archives/2024/page/2/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/vscode/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/imgs/image-20240517154457324-17159319055301.png","hash":"49ca06e7f8c96a4109325adc1a23e9bf1afa0cdd","modified":1716614526786},{"_id":"public/imgs/image-20240517154457324.png","hash":"49ca06e7f8c96a4109325adc1a23e9bf1afa0cdd","modified":1716614526786},{"_id":"source/_posts/vscode-远程连接失败.md","hash":"b7036ca313246738d913b44dcee2968fd1850d0d","modified":1715937427395},{"_id":"source/imgs/image-20240517171503577.png","hash":"4ed73a232351761e6c1b3d20d64e6c9089f8c649","modified":1715937303579},{"_id":"source/back_posts/vscode-安装-卸载.md","hash":"41a7edd944686cec44190b042d87fa51ac22d85a","modified":1715932223361},{"_id":"public/back_posts/vscode-安装-卸载.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/2024/05/17/vscode-远程连接失败/index.html","hash":"c2031075d42bbf95e26c2ea894a143f029ce2846","modified":1719931747442},{"_id":"public/archives/2024/05/page/2/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/imgs/image-20240517171503577.png","hash":"4ed73a232351761e6c1b3d20d64e6c9089f8c649","modified":1716614526786},{"_id":"source/_posts/Windows下通过ssh挂载远程服务器目录.md","hash":"d7a7caead3412abd79b043271a51c09565a35b56","modified":1716607949479},{"_id":"source/imgs/38433cbf3936910bd982dbe3edad457f.png","hash":"30371a5d4ceaa5ff024097958068e738a22accf4","modified":1716607693218},{"_id":"source/imgs/675b07d51113aeaf1b18b08b1fda130b.png","hash":"46b6849b257efa4effb6cd4f321161965984736e","modified":1716607925249},{"_id":"source/imgs/8191070c413a2f5053f4fa1fff32375d.png","hash":"c3db1c9f9cf0f6ce40433f53e1831926825456b9","modified":1716607748090},{"_id":"source/imgs/10679e86d7d5de085f10f418602d3fc0.png","hash":"d77c1d526c639276cb6ee56788691879cd19cc01","modified":1716607707589},{"_id":"source/imgs/9a41a7910eae90cbc4133263b56065b4.png","hash":"1fc80299bb14f1241f50c83d8b94f94cc1dd3dc2","modified":1716607736946},{"_id":"source/imgs/a1e47db6d3e144affe47566fed629e9e.png","hash":"a67eb2eb075457c0b27cdf1d1a076079e0947605","modified":1716607917721},{"_id":"source/imgs/b5509514fe3ed5e171527650e89113df.png","hash":"1b58bb59fd016ad0a74c5ccef22bd0422563dc90","modified":1716607723031},{"_id":"source/imgs/84fe4ccf655091b45ffcad9c61def517.png","hash":"5bfa8341c2e9d5aecbb5f6c77740fc3618bb2115","modified":1716607930560},{"_id":"public/2024/05/25/Windows下通过ssh挂载远程服务器目录/index.html","hash":"7e61caca0dfc69541b3634e55f57422a6446ddc2","modified":1719931747442},{"_id":"public/imgs/10679e86d7d5de085f10f418602d3fc0.png","hash":"d77c1d526c639276cb6ee56788691879cd19cc01","modified":1716614526786},{"_id":"public/imgs/38433cbf3936910bd982dbe3edad457f.png","hash":"30371a5d4ceaa5ff024097958068e738a22accf4","modified":1716614526786},{"_id":"public/imgs/8191070c413a2f5053f4fa1fff32375d.png","hash":"c3db1c9f9cf0f6ce40433f53e1831926825456b9","modified":1716614526786},{"_id":"public/imgs/9a41a7910eae90cbc4133263b56065b4.png","hash":"1fc80299bb14f1241f50c83d8b94f94cc1dd3dc2","modified":1716614526786},{"_id":"public/imgs/84fe4ccf655091b45ffcad9c61def517.png","hash":"5bfa8341c2e9d5aecbb5f6c77740fc3618bb2115","modified":1716614526786},{"_id":"public/imgs/675b07d51113aeaf1b18b08b1fda130b.png","hash":"46b6849b257efa4effb6cd4f321161965984736e","modified":1716614526786},{"_id":"public/imgs/a1e47db6d3e144affe47566fed629e9e.png","hash":"a67eb2eb075457c0b27cdf1d1a076079e0947605","modified":1716614526786},{"_id":"public/imgs/b5509514fe3ed5e171527650e89113df.png","hash":"1b58bb59fd016ad0a74c5ccef22bd0422563dc90","modified":1716614526786},{"_id":"source/_posts/count_file.sh","hash":"385a8f45d002a855222d9ac8f40998fa6ca72c5c","modified":1716608240493},{"_id":"source/back_posts/Windows下通过ssh挂载远程服务器目录.md","hash":"d7a7caead3412abd79b043271a51c09565a35b56","modified":1716608005837},{"_id":"source/back_posts/vscode-远程连接失败.md","hash":"b7036ca313246738d913b44dcee2968fd1850d0d","modified":1716608005895},{"_id":"public/back_posts/Windows下通过ssh挂载远程服务器目录.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"public/back_posts/vscode-远程连接失败.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716614526786},{"_id":"source/back_posts/count_file.sh","hash":"385a8f45d002a855222d9ac8f40998fa6ca72c5c","modified":1716608484226},{"_id":"public/back_posts/count_file.sh","hash":"385a8f45d002a855222d9ac8f40998fa6ca72c5c","modified":1716614526786},{"_id":"source/_posts/01以太网ethernet-概念.md","hash":"b937d85ec5768593f83c62a584eae2e3d771dd3a","modified":1716614493003},{"_id":"public/2024/05/23/01以太网ethernet-概念/index.html","hash":"58cdbc69d8d610043ceba32498bdf4207b867383","modified":1719931747442},{"_id":"public/page/3/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/archives/page/3/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/ethrnet/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"source/_posts/操作系统中的缺页.md","hash":"fee1865d3534cf7ffa1e280ae04425bf1b637a4b","modified":1716803633090},{"_id":"source/back_posts/01以太网ethernet-概念.md","hash":"b937d85ec5768593f83c62a584eae2e3d771dd3a","modified":1716614636132},{"_id":"public/back_posts/01以太网ethernet-概念.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716803659739},{"_id":"public/2024/05/27/操作系统中的缺页/index.html","hash":"14f4e87225417294fb20b36f74ad86a7943ea8db","modified":1719931747442},{"_id":"public/tags/缺页/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"source/_posts/shell脚本-符合意义.md","hash":"50a2f734cc2582ff8b3e7488541984c210c9b983","modified":1716965340773},{"_id":"source/imgs/0a6cf9231486414a8095f6dd113a2c7d.png","hash":"a24dc0a54bffdaf72371c37cb81615253fb34b53","modified":1716965204466},{"_id":"source/imgs/325ec497200142f98be97ec17d2c9cf3.png","hash":"801800930ad5f3479782e32030d5ca265d159001","modified":1716965296816},{"_id":"source/imgs/36d83bdde0524001a910df7a8c9c3083.png","hash":"e4ec5aae74827f259304bb1c10bf68265e231dc3","modified":1716965253007},{"_id":"source/imgs/efcc46bc1fb845e898a37da989107ef9.png","hash":"658056a47bc15d242e3147e0b4c8db6900679b96","modified":1716965168168},{"_id":"source/back_posts/操作系统中的缺页.md","hash":"fee1865d3534cf7ffa1e280ae04425bf1b637a4b","modified":1716803701763},{"_id":"source/imgs/2a8ad08662864bc293b3c520e486c473.png","hash":"1b6a392053198c0700dda6da5fd3297a2fa7ffbf","modified":1716965258416},{"_id":"source/imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png","hash":"80e49f4827f17da0dc966504b027baba7564a45f","modified":1716965231566},{"_id":"source/imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png","hash":"e8b467a0e556ef6fe047179958ef16e43069a0ff","modified":1716965113690},{"_id":"source/imgs/2ef32c1ce3654484b236af25368bdab1.png","hash":"c17639aa6b2cbe8b658a6c96b6bfa5b510c90c3e","modified":1716965105095},{"_id":"public/back_posts/操作系统中的缺页.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716965378434},{"_id":"public/2024/05/29/shell脚本-符合意义/index.html","hash":"079a97d738ce558584d2c2112af6db66e8d03142","modified":1719931747442},{"_id":"public/categories/test/page/2/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/imgs/325ec497200142f98be97ec17d2c9cf3.png","hash":"801800930ad5f3479782e32030d5ca265d159001","modified":1716965378434},{"_id":"public/imgs/0a6cf9231486414a8095f6dd113a2c7d.png","hash":"a24dc0a54bffdaf72371c37cb81615253fb34b53","modified":1716965378434},{"_id":"public/imgs/36d83bdde0524001a910df7a8c9c3083.png","hash":"e4ec5aae74827f259304bb1c10bf68265e231dc3","modified":1716965378434},{"_id":"public/imgs/efcc46bc1fb845e898a37da989107ef9.png","hash":"658056a47bc15d242e3147e0b4c8db6900679b96","modified":1716965378434},{"_id":"public/imgs/2a8ad08662864bc293b3c520e486c473.png","hash":"1b6a392053198c0700dda6da5fd3297a2fa7ffbf","modified":1716965378434},{"_id":"public/imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png","hash":"80e49f4827f17da0dc966504b027baba7564a45f","modified":1716965378434},{"_id":"public/imgs/2ef32c1ce3654484b236af25368bdab1.png","hash":"c17639aa6b2cbe8b658a6c96b6bfa5b510c90c3e","modified":1716965378434},{"_id":"public/imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png","hash":"e8b467a0e556ef6fe047179958ef16e43069a0ff","modified":1716965378434},{"_id":"source/_posts/dtb-to-dts.md","hash":"eab231359d87e8bce79fce3efc20ba45c4eb48e5","modified":1717038418208},{"_id":"source/back_posts/shell脚本-符合意义.md","hash":"50a2f734cc2582ff8b3e7488541984c210c9b983","modified":1716965436149},{"_id":"public/back_posts/shell脚本-符合意义.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1717038435724},{"_id":"public/2024/05/30/dtb-to-dts/index.html","hash":"d3902858a4374712177e671f313ce0490bfb2efc","modified":1719931747442},{"_id":"public/tags/dtb/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/dts/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"source/back_posts/dtb-to-dts.md","hash":"eab231359d87e8bce79fce3efc20ba45c4eb48e5","modified":1717038489007},{"_id":"source/imgs/image-20240530170508734.png","hash":"9de86ddf5c28b7281fc1acd22bffb4bb9fee508e","modified":1717059908775},{"_id":"public/back_posts/dtb-to-dts.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1717059986039},{"_id":"public/imgs/image-20240530170508734.png","hash":"9de86ddf5c28b7281fc1acd22bffb4bb9fee508e","modified":1717059986039},{"_id":"source/_posts/struct-dev-debug.md","hash":"c15afae6d98e680f98502842fac15613d800afdd","modified":1717385350625},{"_id":"public/2024/06/03/struct-dev-debug/index.html","hash":"c2e2c822c519c4d42ea71d0122328afb40247de7","modified":1719931747442},{"_id":"public/archives/2024/06/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/debug/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"source/_posts/systemctl-详解.md","hash":"7e60f7bbe85ac9f5925ffd2e11bcb6eba33c5bed","modified":1717395224047},{"_id":"source/back_posts/struct-dev-debug.md","hash":"c15afae6d98e680f98502842fac15613d800afdd","modified":1717385441361},{"_id":"public/back_posts/struct-dev-debug.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1717395248185},{"_id":"public/2024/06/03/systemctl-详解/index.html","hash":"9ce86e27dbc7bbe4c830b0be7bf656b04500dc0e","modified":1719931747442},{"_id":"source/back_posts/systemctl-详解.md","hash":"7e60f7bbe85ac9f5925ffd2e11bcb6eba33c5bed","modified":1717395289315},{"_id":"public/back_posts/systemctl-详解.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1717479102529},{"_id":"source/imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif","hash":"06711bf4ab0fc224369fb6bbbd3e32951480b30f","modified":1717665434479},{"_id":"public/imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif","hash":"06711bf4ab0fc224369fb6bbbd3e32951480b30f","modified":1717674030278},{"_id":"source/_posts/linux-内存管理.md","hash":"381524dd6608e3c2e8a9ab81c44f88487ac90cd9","modified":1718710434019},{"_id":"public/2024/06/17/linux-内存管理/index.html","hash":"d40954386527fba1f81ce1b7707012285dd0d9b0","modified":1719931747442},{"_id":"public/tags/内存管理/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"source/back_posts/linux-内存管理.md","hash":"381524dd6608e3c2e8a9ab81c44f88487ac90cd9","modified":1718710493270},{"_id":"public/back_posts/linux-内存管理.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1718710449571},{"_id":"source/_posts/设备驱动-reversed-memory-预留内存.md","hash":"bc793b58532477651900a5eb84111b75d52b773d","modified":1718785839183},{"_id":"source/imgs/2704972-20220410142315999-1415044429.jpg","hash":"099c52bb5ee76465c755e40b2695ef98cd98d35a","modified":1718785529048},{"_id":"public/2024/06/19/设备驱动-reversed-memory-预留内存/index.html","hash":"8e1f3ce9ae0a910be338129e8d394163e190f407","modified":1719931747442},{"_id":"public/archives/2024/page/3/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/imgs/2704972-20220410142315999-1415044429.jpg","hash":"099c52bb5ee76465c755e40b2695ef98cd98d35a","modified":1718785878046},{"_id":"source/_posts/kernel-workqueue.md","hash":"46ffc8f0ccca09307150d5ecf97743f5811bd278","modified":1719218530363},{"_id":"source/back_posts/设备驱动-reversed-memory-预留内存.md","hash":"bc793b58532477651900a5eb84111b75d52b773d","modified":1718785923282},{"_id":"source/imgs/d32faea7d5004b979cc98527aa0973e8.png","hash":"12894291e8731bd4aac2d167fbc37a52dd8d666a","modified":1718962012398},{"_id":"source/imgs/2b8686c61a24478a8112e4b83228f177.png","hash":"7a9b5951fe327571d9da21afad77d72f5c06a560","modified":1718962030515},{"_id":"public/back_posts/设备驱动-reversed-memory-预留内存.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719221692114},{"_id":"public/2024/06/21/kernel-workqueue/index.html","hash":"57541f986d8e301c52c67dea4cef75fab49c742e","modified":1719931747442},{"_id":"public/imgs/d32faea7d5004b979cc98527aa0973e8.png","hash":"12894291e8731bd4aac2d167fbc37a52dd8d666a","modified":1719221692114},{"_id":"public/imgs/2b8686c61a24478a8112e4b83228f177.png","hash":"7a9b5951fe327571d9da21afad77d72f5c06a560","modified":1719221692114},{"_id":"source/_posts/小爱同学控制电脑开关.md","hash":"0fcf49b55ec5249c53797e9df5f6a963462f520b","modified":1719931215942},{"_id":"source/imgs/82c684268ac443d191e73eb73b60aec4.png","hash":"c97f547bdcbff1eb5175d387d5b4ef4c53acd382","modified":1719928609767},{"_id":"source/imgs/image-20240702220340059.png","hash":"2fdbc0e7336b55ed16c540cb64d5886e032bd74e","modified":1719929023554},{"_id":"source/imgs/image-20240702220502413.png","hash":"019d9f538c1f2af99cac2ce6bf48ffd691a1a13b","modified":1719929106966},{"_id":"source/imgs/image-20240702220705763.png","hash":"b0bacd7d1b88f6ade9ec3b184e5f1a261d906573","modified":1719929228905},{"_id":"source/imgs/image-20240702220932130.png","hash":"99320ca45e1d2cea98bed26b6765323f9c282877","modified":1719929375277},{"_id":"source/imgs/image-20240702221620487.png","hash":"6d60afbe44b9cdccbfdd67c55566b394f066ef6c","modified":1719929783750},{"_id":"source/imgs/image-20240702222853017.png","hash":"625a1387f194ad0c1a8ea245ed062f32b2f5ed6a","modified":1719930535741},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702220340059.png","hash":"2fdbc0e7336b55ed16c540cb64d5886e032bd74e","modified":1719929020092},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702220502413.png","hash":"019d9f538c1f2af99cac2ce6bf48ffd691a1a13b","modified":1719929102448},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702220705763.png","hash":"b0bacd7d1b88f6ade9ec3b184e5f1a261d906573","modified":1719929225787},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702220932130.png","hash":"99320ca45e1d2cea98bed26b6765323f9c282877","modified":1719929372160},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702222853017.png","hash":"625a1387f194ad0c1a8ea245ed062f32b2f5ed6a","modified":1719930533026},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702221620487.png","hash":"6d60afbe44b9cdccbfdd67c55566b394f066ef6c","modified":1719929780499},{"_id":"source/imgs/cce3ff865e6348cb9da8625fe5b92fe0.png","hash":"e4016ab463bcf2f176a4a0f029413802db39019a","modified":1719928589482},{"_id":"source/imgs/image-20240702212534790.png","hash":"aa752be7bc227dca6e9bdc45f31a36545e52c5bc","modified":1719926740488},{"_id":"source/imgs/image-20240702214224123.png","hash":"bdcf3a642e876e886d32b23c6030769bc4a0dfd0","modified":1719927747368},{"_id":"source/imgs/image-20240702220828261.png","hash":"a48fadd97290a5769293e676e8b6707cdc00b97a","modified":1719929311958},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702212534790.png","hash":"aa752be7bc227dca6e9bdc45f31a36545e52c5bc","modified":1719926734859},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702214224123.png","hash":"bdcf3a642e876e886d32b23c6030769bc4a0dfd0","modified":1719927744191},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702220828261.png","hash":"a48fadd97290a5769293e676e8b6707cdc00b97a","modified":1719929308307},{"_id":"source/imgs/image-20240702221037900.png","hash":"c5f919b920dcd93b2d57b2dedd49a5ee6ac49cf2","modified":1719929441620},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702221037900.png","hash":"c5f919b920dcd93b2d57b2dedd49a5ee6ac49cf2","modified":1719929437964},{"_id":"source/imgs/image-20240702211605888.png","hash":"b4843bd54458aa3cf05aae6711fb2c964bd446aa","modified":1719926168833},{"_id":"source/imgs/xiaoaiui.png","hash":"baf16a13cf4f134134e01a98433c4e9772ded518","modified":1719925797711},{"_id":"source/_posts/小爱同学控制电脑开关.assets/image-20240702211605888.png","hash":"b4843bd54458aa3cf05aae6711fb2c964bd446aa","modified":1719926165989},{"_id":"public/2024/07/02/小爱同学控制电脑开关/index.html","hash":"ce5291997f2a8fd175796deeb415d200d01eea61","modified":1719931747442},{"_id":"public/archives/2024/07/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/tags/wol/index.html","hash":"c8f906346f5cf033a3c89419ddd62889183e7b99","modified":1719931747442},{"_id":"public/imgs/image-20240702220340059.png","hash":"2fdbc0e7336b55ed16c540cb64d5886e032bd74e","modified":1719931255898},{"_id":"public/imgs/image-20240702220705763.png","hash":"b0bacd7d1b88f6ade9ec3b184e5f1a261d906573","modified":1719931255898},{"_id":"public/imgs/image-20240702221620487.png","hash":"6d60afbe44b9cdccbfdd67c55566b394f066ef6c","modified":1719931255898},{"_id":"public/imgs/image-20240702222853017.png","hash":"625a1387f194ad0c1a8ea245ed062f32b2f5ed6a","modified":1719931255898},{"_id":"public/imgs/82c684268ac443d191e73eb73b60aec4.png","hash":"c97f547bdcbff1eb5175d387d5b4ef4c53acd382","modified":1719931255898},{"_id":"public/imgs/cce3ff865e6348cb9da8625fe5b92fe0.png","hash":"e4016ab463bcf2f176a4a0f029413802db39019a","modified":1719931255898},{"_id":"public/imgs/image-20240702214224123.png","hash":"bdcf3a642e876e886d32b23c6030769bc4a0dfd0","modified":1719931255898},{"_id":"public/imgs/image-20240702220502413.png","hash":"019d9f538c1f2af99cac2ce6bf48ffd691a1a13b","modified":1719931255898},{"_id":"public/imgs/image-20240702212534790.png","hash":"aa752be7bc227dca6e9bdc45f31a36545e52c5bc","modified":1719931255898},{"_id":"public/imgs/image-20240702220932130.png","hash":"99320ca45e1d2cea98bed26b6765323f9c282877","modified":1719931255898},{"_id":"public/imgs/image-20240702220828261.png","hash":"a48fadd97290a5769293e676e8b6707cdc00b97a","modified":1719931255898},{"_id":"public/imgs/image-20240702221037900.png","hash":"c5f919b920dcd93b2d57b2dedd49a5ee6ac49cf2","modified":1719931255898},{"_id":"public/imgs/xiaoaiui.png","hash":"baf16a13cf4f134134e01a98433c4e9772ded518","modified":1719931255898},{"_id":"public/imgs/image-20240702211605888.png","hash":"b4843bd54458aa3cf05aae6711fb2c964bd446aa","modified":1719931255898},{"_id":"source/back_posts/kernel-workqueue.md","hash":"46ffc8f0ccca09307150d5ecf97743f5811bd278","modified":1719931287731},{"_id":"source/back_posts/小爱同学控制电脑开关.md","hash":"0fcf49b55ec5249c53797e9df5f6a963462f520b","modified":1719931287852},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220340059.png","hash":"2fdbc0e7336b55ed16c540cb64d5886e032bd74e","modified":1719931287808},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220502413.png","hash":"019d9f538c1f2af99cac2ce6bf48ffd691a1a13b","modified":1719931287813},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220705763.png","hash":"b0bacd7d1b88f6ade9ec3b184e5f1a261d906573","modified":1719931287817},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702222853017.png","hash":"625a1387f194ad0c1a8ea245ed062f32b2f5ed6a","modified":1719931287844},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702221620487.png","hash":"6d60afbe44b9cdccbfdd67c55566b394f066ef6c","modified":1719931287840},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220932130.png","hash":"99320ca45e1d2cea98bed26b6765323f9c282877","modified":1719931287821},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702214224123.png","hash":"bdcf3a642e876e886d32b23c6030769bc4a0dfd0","modified":1719931287836},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702212534790.png","hash":"aa752be7bc227dca6e9bdc45f31a36545e52c5bc","modified":1719931287833},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702220828261.png","hash":"a48fadd97290a5769293e676e8b6707cdc00b97a","modified":1719931287829},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702221037900.png","hash":"c5f919b920dcd93b2d57b2dedd49a5ee6ac49cf2","modified":1719931287825},{"_id":"source/back_posts/小爱同学控制电脑开关.assets/image-20240702211605888.png","hash":"b4843bd54458aa3cf05aae6711fb2c964bd446aa","modified":1719931287848},{"_id":"public/back_posts/小爱同学控制电脑开关.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719931438394},{"_id":"public/back_posts/kernel-workqueue.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702220340059.png","hash":"2fdbc0e7336b55ed16c540cb64d5886e032bd74e","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702220705763.png","hash":"b0bacd7d1b88f6ade9ec3b184e5f1a261d906573","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702222853017.png","hash":"625a1387f194ad0c1a8ea245ed062f32b2f5ed6a","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702221620487.png","hash":"6d60afbe44b9cdccbfdd67c55566b394f066ef6c","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702212534790.png","hash":"aa752be7bc227dca6e9bdc45f31a36545e52c5bc","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702220502413.png","hash":"019d9f538c1f2af99cac2ce6bf48ffd691a1a13b","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702220932130.png","hash":"99320ca45e1d2cea98bed26b6765323f9c282877","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702214224123.png","hash":"bdcf3a642e876e886d32b23c6030769bc4a0dfd0","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702221037900.png","hash":"c5f919b920dcd93b2d57b2dedd49a5ee6ac49cf2","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702220828261.png","hash":"a48fadd97290a5769293e676e8b6707cdc00b97a","modified":1719931438394},{"_id":"public/back_posts/小爱同学控制电脑开关.assets/image-20240702211605888.png","hash":"b4843bd54458aa3cf05aae6711fb2c964bd446aa","modified":1719931438394}],"Category":[{"name":"rust","_id":"clvjcoaap0002r9w0crcqdq03"},{"name":"test","_id":"clvjcoaav000br9w04s5fhod2"},{"name":"kernel","_id":"clvjcoaax000ir9w04u7q98wg"},{"name":"OSTEP","_id":"clw7gjvtt00024zw0fh4pclyx"},{"name":"linux","_id":"clw7gjvtw00054zw09m1y49ox"},{"name":"uboot","_id":"clw7gupas000164w0bopbhhya"},{"name":"driver","_id":"clw7gupat000364w0drn50ao5"}],"Data":[],"Page":[{"title":"02-rust基本类型","date":"2023-08-26T13:17:00.000Z","categories":["rust"],"tags":["rust基本类型","rust"],"_content":"\n\n\n\n\n\n\n\n\n[toc]\n\n# Rust基本数据类型\n\nRust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：\n\n- 数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数\n- 字符串：字符串字面量和字符串切片 `&str`\n- 布尔类型： `true`和`false`\n- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节\n- 单元类型: 即 `()` ，其唯一的值也是 `()`\n\n## 1.数值类型\n\n| 长度       | 有符号类型 | 无符号类型 |\n| ---------- | ---------- | ---------- |\n| 8 位       | `i8`       | `u8`       |\n| 16 位      | `i16`      | `u16`      |\n| 32 位      | `i32`      | `u32`      |\n| 64 位      | `i64`      | `u64`      |\n| 128 位     | `i128`     | `u128`     |\n| 视架构而定 | `isize`    | `usize`    |\n\n整形字面量可以用下表的形式书写：\n\n| 数字字面量         | 示例          |\n| ------------------ | ------------- |\n| 十进制             | `98_222`      |\n| 十六进制           | `0xff`        |\n| 八进制             | `0o77`        |\n| 二进制             | `0b1111_0000` |\n| 字节 (仅限于 `u8`) | `b'A'`        |\n\n## 2.[浮点类型](https://course.rs/basic/base-type/numbers.html#浮点类型)\n\n**浮点类型数字** 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高。\n\n下面是一个演示浮点数的示例：\n\n```rust\nfn main() {\n    let x = 2.0; // f64\n\n    let y: f32 = 3.0; // f32\n}\n```\n\n## 3.[序列(Range)](https://course.rs/basic/base-type/numbers.html#序列range)\n\nRust 提供了一个非常简洁的方式，用来生成连续的数值，例如 **`1..5`，生成从 1 到 4 的连续数字，不包含 5** ；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：\n\n```rust\nfor i in 1..=5 {\n    println!(\"{}\",i);\n}\n```\n\n最终程序输出:\n\n```console\n1\n2\n3\n4\n5\n```\n\n**序列只允许用于数字或字符类型**，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：\n\n```rust\nfor i in 'a'..='z' {\n    println!(\"{}\",i);\n}\n```\n\n## 4.[有理数和复数](https://course.rs/basic/base-type/numbers.html#有理数和复数)\n\nRust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：\n\n- 有理数和复数\n- 任意大小的整数和任意精度的浮点数\n- 固定精度的十进制小数，常用于货币相关的场景\n\n好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。\n\n按照以下步骤来引入 `num` 库：\n\n1. 创建新工程 `cargo new complex-num && cd complex-num`\n2. 在 `Cargo.toml` 中的 `[dependencies]` 下添加一行 `num = \"0.4.0\"`\n3. 将 `src/main.rs` 文件中的 `main` 函数替换为下面的代码\n4. 运行 `cargo run`\n\n```rust\nuse num::complex::Complex;\n\n fn main() {\n   let a = Complex { re: 2.1, im: -1.2 };\n   let b = Complex::new(11.1, 22.2);\n   let result = a + b;\n\n   println!(\"{} + {}i\", result.re, result.im)\n }\n```\n\n#### [总结](https://course.rs/basic/base-type/numbers.html#总结)\n\n之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：\n\n- **Rust 拥有相当多的数值类型**. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数\n- **类型转换必须是显式的**. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数\n- **Rust 的数值上可以使用方法**. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14` 的具体类型\n\n## 5.[函数要点](https://course.rs/basic/base-type/function.html#函数要点)\n\n- 函数名和变量名使用[蛇形命名法(snake case)](https://course.rs/practice/naming.html)，例如 `fn add_two() -> {}`\n- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可\n- 每个函数参数都需要标注类型\n\n```\nfn add(i: i32, j: i32) -> i32 {\n   i + j\n }\n\n```\n\n![img](https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png)\n\n### 返回值：\n\n​\t[无返回值`()`](https://course.rs/basic/base-type/function.html#无返回值)\n\n- 函数没有返回值，那么返回一个 `()`\n- 通过 `;` 结尾的表达式返回一个 `()`\n\n​    [永不返回的发散函数 `!`](https://course.rs/basic/base-type/function.html#永不返回的发散函数-)\n\n​\t\t当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：\n\n## 6.练习\n\n[数值类型 - Rust By Practice( Rust 练习实践 )](https://zh.practice.rs/basic-types/numbers.html)\n\n```// 填空\nfn main() {\n    let v: u16 = 38_u8 as u16; //从8位无符号整数（u8）到16位无符号整数（u16）的类型转换\n}\n```\n\n```\n\n// 修改 `assert_eq!` 让代码工作\nfn main() {\n    let x = 5;\t\t//i32\n    assert_eq!(\"i32\".to_string(), type_of(&x)); //\n}\n\n// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  \"i8\", \"u8\", \"i32\", \"u32\"\nfn type_of<T>(_: &T) -> String {\n    format!(\"{}\", std::any::type_name::<T>())\n}\n\n```\n\n```\nfn main() {\n    assert_eq!(i8::MAX, 127); \n    assert_eq!(u8::MAX, 255); \n}\n\n```\n\n```\n\n// 解决代码中的错误和 `panic`\nfn main() {\n   let v1 = 251_u8.wrapping_add(8);\n   let v2 = match u8::checked_add(251, 8) {\n        Some(value) => value,\n        None => {\n            println!(\"Overflow occurred.\");\n            0\n        }\n    };\n   println!(\"{},{}\",v1,v2);\n}\n\n```\n\n```\nfn main() {\n    let x = 1_000.000_1; // f64\n    let y: f32 = 0.12; // f32\n    let z = 0.01_f64; // f64\n}\n```\n\n```c\n#使用两种方法来让下面代码工作\nfn main() {\n    assert!(0.1+0.2==0.3);\n}\n fn main() {\n     assert!(0.1_f32+0.2_f32==0.3_f32);\n }\n//降低精度\nfn main() {\n    let eps=0.001;\n    assert!((0.1_f64+ 0.2 - 0.3).abs() < eps);\n}\n//设置允许误差\n```\n\n### [序列Range](https://zh.practice.rs/basic-types/numbers.html#序列range)\n\n1. 🌟🌟 两个目标: 1. 修改 `assert!` 让它工作 2. 让 `println!` 输出: 97 - 122\n\n```\nfn main() {\n    let mut sum = 0;\n    for i in -3..2 {\n        sum += i\n    }\n\n    assert!(sum == -5);\n\n    for c in 'a'..='z' {\n        println!(\"{}\",c as u8);\n    }\n}\n\n```\n\n```\\// 填空\nuse std::ops::{Range, RangeInclusive};\nfn main() {\n    assert_eq!((1..5), Range{ start: 1, end: 5 });\n    assert_eq!((1..=5), RangeInclusive::new(1, 5));\n}\n///RangeInclusive::new(1, 5) 创建的是一个闭区间，表示从 1 到 5（包括 5）的范围。若 (1..5) 创建的是一个半开区间，表示从 1 到 5（不包括 5）的范围。\n```\n\n```\nuse std::mem::size_of_val;\nfn main() {\n    let unit: () = ();\n    assert!(size_of_val(&unit) == 0);\t\t//单元类型占用的内存大小 0\n\n    println!(\"Success!\")\n}\n```\n\n### [语句与表达式](https://zh.practice.rs/basic-types/statements-expressions.html#语句与表达式)\n\n```\nfn main() {\n   let v = {\n       let mut x = 1;\n       x += 2\t\t// 没有返回值  \n   };\n\n   assert_eq!(v, 3);\n}\n正确的做法\nfn main() {\n   let v = {\n       let mut x = 1;\n       x += 2;\n       x\n   };\n\n   assert_eq!(v, 3);\n}\n\nlet z = {\n\t// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`\n\t2 * x;\n};\nfn main() {\n   let v = { let x = 3; x};\n\n   assert!(v == 3);\n}\n```\n\n### [函数](https://zh.practice.rs/basic-types/functions.html#函数)\n\n\n\n## 7.总结：\n\n1.`let x = 2.0; // f64`\n\n2.比较浮点数`(0.1_f64 + 0.2 - 0.3).abs() < 0.00001`\n\n3.`编译器会进行自动推导，给予twenty i32的类型  let twenty = 20;`\n\n4.按照补码循环溢出规则处理`et b = 255_u8.wrapping_add(20);  // 19`  `在 u8 的情况下，256 变成 0，257 变成 1，`\n\n5.`(1..5)  表示从 1 到 5（不包括 5）半开区间的范围`\n\n6.`(1..=5)  表示从 1 到 5（包括 5）半闭区间的范围`\n\n6.**表达式不能包含分号**。`表达式总要返回值`\n\n7.返回值为！的表达式\n\n```\nloop {}  \npanic!(\"Never return\");  \ntodo!();  \nunimplemented!();  //未实现的占位符函数\n \n```\n","source":"back_posts/02-rust基本类型.md","raw":"---\ntitle: 02-rust基本类型\ndate: 2023-08-26 21:17:00\ncategories:\n- rust\ntags:\n- rust基本类型\n- rust\n\n---\n\n\n\n\n\n\n\n\n\n[toc]\n\n# Rust基本数据类型\n\nRust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：\n\n- 数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数\n- 字符串：字符串字面量和字符串切片 `&str`\n- 布尔类型： `true`和`false`\n- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节\n- 单元类型: 即 `()` ，其唯一的值也是 `()`\n\n## 1.数值类型\n\n| 长度       | 有符号类型 | 无符号类型 |\n| ---------- | ---------- | ---------- |\n| 8 位       | `i8`       | `u8`       |\n| 16 位      | `i16`      | `u16`      |\n| 32 位      | `i32`      | `u32`      |\n| 64 位      | `i64`      | `u64`      |\n| 128 位     | `i128`     | `u128`     |\n| 视架构而定 | `isize`    | `usize`    |\n\n整形字面量可以用下表的形式书写：\n\n| 数字字面量         | 示例          |\n| ------------------ | ------------- |\n| 十进制             | `98_222`      |\n| 十六进制           | `0xff`        |\n| 八进制             | `0o77`        |\n| 二进制             | `0b1111_0000` |\n| 字节 (仅限于 `u8`) | `b'A'`        |\n\n## 2.[浮点类型](https://course.rs/basic/base-type/numbers.html#浮点类型)\n\n**浮点类型数字** 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高。\n\n下面是一个演示浮点数的示例：\n\n```rust\nfn main() {\n    let x = 2.0; // f64\n\n    let y: f32 = 3.0; // f32\n}\n```\n\n## 3.[序列(Range)](https://course.rs/basic/base-type/numbers.html#序列range)\n\nRust 提供了一个非常简洁的方式，用来生成连续的数值，例如 **`1..5`，生成从 1 到 4 的连续数字，不包含 5** ；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：\n\n```rust\nfor i in 1..=5 {\n    println!(\"{}\",i);\n}\n```\n\n最终程序输出:\n\n```console\n1\n2\n3\n4\n5\n```\n\n**序列只允许用于数字或字符类型**，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：\n\n```rust\nfor i in 'a'..='z' {\n    println!(\"{}\",i);\n}\n```\n\n## 4.[有理数和复数](https://course.rs/basic/base-type/numbers.html#有理数和复数)\n\nRust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：\n\n- 有理数和复数\n- 任意大小的整数和任意精度的浮点数\n- 固定精度的十进制小数，常用于货币相关的场景\n\n好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。\n\n按照以下步骤来引入 `num` 库：\n\n1. 创建新工程 `cargo new complex-num && cd complex-num`\n2. 在 `Cargo.toml` 中的 `[dependencies]` 下添加一行 `num = \"0.4.0\"`\n3. 将 `src/main.rs` 文件中的 `main` 函数替换为下面的代码\n4. 运行 `cargo run`\n\n```rust\nuse num::complex::Complex;\n\n fn main() {\n   let a = Complex { re: 2.1, im: -1.2 };\n   let b = Complex::new(11.1, 22.2);\n   let result = a + b;\n\n   println!(\"{} + {}i\", result.re, result.im)\n }\n```\n\n#### [总结](https://course.rs/basic/base-type/numbers.html#总结)\n\n之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：\n\n- **Rust 拥有相当多的数值类型**. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数\n- **类型转换必须是显式的**. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数\n- **Rust 的数值上可以使用方法**. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14` 的具体类型\n\n## 5.[函数要点](https://course.rs/basic/base-type/function.html#函数要点)\n\n- 函数名和变量名使用[蛇形命名法(snake case)](https://course.rs/practice/naming.html)，例如 `fn add_two() -> {}`\n- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可\n- 每个函数参数都需要标注类型\n\n```\nfn add(i: i32, j: i32) -> i32 {\n   i + j\n }\n\n```\n\n![img](https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png)\n\n### 返回值：\n\n​\t[无返回值`()`](https://course.rs/basic/base-type/function.html#无返回值)\n\n- 函数没有返回值，那么返回一个 `()`\n- 通过 `;` 结尾的表达式返回一个 `()`\n\n​    [永不返回的发散函数 `!`](https://course.rs/basic/base-type/function.html#永不返回的发散函数-)\n\n​\t\t当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：\n\n## 6.练习\n\n[数值类型 - Rust By Practice( Rust 练习实践 )](https://zh.practice.rs/basic-types/numbers.html)\n\n```// 填空\nfn main() {\n    let v: u16 = 38_u8 as u16; //从8位无符号整数（u8）到16位无符号整数（u16）的类型转换\n}\n```\n\n```\n\n// 修改 `assert_eq!` 让代码工作\nfn main() {\n    let x = 5;\t\t//i32\n    assert_eq!(\"i32\".to_string(), type_of(&x)); //\n}\n\n// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  \"i8\", \"u8\", \"i32\", \"u32\"\nfn type_of<T>(_: &T) -> String {\n    format!(\"{}\", std::any::type_name::<T>())\n}\n\n```\n\n```\nfn main() {\n    assert_eq!(i8::MAX, 127); \n    assert_eq!(u8::MAX, 255); \n}\n\n```\n\n```\n\n// 解决代码中的错误和 `panic`\nfn main() {\n   let v1 = 251_u8.wrapping_add(8);\n   let v2 = match u8::checked_add(251, 8) {\n        Some(value) => value,\n        None => {\n            println!(\"Overflow occurred.\");\n            0\n        }\n    };\n   println!(\"{},{}\",v1,v2);\n}\n\n```\n\n```\nfn main() {\n    let x = 1_000.000_1; // f64\n    let y: f32 = 0.12; // f32\n    let z = 0.01_f64; // f64\n}\n```\n\n```c\n#使用两种方法来让下面代码工作\nfn main() {\n    assert!(0.1+0.2==0.3);\n}\n fn main() {\n     assert!(0.1_f32+0.2_f32==0.3_f32);\n }\n//降低精度\nfn main() {\n    let eps=0.001;\n    assert!((0.1_f64+ 0.2 - 0.3).abs() < eps);\n}\n//设置允许误差\n```\n\n### [序列Range](https://zh.practice.rs/basic-types/numbers.html#序列range)\n\n1. 🌟🌟 两个目标: 1. 修改 `assert!` 让它工作 2. 让 `println!` 输出: 97 - 122\n\n```\nfn main() {\n    let mut sum = 0;\n    for i in -3..2 {\n        sum += i\n    }\n\n    assert!(sum == -5);\n\n    for c in 'a'..='z' {\n        println!(\"{}\",c as u8);\n    }\n}\n\n```\n\n```\\// 填空\nuse std::ops::{Range, RangeInclusive};\nfn main() {\n    assert_eq!((1..5), Range{ start: 1, end: 5 });\n    assert_eq!((1..=5), RangeInclusive::new(1, 5));\n}\n///RangeInclusive::new(1, 5) 创建的是一个闭区间，表示从 1 到 5（包括 5）的范围。若 (1..5) 创建的是一个半开区间，表示从 1 到 5（不包括 5）的范围。\n```\n\n```\nuse std::mem::size_of_val;\nfn main() {\n    let unit: () = ();\n    assert!(size_of_val(&unit) == 0);\t\t//单元类型占用的内存大小 0\n\n    println!(\"Success!\")\n}\n```\n\n### [语句与表达式](https://zh.practice.rs/basic-types/statements-expressions.html#语句与表达式)\n\n```\nfn main() {\n   let v = {\n       let mut x = 1;\n       x += 2\t\t// 没有返回值  \n   };\n\n   assert_eq!(v, 3);\n}\n正确的做法\nfn main() {\n   let v = {\n       let mut x = 1;\n       x += 2;\n       x\n   };\n\n   assert_eq!(v, 3);\n}\n\nlet z = {\n\t// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`\n\t2 * x;\n};\nfn main() {\n   let v = { let x = 3; x};\n\n   assert!(v == 3);\n}\n```\n\n### [函数](https://zh.practice.rs/basic-types/functions.html#函数)\n\n\n\n## 7.总结：\n\n1.`let x = 2.0; // f64`\n\n2.比较浮点数`(0.1_f64 + 0.2 - 0.3).abs() < 0.00001`\n\n3.`编译器会进行自动推导，给予twenty i32的类型  let twenty = 20;`\n\n4.按照补码循环溢出规则处理`et b = 255_u8.wrapping_add(20);  // 19`  `在 u8 的情况下，256 变成 0，257 变成 1，`\n\n5.`(1..5)  表示从 1 到 5（不包括 5）半开区间的范围`\n\n6.`(1..=5)  表示从 1 到 5（包括 5）半闭区间的范围`\n\n6.**表达式不能包含分号**。`表达式总要返回值`\n\n7.返回值为！的表达式\n\n```\nloop {}  \npanic!(\"Never return\");  \ntodo!();  \nunimplemented!();  //未实现的占位符函数\n \n```\n","updated":"2024-05-15T06:11:08.980Z","path":"back_posts/02-rust基本类型.html","comments":1,"layout":"page","_id":"clw7fflkf0000x2w0001j3j23","content":"<p>[toc]</p>\n<h1 id=\"Rust基本数据类型\"><a href=\"#Rust基本数据类型\" class=\"headerlink\" title=\"Rust基本数据类型\"></a>Rust基本数据类型</h1><p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：</p>\n<ul>\n<li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</li>\n<li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li>\n<li>布尔类型： <code>true</code>和<code>false</code></li>\n<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>\n<li>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></li>\n</ul>\n<h2 id=\"1-数值类型\"><a href=\"#1-数值类型\" class=\"headerlink\" title=\"1.数值类型\"></a>1.数值类型</h2><table>\n<thead>\n<tr>\n<th>长度</th>\n<th>有符号类型</th>\n<th>无符号类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8 位</td>\n<td><code>i8</code></td>\n<td><code>u8</code></td>\n</tr>\n<tr>\n<td>16 位</td>\n<td><code>i16</code></td>\n<td><code>u16</code></td>\n</tr>\n<tr>\n<td>32 位</td>\n<td><code>i32</code></td>\n<td><code>u32</code></td>\n</tr>\n<tr>\n<td>64 位</td>\n<td><code>i64</code></td>\n<td><code>u64</code></td>\n</tr>\n<tr>\n<td>128 位</td>\n<td><code>i128</code></td>\n<td><code>u128</code></td>\n</tr>\n<tr>\n<td>视架构而定</td>\n<td><code>isize</code></td>\n<td><code>usize</code></td>\n</tr>\n</tbody></table>\n<p>整形字面量可以用下表的形式书写：</p>\n<table>\n<thead>\n<tr>\n<th>数字字面量</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>十进制</td>\n<td><code>98_222</code></td>\n</tr>\n<tr>\n<td>十六进制</td>\n<td><code>0xff</code></td>\n</tr>\n<tr>\n<td>八进制</td>\n<td><code>0o77</code></td>\n</tr>\n<tr>\n<td>二进制</td>\n<td><code>0b1111_0000</code></td>\n</tr>\n<tr>\n<td>字节 (仅限于 <code>u8</code>)</td>\n<td><code>b&#39;A&#39;</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"2-浮点类型\"><a href=\"#2-浮点类型\" class=\"headerlink\" title=\"2.浮点类型\"></a>2.<a href=\"https://course.rs/basic/base-type/numbers.html#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B\">浮点类型</a></h2><p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p>\n<p>下面是一个演示浮点数的示例：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">2.0</span>; <span class=\"comment\">// f64</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span>: <span class=\"type\">f32</span> = <span class=\"number\">3.0</span>; <span class=\"comment\">// f32</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-序列-Range\"><a href=\"#3-序列-Range\" class=\"headerlink\" title=\"3.序列(Range)\"></a>3.<a href=\"https://course.rs/basic/base-type/numbers.html#%E5%BA%8F%E5%88%97range\">序列(Range)</a></h2><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <strong><code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5</strong> ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>..=<span class=\"number\">5</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终程序输出:</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><strong>序列只允许用于数字或字符类型</strong>，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"string\">&#x27;a&#x27;</span>..=<span class=\"string\">&#x27;z&#x27;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-有理数和复数\"><a href=\"#4-有理数和复数\" class=\"headerlink\" title=\"4.有理数和复数\"></a>4.<a href=\"https://course.rs/basic/base-type/numbers.html#%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E5%A4%8D%E6%95%B0\">有理数和复数</a></h2><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p>\n<ul>\n<li>有理数和复数</li>\n<li>任意大小的整数和任意精度的浮点数</li>\n<li>固定精度的十进制小数，常用于货币相关的场景</li>\n</ul>\n<p>好在社区已经开发出高质量的 Rust 数值库：<a href=\"https://crates.io/crates/num\">num</a>。</p>\n<p>按照以下步骤来引入 <code>num</code> 库：</p>\n<ol>\n<li>创建新工程 <code>cargo new complex-num &amp;&amp; cd complex-num</code></li>\n<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = &quot;0.4.0&quot;</code></li>\n<li>将 <code>src/main.rs</code> 文件中的 <code>main</code> 函数替换为下面的代码</li>\n<li>运行 <code>cargo run</code></li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> num::complex::Complex;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Complex &#123; re: <span class=\"number\">2.1</span>, im: -<span class=\"number\">1.2</span> &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = Complex::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">11.1</span>, <span class=\"number\">22.2</span>);</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; + &#123;&#125;i&quot;</span>, result.re, result.im)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><a href=\"https://course.rs/basic/base-type/numbers.html#%E6%80%BB%E7%BB%93\">总结</a></h4><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p>\n<ul>\n<li><strong>Rust 拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li>\n<li><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</li>\n<li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整：<code>13.14_f32.round()</code>，在这里我们使用了类型后缀，因为编译器需要知道 <code>13.14</code> 的具体类型</li>\n</ul>\n<h2 id=\"5-函数要点\"><a href=\"#5-函数要点\" class=\"headerlink\" title=\"5.函数要点\"></a>5.<a href=\"https://course.rs/basic/base-type/function.html#%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9\">函数要点</a></h2><ul>\n<li>函数名和变量名使用<a href=\"https://course.rs/practice/naming.html\">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; &#123;&#125;</code></li>\n<li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li>\n<li>每个函数参数都需要标注类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn add(i: i32, j: i32) -&gt; i32 &#123;</span><br><span class=\"line\">   i + j</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png\" alt=\"img\"></p>\n<h3 id=\"返回值：\"><a href=\"#返回值：\" class=\"headerlink\" title=\"返回值：\"></a>返回值：</h3><p>​\t<a href=\"https://course.rs/basic/base-type/function.html#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC\">无返回值<code>()</code></a></p>\n<ul>\n<li>函数没有返回值，那么返回一个 <code>()</code></li>\n<li>通过 <code>;</code> 结尾的表达式返回一个 <code>()</code></li>\n</ul>\n<p>​    <a href=\"https://course.rs/basic/base-type/function.html#%E6%B0%B8%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0-\">永不返回的发散函数 <code>!</code></a></p>\n<p>​\t\t当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p>\n<h2 id=\"6-练习\"><a href=\"#6-练习\" class=\"headerlink\" title=\"6.练习\"></a>6.练习</h2><p><a href=\"https://zh.practice.rs/basic-types/numbers.html\">数值类型 - Rust By Practice( Rust 练习实践 )</a></p>\n<figure class=\"highlight plaintext\"><figcaption><span>填空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let v: u16 = 38_u8 as u16; //从8位无符号整数（u8）到16位无符号整数（u16）的类型转换</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 修改 `assert_eq!` 让代码工作</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let x = 5;\t\t//i32</span><br><span class=\"line\">    assert_eq!(&quot;i32&quot;.to_string(), type_of(&amp;x)); //</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;</span><br><span class=\"line\">fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123;</span><br><span class=\"line\">    format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    assert_eq!(i8::MAX, 127); </span><br><span class=\"line\">    assert_eq!(u8::MAX, 255); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 解决代码中的错误和 `panic`</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v1 = 251_u8.wrapping_add(8);</span><br><span class=\"line\">   let v2 = match u8::checked_add(251, 8) &#123;</span><br><span class=\"line\">        Some(value) =&gt; value,</span><br><span class=\"line\">        None =&gt; &#123;</span><br><span class=\"line\">            println!(&quot;Overflow occurred.&quot;);</span><br><span class=\"line\">            0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let x = 1_000.000_1; // f64</span><br><span class=\"line\">    let y: f32 = 0.12; // f32</span><br><span class=\"line\">    let z = 0.01_f64; // f64</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#使用两种方法来让下面代码工作</span><br><span class=\"line\">fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    assert!(<span class=\"number\">0.1</span>+<span class=\"number\">0.2</span>==<span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     assert!(<span class=\"number\">0.1</span>_f32+<span class=\"number\">0.2</span>_f32==<span class=\"number\">0.3</span>_f32);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//降低精度</span></span><br><span class=\"line\">fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    let eps=<span class=\"number\">0.001</span>;</span><br><span class=\"line\">    assert!((<span class=\"number\">0.1</span>_f64+ <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span>).<span class=\"built_in\">abs</span>() &lt; eps);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置允许误差</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"序列Range\"><a href=\"#序列Range\" class=\"headerlink\" title=\"序列Range\"></a><a href=\"https://zh.practice.rs/basic-types/numbers.html#%E5%BA%8F%E5%88%97range\">序列Range</a></h3><ol>\n<li>🌟🌟 两个目标: 1. 修改 <code>assert!</code> 让它工作 2. 让 <code>println!</code> 输出: 97 - 122</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let mut sum = 0;</span><br><span class=\"line\">    for i in -3..2 &#123;</span><br><span class=\"line\">        sum += i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert!(sum == -5);</span><br><span class=\"line\"></span><br><span class=\"line\">    for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123;</span><br><span class=\"line\">        println!(&quot;&#123;&#125;&quot;,c as u8);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>填空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use std::ops::&#123;Range, RangeInclusive&#125;;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;);</span><br><span class=\"line\">    assert_eq!((1..=5), RangeInclusive::new(1, 5));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">///RangeInclusive::new(1, 5) 创建的是一个闭区间，表示从 1 到 5（包括 5）的范围。若 (1..5) 创建的是一个半开区间，表示从 1 到 5（不包括 5）的范围。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use std::mem::size_of_val;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let unit: () = ();</span><br><span class=\"line\">    assert!(size_of_val(&amp;unit) == 0);\t\t//单元类型占用的内存大小 0</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语句与表达式\"><a href=\"#语句与表达式\" class=\"headerlink\" title=\"语句与表达式\"></a><a href=\"https://zh.practice.rs/basic-types/statements-expressions.html#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F\">语句与表达式</a></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123;</span><br><span class=\"line\">       let mut x = 1;</span><br><span class=\"line\">       x += 2\t\t// 没有返回值  </span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert_eq!(v, 3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">正确的做法</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123;</span><br><span class=\"line\">       let mut x = 1;</span><br><span class=\"line\">       x += 2;</span><br><span class=\"line\">       x</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert_eq!(v, 3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let z = &#123;</span><br><span class=\"line\">\t// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`</span><br><span class=\"line\">\t2 * x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123; let x = 3; x&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert!(v == 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a><a href=\"https://zh.practice.rs/basic-types/functions.html#%E5%87%BD%E6%95%B0\">函数</a></h3><h2 id=\"7-总结：\"><a href=\"#7-总结：\" class=\"headerlink\" title=\"7.总结：\"></a>7.总结：</h2><p>1.<code>let x = 2.0; // f64</code></p>\n<p>2.比较浮点数<code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code></p>\n<p>3.<code>编译器会进行自动推导，给予twenty i32的类型  let twenty = 20;</code></p>\n<p>4.按照补码循环溢出规则处理<code>et b = 255_u8.wrapping_add(20);  // 19</code>  <code>在 u8 的情况下，256 变成 0，257 变成 1，</code></p>\n<p>5.<code>(1..5)  表示从 1 到 5（不包括 5）半开区间的范围</code></p>\n<p>6.<code>(1..=5)  表示从 1 到 5（包括 5）半闭区间的范围</code></p>\n<p>6.<strong>表达式不能包含分号</strong>。<code>表达式总要返回值</code></p>\n<p>7.返回值为！的表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop &#123;&#125;  </span><br><span class=\"line\">panic!(&quot;Never return&quot;);  </span><br><span class=\"line\">todo!();  </span><br><span class=\"line\">unimplemented!();  //未实现的占位符函数</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"Rust基本数据类型\"><a href=\"#Rust基本数据类型\" class=\"headerlink\" title=\"Rust基本数据类型\"></a>Rust基本数据类型</h1><p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：</p>\n<ul>\n<li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</li>\n<li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li>\n<li>布尔类型： <code>true</code>和<code>false</code></li>\n<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>\n<li>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></li>\n</ul>\n<h2 id=\"1-数值类型\"><a href=\"#1-数值类型\" class=\"headerlink\" title=\"1.数值类型\"></a>1.数值类型</h2><table>\n<thead>\n<tr>\n<th>长度</th>\n<th>有符号类型</th>\n<th>无符号类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8 位</td>\n<td><code>i8</code></td>\n<td><code>u8</code></td>\n</tr>\n<tr>\n<td>16 位</td>\n<td><code>i16</code></td>\n<td><code>u16</code></td>\n</tr>\n<tr>\n<td>32 位</td>\n<td><code>i32</code></td>\n<td><code>u32</code></td>\n</tr>\n<tr>\n<td>64 位</td>\n<td><code>i64</code></td>\n<td><code>u64</code></td>\n</tr>\n<tr>\n<td>128 位</td>\n<td><code>i128</code></td>\n<td><code>u128</code></td>\n</tr>\n<tr>\n<td>视架构而定</td>\n<td><code>isize</code></td>\n<td><code>usize</code></td>\n</tr>\n</tbody></table>\n<p>整形字面量可以用下表的形式书写：</p>\n<table>\n<thead>\n<tr>\n<th>数字字面量</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>十进制</td>\n<td><code>98_222</code></td>\n</tr>\n<tr>\n<td>十六进制</td>\n<td><code>0xff</code></td>\n</tr>\n<tr>\n<td>八进制</td>\n<td><code>0o77</code></td>\n</tr>\n<tr>\n<td>二进制</td>\n<td><code>0b1111_0000</code></td>\n</tr>\n<tr>\n<td>字节 (仅限于 <code>u8</code>)</td>\n<td><code>b&#39;A&#39;</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"2-浮点类型\"><a href=\"#2-浮点类型\" class=\"headerlink\" title=\"2.浮点类型\"></a>2.<a href=\"https://course.rs/basic/base-type/numbers.html#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B\">浮点类型</a></h2><p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p>\n<p>下面是一个演示浮点数的示例：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">2.0</span>; <span class=\"comment\">// f64</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span>: <span class=\"type\">f32</span> = <span class=\"number\">3.0</span>; <span class=\"comment\">// f32</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-序列-Range\"><a href=\"#3-序列-Range\" class=\"headerlink\" title=\"3.序列(Range)\"></a>3.<a href=\"https://course.rs/basic/base-type/numbers.html#%E5%BA%8F%E5%88%97range\">序列(Range)</a></h2><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <strong><code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5</strong> ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>..=<span class=\"number\">5</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终程序输出:</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><strong>序列只允许用于数字或字符类型</strong>，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"string\">&#x27;a&#x27;</span>..=<span class=\"string\">&#x27;z&#x27;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-有理数和复数\"><a href=\"#4-有理数和复数\" class=\"headerlink\" title=\"4.有理数和复数\"></a>4.<a href=\"https://course.rs/basic/base-type/numbers.html#%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E5%A4%8D%E6%95%B0\">有理数和复数</a></h2><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p>\n<ul>\n<li>有理数和复数</li>\n<li>任意大小的整数和任意精度的浮点数</li>\n<li>固定精度的十进制小数，常用于货币相关的场景</li>\n</ul>\n<p>好在社区已经开发出高质量的 Rust 数值库：<a href=\"https://crates.io/crates/num\">num</a>。</p>\n<p>按照以下步骤来引入 <code>num</code> 库：</p>\n<ol>\n<li>创建新工程 <code>cargo new complex-num &amp;&amp; cd complex-num</code></li>\n<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = &quot;0.4.0&quot;</code></li>\n<li>将 <code>src/main.rs</code> 文件中的 <code>main</code> 函数替换为下面的代码</li>\n<li>运行 <code>cargo run</code></li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> num::complex::Complex;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Complex &#123; re: <span class=\"number\">2.1</span>, im: -<span class=\"number\">1.2</span> &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = Complex::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">11.1</span>, <span class=\"number\">22.2</span>);</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; + &#123;&#125;i&quot;</span>, result.re, result.im)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><a href=\"https://course.rs/basic/base-type/numbers.html#%E6%80%BB%E7%BB%93\">总结</a></h4><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p>\n<ul>\n<li><strong>Rust 拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li>\n<li><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</li>\n<li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整：<code>13.14_f32.round()</code>，在这里我们使用了类型后缀，因为编译器需要知道 <code>13.14</code> 的具体类型</li>\n</ul>\n<h2 id=\"5-函数要点\"><a href=\"#5-函数要点\" class=\"headerlink\" title=\"5.函数要点\"></a>5.<a href=\"https://course.rs/basic/base-type/function.html#%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9\">函数要点</a></h2><ul>\n<li>函数名和变量名使用<a href=\"https://course.rs/practice/naming.html\">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; &#123;&#125;</code></li>\n<li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li>\n<li>每个函数参数都需要标注类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn add(i: i32, j: i32) -&gt; i32 &#123;</span><br><span class=\"line\">   i + j</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png\" alt=\"img\"></p>\n<h3 id=\"返回值：\"><a href=\"#返回值：\" class=\"headerlink\" title=\"返回值：\"></a>返回值：</h3><p>​\t<a href=\"https://course.rs/basic/base-type/function.html#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC\">无返回值<code>()</code></a></p>\n<ul>\n<li>函数没有返回值，那么返回一个 <code>()</code></li>\n<li>通过 <code>;</code> 结尾的表达式返回一个 <code>()</code></li>\n</ul>\n<p>​    <a href=\"https://course.rs/basic/base-type/function.html#%E6%B0%B8%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0-\">永不返回的发散函数 <code>!</code></a></p>\n<p>​\t\t当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p>\n<h2 id=\"6-练习\"><a href=\"#6-练习\" class=\"headerlink\" title=\"6.练习\"></a>6.练习</h2><p><a href=\"https://zh.practice.rs/basic-types/numbers.html\">数值类型 - Rust By Practice( Rust 练习实践 )</a></p>\n<figure class=\"highlight plaintext\"><figcaption><span>填空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let v: u16 = 38_u8 as u16; //从8位无符号整数（u8）到16位无符号整数（u16）的类型转换</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 修改 `assert_eq!` 让代码工作</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let x = 5;\t\t//i32</span><br><span class=\"line\">    assert_eq!(&quot;i32&quot;.to_string(), type_of(&amp;x)); //</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;</span><br><span class=\"line\">fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123;</span><br><span class=\"line\">    format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    assert_eq!(i8::MAX, 127); </span><br><span class=\"line\">    assert_eq!(u8::MAX, 255); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 解决代码中的错误和 `panic`</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v1 = 251_u8.wrapping_add(8);</span><br><span class=\"line\">   let v2 = match u8::checked_add(251, 8) &#123;</span><br><span class=\"line\">        Some(value) =&gt; value,</span><br><span class=\"line\">        None =&gt; &#123;</span><br><span class=\"line\">            println!(&quot;Overflow occurred.&quot;);</span><br><span class=\"line\">            0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let x = 1_000.000_1; // f64</span><br><span class=\"line\">    let y: f32 = 0.12; // f32</span><br><span class=\"line\">    let z = 0.01_f64; // f64</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#使用两种方法来让下面代码工作</span><br><span class=\"line\">fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    assert!(<span class=\"number\">0.1</span>+<span class=\"number\">0.2</span>==<span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     assert!(<span class=\"number\">0.1</span>_f32+<span class=\"number\">0.2</span>_f32==<span class=\"number\">0.3</span>_f32);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//降低精度</span></span><br><span class=\"line\">fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    let eps=<span class=\"number\">0.001</span>;</span><br><span class=\"line\">    assert!((<span class=\"number\">0.1</span>_f64+ <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span>).<span class=\"built_in\">abs</span>() &lt; eps);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置允许误差</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"序列Range\"><a href=\"#序列Range\" class=\"headerlink\" title=\"序列Range\"></a><a href=\"https://zh.practice.rs/basic-types/numbers.html#%E5%BA%8F%E5%88%97range\">序列Range</a></h3><ol>\n<li>🌟🌟 两个目标: 1. 修改 <code>assert!</code> 让它工作 2. 让 <code>println!</code> 输出: 97 - 122</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let mut sum = 0;</span><br><span class=\"line\">    for i in -3..2 &#123;</span><br><span class=\"line\">        sum += i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert!(sum == -5);</span><br><span class=\"line\"></span><br><span class=\"line\">    for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123;</span><br><span class=\"line\">        println!(&quot;&#123;&#125;&quot;,c as u8);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>填空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use std::ops::&#123;Range, RangeInclusive&#125;;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;);</span><br><span class=\"line\">    assert_eq!((1..=5), RangeInclusive::new(1, 5));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">///RangeInclusive::new(1, 5) 创建的是一个闭区间，表示从 1 到 5（包括 5）的范围。若 (1..5) 创建的是一个半开区间，表示从 1 到 5（不包括 5）的范围。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use std::mem::size_of_val;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let unit: () = ();</span><br><span class=\"line\">    assert!(size_of_val(&amp;unit) == 0);\t\t//单元类型占用的内存大小 0</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语句与表达式\"><a href=\"#语句与表达式\" class=\"headerlink\" title=\"语句与表达式\"></a><a href=\"https://zh.practice.rs/basic-types/statements-expressions.html#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F\">语句与表达式</a></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123;</span><br><span class=\"line\">       let mut x = 1;</span><br><span class=\"line\">       x += 2\t\t// 没有返回值  </span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert_eq!(v, 3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">正确的做法</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123;</span><br><span class=\"line\">       let mut x = 1;</span><br><span class=\"line\">       x += 2;</span><br><span class=\"line\">       x</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert_eq!(v, 3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let z = &#123;</span><br><span class=\"line\">\t// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`</span><br><span class=\"line\">\t2 * x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123; let x = 3; x&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert!(v == 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a><a href=\"https://zh.practice.rs/basic-types/functions.html#%E5%87%BD%E6%95%B0\">函数</a></h3><h2 id=\"7-总结：\"><a href=\"#7-总结：\" class=\"headerlink\" title=\"7.总结：\"></a>7.总结：</h2><p>1.<code>let x = 2.0; // f64</code></p>\n<p>2.比较浮点数<code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code></p>\n<p>3.<code>编译器会进行自动推导，给予twenty i32的类型  let twenty = 20;</code></p>\n<p>4.按照补码循环溢出规则处理<code>et b = 255_u8.wrapping_add(20);  // 19</code>  <code>在 u8 的情况下，256 变成 0，257 变成 1，</code></p>\n<p>5.<code>(1..5)  表示从 1 到 5（不包括 5）半开区间的范围</code></p>\n<p>6.<code>(1..=5)  表示从 1 到 5（包括 5）半闭区间的范围</code></p>\n<p>6.<strong>表达式不能包含分号</strong>。<code>表达式总要返回值</code></p>\n<p>7.返回值为！的表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop &#123;&#125;  </span><br><span class=\"line\">panic!(&quot;Never return&quot;);  </span><br><span class=\"line\">todo!();  </span><br><span class=\"line\">unimplemented!();  //未实现的占位符函数</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n"},{"title":"03-rust复合类型","date":"2023-08-28T13:58:27.000Z","categories":["rust"],"tags":["rust复合类型","rust"],"_content":"\n\n\n\n\n# 1.字符串和切片\n\n## [什么是字符串?](https://course.rs/basic/compound-type/string-slice.html#什么是字符串)\n\n**Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)**\n\n`str` 类型是硬编码进可执行文件，也无法被修改，但是 `String` 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，**当 Rust 用户提到字符串时，往往指的就是 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码**。\n\n```\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\nassert_eq!(slice, &[2, 3]);\n\n```\n\n\n\n## [String 与 &str 的转换](https://course.rs/basic/compound-type/string-slice.html#string-与-str-的转换)\n\n```\nfn main() {\n    let s = String::from(\"hello,world!\");\n    say_hello(&s);\n    say_hello(&s[..]);\n    say_hello(s.as_str());\n}\n\nfn say_hello(s: &str) {\n    println!(\"{}\",s);\n}\n```\n\n## [字符串索引](https://course.rs/basic/compound-type/string-slice.html#字符串索引)\n\n## [字符串切片](https://course.rs/basic/compound-type/string-slice.html#字符串切片)\n\n通过索引区间来访问字符串时，**需要格外的小心**，一不注意，就会导致你程序的崩溃！\n\n## [操作字符串](https://course.rs/basic/compound-type/string-slice.html#操作字符串)\n\n#### [追加 (Push)](https://course.rs/basic/compound-type/string-slice.html#追加-push)\n\n\n\n#### [插入 (Insert)](https://course.rs/basic/compound-type/string-slice.html#插入-insert)\n\n#### [替换 (Replace)](https://course.rs/basic/compound-type/string-slice.html#替换-replace)\n\n#### [删除 (Delete)](https://course.rs/basic/compound-type/string-slice.html#删除-delete)\n\n#### [连接 (Concatenate)](https://course.rs/basic/compound-type/string-slice.html#连接-concatenate)\n\n## [字符串转义](https://course.rs/basic/compound-type/string-slice.html#字符串转义)\n\n```\nfn main() {\n    println!(\"{}\", \"hello \\\\x52\\\\x75\\\\x73\\\\x74\");\n    let raw_str = r\"Escapes don't work here: \\x3F \\u{211D}\";\n    println!(\"{}\", raw_str);\n\n    // 如果字符串包含双引号，可以在开头和结尾加 #\n    let quotes = r#\"And then I said: \"There is no escape!\"\"#;\n    println!(\"{}\", quotes);\n\n    // 如果还是有歧义，可以继续增加，没有限制\n    let longer_delimiter = r###\"A string with \"# in it. And even \"##!\"###;\n    println!(\"{}\", longer_delimiter);\n}\n```\n\n## [操作 UTF-8 字符串](https://course.rs/basic/compound-type/string-slice.html#操作-utf-8-字符串)\n\n[字符串与切片 - Rust语言圣经(Rust Course)](https://course.rs/basic/compound-type/string-slice.html#课后练习)\n\n```\nfor c in \"中国人\".chars() {\n    println!(\"{}\", c);\n}\n```\n\n## [课后练习](https://course.rs/basic/compound-type/string-slice.html#课后练习)\n\n> Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。\n>\n> - [字符串](https://zh.practice.rs/compound-types/string.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md)\n> - [切片](https://zh.practice.rs/compound-types/slice.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md)\n> - [String](https://zh.practice.rs/collections/String.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md)\n\n```\n\n// 填空并修复错误\nfn main() {\n    let s = String::from(\"hello, 世界\");\n    let slice1 = &s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节\n    assert_eq!(slice1, \"h\");\n\n    let slice2 = &s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节\n    assert_eq!(slice2, \"世\");\n    \n    // 迭代 s 中的所有字符\n    for (i, c) in s.chars().enumerate() {\n        if i == 7 {\n            assert_eq!(c, '世')\n        }\n    }\n\n    println!(\"Success!\")\n}\n\n\n\n// 填空\nfn main() {\n    let mut s = String::new();\n     s.push_str(\"hello\");\n\n    let v = vec![104, 101, 108, 108, 111];\n\n    // 将字节数组转换成 String\n    let s1 = String::from_utf8(v).unwrap();\n    \n    \n    assert_eq!(s, s1);\n\n    println!(\"Success!\")\n}\n\n\n\n// 填空\nuse std::mem;\n\nfn main() {\n    let story = String::from(\"Rust By Practice\");\n\n    // 阻止 String 的数据被自动 drop\n    let mut story = mem::ManuallyDrop::new(story);\n\n    let ptr = story.as_mut_ptr();\n    let len = story.len();\n    let capacity = story.capacity();\n\n    assert_eq!(16, len);\n\n    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. \n    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的\n    let s = unsafe { String::from_raw_parts(ptr, len, capacity) };\n\n    assert_eq!(*story, s);\n\n    println!(\"Success!\")\n}\n\n```\n\n\n\n# 2.[元组](https://course.rs/basic/compound-type/tuple.html#元组)\n\n# 3. 元组\n# 4. test\n\n待续。。。\n","source":"back_posts/03-rust复合类型.md","raw":"---\ntitle: 03-rust复合类型\ndate: 2023-08-28 21:58:27\ncategories:\n- rust\ntags:\n- rust复合类型\n- rust\n---\n\n\n\n\n\n# 1.字符串和切片\n\n## [什么是字符串?](https://course.rs/basic/compound-type/string-slice.html#什么是字符串)\n\n**Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)**\n\n`str` 类型是硬编码进可执行文件，也无法被修改，但是 `String` 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，**当 Rust 用户提到字符串时，往往指的就是 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码**。\n\n```\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\nassert_eq!(slice, &[2, 3]);\n\n```\n\n\n\n## [String 与 &str 的转换](https://course.rs/basic/compound-type/string-slice.html#string-与-str-的转换)\n\n```\nfn main() {\n    let s = String::from(\"hello,world!\");\n    say_hello(&s);\n    say_hello(&s[..]);\n    say_hello(s.as_str());\n}\n\nfn say_hello(s: &str) {\n    println!(\"{}\",s);\n}\n```\n\n## [字符串索引](https://course.rs/basic/compound-type/string-slice.html#字符串索引)\n\n## [字符串切片](https://course.rs/basic/compound-type/string-slice.html#字符串切片)\n\n通过索引区间来访问字符串时，**需要格外的小心**，一不注意，就会导致你程序的崩溃！\n\n## [操作字符串](https://course.rs/basic/compound-type/string-slice.html#操作字符串)\n\n#### [追加 (Push)](https://course.rs/basic/compound-type/string-slice.html#追加-push)\n\n\n\n#### [插入 (Insert)](https://course.rs/basic/compound-type/string-slice.html#插入-insert)\n\n#### [替换 (Replace)](https://course.rs/basic/compound-type/string-slice.html#替换-replace)\n\n#### [删除 (Delete)](https://course.rs/basic/compound-type/string-slice.html#删除-delete)\n\n#### [连接 (Concatenate)](https://course.rs/basic/compound-type/string-slice.html#连接-concatenate)\n\n## [字符串转义](https://course.rs/basic/compound-type/string-slice.html#字符串转义)\n\n```\nfn main() {\n    println!(\"{}\", \"hello \\\\x52\\\\x75\\\\x73\\\\x74\");\n    let raw_str = r\"Escapes don't work here: \\x3F \\u{211D}\";\n    println!(\"{}\", raw_str);\n\n    // 如果字符串包含双引号，可以在开头和结尾加 #\n    let quotes = r#\"And then I said: \"There is no escape!\"\"#;\n    println!(\"{}\", quotes);\n\n    // 如果还是有歧义，可以继续增加，没有限制\n    let longer_delimiter = r###\"A string with \"# in it. And even \"##!\"###;\n    println!(\"{}\", longer_delimiter);\n}\n```\n\n## [操作 UTF-8 字符串](https://course.rs/basic/compound-type/string-slice.html#操作-utf-8-字符串)\n\n[字符串与切片 - Rust语言圣经(Rust Course)](https://course.rs/basic/compound-type/string-slice.html#课后练习)\n\n```\nfor c in \"中国人\".chars() {\n    println!(\"{}\", c);\n}\n```\n\n## [课后练习](https://course.rs/basic/compound-type/string-slice.html#课后练习)\n\n> Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。\n>\n> - [字符串](https://zh.practice.rs/compound-types/string.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md)\n> - [切片](https://zh.practice.rs/compound-types/slice.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md)\n> - [String](https://zh.practice.rs/collections/String.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md)\n\n```\n\n// 填空并修复错误\nfn main() {\n    let s = String::from(\"hello, 世界\");\n    let slice1 = &s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节\n    assert_eq!(slice1, \"h\");\n\n    let slice2 = &s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节\n    assert_eq!(slice2, \"世\");\n    \n    // 迭代 s 中的所有字符\n    for (i, c) in s.chars().enumerate() {\n        if i == 7 {\n            assert_eq!(c, '世')\n        }\n    }\n\n    println!(\"Success!\")\n}\n\n\n\n// 填空\nfn main() {\n    let mut s = String::new();\n     s.push_str(\"hello\");\n\n    let v = vec![104, 101, 108, 108, 111];\n\n    // 将字节数组转换成 String\n    let s1 = String::from_utf8(v).unwrap();\n    \n    \n    assert_eq!(s, s1);\n\n    println!(\"Success!\")\n}\n\n\n\n// 填空\nuse std::mem;\n\nfn main() {\n    let story = String::from(\"Rust By Practice\");\n\n    // 阻止 String 的数据被自动 drop\n    let mut story = mem::ManuallyDrop::new(story);\n\n    let ptr = story.as_mut_ptr();\n    let len = story.len();\n    let capacity = story.capacity();\n\n    assert_eq!(16, len);\n\n    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. \n    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的\n    let s = unsafe { String::from_raw_parts(ptr, len, capacity) };\n\n    assert_eq!(*story, s);\n\n    println!(\"Success!\")\n}\n\n```\n\n\n\n# 2.[元组](https://course.rs/basic/compound-type/tuple.html#元组)\n\n# 3. 元组\n# 4. test\n\n待续。。。\n","updated":"2024-05-15T06:11:08.981Z","path":"back_posts/03-rust复合类型.html","comments":1,"layout":"page","_id":"clw7fflkn0002x2w069iu77y8","content":"<h1 id=\"1-字符串和切片\"><a href=\"#1-字符串和切片\" class=\"headerlink\" title=\"1.字符串和切片\"></a>1.字符串和切片</h1><h2 id=\"什么是字符串\"><a href=\"#什么是字符串\" class=\"headerlink\" title=\"什么是字符串?\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2\">什么是字符串?</a></h2><p><strong>Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)</strong></p>\n<p><code>str</code> 类型是硬编码进可执行文件，也无法被修改，但是 <code>String</code> 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，<strong>当 Rust 用户提到字符串时，往往指的就是 <code>String</code> 类型和 <code>&amp;str</code> 字符串切片类型，这两个类型都是 UTF-8 编码</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1, 2, 3, 4, 5];</span><br><span class=\"line\"></span><br><span class=\"line\">let slice = &amp;a[1..3];</span><br><span class=\"line\"></span><br><span class=\"line\">assert_eq!(slice, &amp;[2, 3]);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"String-与-str-的转换\"><a href=\"#String-与-str-的转换\" class=\"headerlink\" title=\"String 与 &amp;str 的转换\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#string-%E4%B8%8E-str-%E7%9A%84%E8%BD%AC%E6%8D%A2\">String 与 &amp;str 的转换</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let s = String::from(&quot;hello,world!&quot;);</span><br><span class=\"line\">    say_hello(&amp;s);</span><br><span class=\"line\">    say_hello(&amp;s[..]);</span><br><span class=\"line\">    say_hello(s.as_str());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn say_hello(s: &amp;str) &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;,s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串索引\"><a href=\"#字符串索引\" class=\"headerlink\" title=\"字符串索引\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95\">字符串索引</a></h2><h2 id=\"字符串切片\"><a href=\"#字符串切片\" class=\"headerlink\" title=\"字符串切片\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87\">字符串切片</a></h2><p>通过索引区间来访问字符串时，<strong>需要格外的小心</strong>，一不注意，就会导致你程序的崩溃！</p>\n<h2 id=\"操作字符串\"><a href=\"#操作字符串\" class=\"headerlink\" title=\"操作字符串\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2\">操作字符串</a></h2><h4 id=\"追加-Push\"><a href=\"#追加-Push\" class=\"headerlink\" title=\"追加 (Push)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%BF%BD%E5%8A%A0-push\">追加 (Push)</a></h4><h4 id=\"插入-Insert\"><a href=\"#插入-Insert\" class=\"headerlink\" title=\"插入 (Insert)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%8F%92%E5%85%A5-insert\">插入 (Insert)</a></h4><h4 id=\"替换-Replace\"><a href=\"#替换-Replace\" class=\"headerlink\" title=\"替换 (Replace)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%9B%BF%E6%8D%A2-replace\">替换 (Replace)</a></h4><h4 id=\"删除-Delete\"><a href=\"#删除-Delete\" class=\"headerlink\" title=\"删除 (Delete)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%88%A0%E9%99%A4-delete\">删除 (Delete)</a></h4><h4 id=\"连接-Concatenate\"><a href=\"#连接-Concatenate\" class=\"headerlink\" title=\"连接 (Concatenate)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%BF%9E%E6%8E%A5-concatenate\">连接 (Concatenate)</a></h4><h2 id=\"字符串转义\"><a href=\"#字符串转义\" class=\"headerlink\" title=\"字符串转义\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89\">字符串转义</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, &quot;hello \\\\x52\\\\x75\\\\x73\\\\x74&quot;);</span><br><span class=\"line\">    let raw_str = r&quot;Escapes don&#x27;t work here: \\x3F \\u&#123;211D&#125;&quot;;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, raw_str);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果字符串包含双引号，可以在开头和结尾加 #</span><br><span class=\"line\">    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, quotes);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果还是有歧义，可以继续增加，没有限制</span><br><span class=\"line\">    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, longer_delimiter);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作-UTF-8-字符串\"><a href=\"#操作-UTF-8-字符串\" class=\"headerlink\" title=\"操作 UTF-8 字符串\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2\">操作 UTF-8 字符串</a></h2><p><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0\">字符串与切片 - Rust语言圣经(Rust Course)</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for c in &quot;中国人&quot;.chars() &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"课后练习\"><a href=\"#课后练习\" class=\"headerlink\" title=\"课后练习\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0\">课后练习</a></h2><blockquote>\n<p>Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。</p>\n<ul>\n<li><a href=\"https://zh.practice.rs/compound-types/string.html\">字符串</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md\">习题解答</a></li>\n</ul>\n</li>\n<li><a href=\"https://zh.practice.rs/compound-types/slice.html\">切片</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md\">习题解答</a></li>\n</ul>\n</li>\n<li><a href=\"https://zh.practice.rs/collections/String.html\">String</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md\">习题解答</a></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 填空并修复错误</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let s = String::from(&quot;hello, 世界&quot;);</span><br><span class=\"line\">    let slice1 = &amp;s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节</span><br><span class=\"line\">    assert_eq!(slice1, &quot;h&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let slice2 = &amp;s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节</span><br><span class=\"line\">    assert_eq!(slice2, &quot;世&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 迭代 s 中的所有字符</span><br><span class=\"line\">    for (i, c) in s.chars().enumerate() &#123;</span><br><span class=\"line\">        if i == 7 &#123;</span><br><span class=\"line\">            assert_eq!(c, &#x27;世&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 填空</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let mut s = String::new();</span><br><span class=\"line\">     s.push_str(&quot;hello&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let v = vec![104, 101, 108, 108, 111];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将字节数组转换成 String</span><br><span class=\"line\">    let s1 = String::from_utf8(v).unwrap();</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    assert_eq!(s, s1);</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 填空</span><br><span class=\"line\">use std::mem;</span><br><span class=\"line\"></span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let story = String::from(&quot;Rust By Practice&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 阻止 String 的数据被自动 drop</span><br><span class=\"line\">    let mut story = mem::ManuallyDrop::new(story);</span><br><span class=\"line\"></span><br><span class=\"line\">    let ptr = story.as_mut_ptr();</span><br><span class=\"line\">    let len = story.len();</span><br><span class=\"line\">    let capacity = story.capacity();</span><br><span class=\"line\"></span><br><span class=\"line\">    assert_eq!(16, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. </span><br><span class=\"line\">    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的</span><br><span class=\"line\">    let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert_eq!(*story, s);</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"2-元组\"><a href=\"#2-元组\" class=\"headerlink\" title=\"2.元组\"></a>2.<a href=\"https://course.rs/basic/compound-type/tuple.html#%E5%85%83%E7%BB%84\">元组</a></h1><h1 id=\"3-元组\"><a href=\"#3-元组\" class=\"headerlink\" title=\"3. 元组\"></a>3. 元组</h1><h1 id=\"4-test\"><a href=\"#4-test\" class=\"headerlink\" title=\"4. test\"></a>4. test</h1><p>待续。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-字符串和切片\"><a href=\"#1-字符串和切片\" class=\"headerlink\" title=\"1.字符串和切片\"></a>1.字符串和切片</h1><h2 id=\"什么是字符串\"><a href=\"#什么是字符串\" class=\"headerlink\" title=\"什么是字符串?\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2\">什么是字符串?</a></h2><p><strong>Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)</strong></p>\n<p><code>str</code> 类型是硬编码进可执行文件，也无法被修改，但是 <code>String</code> 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，<strong>当 Rust 用户提到字符串时，往往指的就是 <code>String</code> 类型和 <code>&amp;str</code> 字符串切片类型，这两个类型都是 UTF-8 编码</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1, 2, 3, 4, 5];</span><br><span class=\"line\"></span><br><span class=\"line\">let slice = &amp;a[1..3];</span><br><span class=\"line\"></span><br><span class=\"line\">assert_eq!(slice, &amp;[2, 3]);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"String-与-str-的转换\"><a href=\"#String-与-str-的转换\" class=\"headerlink\" title=\"String 与 &amp;str 的转换\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#string-%E4%B8%8E-str-%E7%9A%84%E8%BD%AC%E6%8D%A2\">String 与 &amp;str 的转换</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let s = String::from(&quot;hello,world!&quot;);</span><br><span class=\"line\">    say_hello(&amp;s);</span><br><span class=\"line\">    say_hello(&amp;s[..]);</span><br><span class=\"line\">    say_hello(s.as_str());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn say_hello(s: &amp;str) &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;,s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串索引\"><a href=\"#字符串索引\" class=\"headerlink\" title=\"字符串索引\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95\">字符串索引</a></h2><h2 id=\"字符串切片\"><a href=\"#字符串切片\" class=\"headerlink\" title=\"字符串切片\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87\">字符串切片</a></h2><p>通过索引区间来访问字符串时，<strong>需要格外的小心</strong>，一不注意，就会导致你程序的崩溃！</p>\n<h2 id=\"操作字符串\"><a href=\"#操作字符串\" class=\"headerlink\" title=\"操作字符串\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2\">操作字符串</a></h2><h4 id=\"追加-Push\"><a href=\"#追加-Push\" class=\"headerlink\" title=\"追加 (Push)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%BF%BD%E5%8A%A0-push\">追加 (Push)</a></h4><h4 id=\"插入-Insert\"><a href=\"#插入-Insert\" class=\"headerlink\" title=\"插入 (Insert)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%8F%92%E5%85%A5-insert\">插入 (Insert)</a></h4><h4 id=\"替换-Replace\"><a href=\"#替换-Replace\" class=\"headerlink\" title=\"替换 (Replace)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%9B%BF%E6%8D%A2-replace\">替换 (Replace)</a></h4><h4 id=\"删除-Delete\"><a href=\"#删除-Delete\" class=\"headerlink\" title=\"删除 (Delete)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%88%A0%E9%99%A4-delete\">删除 (Delete)</a></h4><h4 id=\"连接-Concatenate\"><a href=\"#连接-Concatenate\" class=\"headerlink\" title=\"连接 (Concatenate)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%BF%9E%E6%8E%A5-concatenate\">连接 (Concatenate)</a></h4><h2 id=\"字符串转义\"><a href=\"#字符串转义\" class=\"headerlink\" title=\"字符串转义\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89\">字符串转义</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, &quot;hello \\\\x52\\\\x75\\\\x73\\\\x74&quot;);</span><br><span class=\"line\">    let raw_str = r&quot;Escapes don&#x27;t work here: \\x3F \\u&#123;211D&#125;&quot;;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, raw_str);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果字符串包含双引号，可以在开头和结尾加 #</span><br><span class=\"line\">    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, quotes);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果还是有歧义，可以继续增加，没有限制</span><br><span class=\"line\">    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, longer_delimiter);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作-UTF-8-字符串\"><a href=\"#操作-UTF-8-字符串\" class=\"headerlink\" title=\"操作 UTF-8 字符串\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2\">操作 UTF-8 字符串</a></h2><p><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0\">字符串与切片 - Rust语言圣经(Rust Course)</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for c in &quot;中国人&quot;.chars() &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"课后练习\"><a href=\"#课后练习\" class=\"headerlink\" title=\"课后练习\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0\">课后练习</a></h2><blockquote>\n<p>Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。</p>\n<ul>\n<li><a href=\"https://zh.practice.rs/compound-types/string.html\">字符串</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md\">习题解答</a></li>\n</ul>\n</li>\n<li><a href=\"https://zh.practice.rs/compound-types/slice.html\">切片</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md\">习题解答</a></li>\n</ul>\n</li>\n<li><a href=\"https://zh.practice.rs/collections/String.html\">String</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md\">习题解答</a></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 填空并修复错误</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let s = String::from(&quot;hello, 世界&quot;);</span><br><span class=\"line\">    let slice1 = &amp;s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节</span><br><span class=\"line\">    assert_eq!(slice1, &quot;h&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let slice2 = &amp;s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节</span><br><span class=\"line\">    assert_eq!(slice2, &quot;世&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 迭代 s 中的所有字符</span><br><span class=\"line\">    for (i, c) in s.chars().enumerate() &#123;</span><br><span class=\"line\">        if i == 7 &#123;</span><br><span class=\"line\">            assert_eq!(c, &#x27;世&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 填空</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let mut s = String::new();</span><br><span class=\"line\">     s.push_str(&quot;hello&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let v = vec![104, 101, 108, 108, 111];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将字节数组转换成 String</span><br><span class=\"line\">    let s1 = String::from_utf8(v).unwrap();</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    assert_eq!(s, s1);</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 填空</span><br><span class=\"line\">use std::mem;</span><br><span class=\"line\"></span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let story = String::from(&quot;Rust By Practice&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 阻止 String 的数据被自动 drop</span><br><span class=\"line\">    let mut story = mem::ManuallyDrop::new(story);</span><br><span class=\"line\"></span><br><span class=\"line\">    let ptr = story.as_mut_ptr();</span><br><span class=\"line\">    let len = story.len();</span><br><span class=\"line\">    let capacity = story.capacity();</span><br><span class=\"line\"></span><br><span class=\"line\">    assert_eq!(16, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. </span><br><span class=\"line\">    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的</span><br><span class=\"line\">    let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert_eq!(*story, s);</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"2-元组\"><a href=\"#2-元组\" class=\"headerlink\" title=\"2.元组\"></a>2.<a href=\"https://course.rs/basic/compound-type/tuple.html#%E5%85%83%E7%BB%84\">元组</a></h1><h1 id=\"3-元组\"><a href=\"#3-元组\" class=\"headerlink\" title=\"3. 元组\"></a>3. 元组</h1><h1 id=\"4-test\"><a href=\"#4-test\" class=\"headerlink\" title=\"4. test\"></a>4. test</h1><p>待续。。。</p>\n"},{"title":"01-rust环境搭建","date":"2023-08-26T09:03:59.000Z","categories":["rust"],"tags":["rust环境搭建","rust"],"_content":"\n\n\n\n\n\n\n\n\n\n\n当前环境：win11+wsl+vscode\n\n## 1.安装rustup\n\n```\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\nsudo apt install build-essential\nrustc -V \ncargo -V\n```\n\n## 2.安装vsocode插件\n\n```\nrust-analyzer ，Rust 语言插件\nEven Better TOML，支持 .toml 文件完整特性\nError Lens, 更好的获得错误展示\nOne Dark Pro, 非常好看的 VSCode 主题\nCodeLLDB, Debugger 程序\n```\n\n## 3.运行hello world!\n\n```\ncargo new world_hello\ncd world_hello\ncargo run\n#编译\ncargo build\n#运行\n./target/debug/world_hello\nHello, world!\n#快速的检查一下代码能否编译通过\ncargo check\n```\n\n## 4.修改 Rust 的下载镜像为国内的镜像地址\n\n```\n#在 $HOME/.cargo/config.toml 添加以下内容：\n\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n","source":"back_posts/01-rust环境搭建.md","raw":"---\ntitle: 01-rust环境搭建\ndate: 2023-08-26 17:03:59\ncategories:\n- rust\ntags:\n- rust环境搭建\n- rust\n---\n\n\n\n\n\n\n\n\n\n\n\n当前环境：win11+wsl+vscode\n\n## 1.安装rustup\n\n```\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\nsudo apt install build-essential\nrustc -V \ncargo -V\n```\n\n## 2.安装vsocode插件\n\n```\nrust-analyzer ，Rust 语言插件\nEven Better TOML，支持 .toml 文件完整特性\nError Lens, 更好的获得错误展示\nOne Dark Pro, 非常好看的 VSCode 主题\nCodeLLDB, Debugger 程序\n```\n\n## 3.运行hello world!\n\n```\ncargo new world_hello\ncd world_hello\ncargo run\n#编译\ncargo build\n#运行\n./target/debug/world_hello\nHello, world!\n#快速的检查一下代码能否编译通过\ncargo check\n```\n\n## 4.修改 Rust 的下载镜像为国内的镜像地址\n\n```\n#在 $HOME/.cargo/config.toml 添加以下内容：\n\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n","updated":"2024-05-15T06:11:08.969Z","path":"back_posts/01-rust环境搭建.html","comments":1,"layout":"page","_id":"clw7fflkp0004x2w09qqu8rpq","content":"<p>当前环境：win11+wsl+vscode</p>\n<h2 id=\"1-安装rustup\"><a href=\"#1-安装rustup\" class=\"headerlink\" title=\"1.安装rustup\"></a>1.安装rustup</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br><span class=\"line\">sudo apt install build-essential</span><br><span class=\"line\">rustc -V </span><br><span class=\"line\">cargo -V</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装vsocode插件\"><a href=\"#2-安装vsocode插件\" class=\"headerlink\" title=\"2.安装vsocode插件\"></a>2.安装vsocode插件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rust-analyzer ，Rust 语言插件</span><br><span class=\"line\">Even Better TOML，支持 .toml 文件完整特性</span><br><span class=\"line\">Error Lens, 更好的获得错误展示</span><br><span class=\"line\">One Dark Pro, 非常好看的 VSCode 主题</span><br><span class=\"line\">CodeLLDB, Debugger 程序</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-运行hello-world\"><a href=\"#3-运行hello-world\" class=\"headerlink\" title=\"3.运行hello world!\"></a>3.运行hello world!</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo new world_hello</span><br><span class=\"line\">cd world_hello</span><br><span class=\"line\">cargo run</span><br><span class=\"line\">#编译</span><br><span class=\"line\">cargo build</span><br><span class=\"line\">#运行</span><br><span class=\"line\">./target/debug/world_hello</span><br><span class=\"line\">Hello, world!</span><br><span class=\"line\">#快速的检查一下代码能否编译通过</span><br><span class=\"line\">cargo check</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-修改-Rust-的下载镜像为国内的镜像地址\"><a href=\"#4-修改-Rust-的下载镜像为国内的镜像地址\" class=\"headerlink\" title=\"4.修改 Rust 的下载镜像为国内的镜像地址\"></a>4.修改 Rust 的下载镜像为国内的镜像地址</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在 $HOME/.cargo/config.toml 添加以下内容：</span><br><span class=\"line\"></span><br><span class=\"line\">[source.crates-io]</span><br><span class=\"line\">replace-with = &#x27;ustc&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">[source.ustc]</span><br><span class=\"line\">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>当前环境：win11+wsl+vscode</p>\n<h2 id=\"1-安装rustup\"><a href=\"#1-安装rustup\" class=\"headerlink\" title=\"1.安装rustup\"></a>1.安装rustup</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br><span class=\"line\">sudo apt install build-essential</span><br><span class=\"line\">rustc -V </span><br><span class=\"line\">cargo -V</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装vsocode插件\"><a href=\"#2-安装vsocode插件\" class=\"headerlink\" title=\"2.安装vsocode插件\"></a>2.安装vsocode插件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rust-analyzer ，Rust 语言插件</span><br><span class=\"line\">Even Better TOML，支持 .toml 文件完整特性</span><br><span class=\"line\">Error Lens, 更好的获得错误展示</span><br><span class=\"line\">One Dark Pro, 非常好看的 VSCode 主题</span><br><span class=\"line\">CodeLLDB, Debugger 程序</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-运行hello-world\"><a href=\"#3-运行hello-world\" class=\"headerlink\" title=\"3.运行hello world!\"></a>3.运行hello world!</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo new world_hello</span><br><span class=\"line\">cd world_hello</span><br><span class=\"line\">cargo run</span><br><span class=\"line\">#编译</span><br><span class=\"line\">cargo build</span><br><span class=\"line\">#运行</span><br><span class=\"line\">./target/debug/world_hello</span><br><span class=\"line\">Hello, world!</span><br><span class=\"line\">#快速的检查一下代码能否编译通过</span><br><span class=\"line\">cargo check</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-修改-Rust-的下载镜像为国内的镜像地址\"><a href=\"#4-修改-Rust-的下载镜像为国内的镜像地址\" class=\"headerlink\" title=\"4.修改 Rust 的下载镜像为国内的镜像地址\"></a>4.修改 Rust 的下载镜像为国内的镜像地址</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在 $HOME/.cargo/config.toml 添加以下内容：</span><br><span class=\"line\"></span><br><span class=\"line\">[source.crates-io]</span><br><span class=\"line\">replace-with = &#x27;ustc&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">[source.ustc]</span><br><span class=\"line\">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"cpufreq","date":"2024-04-28T09:04:13.000Z","categories":["kernel"],"tags":["power","cpufreq"],"_content":"\n[toc]\n\n# cpufreq\n\n\n\nCPUFreq框架是内核的CPU调频框架，整个调频框架由以下几个部分组成：\n\n- cpufreq driver\n- cpufreq framework (core)\n- cpufreq governor\n\n一些基本概念：\n\nP-state: voltage and frequency point\n\n总体上，CPU Freq主要在sysfs向userspace提供了调频操作和策略设置节点。当使用一些自动调频的governor时，允许governor从系统获取信息，自动触发调频动作。\n\n另外，还向其他模块提供了qos频率投票，以及调频事件的notifier机制。\n\n下面分开来看每个部分。\n\n## Driver\n\n\n\nCpufreq Driver主要负责底层调频的操作，核心是实现 `cpufreq_dirver` 对象，并通过 `cpufreq_register_driver` 将驱动注册到系统，供core部分使用。\n\n其中，最核心的几个回调包括：\n\n- online: hotplug callback\n- offline: hotplug callback\n- target_index: set freq\n- set_boost: enter into boost mode\n\n以 `mediatek-cpufreq-hw.c` 为例，其freq table保存在硬件寄存器中，driver初始化时，从硬件中读出freq table，并实现相关调频回调，最终注册到core。\n\ndb845c使用的 `qcom-cpufreq-hw.c` 为例，其freq table保存在dts中，driver使用OPP框架来读取这些配置，并实现cpufreq回调。\n\n\\* OPP（Operating Performance Point，提供dts的freq-valt-table配置，及获取接口。\n\n## Core\n\n\n\nCore部分核心文件是 `/drivers/cpufreq/cpufreq.c`\n\n这个文件主要实现了BOOST，DRIVER，SYSFS，FREQ，NOTIFIER，GOVERNOR，POLICY相关功能的操作接口。\n\n`cpufreq_register_driver` (cpufreq_driver* cpufreq_driver)\n\n`cpufreq_register_governor` (cpufreq_governor_list)\n\n`cpufreq_register_notifier` (cpufreq_transition_notifier_list)\n\n`cpufreq_policy_alloc` (cpufreq_policy* PERCPU:cpufreq_cpu_data)\n\n`cpufreq_policy` 是一个调频实体，对应一个调频域（freq domain），一般为一个cluster，这个结构保存了每个调频实体（通常是一个cluster）调频相关的所有私有信息。同时，他作为调频操作的句柄，cpufreq顶层操作接口使用policy来对一个调频实体进行操作。\n\n每个CPU有一个percpu的指针指向其所属的policy，cluster中的多个CPU共享一个policy。（`cpufreq_cpu_data`）\n\nMainflow：\n\n1、cpufreq driver注册\n\n2、governor注册（每个policy初始化自己的governor）\n\n3、cpu hotplug state: \"cpufreq:online\"，`cpuhp_cpufreq_online`、`cpuhp_cpufreq_offline`，创建出percpu policy，绑定driver、governor\n\n4、向sysfs创建节点，提供功能\n\n5、governor开始工作，通过 `__cpufreq_driver_target` 进行调频。\n\n- Qos是调频投票机制，用来实现max_freq、min_freq limitation。(`cpufreq_notifier_min` `cpufreq_notifier_max`)，在其他module有需求投票后，freq constrants会被更新。\n\n## Sysfs\n\n\n\n```\n/sys/devices/system/cpu/cpu0/cpufreq/policyX\nscaling_driver\t\t\tr\t# cpufreq driver name\naffected_cpus\t\t\tr\t# cpu\nrelated_cpus\t\t\tr\t# <?>\nscaling_cur_freq\t\trw\t# cur freq\nscaling_min_freq\t\trw\t# min freq limit\nscaling_max_freq\t\trw\t# max freq limit\nscaling_governor\t\trw\t# selected governor\nscaling_available_governors\tr\t# available governors\nscaling_setspeed\t\tr\t# <not supported>\ncpuinfo_min_freq\t\tr\t# hardware min freq\ncpuinfo_max_freq\t\tr\t# hardware max freq\ncpuinfo_transition_latency\tr\t# hardware latency\n```\n\n\n\n## Governors\n\n\n\nGovernor负责从系统收集信息，并触发调频动作。\n\n**powersave**\n\nalways lowest frequency\n\n**performance**\n\nalways highest frequency\n\n**schedutil**\n\nuses CPU utilization data from scheduler to determine target frequence\n\n待完成\n\n**userspace**\n\nallow user space set the frequency\n\n**ondemand**\n\nuses CPU load as a CPU frequency selection metric\n\nit reaches the target by CPU load, 0->min, 100->max\n\n**conservative**\n\nuses CPU load as a CPU frequency selection metric\n\nit reaches the target step by step, up_threshold->up, down_threshold->down\n\n## Files\n\n\n\n```\n- /drivers/cpufreq/cpufreq.c\n- /drivers/cpufreq/cpufreq-dt.c\n- /drivers/cpufreq/cpufreq_stats.c\n- /drivers/cpufreq/cpufreq_conservative.c\n- /drivers/cpufreq/cpufreq_governor.c\n- /drivers/cpufreq/cpufreq_ondemand.c\n- /drivers/cpufreq/cpufreq_powersave.c\n- /drivers/cpufreq/cpufreq_performance.c\n- /drivers/cpufreq/cpufreq_userspace.c\n- /kernel/sched/cpufreq_schedutil.c\n- /kernel/power/qos.c\n```\n\n## rk3588-cpufreq-sys\n\n>查看cpufreq节点\n>RK3588的cpu是4个A55+4个A76，分为3组单独管理，节点分别是：\n>/sys/devices/system/cpu/cpufreq/policy0:（对应4个A55：CPU0-3）\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed\n>\n>/sys/devices/system/cpu/cpufreq/policy4:(对应2个A76：CPU4-5)\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed\n>\n>/sys/devices/system/cpu/cpufreq/policy6:(对应2个A76：CPU6-7)\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_drive\n>                        \n>\n>CPU性能模式\n>echo performance > /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>获取cpu运行的模式\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_available_governors\n>获取当前CPU支持的频点\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_available_frequencies\n>\n>cat /sys/devices/system/cpu/cpufreq/policy6/cpuinfo_cur_freq       \n>\n>\n>2.0设置cpufrq为performance模式\n>echo performance > /sys/devices/system/cpu/cpufreq/policy0/scaling_governor\n>echo performance > /sys/devices/system/cpu/cpufreq/policy4/scaling_governor\n>echo performance > /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>\n>查看模式\n>cat /sys/devices/system/cpu/cpufreq/policy*/scaling_governor\n>查看频率\n>cat /sys/devices/system/cpu/cpufreq/policy*/cpuinfo_cur_freq       \n\n## rk3588-cpufreq-code\n\n![cpufreq framework](../imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif)\n\n相关文件\n\nkernel/drivers/cpufreq/cpufreq.c\n\nkernel/drivers/cpufreq/rockchip-cpufreq.c\n\nkernel/drivers/cpufreq/cpufreq-dt-platdev.c\n\nkernel/drivers/cpufreq/cpufreq-dt.c\n\n```\nCONFIG_CPU_FREQ=y\nCONFIG_CPU_FREQ_STAT=y\nCONFIG_CPU_FREQ_TIMES=y\nCONFIG_CPU_FREQ_GOV_POWERSAVE=y\nCONFIG_CPU_FREQ_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_CPU_FREQ_GOV_CONSERVATIVE=y\nCONFIG_CPU_FREQ_GOV_INTERACTIVE=y\nCONFIG_CPU_FREQ_GOV_PERFORMANCE=y\nCONFIG_CPU_FREQ_GOV_COMMON=y\nCONFIG_CPU_FREQ_GOV_ATTR_SET=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y\nCONFIG_CPUFREQ_DT=y\n```\n\n\n\n### 1. CPUFreq核心和接口\n\ncpufreq代码为CPUFreq架构的驱 动程序（那些执行硬件频率切换的代码）以及 “通知器” 提供了一个标准化的接口。 包括设备驱动程序；需要了解策略变化（如 ACPI 热量管理），或所有频率变化（如计时代码）， 甚至需要强制限制为指定频率（如 ARM 架构上的 LCD 驱动程序）的其它内核组件。 此外，内核 “常数” loops_per_jiffy 会根据频率变化而更新。\n\ncpufreq策略的引用计数由 cpufreq_cpu_get 和 cpufreq_cpu_put 来完成，以确保 cpufreq 驱 动程序被正确地注册到核心中，并且驱动程序在 cpufreq_put_cpu 被调用之前不会被卸载。这也保证 了每个CPU核的cpufreq 策略在使用期间不会被释放。\n\n### 2. CPUFreq 通知器\n\nCPUFreq通知器遵循标准的内核通知器接口。 关于通知器的细节请参阅 linux/include/linux/notifier.h。\n\n这里有两个不同的CPUfreq通知器 - 策略通知器和转换通知器。\n\n#### 2.1 CPUFreq策略通知器\n\n当创建或移除策略时，这些都会被通知。\n\n阶段是在通知器的第二个参数中指定的。当第一次创建策略时，阶段是CPUFREQ_CREATE_POLICY，当 策略被移除时，阶段是CPUFREQ_REMOVE_POLICY。\n\n第三个参数 `void *pointer` 指向一个结构体cpufreq_policy，其包括min，max(新策略的下限和 上限（单位为kHz）)这几个值。\n\n#### 2.2 CPUFreq转换通知器\n\n当CPUfreq驱动切换CPU核心频率时，策略中的每个在线CPU都会收到两次通知，这些变化没有任何外部干 预。\n\n第二个参数指定阶段 - CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.\n\n第三个参数是一个包含如下值的结构体cpufreq_freqs：\n\n| policy | 指向struct cpufreq_policy的指针 |\n| ------ | ------------------------------- |\n| old    | 旧频率                          |\n| new    | 新频率                          |\n| flags  | cpufreq驱动的标志               |\n\n\n\n\n\n```\ncore_initcall(cpufreq_core_init);\n\tcpufreq_default_governor\t\t//获取默认的cpufreq策略 如schedutil powersave performace等\n\tkobject_create_and_add\t\t\t//创建sys/devices/system/cpu/cpufreq接口\n\t\n```\n\n\n\n```\nmodule_init(rockchip_cpufreq_driver_init)\n\tfor_each_possible_cpu\n\trockchip_cluster_info_lookup\n\trockchip_cpufreq_cluster_init\n\tcpufreq_register_notifier\t\t//注册通知CPUFREQ_POLICY_NOTYFIER  CPUFREQ_TRANSITION_NOTIFIER \n\t\trockchip_cpufreq_notifier\n\t\t\trockchip_cpufreq_add_monitor\n\t\t\t\trockchip_system_monitor_register\n```\n\n\n\n```\n#define for_each_cpu(cpu, mask)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\\\n\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n\t\t\n#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)\n\n\n/* Valid inputs for n are -1 and 0. */\nstatic inline unsigned int cpumask_next(int n, const struct cpumask *srcp)\n{\n\treturn n+1;\n}\n\n#if NR_CPUS == 1\n#define nr_cpu_ids\t\t1U\n#else\nextern unsigned int nr_cpu_ids;\n#endif\n```\n\n\n\n```\ndt_cpufreq_probe\n\tcpufreq_register_driver\n\t\tsubsys_interface_register \n\t\t\tcpufreq_interface\n\t\t\tcpufreq_add_dev\n\t\t\t\tcpufreq_online\n\t\t\t\t\tcpufreq_add_policy_cpu\n\t\t\t\t\t\tcpufreq_start_governor\n```\n\n\n\n\n\n## Reference\n\nhttps://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html\n\nhttps://docs.kernel.org/scheduler/schedutil.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_overview.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_driver.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_core.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_governor.html\n\n module_init()加载顺序 \n\nhttps://blog.csdn.net/shafa00419/article/details/85234867)","source":"back_posts/cpufreq.md","raw":"---\ntitle: cpufreq\ndate: 2024-04-28 17:04:13\ncategories:\n- kernel\ntags:\n- power\n- cpufreq\n---\n\n[toc]\n\n# cpufreq\n\n\n\nCPUFreq框架是内核的CPU调频框架，整个调频框架由以下几个部分组成：\n\n- cpufreq driver\n- cpufreq framework (core)\n- cpufreq governor\n\n一些基本概念：\n\nP-state: voltage and frequency point\n\n总体上，CPU Freq主要在sysfs向userspace提供了调频操作和策略设置节点。当使用一些自动调频的governor时，允许governor从系统获取信息，自动触发调频动作。\n\n另外，还向其他模块提供了qos频率投票，以及调频事件的notifier机制。\n\n下面分开来看每个部分。\n\n## Driver\n\n\n\nCpufreq Driver主要负责底层调频的操作，核心是实现 `cpufreq_dirver` 对象，并通过 `cpufreq_register_driver` 将驱动注册到系统，供core部分使用。\n\n其中，最核心的几个回调包括：\n\n- online: hotplug callback\n- offline: hotplug callback\n- target_index: set freq\n- set_boost: enter into boost mode\n\n以 `mediatek-cpufreq-hw.c` 为例，其freq table保存在硬件寄存器中，driver初始化时，从硬件中读出freq table，并实现相关调频回调，最终注册到core。\n\ndb845c使用的 `qcom-cpufreq-hw.c` 为例，其freq table保存在dts中，driver使用OPP框架来读取这些配置，并实现cpufreq回调。\n\n\\* OPP（Operating Performance Point，提供dts的freq-valt-table配置，及获取接口。\n\n## Core\n\n\n\nCore部分核心文件是 `/drivers/cpufreq/cpufreq.c`\n\n这个文件主要实现了BOOST，DRIVER，SYSFS，FREQ，NOTIFIER，GOVERNOR，POLICY相关功能的操作接口。\n\n`cpufreq_register_driver` (cpufreq_driver* cpufreq_driver)\n\n`cpufreq_register_governor` (cpufreq_governor_list)\n\n`cpufreq_register_notifier` (cpufreq_transition_notifier_list)\n\n`cpufreq_policy_alloc` (cpufreq_policy* PERCPU:cpufreq_cpu_data)\n\n`cpufreq_policy` 是一个调频实体，对应一个调频域（freq domain），一般为一个cluster，这个结构保存了每个调频实体（通常是一个cluster）调频相关的所有私有信息。同时，他作为调频操作的句柄，cpufreq顶层操作接口使用policy来对一个调频实体进行操作。\n\n每个CPU有一个percpu的指针指向其所属的policy，cluster中的多个CPU共享一个policy。（`cpufreq_cpu_data`）\n\nMainflow：\n\n1、cpufreq driver注册\n\n2、governor注册（每个policy初始化自己的governor）\n\n3、cpu hotplug state: \"cpufreq:online\"，`cpuhp_cpufreq_online`、`cpuhp_cpufreq_offline`，创建出percpu policy，绑定driver、governor\n\n4、向sysfs创建节点，提供功能\n\n5、governor开始工作，通过 `__cpufreq_driver_target` 进行调频。\n\n- Qos是调频投票机制，用来实现max_freq、min_freq limitation。(`cpufreq_notifier_min` `cpufreq_notifier_max`)，在其他module有需求投票后，freq constrants会被更新。\n\n## Sysfs\n\n\n\n```\n/sys/devices/system/cpu/cpu0/cpufreq/policyX\nscaling_driver\t\t\tr\t# cpufreq driver name\naffected_cpus\t\t\tr\t# cpu\nrelated_cpus\t\t\tr\t# <?>\nscaling_cur_freq\t\trw\t# cur freq\nscaling_min_freq\t\trw\t# min freq limit\nscaling_max_freq\t\trw\t# max freq limit\nscaling_governor\t\trw\t# selected governor\nscaling_available_governors\tr\t# available governors\nscaling_setspeed\t\tr\t# <not supported>\ncpuinfo_min_freq\t\tr\t# hardware min freq\ncpuinfo_max_freq\t\tr\t# hardware max freq\ncpuinfo_transition_latency\tr\t# hardware latency\n```\n\n\n\n## Governors\n\n\n\nGovernor负责从系统收集信息，并触发调频动作。\n\n**powersave**\n\nalways lowest frequency\n\n**performance**\n\nalways highest frequency\n\n**schedutil**\n\nuses CPU utilization data from scheduler to determine target frequence\n\n待完成\n\n**userspace**\n\nallow user space set the frequency\n\n**ondemand**\n\nuses CPU load as a CPU frequency selection metric\n\nit reaches the target by CPU load, 0->min, 100->max\n\n**conservative**\n\nuses CPU load as a CPU frequency selection metric\n\nit reaches the target step by step, up_threshold->up, down_threshold->down\n\n## Files\n\n\n\n```\n- /drivers/cpufreq/cpufreq.c\n- /drivers/cpufreq/cpufreq-dt.c\n- /drivers/cpufreq/cpufreq_stats.c\n- /drivers/cpufreq/cpufreq_conservative.c\n- /drivers/cpufreq/cpufreq_governor.c\n- /drivers/cpufreq/cpufreq_ondemand.c\n- /drivers/cpufreq/cpufreq_powersave.c\n- /drivers/cpufreq/cpufreq_performance.c\n- /drivers/cpufreq/cpufreq_userspace.c\n- /kernel/sched/cpufreq_schedutil.c\n- /kernel/power/qos.c\n```\n\n## rk3588-cpufreq-sys\n\n>查看cpufreq节点\n>RK3588的cpu是4个A55+4个A76，分为3组单独管理，节点分别是：\n>/sys/devices/system/cpu/cpufreq/policy0:（对应4个A55：CPU0-3）\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed\n>\n>/sys/devices/system/cpu/cpufreq/policy4:(对应2个A76：CPU4-5)\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed\n>\n>/sys/devices/system/cpu/cpufreq/policy6:(对应2个A76：CPU6-7)\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_drive\n>                        \n>\n>CPU性能模式\n>echo performance > /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>获取cpu运行的模式\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_available_governors\n>获取当前CPU支持的频点\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_available_frequencies\n>\n>cat /sys/devices/system/cpu/cpufreq/policy6/cpuinfo_cur_freq       \n>\n>\n>2.0设置cpufrq为performance模式\n>echo performance > /sys/devices/system/cpu/cpufreq/policy0/scaling_governor\n>echo performance > /sys/devices/system/cpu/cpufreq/policy4/scaling_governor\n>echo performance > /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>\n>查看模式\n>cat /sys/devices/system/cpu/cpufreq/policy*/scaling_governor\n>查看频率\n>cat /sys/devices/system/cpu/cpufreq/policy*/cpuinfo_cur_freq       \n\n## rk3588-cpufreq-code\n\n![cpufreq framework](../imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif)\n\n相关文件\n\nkernel/drivers/cpufreq/cpufreq.c\n\nkernel/drivers/cpufreq/rockchip-cpufreq.c\n\nkernel/drivers/cpufreq/cpufreq-dt-platdev.c\n\nkernel/drivers/cpufreq/cpufreq-dt.c\n\n```\nCONFIG_CPU_FREQ=y\nCONFIG_CPU_FREQ_STAT=y\nCONFIG_CPU_FREQ_TIMES=y\nCONFIG_CPU_FREQ_GOV_POWERSAVE=y\nCONFIG_CPU_FREQ_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_CPU_FREQ_GOV_CONSERVATIVE=y\nCONFIG_CPU_FREQ_GOV_INTERACTIVE=y\nCONFIG_CPU_FREQ_GOV_PERFORMANCE=y\nCONFIG_CPU_FREQ_GOV_COMMON=y\nCONFIG_CPU_FREQ_GOV_ATTR_SET=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y\nCONFIG_CPUFREQ_DT=y\n```\n\n\n\n### 1. CPUFreq核心和接口\n\ncpufreq代码为CPUFreq架构的驱 动程序（那些执行硬件频率切换的代码）以及 “通知器” 提供了一个标准化的接口。 包括设备驱动程序；需要了解策略变化（如 ACPI 热量管理），或所有频率变化（如计时代码）， 甚至需要强制限制为指定频率（如 ARM 架构上的 LCD 驱动程序）的其它内核组件。 此外，内核 “常数” loops_per_jiffy 会根据频率变化而更新。\n\ncpufreq策略的引用计数由 cpufreq_cpu_get 和 cpufreq_cpu_put 来完成，以确保 cpufreq 驱 动程序被正确地注册到核心中，并且驱动程序在 cpufreq_put_cpu 被调用之前不会被卸载。这也保证 了每个CPU核的cpufreq 策略在使用期间不会被释放。\n\n### 2. CPUFreq 通知器\n\nCPUFreq通知器遵循标准的内核通知器接口。 关于通知器的细节请参阅 linux/include/linux/notifier.h。\n\n这里有两个不同的CPUfreq通知器 - 策略通知器和转换通知器。\n\n#### 2.1 CPUFreq策略通知器\n\n当创建或移除策略时，这些都会被通知。\n\n阶段是在通知器的第二个参数中指定的。当第一次创建策略时，阶段是CPUFREQ_CREATE_POLICY，当 策略被移除时，阶段是CPUFREQ_REMOVE_POLICY。\n\n第三个参数 `void *pointer` 指向一个结构体cpufreq_policy，其包括min，max(新策略的下限和 上限（单位为kHz）)这几个值。\n\n#### 2.2 CPUFreq转换通知器\n\n当CPUfreq驱动切换CPU核心频率时，策略中的每个在线CPU都会收到两次通知，这些变化没有任何外部干 预。\n\n第二个参数指定阶段 - CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.\n\n第三个参数是一个包含如下值的结构体cpufreq_freqs：\n\n| policy | 指向struct cpufreq_policy的指针 |\n| ------ | ------------------------------- |\n| old    | 旧频率                          |\n| new    | 新频率                          |\n| flags  | cpufreq驱动的标志               |\n\n\n\n\n\n```\ncore_initcall(cpufreq_core_init);\n\tcpufreq_default_governor\t\t//获取默认的cpufreq策略 如schedutil powersave performace等\n\tkobject_create_and_add\t\t\t//创建sys/devices/system/cpu/cpufreq接口\n\t\n```\n\n\n\n```\nmodule_init(rockchip_cpufreq_driver_init)\n\tfor_each_possible_cpu\n\trockchip_cluster_info_lookup\n\trockchip_cpufreq_cluster_init\n\tcpufreq_register_notifier\t\t//注册通知CPUFREQ_POLICY_NOTYFIER  CPUFREQ_TRANSITION_NOTIFIER \n\t\trockchip_cpufreq_notifier\n\t\t\trockchip_cpufreq_add_monitor\n\t\t\t\trockchip_system_monitor_register\n```\n\n\n\n```\n#define for_each_cpu(cpu, mask)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\\\n\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n\t\t\n#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)\n\n\n/* Valid inputs for n are -1 and 0. */\nstatic inline unsigned int cpumask_next(int n, const struct cpumask *srcp)\n{\n\treturn n+1;\n}\n\n#if NR_CPUS == 1\n#define nr_cpu_ids\t\t1U\n#else\nextern unsigned int nr_cpu_ids;\n#endif\n```\n\n\n\n```\ndt_cpufreq_probe\n\tcpufreq_register_driver\n\t\tsubsys_interface_register \n\t\t\tcpufreq_interface\n\t\t\tcpufreq_add_dev\n\t\t\t\tcpufreq_online\n\t\t\t\t\tcpufreq_add_policy_cpu\n\t\t\t\t\t\tcpufreq_start_governor\n```\n\n\n\n\n\n## Reference\n\nhttps://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html\n\nhttps://docs.kernel.org/scheduler/schedutil.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_overview.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_driver.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_core.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_governor.html\n\n module_init()加载顺序 \n\nhttps://blog.csdn.net/shafa00419/article/details/85234867)","updated":"2024-06-06T11:41:25.795Z","path":"back_posts/cpufreq.html","_id":"clw7fflkq0006x2w02d4x52gy","comments":1,"layout":"page","content":"<p>[toc]</p>\n<h1 id=\"cpufreq\"><a href=\"#cpufreq\" class=\"headerlink\" title=\"cpufreq\"></a>cpufreq</h1><p>CPUFreq框架是内核的CPU调频框架，整个调频框架由以下几个部分组成：</p>\n<ul>\n<li>cpufreq driver</li>\n<li>cpufreq framework (core)</li>\n<li>cpufreq governor</li>\n</ul>\n<p>一些基本概念：</p>\n<p>P-state: voltage and frequency point</p>\n<p>总体上，CPU Freq主要在sysfs向userspace提供了调频操作和策略设置节点。当使用一些自动调频的governor时，允许governor从系统获取信息，自动触发调频动作。</p>\n<p>另外，还向其他模块提供了qos频率投票，以及调频事件的notifier机制。</p>\n<p>下面分开来看每个部分。</p>\n<h2 id=\"Driver\"><a href=\"#Driver\" class=\"headerlink\" title=\"Driver\"></a>Driver</h2><p>Cpufreq Driver主要负责底层调频的操作，核心是实现 <code>cpufreq_dirver</code> 对象，并通过 <code>cpufreq_register_driver</code> 将驱动注册到系统，供core部分使用。</p>\n<p>其中，最核心的几个回调包括：</p>\n<ul>\n<li>online: hotplug callback</li>\n<li>offline: hotplug callback</li>\n<li>target_index: set freq</li>\n<li>set_boost: enter into boost mode</li>\n</ul>\n<p>以 <code>mediatek-cpufreq-hw.c</code> 为例，其freq table保存在硬件寄存器中，driver初始化时，从硬件中读出freq table，并实现相关调频回调，最终注册到core。</p>\n<p>db845c使用的 <code>qcom-cpufreq-hw.c</code> 为例，其freq table保存在dts中，driver使用OPP框架来读取这些配置，并实现cpufreq回调。</p>\n<p>* OPP（Operating Performance Point，提供dts的freq-valt-table配置，及获取接口。</p>\n<h2 id=\"Core\"><a href=\"#Core\" class=\"headerlink\" title=\"Core\"></a>Core</h2><p>Core部分核心文件是 <code>/drivers/cpufreq/cpufreq.c</code></p>\n<p>这个文件主要实现了BOOST，DRIVER，SYSFS，FREQ，NOTIFIER，GOVERNOR，POLICY相关功能的操作接口。</p>\n<p><code>cpufreq_register_driver</code> (cpufreq_driver* cpufreq_driver)</p>\n<p><code>cpufreq_register_governor</code> (cpufreq_governor_list)</p>\n<p><code>cpufreq_register_notifier</code> (cpufreq_transition_notifier_list)</p>\n<p><code>cpufreq_policy_alloc</code> (cpufreq_policy* PERCPU:cpufreq_cpu_data)</p>\n<p><code>cpufreq_policy</code> 是一个调频实体，对应一个调频域（freq domain），一般为一个cluster，这个结构保存了每个调频实体（通常是一个cluster）调频相关的所有私有信息。同时，他作为调频操作的句柄，cpufreq顶层操作接口使用policy来对一个调频实体进行操作。</p>\n<p>每个CPU有一个percpu的指针指向其所属的policy，cluster中的多个CPU共享一个policy。（<code>cpufreq_cpu_data</code>）</p>\n<p>Mainflow：</p>\n<p>1、cpufreq driver注册</p>\n<p>2、governor注册（每个policy初始化自己的governor）</p>\n<p>3、cpu hotplug state: “cpufreq:online”，<code>cpuhp_cpufreq_online</code>、<code>cpuhp_cpufreq_offline</code>，创建出percpu policy，绑定driver、governor</p>\n<p>4、向sysfs创建节点，提供功能</p>\n<p>5、governor开始工作，通过 <code>__cpufreq_driver_target</code> 进行调频。</p>\n<ul>\n<li>Qos是调频投票机制，用来实现max_freq、min_freq limitation。(<code>cpufreq_notifier_min</code> <code>cpufreq_notifier_max</code>)，在其他module有需求投票后，freq constrants会被更新。</li>\n</ul>\n<h2 id=\"Sysfs\"><a href=\"#Sysfs\" class=\"headerlink\" title=\"Sysfs\"></a>Sysfs</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sys/devices/system/cpu/cpu0/cpufreq/policyX</span><br><span class=\"line\">scaling_driver\t\t\tr\t# cpufreq driver name</span><br><span class=\"line\">affected_cpus\t\t\tr\t# cpu</span><br><span class=\"line\">related_cpus\t\t\tr\t# &lt;?&gt;</span><br><span class=\"line\">scaling_cur_freq\t\trw\t# cur freq</span><br><span class=\"line\">scaling_min_freq\t\trw\t# min freq limit</span><br><span class=\"line\">scaling_max_freq\t\trw\t# max freq limit</span><br><span class=\"line\">scaling_governor\t\trw\t# selected governor</span><br><span class=\"line\">scaling_available_governors\tr\t# available governors</span><br><span class=\"line\">scaling_setspeed\t\tr\t# &lt;not supported&gt;</span><br><span class=\"line\">cpuinfo_min_freq\t\tr\t# hardware min freq</span><br><span class=\"line\">cpuinfo_max_freq\t\tr\t# hardware max freq</span><br><span class=\"line\">cpuinfo_transition_latency\tr\t# hardware latency</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Governors\"><a href=\"#Governors\" class=\"headerlink\" title=\"Governors\"></a>Governors</h2><p>Governor负责从系统收集信息，并触发调频动作。</p>\n<p><strong>powersave</strong></p>\n<p>always lowest frequency</p>\n<p><strong>performance</strong></p>\n<p>always highest frequency</p>\n<p><strong>schedutil</strong></p>\n<p>uses CPU utilization data from scheduler to determine target frequence</p>\n<p>待完成</p>\n<p><strong>userspace</strong></p>\n<p>allow user space set the frequency</p>\n<p><strong>ondemand</strong></p>\n<p>uses CPU load as a CPU frequency selection metric</p>\n<p>it reaches the target by CPU load, 0-&gt;min, 100-&gt;max</p>\n<p><strong>conservative</strong></p>\n<p>uses CPU load as a CPU frequency selection metric</p>\n<p>it reaches the target step by step, up_threshold-&gt;up, down_threshold-&gt;down</p>\n<h2 id=\"Files\"><a href=\"#Files\" class=\"headerlink\" title=\"Files\"></a>Files</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- /drivers/cpufreq/cpufreq.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq-dt.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_stats.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_conservative.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_governor.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_ondemand.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_powersave.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_performance.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_userspace.c</span><br><span class=\"line\">- /kernel/sched/cpufreq_schedutil.c</span><br><span class=\"line\">- /kernel/power/qos.c</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rk3588-cpufreq-sys\"><a href=\"#rk3588-cpufreq-sys\" class=\"headerlink\" title=\"rk3588-cpufreq-sys\"></a>rk3588-cpufreq-sys</h2><blockquote>\n<p>查看cpufreq节点<br>RK3588的cpu是4个A55+4个A76，分为3组单独管理，节点分别是：<br>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy0:（对应4个A55：CPU0-3）<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed</p>\n<p>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy4:(对应2个A76：CPU4-5)<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed</p>\n<p>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6:(对应2个A76：CPU6-7)<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_drive</p>\n<p>CPU性能模式<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor<br>获取cpu运行的模式<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_available_governors<br>获取当前CPU支持的频点<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_available_frequencies</p>\n<p>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;cpuinfo_cur_freq       </p>\n<p>2.0设置cpufrq为performance模式<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy0&#x2F;scaling_governor<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy4&#x2F;scaling_governor<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor</p>\n<p>查看模式<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy*&#x2F;scaling_governor<br>查看频率<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy*&#x2F;cpuinfo_cur_freq       </p>\n</blockquote>\n<h2 id=\"rk3588-cpufreq-code\"><a href=\"#rk3588-cpufreq-code\" class=\"headerlink\" title=\"rk3588-cpufreq-code\"></a>rk3588-cpufreq-code</h2><p><img src=\"/../imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif\" alt=\"cpufreq framework\"></p>\n<p>相关文件</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;rockchip-cpufreq.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq-dt-platdev.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq-dt.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_CPU_FREQ=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_STAT=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_TIMES=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_POWERSAVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_USERSPACE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_ONDEMAND=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_INTERACTIVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_PERFORMANCE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_COMMON=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_ATTR_SET=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y</span><br><span class=\"line\">CONFIG_CPUFREQ_DT=y</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"1-CPUFreq核心和接口\"><a href=\"#1-CPUFreq核心和接口\" class=\"headerlink\" title=\"1. CPUFreq核心和接口\"></a>1. CPUFreq核心和接口</h3><p>cpufreq代码为CPUFreq架构的驱 动程序（那些执行硬件频率切换的代码）以及 “通知器” 提供了一个标准化的接口。 包括设备驱动程序；需要了解策略变化（如 ACPI 热量管理），或所有频率变化（如计时代码）， 甚至需要强制限制为指定频率（如 ARM 架构上的 LCD 驱动程序）的其它内核组件。 此外，内核 “常数” loops_per_jiffy 会根据频率变化而更新。</p>\n<p>cpufreq策略的引用计数由 cpufreq_cpu_get 和 cpufreq_cpu_put 来完成，以确保 cpufreq 驱 动程序被正确地注册到核心中，并且驱动程序在 cpufreq_put_cpu 被调用之前不会被卸载。这也保证 了每个CPU核的cpufreq 策略在使用期间不会被释放。</p>\n<h3 id=\"2-CPUFreq-通知器\"><a href=\"#2-CPUFreq-通知器\" class=\"headerlink\" title=\"2. CPUFreq 通知器\"></a>2. CPUFreq 通知器</h3><p>CPUFreq通知器遵循标准的内核通知器接口。 关于通知器的细节请参阅 linux&#x2F;include&#x2F;linux&#x2F;notifier.h。</p>\n<p>这里有两个不同的CPUfreq通知器 - 策略通知器和转换通知器。</p>\n<h4 id=\"2-1-CPUFreq策略通知器\"><a href=\"#2-1-CPUFreq策略通知器\" class=\"headerlink\" title=\"2.1 CPUFreq策略通知器\"></a>2.1 CPUFreq策略通知器</h4><p>当创建或移除策略时，这些都会被通知。</p>\n<p>阶段是在通知器的第二个参数中指定的。当第一次创建策略时，阶段是CPUFREQ_CREATE_POLICY，当 策略被移除时，阶段是CPUFREQ_REMOVE_POLICY。</p>\n<p>第三个参数 <code>void *pointer</code> 指向一个结构体cpufreq_policy，其包括min，max(新策略的下限和 上限（单位为kHz）)这几个值。</p>\n<h4 id=\"2-2-CPUFreq转换通知器\"><a href=\"#2-2-CPUFreq转换通知器\" class=\"headerlink\" title=\"2.2 CPUFreq转换通知器\"></a>2.2 CPUFreq转换通知器</h4><p>当CPUfreq驱动切换CPU核心频率时，策略中的每个在线CPU都会收到两次通知，这些变化没有任何外部干 预。</p>\n<p>第二个参数指定阶段 - CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.</p>\n<p>第三个参数是一个包含如下值的结构体cpufreq_freqs：</p>\n<table>\n<thead>\n<tr>\n<th>policy</th>\n<th>指向struct cpufreq_policy的指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>old</td>\n<td>旧频率</td>\n</tr>\n<tr>\n<td>new</td>\n<td>新频率</td>\n</tr>\n<tr>\n<td>flags</td>\n<td>cpufreq驱动的标志</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">core_initcall(cpufreq_core_init);</span><br><span class=\"line\">\tcpufreq_default_governor\t\t//获取默认的cpufreq策略 如schedutil powersave performace等</span><br><span class=\"line\">\tkobject_create_and_add\t\t\t//创建sys/devices/system/cpu/cpufreq接口</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module_init(rockchip_cpufreq_driver_init)</span><br><span class=\"line\">\tfor_each_possible_cpu</span><br><span class=\"line\">\trockchip_cluster_info_lookup</span><br><span class=\"line\">\trockchip_cpufreq_cluster_init</span><br><span class=\"line\">\tcpufreq_register_notifier\t\t//注册通知CPUFREQ_POLICY_NOTYFIER  CPUFREQ_TRANSITION_NOTIFIER </span><br><span class=\"line\">\t\trockchip_cpufreq_notifier</span><br><span class=\"line\">\t\t\trockchip_cpufreq_add_monitor</span><br><span class=\"line\">\t\t\t\trockchip_system_monitor_register</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define for_each_cpu(cpu, mask)\t\t\t\t\\</span><br><span class=\"line\">\tfor ((cpu) = -1;\t\t\t\t\\</span><br><span class=\"line\">\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\</span><br><span class=\"line\">\t\t(cpu) &lt; nr_cpu_ids;)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/* Valid inputs for n are -1 and 0. */</span><br><span class=\"line\">static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn n+1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#if NR_CPUS == 1</span><br><span class=\"line\">#define nr_cpu_ids\t\t1U</span><br><span class=\"line\">#else</span><br><span class=\"line\">extern unsigned int nr_cpu_ids;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dt_cpufreq_probe</span><br><span class=\"line\">\tcpufreq_register_driver</span><br><span class=\"line\">\t\tsubsys_interface_register </span><br><span class=\"line\">\t\t\tcpufreq_interface</span><br><span class=\"line\">\t\t\tcpufreq_add_dev</span><br><span class=\"line\">\t\t\t\tcpufreq_online</span><br><span class=\"line\">\t\t\t\t\tcpufreq_add_policy_cpu</span><br><span class=\"line\">\t\t\t\t\t\tcpufreq_start_governor</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html\">https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html</a></p>\n<p><a href=\"https://docs.kernel.org/scheduler/schedutil.html\">https://docs.kernel.org/scheduler/schedutil.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_overview.html\">http://www.wowotech.net/pm_subsystem/cpufreq_overview.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_driver.html\">http://www.wowotech.net/pm_subsystem/cpufreq_driver.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_core.html\">http://www.wowotech.net/pm_subsystem/cpufreq_core.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_governor.html\">http://www.wowotech.net/pm_subsystem/cpufreq_governor.html</a></p>\n<p> module_init()加载顺序 </p>\n<p><a href=\"https://blog.csdn.net/shafa00419/article/details/85234867\">https://blog.csdn.net/shafa00419/article/details/85234867</a>)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"cpufreq\"><a href=\"#cpufreq\" class=\"headerlink\" title=\"cpufreq\"></a>cpufreq</h1><p>CPUFreq框架是内核的CPU调频框架，整个调频框架由以下几个部分组成：</p>\n<ul>\n<li>cpufreq driver</li>\n<li>cpufreq framework (core)</li>\n<li>cpufreq governor</li>\n</ul>\n<p>一些基本概念：</p>\n<p>P-state: voltage and frequency point</p>\n<p>总体上，CPU Freq主要在sysfs向userspace提供了调频操作和策略设置节点。当使用一些自动调频的governor时，允许governor从系统获取信息，自动触发调频动作。</p>\n<p>另外，还向其他模块提供了qos频率投票，以及调频事件的notifier机制。</p>\n<p>下面分开来看每个部分。</p>\n<h2 id=\"Driver\"><a href=\"#Driver\" class=\"headerlink\" title=\"Driver\"></a>Driver</h2><p>Cpufreq Driver主要负责底层调频的操作，核心是实现 <code>cpufreq_dirver</code> 对象，并通过 <code>cpufreq_register_driver</code> 将驱动注册到系统，供core部分使用。</p>\n<p>其中，最核心的几个回调包括：</p>\n<ul>\n<li>online: hotplug callback</li>\n<li>offline: hotplug callback</li>\n<li>target_index: set freq</li>\n<li>set_boost: enter into boost mode</li>\n</ul>\n<p>以 <code>mediatek-cpufreq-hw.c</code> 为例，其freq table保存在硬件寄存器中，driver初始化时，从硬件中读出freq table，并实现相关调频回调，最终注册到core。</p>\n<p>db845c使用的 <code>qcom-cpufreq-hw.c</code> 为例，其freq table保存在dts中，driver使用OPP框架来读取这些配置，并实现cpufreq回调。</p>\n<p>* OPP（Operating Performance Point，提供dts的freq-valt-table配置，及获取接口。</p>\n<h2 id=\"Core\"><a href=\"#Core\" class=\"headerlink\" title=\"Core\"></a>Core</h2><p>Core部分核心文件是 <code>/drivers/cpufreq/cpufreq.c</code></p>\n<p>这个文件主要实现了BOOST，DRIVER，SYSFS，FREQ，NOTIFIER，GOVERNOR，POLICY相关功能的操作接口。</p>\n<p><code>cpufreq_register_driver</code> (cpufreq_driver* cpufreq_driver)</p>\n<p><code>cpufreq_register_governor</code> (cpufreq_governor_list)</p>\n<p><code>cpufreq_register_notifier</code> (cpufreq_transition_notifier_list)</p>\n<p><code>cpufreq_policy_alloc</code> (cpufreq_policy* PERCPU:cpufreq_cpu_data)</p>\n<p><code>cpufreq_policy</code> 是一个调频实体，对应一个调频域（freq domain），一般为一个cluster，这个结构保存了每个调频实体（通常是一个cluster）调频相关的所有私有信息。同时，他作为调频操作的句柄，cpufreq顶层操作接口使用policy来对一个调频实体进行操作。</p>\n<p>每个CPU有一个percpu的指针指向其所属的policy，cluster中的多个CPU共享一个policy。（<code>cpufreq_cpu_data</code>）</p>\n<p>Mainflow：</p>\n<p>1、cpufreq driver注册</p>\n<p>2、governor注册（每个policy初始化自己的governor）</p>\n<p>3、cpu hotplug state: “cpufreq:online”，<code>cpuhp_cpufreq_online</code>、<code>cpuhp_cpufreq_offline</code>，创建出percpu policy，绑定driver、governor</p>\n<p>4、向sysfs创建节点，提供功能</p>\n<p>5、governor开始工作，通过 <code>__cpufreq_driver_target</code> 进行调频。</p>\n<ul>\n<li>Qos是调频投票机制，用来实现max_freq、min_freq limitation。(<code>cpufreq_notifier_min</code> <code>cpufreq_notifier_max</code>)，在其他module有需求投票后，freq constrants会被更新。</li>\n</ul>\n<h2 id=\"Sysfs\"><a href=\"#Sysfs\" class=\"headerlink\" title=\"Sysfs\"></a>Sysfs</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sys/devices/system/cpu/cpu0/cpufreq/policyX</span><br><span class=\"line\">scaling_driver\t\t\tr\t# cpufreq driver name</span><br><span class=\"line\">affected_cpus\t\t\tr\t# cpu</span><br><span class=\"line\">related_cpus\t\t\tr\t# &lt;?&gt;</span><br><span class=\"line\">scaling_cur_freq\t\trw\t# cur freq</span><br><span class=\"line\">scaling_min_freq\t\trw\t# min freq limit</span><br><span class=\"line\">scaling_max_freq\t\trw\t# max freq limit</span><br><span class=\"line\">scaling_governor\t\trw\t# selected governor</span><br><span class=\"line\">scaling_available_governors\tr\t# available governors</span><br><span class=\"line\">scaling_setspeed\t\tr\t# &lt;not supported&gt;</span><br><span class=\"line\">cpuinfo_min_freq\t\tr\t# hardware min freq</span><br><span class=\"line\">cpuinfo_max_freq\t\tr\t# hardware max freq</span><br><span class=\"line\">cpuinfo_transition_latency\tr\t# hardware latency</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Governors\"><a href=\"#Governors\" class=\"headerlink\" title=\"Governors\"></a>Governors</h2><p>Governor负责从系统收集信息，并触发调频动作。</p>\n<p><strong>powersave</strong></p>\n<p>always lowest frequency</p>\n<p><strong>performance</strong></p>\n<p>always highest frequency</p>\n<p><strong>schedutil</strong></p>\n<p>uses CPU utilization data from scheduler to determine target frequence</p>\n<p>待完成</p>\n<p><strong>userspace</strong></p>\n<p>allow user space set the frequency</p>\n<p><strong>ondemand</strong></p>\n<p>uses CPU load as a CPU frequency selection metric</p>\n<p>it reaches the target by CPU load, 0-&gt;min, 100-&gt;max</p>\n<p><strong>conservative</strong></p>\n<p>uses CPU load as a CPU frequency selection metric</p>\n<p>it reaches the target step by step, up_threshold-&gt;up, down_threshold-&gt;down</p>\n<h2 id=\"Files\"><a href=\"#Files\" class=\"headerlink\" title=\"Files\"></a>Files</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- /drivers/cpufreq/cpufreq.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq-dt.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_stats.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_conservative.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_governor.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_ondemand.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_powersave.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_performance.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_userspace.c</span><br><span class=\"line\">- /kernel/sched/cpufreq_schedutil.c</span><br><span class=\"line\">- /kernel/power/qos.c</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rk3588-cpufreq-sys\"><a href=\"#rk3588-cpufreq-sys\" class=\"headerlink\" title=\"rk3588-cpufreq-sys\"></a>rk3588-cpufreq-sys</h2><blockquote>\n<p>查看cpufreq节点<br>RK3588的cpu是4个A55+4个A76，分为3组单独管理，节点分别是：<br>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy0:（对应4个A55：CPU0-3）<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed</p>\n<p>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy4:(对应2个A76：CPU4-5)<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed</p>\n<p>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6:(对应2个A76：CPU6-7)<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_drive</p>\n<p>CPU性能模式<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor<br>获取cpu运行的模式<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_available_governors<br>获取当前CPU支持的频点<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_available_frequencies</p>\n<p>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;cpuinfo_cur_freq       </p>\n<p>2.0设置cpufrq为performance模式<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy0&#x2F;scaling_governor<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy4&#x2F;scaling_governor<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor</p>\n<p>查看模式<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy*&#x2F;scaling_governor<br>查看频率<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy*&#x2F;cpuinfo_cur_freq       </p>\n</blockquote>\n<h2 id=\"rk3588-cpufreq-code\"><a href=\"#rk3588-cpufreq-code\" class=\"headerlink\" title=\"rk3588-cpufreq-code\"></a>rk3588-cpufreq-code</h2><p><img src=\"/../imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif\" alt=\"cpufreq framework\"></p>\n<p>相关文件</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;rockchip-cpufreq.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq-dt-platdev.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq-dt.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_CPU_FREQ=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_STAT=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_TIMES=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_POWERSAVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_USERSPACE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_ONDEMAND=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_INTERACTIVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_PERFORMANCE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_COMMON=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_ATTR_SET=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y</span><br><span class=\"line\">CONFIG_CPUFREQ_DT=y</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"1-CPUFreq核心和接口\"><a href=\"#1-CPUFreq核心和接口\" class=\"headerlink\" title=\"1. CPUFreq核心和接口\"></a>1. CPUFreq核心和接口</h3><p>cpufreq代码为CPUFreq架构的驱 动程序（那些执行硬件频率切换的代码）以及 “通知器” 提供了一个标准化的接口。 包括设备驱动程序；需要了解策略变化（如 ACPI 热量管理），或所有频率变化（如计时代码）， 甚至需要强制限制为指定频率（如 ARM 架构上的 LCD 驱动程序）的其它内核组件。 此外，内核 “常数” loops_per_jiffy 会根据频率变化而更新。</p>\n<p>cpufreq策略的引用计数由 cpufreq_cpu_get 和 cpufreq_cpu_put 来完成，以确保 cpufreq 驱 动程序被正确地注册到核心中，并且驱动程序在 cpufreq_put_cpu 被调用之前不会被卸载。这也保证 了每个CPU核的cpufreq 策略在使用期间不会被释放。</p>\n<h3 id=\"2-CPUFreq-通知器\"><a href=\"#2-CPUFreq-通知器\" class=\"headerlink\" title=\"2. CPUFreq 通知器\"></a>2. CPUFreq 通知器</h3><p>CPUFreq通知器遵循标准的内核通知器接口。 关于通知器的细节请参阅 linux&#x2F;include&#x2F;linux&#x2F;notifier.h。</p>\n<p>这里有两个不同的CPUfreq通知器 - 策略通知器和转换通知器。</p>\n<h4 id=\"2-1-CPUFreq策略通知器\"><a href=\"#2-1-CPUFreq策略通知器\" class=\"headerlink\" title=\"2.1 CPUFreq策略通知器\"></a>2.1 CPUFreq策略通知器</h4><p>当创建或移除策略时，这些都会被通知。</p>\n<p>阶段是在通知器的第二个参数中指定的。当第一次创建策略时，阶段是CPUFREQ_CREATE_POLICY，当 策略被移除时，阶段是CPUFREQ_REMOVE_POLICY。</p>\n<p>第三个参数 <code>void *pointer</code> 指向一个结构体cpufreq_policy，其包括min，max(新策略的下限和 上限（单位为kHz）)这几个值。</p>\n<h4 id=\"2-2-CPUFreq转换通知器\"><a href=\"#2-2-CPUFreq转换通知器\" class=\"headerlink\" title=\"2.2 CPUFreq转换通知器\"></a>2.2 CPUFreq转换通知器</h4><p>当CPUfreq驱动切换CPU核心频率时，策略中的每个在线CPU都会收到两次通知，这些变化没有任何外部干 预。</p>\n<p>第二个参数指定阶段 - CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.</p>\n<p>第三个参数是一个包含如下值的结构体cpufreq_freqs：</p>\n<table>\n<thead>\n<tr>\n<th>policy</th>\n<th>指向struct cpufreq_policy的指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>old</td>\n<td>旧频率</td>\n</tr>\n<tr>\n<td>new</td>\n<td>新频率</td>\n</tr>\n<tr>\n<td>flags</td>\n<td>cpufreq驱动的标志</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">core_initcall(cpufreq_core_init);</span><br><span class=\"line\">\tcpufreq_default_governor\t\t//获取默认的cpufreq策略 如schedutil powersave performace等</span><br><span class=\"line\">\tkobject_create_and_add\t\t\t//创建sys/devices/system/cpu/cpufreq接口</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module_init(rockchip_cpufreq_driver_init)</span><br><span class=\"line\">\tfor_each_possible_cpu</span><br><span class=\"line\">\trockchip_cluster_info_lookup</span><br><span class=\"line\">\trockchip_cpufreq_cluster_init</span><br><span class=\"line\">\tcpufreq_register_notifier\t\t//注册通知CPUFREQ_POLICY_NOTYFIER  CPUFREQ_TRANSITION_NOTIFIER </span><br><span class=\"line\">\t\trockchip_cpufreq_notifier</span><br><span class=\"line\">\t\t\trockchip_cpufreq_add_monitor</span><br><span class=\"line\">\t\t\t\trockchip_system_monitor_register</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define for_each_cpu(cpu, mask)\t\t\t\t\\</span><br><span class=\"line\">\tfor ((cpu) = -1;\t\t\t\t\\</span><br><span class=\"line\">\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\</span><br><span class=\"line\">\t\t(cpu) &lt; nr_cpu_ids;)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/* Valid inputs for n are -1 and 0. */</span><br><span class=\"line\">static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn n+1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#if NR_CPUS == 1</span><br><span class=\"line\">#define nr_cpu_ids\t\t1U</span><br><span class=\"line\">#else</span><br><span class=\"line\">extern unsigned int nr_cpu_ids;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dt_cpufreq_probe</span><br><span class=\"line\">\tcpufreq_register_driver</span><br><span class=\"line\">\t\tsubsys_interface_register </span><br><span class=\"line\">\t\t\tcpufreq_interface</span><br><span class=\"line\">\t\t\tcpufreq_add_dev</span><br><span class=\"line\">\t\t\t\tcpufreq_online</span><br><span class=\"line\">\t\t\t\t\tcpufreq_add_policy_cpu</span><br><span class=\"line\">\t\t\t\t\t\tcpufreq_start_governor</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html\">https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html</a></p>\n<p><a href=\"https://docs.kernel.org/scheduler/schedutil.html\">https://docs.kernel.org/scheduler/schedutil.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_overview.html\">http://www.wowotech.net/pm_subsystem/cpufreq_overview.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_driver.html\">http://www.wowotech.net/pm_subsystem/cpufreq_driver.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_core.html\">http://www.wowotech.net/pm_subsystem/cpufreq_core.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_governor.html\">http://www.wowotech.net/pm_subsystem/cpufreq_governor.html</a></p>\n<p> module_init()加载顺序 </p>\n<p><a href=\"https://blog.csdn.net/shafa00419/article/details/85234867\">https://blog.csdn.net/shafa00419/article/details/85234867</a>)</p>\n"},{"title":"github+hexo 博客搭建","date":"2023-08-25T11:32:35.000Z","categories":["test"],"tags":["test"],"_content":"\n\n@[toc]\n环境：win11+wsl\n## 1.安装Node.js、Git和Hexo\n打开终端安装以下软件\n```\nsudo apt update\nsudo apt-get install git\n\nsudo apt install nodejs\nsudo apt install npm        #Node.js 的包管理器\nsudo npm install -g hexo-cli        #安装hexo\n```\n## 2.创建 GitHub 仓库并配置ssh\n登录你的 GitHub 帐号，并创建一个新的仓库，仓库名是 `<username>.github.io`，其中 `<username>` 是你的 GitHub 用户名。将该仓库设置为公开仓库。\n设置ssh\n```\nssh-keygen -t rsa -C 'xxx@xxx.com'  #自己的邮箱\ncat ~/.ssh/id_rsa.pub  #将里面的内容复制到 github ->settings ->SSH and GPC keys ->SSH keys ->New SSH key中\nssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）\n#接着在本地绑定与Github的用户名和邮箱（git）\ngit config --global user.name \"<username>\"    #自己的用户名\ngit config --global user.email 'xxx@xxx.com'  #自己的邮箱\n```\n## 3.初始化Hexo\n创建一个新的文件夹，用于存储你的博客项目。\n在终端中，进入该文件夹，并运行以下命令来初始化 Hexo\n```\nmkdir myblog\nhexo init    \n#或者直接一步到位 \nhexo init myblog\n```\n## 4.配置Hexo\n- 进入你的 Hexo 项目文件夹，找到 _config.yml 文件，使用文本编辑器打开它。\n- 在 _config.yml 文件中，配置你的博客设置，例如标题、描述、作者等。\n- 根据需要，你还可以配置主题、插件和其他 Hexo 选项。\n编辑_config.yml文件，添加如下内容 \n```\ndeploy:\n        type: git\n        repo: git@github.com: <username>/ <username>.github.io.git  #<username>为自己的用户名\n        branch: main\n```\n```\nnpm install hexo-deployer-git    #安装 hexo-deployer-git 插件 将部署过程自动化\n```\n## 5.创建博客内容\n在终端中，运行以下命令来创建新的博客文章：\n```\nhexo new \"My First Post\"\n```\n这将在 Hexo 项目的 source/_posts 目录下创建一个新的 Markdown 文件，用于编写你的第一篇博客文章。\n## 6.部署\n```\nhexo s    # 预览\n#Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n#用浏览器打开 http://localhost:4000/\nhexo g #生成静态网站文件\nhexo d #将生成的静态网站文件部署到github\n```\n## 7.查看\n浏览器打开`<username>.github.io`即可查看\n\n\n## 8.参考：\nhttps://blog.csdn.net/qq_62928039/article/details/130248518\n\n## 9.选择主题：\nhttps://hexo.io/themes/\nhttps://github.com/yelog/hexo-theme-3-hexo\n```\n#在hexo根目录下\ngit clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo\n#修改hexo根目录的_config.yml，如下\ntheme: 3-hexo\n#博客配置\nhttp://yelog.org/2017/03/23/3-hexo-instruction/\n```\n最终效果：\nhttps://yyheroi.github.io\n","source":"back_posts/github+hexo博客搭建.md","raw":"---\ntitle: github+hexo 博客搭建\ndate: 2023-08-25 19:32:35\ncategories:\n- test\ntags:\n- test\n---\n\n\n@[toc]\n环境：win11+wsl\n## 1.安装Node.js、Git和Hexo\n打开终端安装以下软件\n```\nsudo apt update\nsudo apt-get install git\n\nsudo apt install nodejs\nsudo apt install npm        #Node.js 的包管理器\nsudo npm install -g hexo-cli        #安装hexo\n```\n## 2.创建 GitHub 仓库并配置ssh\n登录你的 GitHub 帐号，并创建一个新的仓库，仓库名是 `<username>.github.io`，其中 `<username>` 是你的 GitHub 用户名。将该仓库设置为公开仓库。\n设置ssh\n```\nssh-keygen -t rsa -C 'xxx@xxx.com'  #自己的邮箱\ncat ~/.ssh/id_rsa.pub  #将里面的内容复制到 github ->settings ->SSH and GPC keys ->SSH keys ->New SSH key中\nssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）\n#接着在本地绑定与Github的用户名和邮箱（git）\ngit config --global user.name \"<username>\"    #自己的用户名\ngit config --global user.email 'xxx@xxx.com'  #自己的邮箱\n```\n## 3.初始化Hexo\n创建一个新的文件夹，用于存储你的博客项目。\n在终端中，进入该文件夹，并运行以下命令来初始化 Hexo\n```\nmkdir myblog\nhexo init    \n#或者直接一步到位 \nhexo init myblog\n```\n## 4.配置Hexo\n- 进入你的 Hexo 项目文件夹，找到 _config.yml 文件，使用文本编辑器打开它。\n- 在 _config.yml 文件中，配置你的博客设置，例如标题、描述、作者等。\n- 根据需要，你还可以配置主题、插件和其他 Hexo 选项。\n编辑_config.yml文件，添加如下内容 \n```\ndeploy:\n        type: git\n        repo: git@github.com: <username>/ <username>.github.io.git  #<username>为自己的用户名\n        branch: main\n```\n```\nnpm install hexo-deployer-git    #安装 hexo-deployer-git 插件 将部署过程自动化\n```\n## 5.创建博客内容\n在终端中，运行以下命令来创建新的博客文章：\n```\nhexo new \"My First Post\"\n```\n这将在 Hexo 项目的 source/_posts 目录下创建一个新的 Markdown 文件，用于编写你的第一篇博客文章。\n## 6.部署\n```\nhexo s    # 预览\n#Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n#用浏览器打开 http://localhost:4000/\nhexo g #生成静态网站文件\nhexo d #将生成的静态网站文件部署到github\n```\n## 7.查看\n浏览器打开`<username>.github.io`即可查看\n\n\n## 8.参考：\nhttps://blog.csdn.net/qq_62928039/article/details/130248518\n\n## 9.选择主题：\nhttps://hexo.io/themes/\nhttps://github.com/yelog/hexo-theme-3-hexo\n```\n#在hexo根目录下\ngit clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo\n#修改hexo根目录的_config.yml，如下\ntheme: 3-hexo\n#博客配置\nhttp://yelog.org/2017/03/23/3-hexo-instruction/\n```\n最终效果：\nhttps://yyheroi.github.io\n","updated":"2024-05-15T06:11:08.990Z","path":"back_posts/github+hexo博客搭建.html","comments":1,"layout":"page","_id":"clw7fflkr0007x2w07k697mbm","content":"<p>@[toc]<br>环境：win11+wsl</p>\n<h2 id=\"1-安装Node-js、Git和Hexo\"><a href=\"#1-安装Node-js、Git和Hexo\" class=\"headerlink\" title=\"1.安装Node.js、Git和Hexo\"></a>1.安装Node.js、Git和Hexo</h2><p>打开终端安装以下软件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install git</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm        #Node.js 的包管理器</span><br><span class=\"line\">sudo npm install -g hexo-cli        #安装hexo</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-创建-GitHub-仓库并配置ssh\"><a href=\"#2-创建-GitHub-仓库并配置ssh\" class=\"headerlink\" title=\"2.创建 GitHub 仓库并配置ssh\"></a>2.创建 GitHub 仓库并配置ssh</h2><p>登录你的 GitHub 帐号，并创建一个新的仓库，仓库名是 <code>&lt;username&gt;.github.io</code>，其中 <code>&lt;username&gt;</code> 是你的 GitHub 用户名。将该仓库设置为公开仓库。<br>设置ssh</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br><span class=\"line\">cat ~/.ssh/id_rsa.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class=\"line\">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class=\"line\">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class=\"line\">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class=\"line\">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-初始化Hexo\"><a href=\"#3-初始化Hexo\" class=\"headerlink\" title=\"3.初始化Hexo\"></a>3.初始化Hexo</h2><p>创建一个新的文件夹，用于存储你的博客项目。<br>在终端中，进入该文件夹，并运行以下命令来初始化 Hexo</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir myblog</span><br><span class=\"line\">hexo init    </span><br><span class=\"line\">#或者直接一步到位 </span><br><span class=\"line\">hexo init myblog</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-配置Hexo\"><a href=\"#4-配置Hexo\" class=\"headerlink\" title=\"4.配置Hexo\"></a>4.配置Hexo</h2><ul>\n<li>进入你的 Hexo 项目文件夹，找到 _config.yml 文件，使用文本编辑器打开它。</li>\n<li>在 _config.yml 文件中，配置你的博客设置，例如标题、描述、作者等。</li>\n<li>根据需要，你还可以配置主题、插件和其他 Hexo 选项。<br>编辑_config.yml文件，添加如下内容 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">        type: git</span><br><span class=\"line\">        repo: git@github.com: &lt;username&gt;/ &lt;username&gt;.github.io.git  #&lt;username&gt;为自己的用户名</span><br><span class=\"line\">        branch: main</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git    #安装 hexo-deployer-git 插件 将部署过程自动化</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"5-创建博客内容\"><a href=\"#5-创建博客内容\" class=\"headerlink\" title=\"5.创建博客内容\"></a>5.创建博客内容</h2><p>在终端中，运行以下命令来创建新的博客文章：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;My First Post&quot;</span><br></pre></td></tr></table></figure>\n<p>这将在 Hexo 项目的 source&#x2F;_posts 目录下创建一个新的 Markdown 文件，用于编写你的第一篇博客文章。</p>\n<h2 id=\"6-部署\"><a href=\"#6-部署\" class=\"headerlink\" title=\"6.部署\"></a>6.部署</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s    # 预览</span><br><span class=\"line\">#Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class=\"line\">#用浏览器打开 http://localhost:4000/</span><br><span class=\"line\">hexo g #生成静态网站文件</span><br><span class=\"line\">hexo d #将生成的静态网站文件部署到github</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-查看\"><a href=\"#7-查看\" class=\"headerlink\" title=\"7.查看\"></a>7.查看</h2><p>浏览器打开<code>&lt;username&gt;.github.io</code>即可查看</p>\n<h2 id=\"8-参考：\"><a href=\"#8-参考：\" class=\"headerlink\" title=\"8.参考：\"></a>8.参考：</h2><p><a href=\"https://blog.csdn.net/qq_62928039/article/details/130248518\">https://blog.csdn.net/qq_62928039/article/details/130248518</a></p>\n<h2 id=\"9-选择主题：\"><a href=\"#9-选择主题：\" class=\"headerlink\" title=\"9.选择主题：\"></a>9.选择主题：</h2><p><a href=\"https://hexo.io/themes/\">https://hexo.io/themes/</a><br><a href=\"https://github.com/yelog/hexo-theme-3-hexo\">https://github.com/yelog/hexo-theme-3-hexo</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在hexo根目录下</span><br><span class=\"line\">git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</span><br><span class=\"line\">#修改hexo根目录的_config.yml，如下</span><br><span class=\"line\">theme: 3-hexo</span><br><span class=\"line\">#博客配置</span><br><span class=\"line\">http://yelog.org/2017/03/23/3-hexo-instruction/</span><br></pre></td></tr></table></figure>\n<p>最终效果：<br><a href=\"https://yyheroi.github.io/\">https://yyheroi.github.io</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>@[toc]<br>环境：win11+wsl</p>\n<h2 id=\"1-安装Node-js、Git和Hexo\"><a href=\"#1-安装Node-js、Git和Hexo\" class=\"headerlink\" title=\"1.安装Node.js、Git和Hexo\"></a>1.安装Node.js、Git和Hexo</h2><p>打开终端安装以下软件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install git</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm        #Node.js 的包管理器</span><br><span class=\"line\">sudo npm install -g hexo-cli        #安装hexo</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-创建-GitHub-仓库并配置ssh\"><a href=\"#2-创建-GitHub-仓库并配置ssh\" class=\"headerlink\" title=\"2.创建 GitHub 仓库并配置ssh\"></a>2.创建 GitHub 仓库并配置ssh</h2><p>登录你的 GitHub 帐号，并创建一个新的仓库，仓库名是 <code>&lt;username&gt;.github.io</code>，其中 <code>&lt;username&gt;</code> 是你的 GitHub 用户名。将该仓库设置为公开仓库。<br>设置ssh</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br><span class=\"line\">cat ~/.ssh/id_rsa.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class=\"line\">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class=\"line\">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class=\"line\">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class=\"line\">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-初始化Hexo\"><a href=\"#3-初始化Hexo\" class=\"headerlink\" title=\"3.初始化Hexo\"></a>3.初始化Hexo</h2><p>创建一个新的文件夹，用于存储你的博客项目。<br>在终端中，进入该文件夹，并运行以下命令来初始化 Hexo</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir myblog</span><br><span class=\"line\">hexo init    </span><br><span class=\"line\">#或者直接一步到位 </span><br><span class=\"line\">hexo init myblog</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-配置Hexo\"><a href=\"#4-配置Hexo\" class=\"headerlink\" title=\"4.配置Hexo\"></a>4.配置Hexo</h2><ul>\n<li>进入你的 Hexo 项目文件夹，找到 _config.yml 文件，使用文本编辑器打开它。</li>\n<li>在 _config.yml 文件中，配置你的博客设置，例如标题、描述、作者等。</li>\n<li>根据需要，你还可以配置主题、插件和其他 Hexo 选项。<br>编辑_config.yml文件，添加如下内容 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">        type: git</span><br><span class=\"line\">        repo: git@github.com: &lt;username&gt;/ &lt;username&gt;.github.io.git  #&lt;username&gt;为自己的用户名</span><br><span class=\"line\">        branch: main</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git    #安装 hexo-deployer-git 插件 将部署过程自动化</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"5-创建博客内容\"><a href=\"#5-创建博客内容\" class=\"headerlink\" title=\"5.创建博客内容\"></a>5.创建博客内容</h2><p>在终端中，运行以下命令来创建新的博客文章：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;My First Post&quot;</span><br></pre></td></tr></table></figure>\n<p>这将在 Hexo 项目的 source&#x2F;_posts 目录下创建一个新的 Markdown 文件，用于编写你的第一篇博客文章。</p>\n<h2 id=\"6-部署\"><a href=\"#6-部署\" class=\"headerlink\" title=\"6.部署\"></a>6.部署</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s    # 预览</span><br><span class=\"line\">#Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class=\"line\">#用浏览器打开 http://localhost:4000/</span><br><span class=\"line\">hexo g #生成静态网站文件</span><br><span class=\"line\">hexo d #将生成的静态网站文件部署到github</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-查看\"><a href=\"#7-查看\" class=\"headerlink\" title=\"7.查看\"></a>7.查看</h2><p>浏览器打开<code>&lt;username&gt;.github.io</code>即可查看</p>\n<h2 id=\"8-参考：\"><a href=\"#8-参考：\" class=\"headerlink\" title=\"8.参考：\"></a>8.参考：</h2><p><a href=\"https://blog.csdn.net/qq_62928039/article/details/130248518\">https://blog.csdn.net/qq_62928039/article/details/130248518</a></p>\n<h2 id=\"9-选择主题：\"><a href=\"#9-选择主题：\" class=\"headerlink\" title=\"9.选择主题：\"></a>9.选择主题：</h2><p><a href=\"https://hexo.io/themes/\">https://hexo.io/themes/</a><br><a href=\"https://github.com/yelog/hexo-theme-3-hexo\">https://github.com/yelog/hexo-theme-3-hexo</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在hexo根目录下</span><br><span class=\"line\">git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</span><br><span class=\"line\">#修改hexo根目录的_config.yml，如下</span><br><span class=\"line\">theme: 3-hexo</span><br><span class=\"line\">#博客配置</span><br><span class=\"line\">http://yelog.org/2017/03/23/3-hexo-instruction/</span><br></pre></td></tr></table></figure>\n<p>最终效果：<br><a href=\"https://yyheroi.github.io/\">https://yyheroi.github.io</a></p>\n"},{"title":"Hello World","date":"2023-08-24T16:00:00.000Z","categories":["test"],"tags":["test"],"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"back_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2023-08-25 00:00:00\ncategories:\n- test\ntags:\n- test\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","updated":"2024-05-15T06:11:08.991Z","path":"back_posts/hello-world.html","comments":1,"layout":"page","_id":"clw7fflks0008x2w015yo7zy7","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"_content":"# 块设备驱动\n\n\n\n块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。","source":"back_posts/linux块设备驱动.md","raw":"# 块设备驱动\n\n\n\n块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。","date":"2024-05-15T06:11:08.991Z","updated":"2024-05-15T06:11:08.991Z","path":"back_posts/linux块设备驱动.html","title":"","comments":1,"layout":"page","_id":"clw7fflks0009x2w0709d7bi5","content":"<h1 id=\"块设备驱动\"><a href=\"#块设备驱动\" class=\"headerlink\" title=\"块设备驱动\"></a>块设备驱动</h1><p>块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"块设备驱动\"><a href=\"#块设备驱动\" class=\"headerlink\" title=\"块设备驱动\"></a>块设备驱动</h1><p>块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。</p>\n"},{"_content":"> \n\nU-Boot官网:`https://docs.u-boot.org/en/latest/`\n\nu-boot启动流程\n\n- 板子上电以后，首先执行的是ROM中的一段启动代码。启动代码**根据寄存器/外部管脚配置**，确定是进入下载模式，还是从某介质(Flash/EMMC/SD卡等存储设备)启动u-boot\n\n> ROM中的代码是固化的，无法修改\n\n# 一、介绍\n\n> FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。\n>\n> uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  \n\n> U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc/README.fdt-control\n\n### dtb在U-boot中的位置\n\n- dtb能够以两种形式编译到U-boot的镜像中\n\n1. dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)\n\n> 通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址\n\n1. dtb集成到u-boot的bin文件内部\n\n> 通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb\n\n1. 获取dts文件的地址gd->fdt_blob\n\n```\n// 宏用来表示是否把dtb文件放在uboot.bin的文件中\nCONFIG_OF_EMBED\n\n// 单独编译dtb文件\nCONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址\n\ngd->fdt_blob = (ulong *)&_end;\n\n// 可以通过fdtcontroladdr环境变量来指定fdt的地址\ngd->fdt_blob = (void *)getenv_ulong(\"fdtcontroladdr\", 16,\n\t\t\t\t\t\t(uintptr_t)gd->fdt_blob); \n```\n\n###  dtb解析接口\n\n- 定义在lib/fdtdec.c文件中，节点变量node中存放的是偏移地址\n\n```\n// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点\nint fdt_path_offset(const void *fdt, const char *path)\neg：node = fdt_path_offset(gd->fdt_blob, “/aliases”);\n\n// 获得节点node的某个字符串属性值\nconst void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)\neg： mac = fdt_getprop(gd->fdt_blob, node, “mac-address”, &len);\n\n// 获得节点node的某个整形数组属性值\nint fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)\neg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));\n\n// 获得节点node的地址属性值\nfdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)\neg：fdtdec_get_addr(blob, node, “reg”);\n\n// 获得config节点下的整形属性、bool属性、字符串等等\nfdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string\n\n// 获得chosen下的name节点的偏移\nint fdtdec_get_chosen_node(const void *blob, const char *name)\n\n// 获得chosen下name属性的值\nconst char *fdtdec_get_chosen_prop(const void *blob, const char *name)\n```\n\n- 定义在lib/fdtdec_common.c文件中\n\n```\n// 获得节点node的某个整形属性值\nint fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)\neg： bus->udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);\n\n// 获得节点node的某个无符号整形属性值\nfdtdec_get_uint\n```\n\n## fdt 命令\n\n对于u-boot提供了fdt的相关命令\n\n```\nfdt - flattened device tree utility commands\n\nUsage:\nfdt addr [-c]  <addr> [<length>]   - Set the [control] fdt location to <addr>\nfdt apply <addr>                    - Apply overlay to the DT\nfdt move   <fdt> <newaddr> <length> - Copy the fdt to <addr> and make it active\nfdt resize [<extrasize>]            - Resize fdt to size + padding to 4k addr + some optional <extrasize> if needed\nfdt print  <path> [<prop>]          - Recursive print starting at <path>\nfdt list   <path> [<prop>]          - Print one level starting at <path>\nfdt get value <var> <path> <prop>   - Get <property> and store in <var>\nfdt get name <var> <path> <index>   - Get name of node <index> and store in <var>\nfdt get addr <var> <path> <prop>    - Get start address of <property> and store in <var>\nfdt get size <var> <path> [<prop>]  - Get size of [<property>] or num nodes and store in <var>\nfdt set    <path> <prop> [<val>]    - Set <property> [to <val>]\nfdt mknode <path> <node>            - Create a new node after <path>\nfdt rm     <path> [<prop>]          - Delete the node or <property>\nfdt header                          - Display header info\nfdt bootcpu <id>                    - Set boot cpuid\nfdt memory <addr> <size>            - Add/Update memory node\nfdt rsvmem print                    - Show current mem reserves\nfdt rsvmem add <addr> <size>        - Add a mem reserve\nfdt rsvmem delete <index>           - Delete a mem reserves\nfdt chosen [<start> <end>]          - Add/update the /chosen branch in the tree\n                                        <start>/<end> - initrd start/end addr\nNOTE: Dereference aliases by omitting the leading '/', e.g. fdt print ethernet0.\n```\n\nfdt print加path参数，则打path内容，如下(其中/memory是path)：\n\n```c\nU-Boot> fdt print /memory\nmemory {\ndevice_type = \"memory\";\nreg = <0x70000000 0x4000000>;\n};\n\nU-Boot> fdt print #不加参数时，打印出整颗树\n```\n\n\n\n二、u-boot 获取GPT分区表\n\n在uboot中通过命令打印分区表\n\n```\npart list mmc 0\n```\n\n3588-android-uboot\n\n```c\n#include <common.h>\n#include <command.h>\n#include <android_image.h>\n#include <mmc.h>\n#include <stdlib.h>\n#include <memalign.h>\n#include <fdtdec.h>\n\n#define PART_MAX_COUNT  128\n#define\tLAB_SIZE\t\t512\n#define\tHEADER_OFFSET\tLAB_SIZE\n#define\tENTRY_OFFSET\t(2 * LAB_SIZE)\n#define\tVAL1_OFFSET\t\tsizeof(u64)\n#define\tVAL2_OFFSET\t\t(2 * sizeof(u64))\n\nstatic u64 get_gpt_blk_cnt_and_print(struct blk_desc *dev_desc,\n\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte) {\n\tchar efi_str[PARTNAME_SZ + 1];\n\tu64 gpt_part_size, gpt_blk_cnt = 0;\n\tgpt_entry *gpt_e;\n\tint i;\n\n\tgpt_e = *gpt_pte;\n\tfor (i = 0; i < gpt_head->num_partition_entries; i++) {\n\n\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,\n\t\t\t\t\t     PARTNAME_SZ + 1);\n\n\t\tprintf(\"%s: part: %2d name - GPT: %16s \",\n\t\t      __func__, i, efi_str);\n\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -\n\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + 1;\n\t\tgpt_blk_cnt += gpt_part_size;\n\t\t\n\t\tif(gpt_part_size == 1) \n\t\t\tbreak;\n\t\t\n\t\tprintf(\"size(LBA) - GPT: %8llu \",\n\t\t      (unsigned long long)gpt_part_size);\n\n\t\tprintf(\"start LBA - GPT: %8llu \\n\",\n\t\t      le64_to_cpu(gpt_e[i].starting_lba));\n\t}\n\n\treturn gpt_blk_cnt + gpt_e[0].starting_lba - 1;\n}\n\nstatic int get_gpt_meta_data(u64 *data_size, void **data)\n{\n    gpt_header *pgpt_head;\n\tgpt_entry *entries;\n\tvoid *meta_data;\n\tu64 meta_data_size, gpt_entries_size;\n\tstruct blk_desc *dev_desc = NULL;\n\tstruct mmc *mmc = NULL;\n\tu64 blk_size = 0;\n\tu64 blk_cnt = 0;\n\tu64 tag = 0x55AA;\n\tlbaint_t lba;\n    \n\tif (!data_size || !data) {\n\t\tprintf(\"%s *** ERROR: Invalid Argument(s) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    mmc = do_returnmmc();\n\tif (!mmc)\n\t\treturn CMD_RET_FAILURE;\n    \n    dev_desc = mmc_get_blk_desc(mmc);\n\tif (!dev_desc) {\n\t\tprintf(\"%s *** ERROR: mmc_get_blk_desc err ***\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tgpt_entries_size = sizeof(gpt_entry) * PART_MAX_COUNT;\n\tmeta_data_size = LAB_SIZE + sizeof(gpt_header) + gpt_entries_size;\n\tmeta_data = malloc(meta_data_size);\n\tif(!meta_data) {\n\t\tprintf(\"%s *** ERROR: malloc memory (gpt meta data) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    memset(meta_data, 0, meta_data_size);\n\tpgpt_head = (gpt_header *)((char *)meta_data + HEADER_OFFSET);\n\tentries = (gpt_entry *)((char *)meta_data + ENTRY_OFFSET);\n\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc->blksz);\n\n\t/* Read MBR Header from device */\n\tlba = 0; /* MBR is always at 0 */\n\tblk_cnt = 1; /* MBR (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != 1) {\n\t\tprintf(\"*** ERROR: Can't read MBR header ***\\n\");\n\t\tgoto ERROR_OUT;\n\t}\n\n\t/* Read GPT Header from device */\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tblk_cnt = 1; /* GPT Header (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != 1) {\n    \tprintf(\"%s *** ERROR: Can't read GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tif (validate_gpt_header(pgpt_head, lba, dev_desc->lba)) {\n\t\tprintf(\"%s *** ERROR: validate_gpt_header GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tif (dev_desc->sig_type == SIG_TYPE_NONE) {\n\t\tefi_guid_t empty = {};\n\t\tif (memcmp(&pgpt_head->disk_guid, &empty, sizeof(empty))) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_GUID;\n\t\t\tmemcpy(&dev_desc->guid_sig, &pgpt_head->disk_guid,\n\t\t\t      sizeof(empty));\n\t\t} else if (mbr->unique_mbr_signature != 0) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_MBR;\n\t\t\tdev_desc->mbr_sig = mbr->unique_mbr_signature;\n\t\t}\n\t}\n\n\t/* Read GPT Entries from device */\n\tlba = le64_to_cpu(pgpt_head->partition_entry_lba);\n\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head->num_partition_entries) *\n\t\t\t\t   \tle32_to_cpu(pgpt_head->sizeof_partition_entry)),\n\t\t\t\t  \tdev_desc);\n\tif (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) {\n\t\tprintf(\"%s *** ERROR:read entries (lba=%llu) ***\\n\",\n\t\t\t\t__func__, pgpt_head->partition_entry_lba);\n\t\tgoto ERROR_OUT;\n\t}\n\t\n\tblk_size = dev_desc->blksz;\n\tvalidate_gpt_entries(pgpt_head, entries);\n\t\n\tdebug(\"%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n\",\n\t\t\t\t__func__, (unsigned long long)(ulong)lba, blk_cnt, blk_size);\n\t\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n    \n    /* \n\t * build info, layout of meta_data:\n\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries\n\t */\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n\t/*this value makes we known the reserved memory is available*/\n\tmemcpy(meta_data, (void *)&tag, sizeof(u64));\n\tmemcpy(meta_data + VAL1_OFFSET, (void *)&blk_size, sizeof(u64));\n\tmemcpy(meta_data + VAL2_OFFSET, (void *)&blk_cnt, sizeof(u64));\n\n\t*data_size = meta_data_size;\n\t*data = meta_data;\n\n\treturn 0;\n\nERROR_OUT:\n\tfree(meta_data);\n\tmeta_data = NULL;\n\treturn -1;\n}\n```\n\n\n\n参考：\n\n[Device Tree（四）：文件结构解析 (wowotech.net)](http://www.wowotech.net/device_model/dt-code-file-struct-parse.html)\n\n[Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376295326)\n\n[Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376296222)\n\nhttps://www.cnblogs.com/solo666/p/16518154.html","source":"back_posts/uboot之fdt.md","raw":"> \n\nU-Boot官网:`https://docs.u-boot.org/en/latest/`\n\nu-boot启动流程\n\n- 板子上电以后，首先执行的是ROM中的一段启动代码。启动代码**根据寄存器/外部管脚配置**，确定是进入下载模式，还是从某介质(Flash/EMMC/SD卡等存储设备)启动u-boot\n\n> ROM中的代码是固化的，无法修改\n\n# 一、介绍\n\n> FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。\n>\n> uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  \n\n> U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc/README.fdt-control\n\n### dtb在U-boot中的位置\n\n- dtb能够以两种形式编译到U-boot的镜像中\n\n1. dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)\n\n> 通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址\n\n1. dtb集成到u-boot的bin文件内部\n\n> 通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb\n\n1. 获取dts文件的地址gd->fdt_blob\n\n```\n// 宏用来表示是否把dtb文件放在uboot.bin的文件中\nCONFIG_OF_EMBED\n\n// 单独编译dtb文件\nCONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址\n\ngd->fdt_blob = (ulong *)&_end;\n\n// 可以通过fdtcontroladdr环境变量来指定fdt的地址\ngd->fdt_blob = (void *)getenv_ulong(\"fdtcontroladdr\", 16,\n\t\t\t\t\t\t(uintptr_t)gd->fdt_blob); \n```\n\n###  dtb解析接口\n\n- 定义在lib/fdtdec.c文件中，节点变量node中存放的是偏移地址\n\n```\n// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点\nint fdt_path_offset(const void *fdt, const char *path)\neg：node = fdt_path_offset(gd->fdt_blob, “/aliases”);\n\n// 获得节点node的某个字符串属性值\nconst void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)\neg： mac = fdt_getprop(gd->fdt_blob, node, “mac-address”, &len);\n\n// 获得节点node的某个整形数组属性值\nint fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)\neg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));\n\n// 获得节点node的地址属性值\nfdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)\neg：fdtdec_get_addr(blob, node, “reg”);\n\n// 获得config节点下的整形属性、bool属性、字符串等等\nfdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string\n\n// 获得chosen下的name节点的偏移\nint fdtdec_get_chosen_node(const void *blob, const char *name)\n\n// 获得chosen下name属性的值\nconst char *fdtdec_get_chosen_prop(const void *blob, const char *name)\n```\n\n- 定义在lib/fdtdec_common.c文件中\n\n```\n// 获得节点node的某个整形属性值\nint fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)\neg： bus->udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);\n\n// 获得节点node的某个无符号整形属性值\nfdtdec_get_uint\n```\n\n## fdt 命令\n\n对于u-boot提供了fdt的相关命令\n\n```\nfdt - flattened device tree utility commands\n\nUsage:\nfdt addr [-c]  <addr> [<length>]   - Set the [control] fdt location to <addr>\nfdt apply <addr>                    - Apply overlay to the DT\nfdt move   <fdt> <newaddr> <length> - Copy the fdt to <addr> and make it active\nfdt resize [<extrasize>]            - Resize fdt to size + padding to 4k addr + some optional <extrasize> if needed\nfdt print  <path> [<prop>]          - Recursive print starting at <path>\nfdt list   <path> [<prop>]          - Print one level starting at <path>\nfdt get value <var> <path> <prop>   - Get <property> and store in <var>\nfdt get name <var> <path> <index>   - Get name of node <index> and store in <var>\nfdt get addr <var> <path> <prop>    - Get start address of <property> and store in <var>\nfdt get size <var> <path> [<prop>]  - Get size of [<property>] or num nodes and store in <var>\nfdt set    <path> <prop> [<val>]    - Set <property> [to <val>]\nfdt mknode <path> <node>            - Create a new node after <path>\nfdt rm     <path> [<prop>]          - Delete the node or <property>\nfdt header                          - Display header info\nfdt bootcpu <id>                    - Set boot cpuid\nfdt memory <addr> <size>            - Add/Update memory node\nfdt rsvmem print                    - Show current mem reserves\nfdt rsvmem add <addr> <size>        - Add a mem reserve\nfdt rsvmem delete <index>           - Delete a mem reserves\nfdt chosen [<start> <end>]          - Add/update the /chosen branch in the tree\n                                        <start>/<end> - initrd start/end addr\nNOTE: Dereference aliases by omitting the leading '/', e.g. fdt print ethernet0.\n```\n\nfdt print加path参数，则打path内容，如下(其中/memory是path)：\n\n```c\nU-Boot> fdt print /memory\nmemory {\ndevice_type = \"memory\";\nreg = <0x70000000 0x4000000>;\n};\n\nU-Boot> fdt print #不加参数时，打印出整颗树\n```\n\n\n\n二、u-boot 获取GPT分区表\n\n在uboot中通过命令打印分区表\n\n```\npart list mmc 0\n```\n\n3588-android-uboot\n\n```c\n#include <common.h>\n#include <command.h>\n#include <android_image.h>\n#include <mmc.h>\n#include <stdlib.h>\n#include <memalign.h>\n#include <fdtdec.h>\n\n#define PART_MAX_COUNT  128\n#define\tLAB_SIZE\t\t512\n#define\tHEADER_OFFSET\tLAB_SIZE\n#define\tENTRY_OFFSET\t(2 * LAB_SIZE)\n#define\tVAL1_OFFSET\t\tsizeof(u64)\n#define\tVAL2_OFFSET\t\t(2 * sizeof(u64))\n\nstatic u64 get_gpt_blk_cnt_and_print(struct blk_desc *dev_desc,\n\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte) {\n\tchar efi_str[PARTNAME_SZ + 1];\n\tu64 gpt_part_size, gpt_blk_cnt = 0;\n\tgpt_entry *gpt_e;\n\tint i;\n\n\tgpt_e = *gpt_pte;\n\tfor (i = 0; i < gpt_head->num_partition_entries; i++) {\n\n\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,\n\t\t\t\t\t     PARTNAME_SZ + 1);\n\n\t\tprintf(\"%s: part: %2d name - GPT: %16s \",\n\t\t      __func__, i, efi_str);\n\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -\n\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + 1;\n\t\tgpt_blk_cnt += gpt_part_size;\n\t\t\n\t\tif(gpt_part_size == 1) \n\t\t\tbreak;\n\t\t\n\t\tprintf(\"size(LBA) - GPT: %8llu \",\n\t\t      (unsigned long long)gpt_part_size);\n\n\t\tprintf(\"start LBA - GPT: %8llu \\n\",\n\t\t      le64_to_cpu(gpt_e[i].starting_lba));\n\t}\n\n\treturn gpt_blk_cnt + gpt_e[0].starting_lba - 1;\n}\n\nstatic int get_gpt_meta_data(u64 *data_size, void **data)\n{\n    gpt_header *pgpt_head;\n\tgpt_entry *entries;\n\tvoid *meta_data;\n\tu64 meta_data_size, gpt_entries_size;\n\tstruct blk_desc *dev_desc = NULL;\n\tstruct mmc *mmc = NULL;\n\tu64 blk_size = 0;\n\tu64 blk_cnt = 0;\n\tu64 tag = 0x55AA;\n\tlbaint_t lba;\n    \n\tif (!data_size || !data) {\n\t\tprintf(\"%s *** ERROR: Invalid Argument(s) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    mmc = do_returnmmc();\n\tif (!mmc)\n\t\treturn CMD_RET_FAILURE;\n    \n    dev_desc = mmc_get_blk_desc(mmc);\n\tif (!dev_desc) {\n\t\tprintf(\"%s *** ERROR: mmc_get_blk_desc err ***\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tgpt_entries_size = sizeof(gpt_entry) * PART_MAX_COUNT;\n\tmeta_data_size = LAB_SIZE + sizeof(gpt_header) + gpt_entries_size;\n\tmeta_data = malloc(meta_data_size);\n\tif(!meta_data) {\n\t\tprintf(\"%s *** ERROR: malloc memory (gpt meta data) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    memset(meta_data, 0, meta_data_size);\n\tpgpt_head = (gpt_header *)((char *)meta_data + HEADER_OFFSET);\n\tentries = (gpt_entry *)((char *)meta_data + ENTRY_OFFSET);\n\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc->blksz);\n\n\t/* Read MBR Header from device */\n\tlba = 0; /* MBR is always at 0 */\n\tblk_cnt = 1; /* MBR (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != 1) {\n\t\tprintf(\"*** ERROR: Can't read MBR header ***\\n\");\n\t\tgoto ERROR_OUT;\n\t}\n\n\t/* Read GPT Header from device */\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tblk_cnt = 1; /* GPT Header (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != 1) {\n    \tprintf(\"%s *** ERROR: Can't read GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tif (validate_gpt_header(pgpt_head, lba, dev_desc->lba)) {\n\t\tprintf(\"%s *** ERROR: validate_gpt_header GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tif (dev_desc->sig_type == SIG_TYPE_NONE) {\n\t\tefi_guid_t empty = {};\n\t\tif (memcmp(&pgpt_head->disk_guid, &empty, sizeof(empty))) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_GUID;\n\t\t\tmemcpy(&dev_desc->guid_sig, &pgpt_head->disk_guid,\n\t\t\t      sizeof(empty));\n\t\t} else if (mbr->unique_mbr_signature != 0) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_MBR;\n\t\t\tdev_desc->mbr_sig = mbr->unique_mbr_signature;\n\t\t}\n\t}\n\n\t/* Read GPT Entries from device */\n\tlba = le64_to_cpu(pgpt_head->partition_entry_lba);\n\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head->num_partition_entries) *\n\t\t\t\t   \tle32_to_cpu(pgpt_head->sizeof_partition_entry)),\n\t\t\t\t  \tdev_desc);\n\tif (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) {\n\t\tprintf(\"%s *** ERROR:read entries (lba=%llu) ***\\n\",\n\t\t\t\t__func__, pgpt_head->partition_entry_lba);\n\t\tgoto ERROR_OUT;\n\t}\n\t\n\tblk_size = dev_desc->blksz;\n\tvalidate_gpt_entries(pgpt_head, entries);\n\t\n\tdebug(\"%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n\",\n\t\t\t\t__func__, (unsigned long long)(ulong)lba, blk_cnt, blk_size);\n\t\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n    \n    /* \n\t * build info, layout of meta_data:\n\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries\n\t */\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n\t/*this value makes we known the reserved memory is available*/\n\tmemcpy(meta_data, (void *)&tag, sizeof(u64));\n\tmemcpy(meta_data + VAL1_OFFSET, (void *)&blk_size, sizeof(u64));\n\tmemcpy(meta_data + VAL2_OFFSET, (void *)&blk_cnt, sizeof(u64));\n\n\t*data_size = meta_data_size;\n\t*data = meta_data;\n\n\treturn 0;\n\nERROR_OUT:\n\tfree(meta_data);\n\tmeta_data = NULL;\n\treturn -1;\n}\n```\n\n\n\n参考：\n\n[Device Tree（四）：文件结构解析 (wowotech.net)](http://www.wowotech.net/device_model/dt-code-file-struct-parse.html)\n\n[Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376295326)\n\n[Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376296222)\n\nhttps://www.cnblogs.com/solo666/p/16518154.html","date":"2024-05-15T06:11:08.992Z","updated":"2024-05-15T06:11:08.992Z","path":"back_posts/uboot之fdt.html","title":"","comments":1,"layout":"page","_id":"clw7fflkt000ax2w03qcob16u","content":"<blockquote>\n</blockquote>\n<p>U-Boot官网:<code>https://docs.u-boot.org/en/latest/</code></p>\n<p>u-boot启动流程</p>\n<ul>\n<li>板子上电以后，首先执行的是ROM中的一段启动代码。启动代码<strong>根据寄存器&#x2F;外部管脚配置</strong>，确定是进入下载模式，还是从某介质(Flash&#x2F;EMMC&#x2F;SD卡等存储设备)启动u-boot</li>\n</ul>\n<blockquote>\n<p>ROM中的代码是固化的，无法修改</p>\n</blockquote>\n<h1 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h1><blockquote>\n<p>FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。</p>\n<p>uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  </p>\n</blockquote>\n<blockquote>\n<p>U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc&#x2F;README.fdt-control</p>\n</blockquote>\n<h3 id=\"dtb在U-boot中的位置\"><a href=\"#dtb在U-boot中的位置\" class=\"headerlink\" title=\"dtb在U-boot中的位置\"></a>dtb在U-boot中的位置</h3><ul>\n<li>dtb能够以两种形式编译到U-boot的镜像中</li>\n</ul>\n<ol>\n<li>dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址</p>\n</blockquote>\n<ol>\n<li>dtb集成到u-boot的bin文件内部</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb</p>\n</blockquote>\n<ol>\n<li>获取dts文件的地址gd-&gt;fdt_blob</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 宏用来表示是否把dtb文件放在uboot.bin的文件中</span><br><span class=\"line\">CONFIG_OF_EMBED</span><br><span class=\"line\"></span><br><span class=\"line\">// 单独编译dtb文件</span><br><span class=\"line\">CONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址</span><br><span class=\"line\"></span><br><span class=\"line\">gd-&gt;fdt_blob = (ulong *)&amp;_end;</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以通过fdtcontroladdr环境变量来指定fdt的地址</span><br><span class=\"line\">gd-&gt;fdt_blob = (void *)getenv_ulong(&quot;fdtcontroladdr&quot;, 16,</span><br><span class=\"line\">\t\t\t\t\t\t(uintptr_t)gd-&gt;fdt_blob); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dtb解析接口\"><a href=\"#dtb解析接口\" class=\"headerlink\" title=\"dtb解析接口\"></a>dtb解析接口</h3><ul>\n<li>定义在lib&#x2F;fdtdec.c文件中，节点变量node中存放的是偏移地址</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点</span><br><span class=\"line\">int fdt_path_offset(const void *fdt, const char *path)</span><br><span class=\"line\">eg：node = fdt_path_offset(gd-&gt;fdt_blob, “/aliases”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个字符串属性值</span><br><span class=\"line\">const void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)</span><br><span class=\"line\">eg： mac = fdt_getprop(gd-&gt;fdt_blob, node, “mac-address”, &amp;len);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个整形数组属性值</span><br><span class=\"line\">int fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)</span><br><span class=\"line\">eg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的地址属性值</span><br><span class=\"line\">fdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)</span><br><span class=\"line\">eg：fdtdec_get_addr(blob, node, “reg”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得config节点下的整形属性、bool属性、字符串等等</span><br><span class=\"line\">fdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下的name节点的偏移</span><br><span class=\"line\">int fdtdec_get_chosen_node(const void *blob, const char *name)</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下name属性的值</span><br><span class=\"line\">const char *fdtdec_get_chosen_prop(const void *blob, const char *name)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义在lib&#x2F;fdtdec_common.c文件中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得节点node的某个整形属性值</span><br><span class=\"line\">int fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)</span><br><span class=\"line\">eg： bus-&gt;udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个无符号整形属性值</span><br><span class=\"line\">fdtdec_get_uint</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fdt-命令\"><a href=\"#fdt-命令\" class=\"headerlink\" title=\"fdt 命令\"></a>fdt 命令</h2><p>对于u-boot提供了fdt的相关命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdt - flattened device tree utility commands</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">fdt addr [-c]  &lt;addr&gt; [&lt;length&gt;]   - Set the [control] fdt location to &lt;addr&gt;</span><br><span class=\"line\">fdt apply &lt;addr&gt;                    - Apply overlay to the DT</span><br><span class=\"line\">fdt move   &lt;fdt&gt; &lt;newaddr&gt; &lt;length&gt; - Copy the fdt to &lt;addr&gt; and make it active</span><br><span class=\"line\">fdt resize [&lt;extrasize&gt;]            - Resize fdt to size + padding to 4k addr + some optional &lt;extrasize&gt; if needed</span><br><span class=\"line\">fdt print  &lt;path&gt; [&lt;prop&gt;]          - Recursive print starting at &lt;path&gt;</span><br><span class=\"line\">fdt list   &lt;path&gt; [&lt;prop&gt;]          - Print one level starting at &lt;path&gt;</span><br><span class=\"line\">fdt get value &lt;var&gt; &lt;path&gt; &lt;prop&gt;   - Get &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get name &lt;var&gt; &lt;path&gt; &lt;index&gt;   - Get name of node &lt;index&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get addr &lt;var&gt; &lt;path&gt; &lt;prop&gt;    - Get start address of &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get size &lt;var&gt; &lt;path&gt; [&lt;prop&gt;]  - Get size of [&lt;property&gt;] or num nodes and store in &lt;var&gt;</span><br><span class=\"line\">fdt set    &lt;path&gt; &lt;prop&gt; [&lt;val&gt;]    - Set &lt;property&gt; [to &lt;val&gt;]</span><br><span class=\"line\">fdt mknode &lt;path&gt; &lt;node&gt;            - Create a new node after &lt;path&gt;</span><br><span class=\"line\">fdt rm     &lt;path&gt; [&lt;prop&gt;]          - Delete the node or &lt;property&gt;</span><br><span class=\"line\">fdt header                          - Display header info</span><br><span class=\"line\">fdt bootcpu &lt;id&gt;                    - Set boot cpuid</span><br><span class=\"line\">fdt memory &lt;addr&gt; &lt;size&gt;            - Add/Update memory node</span><br><span class=\"line\">fdt rsvmem print                    - Show current mem reserves</span><br><span class=\"line\">fdt rsvmem add &lt;addr&gt; &lt;size&gt;        - Add a mem reserve</span><br><span class=\"line\">fdt rsvmem delete &lt;index&gt;           - Delete a mem reserves</span><br><span class=\"line\">fdt chosen [&lt;start&gt; &lt;end&gt;]          - Add/update the /chosen branch in the tree</span><br><span class=\"line\">                                        &lt;start&gt;/&lt;end&gt; - initrd start/end addr</span><br><span class=\"line\">NOTE: Dereference aliases by omitting the leading &#x27;/&#x27;, e.g. fdt print ethernet0.</span><br></pre></td></tr></table></figure>\n\n<p>fdt print加path参数，则打path内容，如下(其中&#x2F;memory是path)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">U-Boot&gt; fdt print /memory</span><br><span class=\"line\">memory &#123;</span><br><span class=\"line\">device_type = <span class=\"string\">&quot;memory&quot;</span>;</span><br><span class=\"line\">reg = &lt;<span class=\"number\">0x70000000</span> <span class=\"number\">0x4000000</span>&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot&gt; fdt print #不加参数时，打印出整颗树</span><br></pre></td></tr></table></figure>\n\n\n\n<p>二、u-boot 获取GPT分区表</p>\n<p>在uboot中通过命令打印分区表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">part list mmc 0</span><br></pre></td></tr></table></figure>\n\n<p>3588-android-uboot</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;common.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;command.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;android_image.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mmc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memalign.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fdtdec.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PART_MAX_COUNT  128</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tLAB_SIZE\t\t512</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tHEADER_OFFSET\tLAB_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tENTRY_OFFSET\t(2 * LAB_SIZE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL1_OFFSET\t\tsizeof(u64)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL2_OFFSET\t\t(2 * sizeof(u64))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">get_gpt_blk_cnt_and_print</span><span class=\"params\">(<span class=\"keyword\">struct</span> blk_desc *dev_desc,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> efi_str[PARTNAME_SZ + <span class=\"number\">1</span>];</span><br><span class=\"line\">\tu64 gpt_part_size, gpt_blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tgpt_entry *gpt_e;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_e = *gpt_pte;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; gpt_head-&gt;num_partition_entries; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,</span><br><span class=\"line\">\t\t\t\t\t     PARTNAME_SZ + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s: part: %2d name - GPT: %16s &quot;</span>,</span><br><span class=\"line\">\t\t      __func__, i, efi_str);</span><br><span class=\"line\">\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -</span><br><span class=\"line\">\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tgpt_blk_cnt += gpt_part_size;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(gpt_part_size == <span class=\"number\">1</span>) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size(LBA) - GPT: %8llu &quot;</span>,</span><br><span class=\"line\">\t\t      (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)gpt_part_size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start LBA - GPT: %8llu \\n&quot;</span>,</span><br><span class=\"line\">\t\t      le64_to_cpu(gpt_e[i].starting_lba));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gpt_blk_cnt + gpt_e[<span class=\"number\">0</span>].starting_lba - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">get_gpt_meta_data</span><span class=\"params\">(u64 *data_size, <span class=\"type\">void</span> **data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gpt_header *pgpt_head;</span><br><span class=\"line\">\tgpt_entry *entries;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *meta_data;</span><br><span class=\"line\">\tu64 meta_data_size, gpt_entries_size;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_desc</span> *<span class=\"title\">dev_desc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mmc</span> *<span class=\"title\">mmc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tu64 blk_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 tag = <span class=\"number\">0x55AA</span>;</span><br><span class=\"line\">\t<span class=\"type\">lbaint_t</span> lba;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!data_size || !data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Invalid Argument(s) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mmc = do_returnmmc();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!mmc)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> CMD_RET_FAILURE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    dev_desc = mmc_get_blk_desc(mmc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!dev_desc) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: mmc_get_blk_desc err ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_entries_size = <span class=\"keyword\">sizeof</span>(gpt_entry) * PART_MAX_COUNT;</span><br><span class=\"line\">\tmeta_data_size = LAB_SIZE + <span class=\"keyword\">sizeof</span>(gpt_header) + gpt_entries_size;</span><br><span class=\"line\">\tmeta_data = <span class=\"built_in\">malloc</span>(meta_data_size);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!meta_data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: malloc memory (gpt meta data) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(meta_data, <span class=\"number\">0</span>, meta_data_size);</span><br><span class=\"line\">\tpgpt_head = (gpt_header *)((<span class=\"type\">char</span> *)meta_data + HEADER_OFFSET);</span><br><span class=\"line\">\tentries = (gpt_entry *)((<span class=\"type\">char</span> *)meta_data + ENTRY_OFFSET);</span><br><span class=\"line\">\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc-&gt;blksz);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read MBR Header from device */</span></span><br><span class=\"line\">\tlba = <span class=\"number\">0</span>; <span class=\"comment\">/* MBR is always at 0 */</span></span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* MBR (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*** ERROR: Can&#x27;t read MBR header ***\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Header from device */</span></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* GPT Header (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Can&#x27;t read GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (validate_gpt_header(pgpt_head, lba, dev_desc-&gt;lba)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: validate_gpt_header GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dev_desc-&gt;sig_type == SIG_TYPE_NONE) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">efi_guid_t</span> empty = &#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">memcmp</span>(&amp;pgpt_head-&gt;disk_guid, &amp;empty, <span class=\"keyword\">sizeof</span>(empty))) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_GUID;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(&amp;dev_desc-&gt;guid_sig, &amp;pgpt_head-&gt;disk_guid,</span><br><span class=\"line\">\t\t\t      <span class=\"keyword\">sizeof</span>(empty));</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mbr-&gt;unique_mbr_signature != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_MBR;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;mbr_sig = mbr-&gt;unique_mbr_signature;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Entries from device */</span></span><br><span class=\"line\">\tlba = le64_to_cpu(pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head-&gt;num_partition_entries) *</span><br><span class=\"line\">\t\t\t\t   \tle32_to_cpu(pgpt_head-&gt;sizeof_partition_entry)),</span><br><span class=\"line\">\t\t\t\t  \tdev_desc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR:read entries (lba=%llu) ***\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_size = dev_desc-&gt;blksz;</span><br><span class=\"line\">\tvalidate_gpt_entries(pgpt_head, entries);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdebug(<span class=\"string\">&quot;%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)(ulong)lba, blk_cnt, blk_size);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">\t * build info, layout of meta_data:</span></span><br><span class=\"line\"><span class=\"comment\">\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">\t<span class=\"comment\">/*this value makes we known the reserved memory is available*/</span></span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data, (<span class=\"type\">void</span> *)&amp;tag, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL1_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_size, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL2_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_cnt, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data_size = meta_data_size;</span><br><span class=\"line\">\t*data = meta_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR_OUT:</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(meta_data);</span><br><span class=\"line\">\tmeta_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参考：</p>\n<p><a href=\"http://www.wowotech.net/device_model/dt-code-file-struct-parse.html\">Device Tree（四）：文件结构解析 (wowotech.net)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376295326\">Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376296222\">Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/solo666/p/16518154.html\">https://www.cnblogs.com/solo666/p/16518154.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n</blockquote>\n<p>U-Boot官网:<code>https://docs.u-boot.org/en/latest/</code></p>\n<p>u-boot启动流程</p>\n<ul>\n<li>板子上电以后，首先执行的是ROM中的一段启动代码。启动代码<strong>根据寄存器&#x2F;外部管脚配置</strong>，确定是进入下载模式，还是从某介质(Flash&#x2F;EMMC&#x2F;SD卡等存储设备)启动u-boot</li>\n</ul>\n<blockquote>\n<p>ROM中的代码是固化的，无法修改</p>\n</blockquote>\n<h1 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h1><blockquote>\n<p>FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。</p>\n<p>uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  </p>\n</blockquote>\n<blockquote>\n<p>U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc&#x2F;README.fdt-control</p>\n</blockquote>\n<h3 id=\"dtb在U-boot中的位置\"><a href=\"#dtb在U-boot中的位置\" class=\"headerlink\" title=\"dtb在U-boot中的位置\"></a>dtb在U-boot中的位置</h3><ul>\n<li>dtb能够以两种形式编译到U-boot的镜像中</li>\n</ul>\n<ol>\n<li>dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址</p>\n</blockquote>\n<ol>\n<li>dtb集成到u-boot的bin文件内部</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb</p>\n</blockquote>\n<ol>\n<li>获取dts文件的地址gd-&gt;fdt_blob</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 宏用来表示是否把dtb文件放在uboot.bin的文件中</span><br><span class=\"line\">CONFIG_OF_EMBED</span><br><span class=\"line\"></span><br><span class=\"line\">// 单独编译dtb文件</span><br><span class=\"line\">CONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址</span><br><span class=\"line\"></span><br><span class=\"line\">gd-&gt;fdt_blob = (ulong *)&amp;_end;</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以通过fdtcontroladdr环境变量来指定fdt的地址</span><br><span class=\"line\">gd-&gt;fdt_blob = (void *)getenv_ulong(&quot;fdtcontroladdr&quot;, 16,</span><br><span class=\"line\">\t\t\t\t\t\t(uintptr_t)gd-&gt;fdt_blob); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dtb解析接口\"><a href=\"#dtb解析接口\" class=\"headerlink\" title=\"dtb解析接口\"></a>dtb解析接口</h3><ul>\n<li>定义在lib&#x2F;fdtdec.c文件中，节点变量node中存放的是偏移地址</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点</span><br><span class=\"line\">int fdt_path_offset(const void *fdt, const char *path)</span><br><span class=\"line\">eg：node = fdt_path_offset(gd-&gt;fdt_blob, “/aliases”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个字符串属性值</span><br><span class=\"line\">const void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)</span><br><span class=\"line\">eg： mac = fdt_getprop(gd-&gt;fdt_blob, node, “mac-address”, &amp;len);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个整形数组属性值</span><br><span class=\"line\">int fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)</span><br><span class=\"line\">eg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的地址属性值</span><br><span class=\"line\">fdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)</span><br><span class=\"line\">eg：fdtdec_get_addr(blob, node, “reg”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得config节点下的整形属性、bool属性、字符串等等</span><br><span class=\"line\">fdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下的name节点的偏移</span><br><span class=\"line\">int fdtdec_get_chosen_node(const void *blob, const char *name)</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下name属性的值</span><br><span class=\"line\">const char *fdtdec_get_chosen_prop(const void *blob, const char *name)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义在lib&#x2F;fdtdec_common.c文件中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得节点node的某个整形属性值</span><br><span class=\"line\">int fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)</span><br><span class=\"line\">eg： bus-&gt;udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个无符号整形属性值</span><br><span class=\"line\">fdtdec_get_uint</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fdt-命令\"><a href=\"#fdt-命令\" class=\"headerlink\" title=\"fdt 命令\"></a>fdt 命令</h2><p>对于u-boot提供了fdt的相关命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdt - flattened device tree utility commands</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">fdt addr [-c]  &lt;addr&gt; [&lt;length&gt;]   - Set the [control] fdt location to &lt;addr&gt;</span><br><span class=\"line\">fdt apply &lt;addr&gt;                    - Apply overlay to the DT</span><br><span class=\"line\">fdt move   &lt;fdt&gt; &lt;newaddr&gt; &lt;length&gt; - Copy the fdt to &lt;addr&gt; and make it active</span><br><span class=\"line\">fdt resize [&lt;extrasize&gt;]            - Resize fdt to size + padding to 4k addr + some optional &lt;extrasize&gt; if needed</span><br><span class=\"line\">fdt print  &lt;path&gt; [&lt;prop&gt;]          - Recursive print starting at &lt;path&gt;</span><br><span class=\"line\">fdt list   &lt;path&gt; [&lt;prop&gt;]          - Print one level starting at &lt;path&gt;</span><br><span class=\"line\">fdt get value &lt;var&gt; &lt;path&gt; &lt;prop&gt;   - Get &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get name &lt;var&gt; &lt;path&gt; &lt;index&gt;   - Get name of node &lt;index&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get addr &lt;var&gt; &lt;path&gt; &lt;prop&gt;    - Get start address of &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get size &lt;var&gt; &lt;path&gt; [&lt;prop&gt;]  - Get size of [&lt;property&gt;] or num nodes and store in &lt;var&gt;</span><br><span class=\"line\">fdt set    &lt;path&gt; &lt;prop&gt; [&lt;val&gt;]    - Set &lt;property&gt; [to &lt;val&gt;]</span><br><span class=\"line\">fdt mknode &lt;path&gt; &lt;node&gt;            - Create a new node after &lt;path&gt;</span><br><span class=\"line\">fdt rm     &lt;path&gt; [&lt;prop&gt;]          - Delete the node or &lt;property&gt;</span><br><span class=\"line\">fdt header                          - Display header info</span><br><span class=\"line\">fdt bootcpu &lt;id&gt;                    - Set boot cpuid</span><br><span class=\"line\">fdt memory &lt;addr&gt; &lt;size&gt;            - Add/Update memory node</span><br><span class=\"line\">fdt rsvmem print                    - Show current mem reserves</span><br><span class=\"line\">fdt rsvmem add &lt;addr&gt; &lt;size&gt;        - Add a mem reserve</span><br><span class=\"line\">fdt rsvmem delete &lt;index&gt;           - Delete a mem reserves</span><br><span class=\"line\">fdt chosen [&lt;start&gt; &lt;end&gt;]          - Add/update the /chosen branch in the tree</span><br><span class=\"line\">                                        &lt;start&gt;/&lt;end&gt; - initrd start/end addr</span><br><span class=\"line\">NOTE: Dereference aliases by omitting the leading &#x27;/&#x27;, e.g. fdt print ethernet0.</span><br></pre></td></tr></table></figure>\n\n<p>fdt print加path参数，则打path内容，如下(其中&#x2F;memory是path)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">U-Boot&gt; fdt print /memory</span><br><span class=\"line\">memory &#123;</span><br><span class=\"line\">device_type = <span class=\"string\">&quot;memory&quot;</span>;</span><br><span class=\"line\">reg = &lt;<span class=\"number\">0x70000000</span> <span class=\"number\">0x4000000</span>&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot&gt; fdt print #不加参数时，打印出整颗树</span><br></pre></td></tr></table></figure>\n\n\n\n<p>二、u-boot 获取GPT分区表</p>\n<p>在uboot中通过命令打印分区表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">part list mmc 0</span><br></pre></td></tr></table></figure>\n\n<p>3588-android-uboot</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;common.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;command.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;android_image.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mmc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memalign.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fdtdec.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PART_MAX_COUNT  128</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tLAB_SIZE\t\t512</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tHEADER_OFFSET\tLAB_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tENTRY_OFFSET\t(2 * LAB_SIZE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL1_OFFSET\t\tsizeof(u64)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL2_OFFSET\t\t(2 * sizeof(u64))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">get_gpt_blk_cnt_and_print</span><span class=\"params\">(<span class=\"keyword\">struct</span> blk_desc *dev_desc,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> efi_str[PARTNAME_SZ + <span class=\"number\">1</span>];</span><br><span class=\"line\">\tu64 gpt_part_size, gpt_blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tgpt_entry *gpt_e;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_e = *gpt_pte;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; gpt_head-&gt;num_partition_entries; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,</span><br><span class=\"line\">\t\t\t\t\t     PARTNAME_SZ + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s: part: %2d name - GPT: %16s &quot;</span>,</span><br><span class=\"line\">\t\t      __func__, i, efi_str);</span><br><span class=\"line\">\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -</span><br><span class=\"line\">\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tgpt_blk_cnt += gpt_part_size;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(gpt_part_size == <span class=\"number\">1</span>) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size(LBA) - GPT: %8llu &quot;</span>,</span><br><span class=\"line\">\t\t      (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)gpt_part_size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start LBA - GPT: %8llu \\n&quot;</span>,</span><br><span class=\"line\">\t\t      le64_to_cpu(gpt_e[i].starting_lba));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gpt_blk_cnt + gpt_e[<span class=\"number\">0</span>].starting_lba - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">get_gpt_meta_data</span><span class=\"params\">(u64 *data_size, <span class=\"type\">void</span> **data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gpt_header *pgpt_head;</span><br><span class=\"line\">\tgpt_entry *entries;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *meta_data;</span><br><span class=\"line\">\tu64 meta_data_size, gpt_entries_size;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_desc</span> *<span class=\"title\">dev_desc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mmc</span> *<span class=\"title\">mmc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tu64 blk_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 tag = <span class=\"number\">0x55AA</span>;</span><br><span class=\"line\">\t<span class=\"type\">lbaint_t</span> lba;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!data_size || !data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Invalid Argument(s) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mmc = do_returnmmc();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!mmc)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> CMD_RET_FAILURE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    dev_desc = mmc_get_blk_desc(mmc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!dev_desc) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: mmc_get_blk_desc err ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_entries_size = <span class=\"keyword\">sizeof</span>(gpt_entry) * PART_MAX_COUNT;</span><br><span class=\"line\">\tmeta_data_size = LAB_SIZE + <span class=\"keyword\">sizeof</span>(gpt_header) + gpt_entries_size;</span><br><span class=\"line\">\tmeta_data = <span class=\"built_in\">malloc</span>(meta_data_size);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!meta_data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: malloc memory (gpt meta data) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(meta_data, <span class=\"number\">0</span>, meta_data_size);</span><br><span class=\"line\">\tpgpt_head = (gpt_header *)((<span class=\"type\">char</span> *)meta_data + HEADER_OFFSET);</span><br><span class=\"line\">\tentries = (gpt_entry *)((<span class=\"type\">char</span> *)meta_data + ENTRY_OFFSET);</span><br><span class=\"line\">\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc-&gt;blksz);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read MBR Header from device */</span></span><br><span class=\"line\">\tlba = <span class=\"number\">0</span>; <span class=\"comment\">/* MBR is always at 0 */</span></span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* MBR (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*** ERROR: Can&#x27;t read MBR header ***\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Header from device */</span></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* GPT Header (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Can&#x27;t read GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (validate_gpt_header(pgpt_head, lba, dev_desc-&gt;lba)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: validate_gpt_header GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dev_desc-&gt;sig_type == SIG_TYPE_NONE) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">efi_guid_t</span> empty = &#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">memcmp</span>(&amp;pgpt_head-&gt;disk_guid, &amp;empty, <span class=\"keyword\">sizeof</span>(empty))) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_GUID;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(&amp;dev_desc-&gt;guid_sig, &amp;pgpt_head-&gt;disk_guid,</span><br><span class=\"line\">\t\t\t      <span class=\"keyword\">sizeof</span>(empty));</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mbr-&gt;unique_mbr_signature != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_MBR;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;mbr_sig = mbr-&gt;unique_mbr_signature;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Entries from device */</span></span><br><span class=\"line\">\tlba = le64_to_cpu(pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head-&gt;num_partition_entries) *</span><br><span class=\"line\">\t\t\t\t   \tle32_to_cpu(pgpt_head-&gt;sizeof_partition_entry)),</span><br><span class=\"line\">\t\t\t\t  \tdev_desc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR:read entries (lba=%llu) ***\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_size = dev_desc-&gt;blksz;</span><br><span class=\"line\">\tvalidate_gpt_entries(pgpt_head, entries);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdebug(<span class=\"string\">&quot;%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)(ulong)lba, blk_cnt, blk_size);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">\t * build info, layout of meta_data:</span></span><br><span class=\"line\"><span class=\"comment\">\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">\t<span class=\"comment\">/*this value makes we known the reserved memory is available*/</span></span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data, (<span class=\"type\">void</span> *)&amp;tag, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL1_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_size, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL2_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_cnt, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data_size = meta_data_size;</span><br><span class=\"line\">\t*data = meta_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR_OUT:</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(meta_data);</span><br><span class=\"line\">\tmeta_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参考：</p>\n<p><a href=\"http://www.wowotech.net/device_model/dt-code-file-struct-parse.html\">Device Tree（四）：文件结构解析 (wowotech.net)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376295326\">Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376296222\">Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/solo666/p/16518154.html\">https://www.cnblogs.com/solo666/p/16518154.html</a></p>\n"},{"_content":"https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\n\n磁盘上的哪些结构存储文件系统的数据和元数据？\n\n当一个进程打开一个文件时会发生什么？\n\n在读取或写入期间访问哪些磁盘结构？","source":"back_posts/OSTEP-40-文件系统实现.md","raw":"https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\n\n磁盘上的哪些结构存储文件系统的数据和元数据？\n\n当一个进程打开一个文件时会发生什么？\n\n在读取或写入期间访问哪些磁盘结构？","date":"2024-05-15T06:11:08.982Z","updated":"2024-05-15T06:11:08.982Z","path":"back_posts/OSTEP-40-文件系统实现.html","title":"","comments":1,"layout":"page","_id":"clw7fflkt000bx2w0bmaie0nz","content":"<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf</a></p>\n<p>磁盘上的哪些结构存储文件系统的数据和元数据？</p>\n<p>当一个进程打开一个文件时会发生什么？</p>\n<p>在读取或写入期间访问哪些磁盘结构？</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf</a></p>\n<p>磁盘上的哪些结构存储文件系统的数据和元数据？</p>\n<p>当一个进程打开一个文件时会发生什么？</p>\n<p>在读取或写入期间访问哪些磁盘结构？</p>\n"},{"title":"Hexo在多台电脑上提交和更新","date":"2023-09-13T07:35:30.000Z","categories":["test"],"tags":["test"],"_content":"\n[toc]\n\n\n\n# 1.博客搭建\n\nhttps://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\n\n# 2.创建一个新文件夹new，用于上传hexo博客目录\n\n将以下目录（除了红色方框的目录）拷贝到新目录中\n\n![image-20230913154437526](../imgs/image-20230913154437526.png)\n\n参考：https://blog.csdn.net/K1052176873/article/details/122879462 \n\n# 3.github上创建hexo分支并设置为默认分支\n\n## 创建hexo分支\n\n![image-20230913154510439](../imgs/image-20230913154510439.png)\n\n## 将hexo分支设置为默认分支\n\n![image-20230913154524492](../imgs/image-20230913154524492.png)\n\n# 4.进入新建的文件夹中git clone，再上传相关文件至hexo分支\n\n基本原理：github仓库开两个分支，main分支存放的是hexo生成的静态页面，hexo分支存放基本的 Hexo 博客项目的结构和默认配置文件，如文章，主题\n当需要重新搭建环境时，直接拉取hexo分支中Hexo博客目录以及相关配置文件，当需要更新博客时直接\n\n```\ncd new\ngit clone git@github.com:<username>/<username>.github.io.git #<username> 用户名\ngit branch    #查看分支，显示 * hexo\n```\n\n\n\n## 1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\n\n```\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n```\n\n## 2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录\n\n![image-20230913154559571](../imgs/image-20230913154559571.png)\n\n## 3.送new目录中的相关文件到远程仓库 hexo分支\n\n```\ngit add .\ngit commit –m add_branch\ngit push        \n\n```\n\n\n\n# 5.！新环境中快速搭建博客环境！\n\n## 1.设置ssh\n\n参考：https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\n\n```\nssh-keygen -t ed25519 -C \"your_email@gmail.com\"\ncat ~/.ssh/id_ed25519.pub  #将里面的内容复制到 github ->settings ->SSH and GPC keys ->SSH keys ->New SSH key中\nssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）\n#接着在本地绑定与Github的用户名和邮箱（git）\ngit config --global user.name \"<username>\"    #自己的用户名\ngit config --global user.email 'xxx@xxx.com'  #自己的邮箱\n```\n\n## 2.安装nodejs和hexo\n\n```\nsudo apt update\nsudo apt-get install git\n\nsudo apt install nodejs\nsudo apt install npm  \n```\n\n## 3.拉取hexo博客目录\n\n```\ngit clone git@github.com:<username>/<username>.github.io.git #<username> 用户名\ngit branch    #查看分支，显示 * hexo\nnpm install hexo\nnpm install\nnpm install hexo-deployer-git        #不需要hexo init这条指令\nnpm i hexo-renderer-marked\n\n\n#更新博客 添加新文章 hello-world\nhexo new \"hello-world\"\ngit add .        #将文章备份至 hexo分支  或者git add source/_posts/hello-world \ngit commit –m \"hello-world\"\ngit push         #或者git push origin hexo\n\nhexo g        #生成静态页面\nhexo s        #启动本地服务器 预览\nhexo d        #将生成的博客文件部署到 github main分支，Hexo博客项目配置文件中_config.yml已设置好\n```\n\n# 6.遇到的问题\n\n## 问题1.nodejs版本过低\n\nnpm WARN notsup Unsupported engine for hexo@6.3.0: wanted: {\"node\":\">=12.13.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo@6.3.0\nnpm WARN notsup Unsupported engine for hexo-front-matter@3.0.0: wanted: {\"node\":\">=12.13.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-front-matter@3.0.0\nnpm WARN notsup Unsupported engine for hexo-cli@4.3.1: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-cli@4.3.1\nnpm WARN notsup Unsupported engine for hexo-log@3.2.0: wanted: {\"node\":\">=12.4.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-log@3.2.0\nnpm WARN notsup Unsupported engine for abbrev@2.0.0: wanted: {\"node\":\"^14.17.0 || ^16.13.0 || >=18.0.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: abbrev@2.0.0\nnpm WARN notsup Unsupported engine for hexo-fs@4.1.1: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-fs@4.1.1\nnpm WARN notsup Unsupported engine for hexo-log@4.1.0: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-log@4.1.0\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.3 (node_modules/fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\n\n## 升级nodejs\n\n```\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash         #安装 nvm\nsource ~/.bashrc            #加载 nvm\nnvm install node            #使用 nvm 安装最新版本的 Node.js\nnode -v                     #验证 Node.js 版本\n```\n\n\n\n\n\n## 问题2.hexo博客图片不显示\n\nhttps://blog.csdn.net/QRLYLETITBE/article/details/127737904 \n\n```\nnpm i hexo-renderer-marked\n\n```\n\n## 新建imgs文件夹\n\n![image-20230913161638961](../imgs/image-20230913161638961.png)\n\n```\nmarked:\n  prependRoot: true\n  postAsset: true\n\n```\n## 修改图片路径\n\n![image-20230913161842174](../imgs/image-20230913161842174.png)\n","source":"back_posts/Hexo在多台电脑上提交和更新.md","raw":"---\ntitle: Hexo在多台电脑上提交和更新\ndate: 2023-09-13 15:35:30\ncategories:\n- test\ntags:\n- test\n---\n\n[toc]\n\n\n\n# 1.博客搭建\n\nhttps://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\n\n# 2.创建一个新文件夹new，用于上传hexo博客目录\n\n将以下目录（除了红色方框的目录）拷贝到新目录中\n\n![image-20230913154437526](../imgs/image-20230913154437526.png)\n\n参考：https://blog.csdn.net/K1052176873/article/details/122879462 \n\n# 3.github上创建hexo分支并设置为默认分支\n\n## 创建hexo分支\n\n![image-20230913154510439](../imgs/image-20230913154510439.png)\n\n## 将hexo分支设置为默认分支\n\n![image-20230913154524492](../imgs/image-20230913154524492.png)\n\n# 4.进入新建的文件夹中git clone，再上传相关文件至hexo分支\n\n基本原理：github仓库开两个分支，main分支存放的是hexo生成的静态页面，hexo分支存放基本的 Hexo 博客项目的结构和默认配置文件，如文章，主题\n当需要重新搭建环境时，直接拉取hexo分支中Hexo博客目录以及相关配置文件，当需要更新博客时直接\n\n```\ncd new\ngit clone git@github.com:<username>/<username>.github.io.git #<username> 用户名\ngit branch    #查看分支，显示 * hexo\n```\n\n\n\n## 1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\n\n```\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n```\n\n## 2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录\n\n![image-20230913154559571](../imgs/image-20230913154559571.png)\n\n## 3.送new目录中的相关文件到远程仓库 hexo分支\n\n```\ngit add .\ngit commit –m add_branch\ngit push        \n\n```\n\n\n\n# 5.！新环境中快速搭建博客环境！\n\n## 1.设置ssh\n\n参考：https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\n\n```\nssh-keygen -t ed25519 -C \"your_email@gmail.com\"\ncat ~/.ssh/id_ed25519.pub  #将里面的内容复制到 github ->settings ->SSH and GPC keys ->SSH keys ->New SSH key中\nssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）\n#接着在本地绑定与Github的用户名和邮箱（git）\ngit config --global user.name \"<username>\"    #自己的用户名\ngit config --global user.email 'xxx@xxx.com'  #自己的邮箱\n```\n\n## 2.安装nodejs和hexo\n\n```\nsudo apt update\nsudo apt-get install git\n\nsudo apt install nodejs\nsudo apt install npm  \n```\n\n## 3.拉取hexo博客目录\n\n```\ngit clone git@github.com:<username>/<username>.github.io.git #<username> 用户名\ngit branch    #查看分支，显示 * hexo\nnpm install hexo\nnpm install\nnpm install hexo-deployer-git        #不需要hexo init这条指令\nnpm i hexo-renderer-marked\n\n\n#更新博客 添加新文章 hello-world\nhexo new \"hello-world\"\ngit add .        #将文章备份至 hexo分支  或者git add source/_posts/hello-world \ngit commit –m \"hello-world\"\ngit push         #或者git push origin hexo\n\nhexo g        #生成静态页面\nhexo s        #启动本地服务器 预览\nhexo d        #将生成的博客文件部署到 github main分支，Hexo博客项目配置文件中_config.yml已设置好\n```\n\n# 6.遇到的问题\n\n## 问题1.nodejs版本过低\n\nnpm WARN notsup Unsupported engine for hexo@6.3.0: wanted: {\"node\":\">=12.13.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo@6.3.0\nnpm WARN notsup Unsupported engine for hexo-front-matter@3.0.0: wanted: {\"node\":\">=12.13.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-front-matter@3.0.0\nnpm WARN notsup Unsupported engine for hexo-cli@4.3.1: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-cli@4.3.1\nnpm WARN notsup Unsupported engine for hexo-log@3.2.0: wanted: {\"node\":\">=12.4.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-log@3.2.0\nnpm WARN notsup Unsupported engine for abbrev@2.0.0: wanted: {\"node\":\"^14.17.0 || ^16.13.0 || >=18.0.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: abbrev@2.0.0\nnpm WARN notsup Unsupported engine for hexo-fs@4.1.1: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-fs@4.1.1\nnpm WARN notsup Unsupported engine for hexo-log@4.1.0: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-log@4.1.0\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.3 (node_modules/fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\n\n## 升级nodejs\n\n```\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash         #安装 nvm\nsource ~/.bashrc            #加载 nvm\nnvm install node            #使用 nvm 安装最新版本的 Node.js\nnode -v                     #验证 Node.js 版本\n```\n\n\n\n\n\n## 问题2.hexo博客图片不显示\n\nhttps://blog.csdn.net/QRLYLETITBE/article/details/127737904 \n\n```\nnpm i hexo-renderer-marked\n\n```\n\n## 新建imgs文件夹\n\n![image-20230913161638961](../imgs/image-20230913161638961.png)\n\n```\nmarked:\n  prependRoot: true\n  postAsset: true\n\n```\n## 修改图片路径\n\n![image-20230913161842174](../imgs/image-20230913161842174.png)\n","updated":"2024-05-15T06:11:08.981Z","path":"back_posts/Hexo在多台电脑上提交和更新.html","comments":1,"layout":"page","_id":"clw7fflku000cx2w08gypa6ej","content":"<p>[toc]</p>\n<h1 id=\"1-博客搭建\"><a href=\"#1-博客搭建\" class=\"headerlink\" title=\"1.博客搭建\"></a>1.博客搭建</h1><p><a href=\"https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\">https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</a></p>\n<h1 id=\"2-创建一个新文件夹new，用于上传hexo博客目录\"><a href=\"#2-创建一个新文件夹new，用于上传hexo博客目录\" class=\"headerlink\" title=\"2.创建一个新文件夹new，用于上传hexo博客目录\"></a>2.创建一个新文件夹new，用于上传hexo博客目录</h1><p>将以下目录（除了红色方框的目录）拷贝到新目录中</p>\n<p><img src=\"/../imgs/image-20230913154437526.png\" alt=\"image-20230913154437526\"></p>\n<p>参考：<a href=\"https://blog.csdn.net/K1052176873/article/details/122879462\">https://blog.csdn.net/K1052176873/article/details/122879462</a> </p>\n<h1 id=\"3-github上创建hexo分支并设置为默认分支\"><a href=\"#3-github上创建hexo分支并设置为默认分支\" class=\"headerlink\" title=\"3.github上创建hexo分支并设置为默认分支\"></a>3.github上创建hexo分支并设置为默认分支</h1><h2 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h2><p><img src=\"/../imgs/image-20230913154510439.png\" alt=\"image-20230913154510439\"></p>\n<h2 id=\"将hexo分支设置为默认分支\"><a href=\"#将hexo分支设置为默认分支\" class=\"headerlink\" title=\"将hexo分支设置为默认分支\"></a>将hexo分支设置为默认分支</h2><p><img src=\"/../imgs/image-20230913154524492.png\" alt=\"image-20230913154524492\"></p>\n<h1 id=\"4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支\"><a href=\"#4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支\" class=\"headerlink\" title=\"4.进入新建的文件夹中git clone，再上传相关文件至hexo分支\"></a>4.进入新建的文件夹中git clone，再上传相关文件至hexo分支</h1><p>基本原理：github仓库开两个分支，main分支存放的是hexo生成的静态页面，hexo分支存放基本的 Hexo 博客项目的结构和默认配置文件，如文章，主题<br>当需要重新搭建环境时，直接拉取hexo分支中Hexo博客目录以及相关配置文件，当需要更新博客时直接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd new</span><br><span class=\"line\">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class=\"line\">git branch    #查看分支，显示 * hexo</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\"><a href=\"#1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\" class=\"headerlink\" title=\"1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\"></a>1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json</span><br><span class=\"line\">*.log</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">public/</span><br><span class=\"line\">.deploy*/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录\"><a href=\"#2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录\" class=\"headerlink\" title=\"2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录\"></a>2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录</h2><p><img src=\"/../imgs/image-20230913154559571.png\" alt=\"image-20230913154559571\"></p>\n<h2 id=\"3-送new目录中的相关文件到远程仓库-hexo分支\"><a href=\"#3-送new目录中的相关文件到远程仓库-hexo分支\" class=\"headerlink\" title=\"3.送new目录中的相关文件到远程仓库 hexo分支\"></a>3.送new目录中的相关文件到远程仓库 hexo分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit –m add_branch</span><br><span class=\"line\">git push        </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"5-！新环境中快速搭建博客环境！\"><a href=\"#5-！新环境中快速搭建博客环境！\" class=\"headerlink\" title=\"5.！新环境中快速搭建博客环境！\"></a>5.！新环境中快速搭建博客环境！</h1><h2 id=\"1-设置ssh\"><a href=\"#1-设置ssh\" class=\"headerlink\" title=\"1.设置ssh\"></a>1.设置ssh</h2><p>参考：<a href=\"https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t ed25519 -C &quot;your_email@gmail.com&quot;</span><br><span class=\"line\">cat ~/.ssh/id_ed25519.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class=\"line\">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class=\"line\">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class=\"line\">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class=\"line\">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装nodejs和hexo\"><a href=\"#2-安装nodejs和hexo\" class=\"headerlink\" title=\"2.安装nodejs和hexo\"></a>2.安装nodejs和hexo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install git</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-拉取hexo博客目录\"><a href=\"#3-拉取hexo博客目录\" class=\"headerlink\" title=\"3.拉取hexo博客目录\"></a>3.拉取hexo博客目录</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class=\"line\">git branch    #查看分支，显示 * hexo</span><br><span class=\"line\">npm install hexo</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm install hexo-deployer-git        #不需要hexo init这条指令</span><br><span class=\"line\">npm i hexo-renderer-marked</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#更新博客 添加新文章 hello-world</span><br><span class=\"line\">hexo new &quot;hello-world&quot;</span><br><span class=\"line\">git add .        #将文章备份至 hexo分支  或者git add source/_posts/hello-world </span><br><span class=\"line\">git commit –m &quot;hello-world&quot;</span><br><span class=\"line\">git push         #或者git push origin hexo</span><br><span class=\"line\"></span><br><span class=\"line\">hexo g        #生成静态页面</span><br><span class=\"line\">hexo s        #启动本地服务器 预览</span><br><span class=\"line\">hexo d        #将生成的博客文件部署到 github main分支，Hexo博客项目配置文件中_config.yml已设置好</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-遇到的问题\"><a href=\"#6-遇到的问题\" class=\"headerlink\" title=\"6.遇到的问题\"></a>6.遇到的问题</h1><h2 id=\"问题1-nodejs版本过低\"><a href=\"#问题1-nodejs版本过低\" class=\"headerlink\" title=\"问题1.nodejs版本过低\"></a>问题1.nodejs版本过低</h2><p>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#x78;&#x6f;&#64;&#x36;&#46;&#51;&#x2e;&#48;\">&#x68;&#x65;&#x78;&#x6f;&#64;&#x36;&#46;&#51;&#x2e;&#48;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#101;&#x78;&#x6f;&#x40;&#54;&#46;&#x33;&#x2e;&#x30;\">&#x68;&#101;&#x78;&#x6f;&#x40;&#54;&#46;&#x33;&#x2e;&#x30;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#101;&#120;&#111;&#45;&#102;&#114;&#111;&#x6e;&#116;&#x2d;&#109;&#x61;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#x30;&#46;&#x30;\">&#x68;&#101;&#120;&#111;&#45;&#102;&#114;&#111;&#x6e;&#116;&#x2d;&#109;&#x61;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#x30;&#46;&#x30;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#x65;&#120;&#111;&#x2d;&#x66;&#114;&#x6f;&#x6e;&#x74;&#x2d;&#109;&#97;&#116;&#x74;&#101;&#114;&#x40;&#x33;&#x2e;&#x30;&#x2e;&#x30;\">&#x68;&#x65;&#120;&#111;&#x2d;&#x66;&#114;&#x6f;&#x6e;&#x74;&#x2d;&#109;&#97;&#116;&#x74;&#101;&#114;&#x40;&#x33;&#x2e;&#x30;&#x2e;&#x30;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#x65;&#120;&#x6f;&#45;&#99;&#108;&#105;&#x40;&#52;&#x2e;&#51;&#x2e;&#x31;\">&#104;&#x65;&#120;&#x6f;&#45;&#99;&#108;&#105;&#x40;&#52;&#x2e;&#51;&#x2e;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#x65;&#x78;&#x6f;&#45;&#99;&#x6c;&#x69;&#x40;&#x34;&#x2e;&#51;&#x2e;&#x31;\">&#x68;&#x65;&#x78;&#x6f;&#45;&#99;&#x6c;&#x69;&#x40;&#x34;&#x2e;&#51;&#x2e;&#x31;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#120;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#x40;&#x33;&#46;&#x32;&#46;&#48;\">&#x68;&#x65;&#120;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#x40;&#x33;&#46;&#x32;&#46;&#48;</a>: wanted: {“node”:”&gt;&#x3D;12.4.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#x65;&#x78;&#111;&#x2d;&#108;&#111;&#103;&#x40;&#x33;&#x2e;&#x32;&#46;&#x30;\">&#104;&#x65;&#x78;&#111;&#x2d;&#108;&#111;&#103;&#x40;&#x33;&#x2e;&#x32;&#46;&#x30;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x61;&#x62;&#x62;&#114;&#101;&#118;&#64;&#50;&#x2e;&#x30;&#46;&#x30;\">&#x61;&#x62;&#x62;&#114;&#101;&#118;&#64;&#50;&#x2e;&#x30;&#46;&#x30;</a>: wanted: {“node”:”^14.17.0 || ^16.13.0 || &gt;&#x3D;18.0.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#97;&#98;&#x62;&#114;&#101;&#x76;&#x40;&#50;&#46;&#x30;&#46;&#48;\">&#97;&#98;&#x62;&#114;&#101;&#x76;&#x40;&#50;&#46;&#x30;&#46;&#48;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#101;&#120;&#x6f;&#45;&#x66;&#x73;&#x40;&#x34;&#x2e;&#x31;&#x2e;&#x31;\">&#104;&#101;&#120;&#x6f;&#45;&#x66;&#x73;&#x40;&#x34;&#x2e;&#x31;&#x2e;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#101;&#x78;&#111;&#x2d;&#102;&#x73;&#64;&#x34;&#46;&#49;&#46;&#49;\">&#x68;&#101;&#x78;&#111;&#x2d;&#102;&#x73;&#64;&#x34;&#46;&#49;&#46;&#49;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#x78;&#111;&#x2d;&#108;&#x6f;&#x67;&#64;&#52;&#46;&#x31;&#46;&#48;\">&#x68;&#x65;&#x78;&#111;&#x2d;&#108;&#x6f;&#x67;&#64;&#52;&#46;&#x31;&#46;&#48;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#x65;&#120;&#111;&#x2d;&#x6c;&#111;&#103;&#x40;&#52;&#46;&#x31;&#x2e;&#48;\">&#104;&#x65;&#120;&#111;&#x2d;&#x6c;&#111;&#103;&#x40;&#52;&#46;&#x31;&#x2e;&#48;</a><br>npm WARN optional SKIPPING OPTIONAL DEPENDENCY: <a href=\"mailto:&#102;&#x73;&#x65;&#118;&#x65;&#x6e;&#x74;&#x73;&#64;&#x32;&#x2e;&#51;&#46;&#x33;\">&#102;&#x73;&#x65;&#118;&#x65;&#x6e;&#x74;&#x73;&#64;&#x32;&#x2e;&#51;&#46;&#x33;</a> (node_modules&#x2F;fsevents):<br>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href=\"mailto:&#102;&#x73;&#101;&#118;&#101;&#x6e;&#x74;&#115;&#x40;&#x32;&#46;&#51;&#x2e;&#51;\">&#102;&#x73;&#101;&#118;&#101;&#x6e;&#x74;&#115;&#x40;&#x32;&#46;&#51;&#x2e;&#51;</a>: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”linux”,”arch”:”x64”})</p>\n<h2 id=\"升级nodejs\"><a href=\"#升级nodejs\" class=\"headerlink\" title=\"升级nodejs\"></a>升级nodejs</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash         #安装 nvm</span><br><span class=\"line\">source ~/.bashrc            #加载 nvm</span><br><span class=\"line\">nvm install node            #使用 nvm 安装最新版本的 Node.js</span><br><span class=\"line\">node -v                     #验证 Node.js 版本</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"问题2-hexo博客图片不显示\"><a href=\"#问题2-hexo博客图片不显示\" class=\"headerlink\" title=\"问题2.hexo博客图片不显示\"></a>问题2.hexo博客图片不显示</h2><p><a href=\"https://blog.csdn.net/QRLYLETITBE/article/details/127737904\">https://blog.csdn.net/QRLYLETITBE/article/details/127737904</a> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-marked</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"新建imgs文件夹\"><a href=\"#新建imgs文件夹\" class=\"headerlink\" title=\"新建imgs文件夹\"></a>新建imgs文件夹</h2><p><img src=\"/../imgs/image-20230913161638961.png\" alt=\"image-20230913161638961\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"修改图片路径\"><a href=\"#修改图片路径\" class=\"headerlink\" title=\"修改图片路径\"></a>修改图片路径</h2><p><img src=\"/../imgs/image-20230913161842174.png\" alt=\"image-20230913161842174\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"1-博客搭建\"><a href=\"#1-博客搭建\" class=\"headerlink\" title=\"1.博客搭建\"></a>1.博客搭建</h1><p><a href=\"https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\">https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</a></p>\n<h1 id=\"2-创建一个新文件夹new，用于上传hexo博客目录\"><a href=\"#2-创建一个新文件夹new，用于上传hexo博客目录\" class=\"headerlink\" title=\"2.创建一个新文件夹new，用于上传hexo博客目录\"></a>2.创建一个新文件夹new，用于上传hexo博客目录</h1><p>将以下目录（除了红色方框的目录）拷贝到新目录中</p>\n<p><img src=\"/../imgs/image-20230913154437526.png\" alt=\"image-20230913154437526\"></p>\n<p>参考：<a href=\"https://blog.csdn.net/K1052176873/article/details/122879462\">https://blog.csdn.net/K1052176873/article/details/122879462</a> </p>\n<h1 id=\"3-github上创建hexo分支并设置为默认分支\"><a href=\"#3-github上创建hexo分支并设置为默认分支\" class=\"headerlink\" title=\"3.github上创建hexo分支并设置为默认分支\"></a>3.github上创建hexo分支并设置为默认分支</h1><h2 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h2><p><img src=\"/../imgs/image-20230913154510439.png\" alt=\"image-20230913154510439\"></p>\n<h2 id=\"将hexo分支设置为默认分支\"><a href=\"#将hexo分支设置为默认分支\" class=\"headerlink\" title=\"将hexo分支设置为默认分支\"></a>将hexo分支设置为默认分支</h2><p><img src=\"/../imgs/image-20230913154524492.png\" alt=\"image-20230913154524492\"></p>\n<h1 id=\"4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支\"><a href=\"#4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支\" class=\"headerlink\" title=\"4.进入新建的文件夹中git clone，再上传相关文件至hexo分支\"></a>4.进入新建的文件夹中git clone，再上传相关文件至hexo分支</h1><p>基本原理：github仓库开两个分支，main分支存放的是hexo生成的静态页面，hexo分支存放基本的 Hexo 博客项目的结构和默认配置文件，如文章，主题<br>当需要重新搭建环境时，直接拉取hexo分支中Hexo博客目录以及相关配置文件，当需要更新博客时直接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd new</span><br><span class=\"line\">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class=\"line\">git branch    #查看分支，显示 * hexo</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\"><a href=\"#1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\" class=\"headerlink\" title=\"1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\"></a>1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json</span><br><span class=\"line\">*.log</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">public/</span><br><span class=\"line\">.deploy*/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录\"><a href=\"#2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录\" class=\"headerlink\" title=\"2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录\"></a>2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录</h2><p><img src=\"/../imgs/image-20230913154559571.png\" alt=\"image-20230913154559571\"></p>\n<h2 id=\"3-送new目录中的相关文件到远程仓库-hexo分支\"><a href=\"#3-送new目录中的相关文件到远程仓库-hexo分支\" class=\"headerlink\" title=\"3.送new目录中的相关文件到远程仓库 hexo分支\"></a>3.送new目录中的相关文件到远程仓库 hexo分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit –m add_branch</span><br><span class=\"line\">git push        </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"5-！新环境中快速搭建博客环境！\"><a href=\"#5-！新环境中快速搭建博客环境！\" class=\"headerlink\" title=\"5.！新环境中快速搭建博客环境！\"></a>5.！新环境中快速搭建博客环境！</h1><h2 id=\"1-设置ssh\"><a href=\"#1-设置ssh\" class=\"headerlink\" title=\"1.设置ssh\"></a>1.设置ssh</h2><p>参考：<a href=\"https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t ed25519 -C &quot;your_email@gmail.com&quot;</span><br><span class=\"line\">cat ~/.ssh/id_ed25519.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class=\"line\">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class=\"line\">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class=\"line\">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class=\"line\">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装nodejs和hexo\"><a href=\"#2-安装nodejs和hexo\" class=\"headerlink\" title=\"2.安装nodejs和hexo\"></a>2.安装nodejs和hexo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install git</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-拉取hexo博客目录\"><a href=\"#3-拉取hexo博客目录\" class=\"headerlink\" title=\"3.拉取hexo博客目录\"></a>3.拉取hexo博客目录</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class=\"line\">git branch    #查看分支，显示 * hexo</span><br><span class=\"line\">npm install hexo</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm install hexo-deployer-git        #不需要hexo init这条指令</span><br><span class=\"line\">npm i hexo-renderer-marked</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#更新博客 添加新文章 hello-world</span><br><span class=\"line\">hexo new &quot;hello-world&quot;</span><br><span class=\"line\">git add .        #将文章备份至 hexo分支  或者git add source/_posts/hello-world </span><br><span class=\"line\">git commit –m &quot;hello-world&quot;</span><br><span class=\"line\">git push         #或者git push origin hexo</span><br><span class=\"line\"></span><br><span class=\"line\">hexo g        #生成静态页面</span><br><span class=\"line\">hexo s        #启动本地服务器 预览</span><br><span class=\"line\">hexo d        #将生成的博客文件部署到 github main分支，Hexo博客项目配置文件中_config.yml已设置好</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-遇到的问题\"><a href=\"#6-遇到的问题\" class=\"headerlink\" title=\"6.遇到的问题\"></a>6.遇到的问题</h1><h2 id=\"问题1-nodejs版本过低\"><a href=\"#问题1-nodejs版本过低\" class=\"headerlink\" title=\"问题1.nodejs版本过低\"></a>问题1.nodejs版本过低</h2><p>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#x78;&#x6f;&#64;&#x36;&#46;&#51;&#x2e;&#48;\">&#x68;&#x65;&#x78;&#x6f;&#64;&#x36;&#46;&#51;&#x2e;&#48;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#101;&#x78;&#x6f;&#x40;&#54;&#46;&#x33;&#x2e;&#x30;\">&#x68;&#101;&#x78;&#x6f;&#x40;&#54;&#46;&#x33;&#x2e;&#x30;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#101;&#120;&#111;&#45;&#102;&#114;&#111;&#x6e;&#116;&#x2d;&#109;&#x61;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#x30;&#46;&#x30;\">&#x68;&#101;&#120;&#111;&#45;&#102;&#114;&#111;&#x6e;&#116;&#x2d;&#109;&#x61;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#x30;&#46;&#x30;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#x65;&#120;&#111;&#x2d;&#x66;&#114;&#x6f;&#x6e;&#x74;&#x2d;&#109;&#97;&#116;&#x74;&#101;&#114;&#x40;&#x33;&#x2e;&#x30;&#x2e;&#x30;\">&#x68;&#x65;&#120;&#111;&#x2d;&#x66;&#114;&#x6f;&#x6e;&#x74;&#x2d;&#109;&#97;&#116;&#x74;&#101;&#114;&#x40;&#x33;&#x2e;&#x30;&#x2e;&#x30;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#x65;&#120;&#x6f;&#45;&#99;&#108;&#105;&#x40;&#52;&#x2e;&#51;&#x2e;&#x31;\">&#104;&#x65;&#120;&#x6f;&#45;&#99;&#108;&#105;&#x40;&#52;&#x2e;&#51;&#x2e;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#x65;&#x78;&#x6f;&#45;&#99;&#x6c;&#x69;&#x40;&#x34;&#x2e;&#51;&#x2e;&#x31;\">&#x68;&#x65;&#x78;&#x6f;&#45;&#99;&#x6c;&#x69;&#x40;&#x34;&#x2e;&#51;&#x2e;&#x31;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#120;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#x40;&#x33;&#46;&#x32;&#46;&#48;\">&#x68;&#x65;&#120;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#x40;&#x33;&#46;&#x32;&#46;&#48;</a>: wanted: {“node”:”&gt;&#x3D;12.4.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#x65;&#x78;&#111;&#x2d;&#108;&#111;&#103;&#x40;&#x33;&#x2e;&#x32;&#46;&#x30;\">&#104;&#x65;&#x78;&#111;&#x2d;&#108;&#111;&#103;&#x40;&#x33;&#x2e;&#x32;&#46;&#x30;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x61;&#x62;&#x62;&#114;&#101;&#118;&#64;&#50;&#x2e;&#x30;&#46;&#x30;\">&#x61;&#x62;&#x62;&#114;&#101;&#118;&#64;&#50;&#x2e;&#x30;&#46;&#x30;</a>: wanted: {“node”:”^14.17.0 || ^16.13.0 || &gt;&#x3D;18.0.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#97;&#98;&#x62;&#114;&#101;&#x76;&#x40;&#50;&#46;&#x30;&#46;&#48;\">&#97;&#98;&#x62;&#114;&#101;&#x76;&#x40;&#50;&#46;&#x30;&#46;&#48;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#101;&#120;&#x6f;&#45;&#x66;&#x73;&#x40;&#x34;&#x2e;&#x31;&#x2e;&#x31;\">&#104;&#101;&#120;&#x6f;&#45;&#x66;&#x73;&#x40;&#x34;&#x2e;&#x31;&#x2e;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#101;&#x78;&#111;&#x2d;&#102;&#x73;&#64;&#x34;&#46;&#49;&#46;&#49;\">&#x68;&#101;&#x78;&#111;&#x2d;&#102;&#x73;&#64;&#x34;&#46;&#49;&#46;&#49;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#x78;&#111;&#x2d;&#108;&#x6f;&#x67;&#64;&#52;&#46;&#x31;&#46;&#48;\">&#x68;&#x65;&#x78;&#111;&#x2d;&#108;&#x6f;&#x67;&#64;&#52;&#46;&#x31;&#46;&#48;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#x65;&#120;&#111;&#x2d;&#x6c;&#111;&#103;&#x40;&#52;&#46;&#x31;&#x2e;&#48;\">&#104;&#x65;&#120;&#111;&#x2d;&#x6c;&#111;&#103;&#x40;&#52;&#46;&#x31;&#x2e;&#48;</a><br>npm WARN optional SKIPPING OPTIONAL DEPENDENCY: <a href=\"mailto:&#102;&#x73;&#x65;&#118;&#x65;&#x6e;&#x74;&#x73;&#64;&#x32;&#x2e;&#51;&#46;&#x33;\">&#102;&#x73;&#x65;&#118;&#x65;&#x6e;&#x74;&#x73;&#64;&#x32;&#x2e;&#51;&#46;&#x33;</a> (node_modules&#x2F;fsevents):<br>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href=\"mailto:&#102;&#x73;&#101;&#118;&#101;&#x6e;&#x74;&#115;&#x40;&#x32;&#46;&#51;&#x2e;&#51;\">&#102;&#x73;&#101;&#118;&#101;&#x6e;&#x74;&#115;&#x40;&#x32;&#46;&#51;&#x2e;&#51;</a>: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”linux”,”arch”:”x64”})</p>\n<h2 id=\"升级nodejs\"><a href=\"#升级nodejs\" class=\"headerlink\" title=\"升级nodejs\"></a>升级nodejs</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash         #安装 nvm</span><br><span class=\"line\">source ~/.bashrc            #加载 nvm</span><br><span class=\"line\">nvm install node            #使用 nvm 安装最新版本的 Node.js</span><br><span class=\"line\">node -v                     #验证 Node.js 版本</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"问题2-hexo博客图片不显示\"><a href=\"#问题2-hexo博客图片不显示\" class=\"headerlink\" title=\"问题2.hexo博客图片不显示\"></a>问题2.hexo博客图片不显示</h2><p><a href=\"https://blog.csdn.net/QRLYLETITBE/article/details/127737904\">https://blog.csdn.net/QRLYLETITBE/article/details/127737904</a> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-marked</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"新建imgs文件夹\"><a href=\"#新建imgs文件夹\" class=\"headerlink\" title=\"新建imgs文件夹\"></a>新建imgs文件夹</h2><p><img src=\"/../imgs/image-20230913161638961.png\" alt=\"image-20230913161638961\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"修改图片路径\"><a href=\"#修改图片路径\" class=\"headerlink\" title=\"修改图片路径\"></a>修改图片路径</h2><p><img src=\"/../imgs/image-20230913161842174.png\" alt=\"image-20230913161842174\"></p>\n"},{"title":"00-rust学习网站","date":"2023-08-26T08:08:57.000Z","categories":["rust"],"tags":["学习网站","rust"],"_content":"\n\n\n# 相关网站\n\n[GitHub-rust](https://github.com/sunface/rust-course)\n\n[关于本书 - Rust语言圣经(Rust Course)](https://course.rs/about-book.html)\n","source":"back_posts/00-rust学习网站.md","raw":"---\ntitle: 00-rust学习网站\ndate: 2023-08-26 16:08:57\ncategories:\n- rust\ntags:\n- 学习网站\n- rust\n---\n\n\n\n# 相关网站\n\n[GitHub-rust](https://github.com/sunface/rust-course)\n\n[关于本书 - Rust语言圣经(Rust Course)](https://course.rs/about-book.html)\n","updated":"2024-05-15T06:54:20.707Z","path":"back_posts/00-rust学习网站.html","_id":"clw7fflku000dx2w0bwyfbvqe","comments":1,"layout":"page","content":"<h1 id=\"相关网站\"><a href=\"#相关网站\" class=\"headerlink\" title=\"相关网站\"></a>相关网站</h1><p><a href=\"https://github.com/sunface/rust-course\">GitHub-rust</a></p>\n<p><a href=\"https://course.rs/about-book.html\">关于本书 - Rust语言圣经(Rust Course)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"相关网站\"><a href=\"#相关网站\" class=\"headerlink\" title=\"相关网站\"></a>相关网站</h1><p><a href=\"https://github.com/sunface/rust-course\">GitHub-rust</a></p>\n<p><a href=\"https://course.rs/about-book.html\">关于本书 - Rust语言圣经(Rust Course)</a></p>\n"},{"title":"OSTEP-40-VSFS","date":"2024-05-15T06:40:25.000Z","categories":["OSTEP"],"tags":["vsfs"],"_content":"\nhttps://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\n\n磁盘上的哪些结构存储文件系统的数据和元数据？\n\n当一个进程打开一个文件时会发生什么？\n\n在读取或写入期间访问哪些磁盘结构？\n","source":"back_posts/OSTEP-40-VSFS.md","raw":"---\ntitle: OSTEP-40-VSFS\ndate: 2024-05-15 14:40:25\ncategories:\n- OSTEP\ntags:\n- vsfs\n---\n\nhttps://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\n\n磁盘上的哪些结构存储文件系统的数据和元数据？\n\n当一个进程打开一个文件时会发生什么？\n\n在读取或写入期间访问哪些磁盘结构？\n","updated":"2024-05-15T06:54:20.710Z","path":"back_posts/OSTEP-40-VSFS.html","comments":1,"layout":"page","_id":"clw7h6af400007sw0at5heevw","content":"<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf</a></p>\n<p>磁盘上的哪些结构存储文件系统的数据和元数据？</p>\n<p>当一个进程打开一个文件时会发生什么？</p>\n<p>在读取或写入期间访问哪些磁盘结构？</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf</a></p>\n<p>磁盘上的哪些结构存储文件系统的数据和元数据？</p>\n<p>当一个进程打开一个文件时会发生什么？</p>\n<p>在读取或写入期间访问哪些磁盘结构？</p>\n"},{"title":"linux-block","date":"2024-05-15T06:36:36.000Z","categories":["driver"],"tags":["block"],"_content":"\n# 块设备驱动\n\n\n\n块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。\n","source":"back_posts/linux-block.md","raw":"---\ntitle: linux-block\ndate: 2024-05-15 14:36:36\ncategories:\n- driver\ntags:\n- block\n\n---\n\n# 块设备驱动\n\n\n\n块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。\n","updated":"2024-05-15T06:54:20.713Z","path":"back_posts/linux-block.html","comments":1,"layout":"page","_id":"clw7h6af900017sw089z24j7c","content":"<h1 id=\"块设备驱动\"><a href=\"#块设备驱动\" class=\"headerlink\" title=\"块设备驱动\"></a>块设备驱动</h1><p>块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"块设备驱动\"><a href=\"#块设备驱动\" class=\"headerlink\" title=\"块设备驱动\"></a>块设备驱动</h1><p>块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。</p>\n"},{"title":"U-Boot-fdt-GPT","date":"2024-05-15T06:37:05.000Z","categories":["uboot"],"tags":["fdt","GPT","rk3588"],"_content":"\nU-Boot官网:https://docs.u-boot.org/en/latest/\n\nu-boot启动流程\n\n- 板子上电以后，首先执行的是ROM中的一段启动代码。启动代码**根据寄存器/外部管脚配置**，确定是进入下载模式，还是从某介质(Flash/EMMC/SD卡等存储设备)启动u-boot\n\n> ROM中的代码是固化的，无法修改\n\n# 一、介绍\n\n> FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。\n>\n> uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  \n\n> U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc/README.fdt-control\n\n### dtb在U-boot中的位置\n\n- dtb能够以两种形式编译到U-boot的镜像中\n\n1. dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)\n\n> 通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址\n\n1. dtb集成到u-boot的bin文件内部\n\n> 通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb\n\n1. 获取dts文件的地址gd->fdt_blob\n\n```\n// 宏用来表示是否把dtb文件放在uboot.bin的文件中\nCONFIG_OF_EMBED\n\n// 单独编译dtb文件\nCONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址\n\ngd->fdt_blob = (ulong *)&_end;\n\n// 可以通过fdtcontroladdr环境变量来指定fdt的地址\ngd->fdt_blob = (void *)getenv_ulong(\"fdtcontroladdr\", 16,\n\t\t\t\t\t\t(uintptr_t)gd->fdt_blob); \n```\n\n###  dtb解析接口\n\n- 定义在lib/fdtdec.c文件中，节点变量node中存放的是偏移地址\n\n```\n// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点\nint fdt_path_offset(const void *fdt, const char *path)\neg：node = fdt_path_offset(gd->fdt_blob, “/aliases”);\n\n// 获得节点node的某个字符串属性值\nconst void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)\neg： mac = fdt_getprop(gd->fdt_blob, node, “mac-address”, &len);\n\n// 获得节点node的某个整形数组属性值\nint fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)\neg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));\n\n// 获得节点node的地址属性值\nfdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)\neg：fdtdec_get_addr(blob, node, “reg”);\n\n// 获得config节点下的整形属性、bool属性、字符串等等\nfdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string\n\n// 获得chosen下的name节点的偏移\nint fdtdec_get_chosen_node(const void *blob, const char *name)\n\n// 获得chosen下name属性的值\nconst char *fdtdec_get_chosen_prop(const void *blob, const char *name)\n```\n\n- 定义在lib/fdtdec_common.c文件中\n\n```\n// 获得节点node的某个整形属性值\nint fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)\neg： bus->udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);\n\n// 获得节点node的某个无符号整形属性值\nfdtdec_get_uint\n```\n\n## fdt 命令\n\n对于u-boot提供了fdt的相关命令\n\n```\nfdt - flattened device tree utility commands\n\nUsage:\nfdt addr [-c]  <addr> [<length>]   - Set the [control] fdt location to <addr>\nfdt apply <addr>                    - Apply overlay to the DT\nfdt move   <fdt> <newaddr> <length> - Copy the fdt to <addr> and make it active\nfdt resize [<extrasize>]            - Resize fdt to size + padding to 4k addr + some optional <extrasize> if needed\nfdt print  <path> [<prop>]          - Recursive print starting at <path>\nfdt list   <path> [<prop>]          - Print one level starting at <path>\nfdt get value <var> <path> <prop>   - Get <property> and store in <var>\nfdt get name <var> <path> <index>   - Get name of node <index> and store in <var>\nfdt get addr <var> <path> <prop>    - Get start address of <property> and store in <var>\nfdt get size <var> <path> [<prop>]  - Get size of [<property>] or num nodes and store in <var>\nfdt set    <path> <prop> [<val>]    - Set <property> [to <val>]\nfdt mknode <path> <node>            - Create a new node after <path>\nfdt rm     <path> [<prop>]          - Delete the node or <property>\nfdt header                          - Display header info\nfdt bootcpu <id>                    - Set boot cpuid\nfdt memory <addr> <size>            - Add/Update memory node\nfdt rsvmem print                    - Show current mem reserves\nfdt rsvmem add <addr> <size>        - Add a mem reserve\nfdt rsvmem delete <index>           - Delete a mem reserves\nfdt chosen [<start> <end>]          - Add/update the /chosen branch in the tree\n                                        <start>/<end> - initrd start/end addr\nNOTE: Dereference aliases by omitting the leading '/', e.g. fdt print ethernet0.\n```\n\nfdt print加path参数，则打path内容，如下(其中/memory是path)：\n\n```c\nU-Boot> fdt print /memory\nmemory {\ndevice_type = \"memory\";\nreg = <0x70000000 0x4000000>;\n};\n\nU-Boot> fdt print #不加参数时，打印出整颗树\n```\n\n\n\n# 二、u-boot 获取GPT分区表\n\n在uboot中通过命令打印分区表\n\n```\npart list mmc 0\n```\n\n## 3588-android-uboot\n\n```c\n#include <common.h>\n#include <command.h>\n#include <android_image.h>\n#include <mmc.h>\n#include <stdlib.h>\n#include <memalign.h>\n#include <fdtdec.h>\n\n#define PART_MAX_COUNT  128\n#define\tLAB_SIZE\t\t512\n#define\tHEADER_OFFSET\tLAB_SIZE\n#define\tENTRY_OFFSET\t(2 * LAB_SIZE)\n#define\tVAL1_OFFSET\t\tsizeof(u64)\n#define\tVAL2_OFFSET\t\t(2 * sizeof(u64))\n\nstatic u64 get_gpt_blk_cnt_and_print(struct blk_desc *dev_desc,\n\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte) {\n\tchar efi_str[PARTNAME_SZ + 1];\n\tu64 gpt_part_size, gpt_blk_cnt = 0;\n\tgpt_entry *gpt_e;\n\tint i;\n\n\tgpt_e = *gpt_pte;\n\tfor (i = 0; i < gpt_head->num_partition_entries; i++) {\n\n\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,\n\t\t\t\t\t     PARTNAME_SZ + 1);\n\n\t\tprintf(\"%s: part: %2d name - GPT: %16s \",\n\t\t      __func__, i, efi_str);\n\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -\n\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + 1;\n\t\tgpt_blk_cnt += gpt_part_size;\n\t\t\n\t\tif(gpt_part_size == 1) \n\t\t\tbreak;\n\t\t\n\t\tprintf(\"size(LBA) - GPT: %8llu \",\n\t\t      (unsigned long long)gpt_part_size);\n\n\t\tprintf(\"start LBA - GPT: %8llu \\n\",\n\t\t      le64_to_cpu(gpt_e[i].starting_lba));\n\t}\n\n\treturn gpt_blk_cnt + gpt_e[0].starting_lba - 1;\n}\n\nstatic int get_gpt_meta_data(u64 *data_size, void **data)\n{\n    gpt_header *pgpt_head;\n\tgpt_entry *entries;\n\tvoid *meta_data;\n\tu64 meta_data_size, gpt_entries_size;\n\tstruct blk_desc *dev_desc = NULL;\n\tstruct mmc *mmc = NULL;\n\tu64 blk_size = 0;\n\tu64 blk_cnt = 0;\n\tu64 tag = 0x55AA;\n\tlbaint_t lba;\n    \n\tif (!data_size || !data) {\n\t\tprintf(\"%s *** ERROR: Invalid Argument(s) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    mmc = do_returnmmc();\n\tif (!mmc)\n\t\treturn CMD_RET_FAILURE;\n    \n    dev_desc = mmc_get_blk_desc(mmc);\n\tif (!dev_desc) {\n\t\tprintf(\"%s *** ERROR: mmc_get_blk_desc err ***\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tgpt_entries_size = sizeof(gpt_entry) * PART_MAX_COUNT;\n\tmeta_data_size = LAB_SIZE + sizeof(gpt_header) + gpt_entries_size;\n\tmeta_data = malloc(meta_data_size);\n\tif(!meta_data) {\n\t\tprintf(\"%s *** ERROR: malloc memory (gpt meta data) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    memset(meta_data, 0, meta_data_size);\n\tpgpt_head = (gpt_header *)((char *)meta_data + HEADER_OFFSET);\n\tentries = (gpt_entry *)((char *)meta_data + ENTRY_OFFSET);\n\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc->blksz);\n\n\t/* Read MBR Header from device */\n\tlba = 0; /* MBR is always at 0 */\n\tblk_cnt = 1; /* MBR (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != 1) {\n\t\tprintf(\"*** ERROR: Can't read MBR header ***\\n\");\n\t\tgoto ERROR_OUT;\n\t}\n\n\t/* Read GPT Header from device */\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tblk_cnt = 1; /* GPT Header (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != 1) {\n    \tprintf(\"%s *** ERROR: Can't read GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tif (validate_gpt_header(pgpt_head, lba, dev_desc->lba)) {\n\t\tprintf(\"%s *** ERROR: validate_gpt_header GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tif (dev_desc->sig_type == SIG_TYPE_NONE) {\n\t\tefi_guid_t empty = {};\n\t\tif (memcmp(&pgpt_head->disk_guid, &empty, sizeof(empty))) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_GUID;\n\t\t\tmemcpy(&dev_desc->guid_sig, &pgpt_head->disk_guid,\n\t\t\t      sizeof(empty));\n\t\t} else if (mbr->unique_mbr_signature != 0) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_MBR;\n\t\t\tdev_desc->mbr_sig = mbr->unique_mbr_signature;\n\t\t}\n\t}\n\n\t/* Read GPT Entries from device */\n\tlba = le64_to_cpu(pgpt_head->partition_entry_lba);\n\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head->num_partition_entries) *\n\t\t\t\t   \tle32_to_cpu(pgpt_head->sizeof_partition_entry)),\n\t\t\t\t  \tdev_desc);\n\tif (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) {\n\t\tprintf(\"%s *** ERROR:read entries (lba=%llu) ***\\n\",\n\t\t\t\t__func__, pgpt_head->partition_entry_lba);\n\t\tgoto ERROR_OUT;\n\t}\n\t\n\tblk_size = dev_desc->blksz;\n\tvalidate_gpt_entries(pgpt_head, entries);\n\t\n\tdebug(\"%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n\",\n\t\t\t\t__func__, (unsigned long long)(ulong)lba, blk_cnt, blk_size);\n\t\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n    \n    /* \n\t * build info, layout of meta_data:\n\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries\n\t */\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n\t/*this value makes we known the reserved memory is available*/\n\tmemcpy(meta_data, (void *)&tag, sizeof(u64));\n\tmemcpy(meta_data + VAL1_OFFSET, (void *)&blk_size, sizeof(u64));\n\tmemcpy(meta_data + VAL2_OFFSET, (void *)&blk_cnt, sizeof(u64));\n\n\t*data_size = meta_data_size;\n\t*data = meta_data;\n\n\treturn 0;\n\nERROR_OUT:\n\tfree(meta_data);\n\tmeta_data = NULL;\n\treturn -1;\n}\n```\n\n\n\n参考：\n\n[Device Tree（四）：文件结构解析 (wowotech.net)](http://www.wowotech.net/device_model/dt-code-file-struct-parse.html)\n\n[Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376295326)\n\n[Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376296222)\n\nhttps://www.cnblogs.com/solo666/p/16518154.html\n","source":"back_posts/U-Boot-fdt-GPT.md","raw":"---\ntitle: U-Boot-fdt-GPT\ndate: 2024-05-15 14:37:05\ncategories:\n- uboot\ntags:\n- fdt\n- GPT\n- rk3588\n---\n\nU-Boot官网:https://docs.u-boot.org/en/latest/\n\nu-boot启动流程\n\n- 板子上电以后，首先执行的是ROM中的一段启动代码。启动代码**根据寄存器/外部管脚配置**，确定是进入下载模式，还是从某介质(Flash/EMMC/SD卡等存储设备)启动u-boot\n\n> ROM中的代码是固化的，无法修改\n\n# 一、介绍\n\n> FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。\n>\n> uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  \n\n> U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc/README.fdt-control\n\n### dtb在U-boot中的位置\n\n- dtb能够以两种形式编译到U-boot的镜像中\n\n1. dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)\n\n> 通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址\n\n1. dtb集成到u-boot的bin文件内部\n\n> 通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb\n\n1. 获取dts文件的地址gd->fdt_blob\n\n```\n// 宏用来表示是否把dtb文件放在uboot.bin的文件中\nCONFIG_OF_EMBED\n\n// 单独编译dtb文件\nCONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址\n\ngd->fdt_blob = (ulong *)&_end;\n\n// 可以通过fdtcontroladdr环境变量来指定fdt的地址\ngd->fdt_blob = (void *)getenv_ulong(\"fdtcontroladdr\", 16,\n\t\t\t\t\t\t(uintptr_t)gd->fdt_blob); \n```\n\n###  dtb解析接口\n\n- 定义在lib/fdtdec.c文件中，节点变量node中存放的是偏移地址\n\n```\n// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点\nint fdt_path_offset(const void *fdt, const char *path)\neg：node = fdt_path_offset(gd->fdt_blob, “/aliases”);\n\n// 获得节点node的某个字符串属性值\nconst void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)\neg： mac = fdt_getprop(gd->fdt_blob, node, “mac-address”, &len);\n\n// 获得节点node的某个整形数组属性值\nint fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)\neg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));\n\n// 获得节点node的地址属性值\nfdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)\neg：fdtdec_get_addr(blob, node, “reg”);\n\n// 获得config节点下的整形属性、bool属性、字符串等等\nfdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string\n\n// 获得chosen下的name节点的偏移\nint fdtdec_get_chosen_node(const void *blob, const char *name)\n\n// 获得chosen下name属性的值\nconst char *fdtdec_get_chosen_prop(const void *blob, const char *name)\n```\n\n- 定义在lib/fdtdec_common.c文件中\n\n```\n// 获得节点node的某个整形属性值\nint fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)\neg： bus->udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);\n\n// 获得节点node的某个无符号整形属性值\nfdtdec_get_uint\n```\n\n## fdt 命令\n\n对于u-boot提供了fdt的相关命令\n\n```\nfdt - flattened device tree utility commands\n\nUsage:\nfdt addr [-c]  <addr> [<length>]   - Set the [control] fdt location to <addr>\nfdt apply <addr>                    - Apply overlay to the DT\nfdt move   <fdt> <newaddr> <length> - Copy the fdt to <addr> and make it active\nfdt resize [<extrasize>]            - Resize fdt to size + padding to 4k addr + some optional <extrasize> if needed\nfdt print  <path> [<prop>]          - Recursive print starting at <path>\nfdt list   <path> [<prop>]          - Print one level starting at <path>\nfdt get value <var> <path> <prop>   - Get <property> and store in <var>\nfdt get name <var> <path> <index>   - Get name of node <index> and store in <var>\nfdt get addr <var> <path> <prop>    - Get start address of <property> and store in <var>\nfdt get size <var> <path> [<prop>]  - Get size of [<property>] or num nodes and store in <var>\nfdt set    <path> <prop> [<val>]    - Set <property> [to <val>]\nfdt mknode <path> <node>            - Create a new node after <path>\nfdt rm     <path> [<prop>]          - Delete the node or <property>\nfdt header                          - Display header info\nfdt bootcpu <id>                    - Set boot cpuid\nfdt memory <addr> <size>            - Add/Update memory node\nfdt rsvmem print                    - Show current mem reserves\nfdt rsvmem add <addr> <size>        - Add a mem reserve\nfdt rsvmem delete <index>           - Delete a mem reserves\nfdt chosen [<start> <end>]          - Add/update the /chosen branch in the tree\n                                        <start>/<end> - initrd start/end addr\nNOTE: Dereference aliases by omitting the leading '/', e.g. fdt print ethernet0.\n```\n\nfdt print加path参数，则打path内容，如下(其中/memory是path)：\n\n```c\nU-Boot> fdt print /memory\nmemory {\ndevice_type = \"memory\";\nreg = <0x70000000 0x4000000>;\n};\n\nU-Boot> fdt print #不加参数时，打印出整颗树\n```\n\n\n\n# 二、u-boot 获取GPT分区表\n\n在uboot中通过命令打印分区表\n\n```\npart list mmc 0\n```\n\n## 3588-android-uboot\n\n```c\n#include <common.h>\n#include <command.h>\n#include <android_image.h>\n#include <mmc.h>\n#include <stdlib.h>\n#include <memalign.h>\n#include <fdtdec.h>\n\n#define PART_MAX_COUNT  128\n#define\tLAB_SIZE\t\t512\n#define\tHEADER_OFFSET\tLAB_SIZE\n#define\tENTRY_OFFSET\t(2 * LAB_SIZE)\n#define\tVAL1_OFFSET\t\tsizeof(u64)\n#define\tVAL2_OFFSET\t\t(2 * sizeof(u64))\n\nstatic u64 get_gpt_blk_cnt_and_print(struct blk_desc *dev_desc,\n\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte) {\n\tchar efi_str[PARTNAME_SZ + 1];\n\tu64 gpt_part_size, gpt_blk_cnt = 0;\n\tgpt_entry *gpt_e;\n\tint i;\n\n\tgpt_e = *gpt_pte;\n\tfor (i = 0; i < gpt_head->num_partition_entries; i++) {\n\n\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,\n\t\t\t\t\t     PARTNAME_SZ + 1);\n\n\t\tprintf(\"%s: part: %2d name - GPT: %16s \",\n\t\t      __func__, i, efi_str);\n\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -\n\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + 1;\n\t\tgpt_blk_cnt += gpt_part_size;\n\t\t\n\t\tif(gpt_part_size == 1) \n\t\t\tbreak;\n\t\t\n\t\tprintf(\"size(LBA) - GPT: %8llu \",\n\t\t      (unsigned long long)gpt_part_size);\n\n\t\tprintf(\"start LBA - GPT: %8llu \\n\",\n\t\t      le64_to_cpu(gpt_e[i].starting_lba));\n\t}\n\n\treturn gpt_blk_cnt + gpt_e[0].starting_lba - 1;\n}\n\nstatic int get_gpt_meta_data(u64 *data_size, void **data)\n{\n    gpt_header *pgpt_head;\n\tgpt_entry *entries;\n\tvoid *meta_data;\n\tu64 meta_data_size, gpt_entries_size;\n\tstruct blk_desc *dev_desc = NULL;\n\tstruct mmc *mmc = NULL;\n\tu64 blk_size = 0;\n\tu64 blk_cnt = 0;\n\tu64 tag = 0x55AA;\n\tlbaint_t lba;\n    \n\tif (!data_size || !data) {\n\t\tprintf(\"%s *** ERROR: Invalid Argument(s) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    mmc = do_returnmmc();\n\tif (!mmc)\n\t\treturn CMD_RET_FAILURE;\n    \n    dev_desc = mmc_get_blk_desc(mmc);\n\tif (!dev_desc) {\n\t\tprintf(\"%s *** ERROR: mmc_get_blk_desc err ***\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tgpt_entries_size = sizeof(gpt_entry) * PART_MAX_COUNT;\n\tmeta_data_size = LAB_SIZE + sizeof(gpt_header) + gpt_entries_size;\n\tmeta_data = malloc(meta_data_size);\n\tif(!meta_data) {\n\t\tprintf(\"%s *** ERROR: malloc memory (gpt meta data) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    memset(meta_data, 0, meta_data_size);\n\tpgpt_head = (gpt_header *)((char *)meta_data + HEADER_OFFSET);\n\tentries = (gpt_entry *)((char *)meta_data + ENTRY_OFFSET);\n\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc->blksz);\n\n\t/* Read MBR Header from device */\n\tlba = 0; /* MBR is always at 0 */\n\tblk_cnt = 1; /* MBR (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != 1) {\n\t\tprintf(\"*** ERROR: Can't read MBR header ***\\n\");\n\t\tgoto ERROR_OUT;\n\t}\n\n\t/* Read GPT Header from device */\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tblk_cnt = 1; /* GPT Header (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != 1) {\n    \tprintf(\"%s *** ERROR: Can't read GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tif (validate_gpt_header(pgpt_head, lba, dev_desc->lba)) {\n\t\tprintf(\"%s *** ERROR: validate_gpt_header GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tif (dev_desc->sig_type == SIG_TYPE_NONE) {\n\t\tefi_guid_t empty = {};\n\t\tif (memcmp(&pgpt_head->disk_guid, &empty, sizeof(empty))) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_GUID;\n\t\t\tmemcpy(&dev_desc->guid_sig, &pgpt_head->disk_guid,\n\t\t\t      sizeof(empty));\n\t\t} else if (mbr->unique_mbr_signature != 0) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_MBR;\n\t\t\tdev_desc->mbr_sig = mbr->unique_mbr_signature;\n\t\t}\n\t}\n\n\t/* Read GPT Entries from device */\n\tlba = le64_to_cpu(pgpt_head->partition_entry_lba);\n\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head->num_partition_entries) *\n\t\t\t\t   \tle32_to_cpu(pgpt_head->sizeof_partition_entry)),\n\t\t\t\t  \tdev_desc);\n\tif (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) {\n\t\tprintf(\"%s *** ERROR:read entries (lba=%llu) ***\\n\",\n\t\t\t\t__func__, pgpt_head->partition_entry_lba);\n\t\tgoto ERROR_OUT;\n\t}\n\t\n\tblk_size = dev_desc->blksz;\n\tvalidate_gpt_entries(pgpt_head, entries);\n\t\n\tdebug(\"%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n\",\n\t\t\t\t__func__, (unsigned long long)(ulong)lba, blk_cnt, blk_size);\n\t\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n    \n    /* \n\t * build info, layout of meta_data:\n\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries\n\t */\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n\t/*this value makes we known the reserved memory is available*/\n\tmemcpy(meta_data, (void *)&tag, sizeof(u64));\n\tmemcpy(meta_data + VAL1_OFFSET, (void *)&blk_size, sizeof(u64));\n\tmemcpy(meta_data + VAL2_OFFSET, (void *)&blk_cnt, sizeof(u64));\n\n\t*data_size = meta_data_size;\n\t*data = meta_data;\n\n\treturn 0;\n\nERROR_OUT:\n\tfree(meta_data);\n\tmeta_data = NULL;\n\treturn -1;\n}\n```\n\n\n\n参考：\n\n[Device Tree（四）：文件结构解析 (wowotech.net)](http://www.wowotech.net/device_model/dt-code-file-struct-parse.html)\n\n[Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376295326)\n\n[Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376296222)\n\nhttps://www.cnblogs.com/solo666/p/16518154.html\n","updated":"2024-05-15T06:54:20.711Z","path":"back_posts/U-Boot-fdt-GPT.html","comments":1,"layout":"page","_id":"clw7h6af900027sw08fk91eq1","content":"<p>U-Boot官网:<a href=\"https://docs.u-boot.org/en/latest/\">https://docs.u-boot.org/en/latest/</a></p>\n<p>u-boot启动流程</p>\n<ul>\n<li>板子上电以后，首先执行的是ROM中的一段启动代码。启动代码<strong>根据寄存器&#x2F;外部管脚配置</strong>，确定是进入下载模式，还是从某介质(Flash&#x2F;EMMC&#x2F;SD卡等存储设备)启动u-boot</li>\n</ul>\n<blockquote>\n<p>ROM中的代码是固化的，无法修改</p>\n</blockquote>\n<h1 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h1><blockquote>\n<p>FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。</p>\n<p>uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  </p>\n</blockquote>\n<blockquote>\n<p>U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc&#x2F;README.fdt-control</p>\n</blockquote>\n<h3 id=\"dtb在U-boot中的位置\"><a href=\"#dtb在U-boot中的位置\" class=\"headerlink\" title=\"dtb在U-boot中的位置\"></a>dtb在U-boot中的位置</h3><ul>\n<li>dtb能够以两种形式编译到U-boot的镜像中</li>\n</ul>\n<ol>\n<li>dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址</p>\n</blockquote>\n<ol>\n<li>dtb集成到u-boot的bin文件内部</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb</p>\n</blockquote>\n<ol>\n<li>获取dts文件的地址gd-&gt;fdt_blob</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 宏用来表示是否把dtb文件放在uboot.bin的文件中</span><br><span class=\"line\">CONFIG_OF_EMBED</span><br><span class=\"line\"></span><br><span class=\"line\">// 单独编译dtb文件</span><br><span class=\"line\">CONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址</span><br><span class=\"line\"></span><br><span class=\"line\">gd-&gt;fdt_blob = (ulong *)&amp;_end;</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以通过fdtcontroladdr环境变量来指定fdt的地址</span><br><span class=\"line\">gd-&gt;fdt_blob = (void *)getenv_ulong(&quot;fdtcontroladdr&quot;, 16,</span><br><span class=\"line\">\t\t\t\t\t\t(uintptr_t)gd-&gt;fdt_blob); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dtb解析接口\"><a href=\"#dtb解析接口\" class=\"headerlink\" title=\"dtb解析接口\"></a>dtb解析接口</h3><ul>\n<li>定义在lib&#x2F;fdtdec.c文件中，节点变量node中存放的是偏移地址</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点</span><br><span class=\"line\">int fdt_path_offset(const void *fdt, const char *path)</span><br><span class=\"line\">eg：node = fdt_path_offset(gd-&gt;fdt_blob, “/aliases”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个字符串属性值</span><br><span class=\"line\">const void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)</span><br><span class=\"line\">eg： mac = fdt_getprop(gd-&gt;fdt_blob, node, “mac-address”, &amp;len);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个整形数组属性值</span><br><span class=\"line\">int fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)</span><br><span class=\"line\">eg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的地址属性值</span><br><span class=\"line\">fdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)</span><br><span class=\"line\">eg：fdtdec_get_addr(blob, node, “reg”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得config节点下的整形属性、bool属性、字符串等等</span><br><span class=\"line\">fdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下的name节点的偏移</span><br><span class=\"line\">int fdtdec_get_chosen_node(const void *blob, const char *name)</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下name属性的值</span><br><span class=\"line\">const char *fdtdec_get_chosen_prop(const void *blob, const char *name)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义在lib&#x2F;fdtdec_common.c文件中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得节点node的某个整形属性值</span><br><span class=\"line\">int fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)</span><br><span class=\"line\">eg： bus-&gt;udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个无符号整形属性值</span><br><span class=\"line\">fdtdec_get_uint</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fdt-命令\"><a href=\"#fdt-命令\" class=\"headerlink\" title=\"fdt 命令\"></a>fdt 命令</h2><p>对于u-boot提供了fdt的相关命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdt - flattened device tree utility commands</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">fdt addr [-c]  &lt;addr&gt; [&lt;length&gt;]   - Set the [control] fdt location to &lt;addr&gt;</span><br><span class=\"line\">fdt apply &lt;addr&gt;                    - Apply overlay to the DT</span><br><span class=\"line\">fdt move   &lt;fdt&gt; &lt;newaddr&gt; &lt;length&gt; - Copy the fdt to &lt;addr&gt; and make it active</span><br><span class=\"line\">fdt resize [&lt;extrasize&gt;]            - Resize fdt to size + padding to 4k addr + some optional &lt;extrasize&gt; if needed</span><br><span class=\"line\">fdt print  &lt;path&gt; [&lt;prop&gt;]          - Recursive print starting at &lt;path&gt;</span><br><span class=\"line\">fdt list   &lt;path&gt; [&lt;prop&gt;]          - Print one level starting at &lt;path&gt;</span><br><span class=\"line\">fdt get value &lt;var&gt; &lt;path&gt; &lt;prop&gt;   - Get &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get name &lt;var&gt; &lt;path&gt; &lt;index&gt;   - Get name of node &lt;index&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get addr &lt;var&gt; &lt;path&gt; &lt;prop&gt;    - Get start address of &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get size &lt;var&gt; &lt;path&gt; [&lt;prop&gt;]  - Get size of [&lt;property&gt;] or num nodes and store in &lt;var&gt;</span><br><span class=\"line\">fdt set    &lt;path&gt; &lt;prop&gt; [&lt;val&gt;]    - Set &lt;property&gt; [to &lt;val&gt;]</span><br><span class=\"line\">fdt mknode &lt;path&gt; &lt;node&gt;            - Create a new node after &lt;path&gt;</span><br><span class=\"line\">fdt rm     &lt;path&gt; [&lt;prop&gt;]          - Delete the node or &lt;property&gt;</span><br><span class=\"line\">fdt header                          - Display header info</span><br><span class=\"line\">fdt bootcpu &lt;id&gt;                    - Set boot cpuid</span><br><span class=\"line\">fdt memory &lt;addr&gt; &lt;size&gt;            - Add/Update memory node</span><br><span class=\"line\">fdt rsvmem print                    - Show current mem reserves</span><br><span class=\"line\">fdt rsvmem add &lt;addr&gt; &lt;size&gt;        - Add a mem reserve</span><br><span class=\"line\">fdt rsvmem delete &lt;index&gt;           - Delete a mem reserves</span><br><span class=\"line\">fdt chosen [&lt;start&gt; &lt;end&gt;]          - Add/update the /chosen branch in the tree</span><br><span class=\"line\">                                        &lt;start&gt;/&lt;end&gt; - initrd start/end addr</span><br><span class=\"line\">NOTE: Dereference aliases by omitting the leading &#x27;/&#x27;, e.g. fdt print ethernet0.</span><br></pre></td></tr></table></figure>\n\n<p>fdt print加path参数，则打path内容，如下(其中&#x2F;memory是path)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">U-Boot&gt; fdt print /memory</span><br><span class=\"line\">memory &#123;</span><br><span class=\"line\">device_type = <span class=\"string\">&quot;memory&quot;</span>;</span><br><span class=\"line\">reg = &lt;<span class=\"number\">0x70000000</span> <span class=\"number\">0x4000000</span>&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot&gt; fdt print #不加参数时，打印出整颗树</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"二、u-boot-获取GPT分区表\"><a href=\"#二、u-boot-获取GPT分区表\" class=\"headerlink\" title=\"二、u-boot 获取GPT分区表\"></a>二、u-boot 获取GPT分区表</h1><p>在uboot中通过命令打印分区表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">part list mmc 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3588-android-uboot\"><a href=\"#3588-android-uboot\" class=\"headerlink\" title=\"3588-android-uboot\"></a>3588-android-uboot</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;common.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;command.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;android_image.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mmc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memalign.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fdtdec.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PART_MAX_COUNT  128</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tLAB_SIZE\t\t512</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tHEADER_OFFSET\tLAB_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tENTRY_OFFSET\t(2 * LAB_SIZE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL1_OFFSET\t\tsizeof(u64)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL2_OFFSET\t\t(2 * sizeof(u64))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">get_gpt_blk_cnt_and_print</span><span class=\"params\">(<span class=\"keyword\">struct</span> blk_desc *dev_desc,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> efi_str[PARTNAME_SZ + <span class=\"number\">1</span>];</span><br><span class=\"line\">\tu64 gpt_part_size, gpt_blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tgpt_entry *gpt_e;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_e = *gpt_pte;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; gpt_head-&gt;num_partition_entries; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,</span><br><span class=\"line\">\t\t\t\t\t     PARTNAME_SZ + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s: part: %2d name - GPT: %16s &quot;</span>,</span><br><span class=\"line\">\t\t      __func__, i, efi_str);</span><br><span class=\"line\">\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -</span><br><span class=\"line\">\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tgpt_blk_cnt += gpt_part_size;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(gpt_part_size == <span class=\"number\">1</span>) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size(LBA) - GPT: %8llu &quot;</span>,</span><br><span class=\"line\">\t\t      (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)gpt_part_size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start LBA - GPT: %8llu \\n&quot;</span>,</span><br><span class=\"line\">\t\t      le64_to_cpu(gpt_e[i].starting_lba));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gpt_blk_cnt + gpt_e[<span class=\"number\">0</span>].starting_lba - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">get_gpt_meta_data</span><span class=\"params\">(u64 *data_size, <span class=\"type\">void</span> **data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gpt_header *pgpt_head;</span><br><span class=\"line\">\tgpt_entry *entries;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *meta_data;</span><br><span class=\"line\">\tu64 meta_data_size, gpt_entries_size;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_desc</span> *<span class=\"title\">dev_desc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mmc</span> *<span class=\"title\">mmc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tu64 blk_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 tag = <span class=\"number\">0x55AA</span>;</span><br><span class=\"line\">\t<span class=\"type\">lbaint_t</span> lba;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!data_size || !data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Invalid Argument(s) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mmc = do_returnmmc();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!mmc)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> CMD_RET_FAILURE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    dev_desc = mmc_get_blk_desc(mmc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!dev_desc) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: mmc_get_blk_desc err ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_entries_size = <span class=\"keyword\">sizeof</span>(gpt_entry) * PART_MAX_COUNT;</span><br><span class=\"line\">\tmeta_data_size = LAB_SIZE + <span class=\"keyword\">sizeof</span>(gpt_header) + gpt_entries_size;</span><br><span class=\"line\">\tmeta_data = <span class=\"built_in\">malloc</span>(meta_data_size);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!meta_data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: malloc memory (gpt meta data) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(meta_data, <span class=\"number\">0</span>, meta_data_size);</span><br><span class=\"line\">\tpgpt_head = (gpt_header *)((<span class=\"type\">char</span> *)meta_data + HEADER_OFFSET);</span><br><span class=\"line\">\tentries = (gpt_entry *)((<span class=\"type\">char</span> *)meta_data + ENTRY_OFFSET);</span><br><span class=\"line\">\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc-&gt;blksz);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read MBR Header from device */</span></span><br><span class=\"line\">\tlba = <span class=\"number\">0</span>; <span class=\"comment\">/* MBR is always at 0 */</span></span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* MBR (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*** ERROR: Can&#x27;t read MBR header ***\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Header from device */</span></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* GPT Header (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Can&#x27;t read GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (validate_gpt_header(pgpt_head, lba, dev_desc-&gt;lba)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: validate_gpt_header GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dev_desc-&gt;sig_type == SIG_TYPE_NONE) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">efi_guid_t</span> empty = &#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">memcmp</span>(&amp;pgpt_head-&gt;disk_guid, &amp;empty, <span class=\"keyword\">sizeof</span>(empty))) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_GUID;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(&amp;dev_desc-&gt;guid_sig, &amp;pgpt_head-&gt;disk_guid,</span><br><span class=\"line\">\t\t\t      <span class=\"keyword\">sizeof</span>(empty));</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mbr-&gt;unique_mbr_signature != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_MBR;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;mbr_sig = mbr-&gt;unique_mbr_signature;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Entries from device */</span></span><br><span class=\"line\">\tlba = le64_to_cpu(pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head-&gt;num_partition_entries) *</span><br><span class=\"line\">\t\t\t\t   \tle32_to_cpu(pgpt_head-&gt;sizeof_partition_entry)),</span><br><span class=\"line\">\t\t\t\t  \tdev_desc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR:read entries (lba=%llu) ***\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_size = dev_desc-&gt;blksz;</span><br><span class=\"line\">\tvalidate_gpt_entries(pgpt_head, entries);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdebug(<span class=\"string\">&quot;%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)(ulong)lba, blk_cnt, blk_size);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">\t * build info, layout of meta_data:</span></span><br><span class=\"line\"><span class=\"comment\">\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">\t<span class=\"comment\">/*this value makes we known the reserved memory is available*/</span></span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data, (<span class=\"type\">void</span> *)&amp;tag, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL1_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_size, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL2_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_cnt, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data_size = meta_data_size;</span><br><span class=\"line\">\t*data = meta_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR_OUT:</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(meta_data);</span><br><span class=\"line\">\tmeta_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参考：</p>\n<p><a href=\"http://www.wowotech.net/device_model/dt-code-file-struct-parse.html\">Device Tree（四）：文件结构解析 (wowotech.net)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376295326\">Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376296222\">Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/solo666/p/16518154.html\">https://www.cnblogs.com/solo666/p/16518154.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>U-Boot官网:<a href=\"https://docs.u-boot.org/en/latest/\">https://docs.u-boot.org/en/latest/</a></p>\n<p>u-boot启动流程</p>\n<ul>\n<li>板子上电以后，首先执行的是ROM中的一段启动代码。启动代码<strong>根据寄存器&#x2F;外部管脚配置</strong>，确定是进入下载模式，还是从某介质(Flash&#x2F;EMMC&#x2F;SD卡等存储设备)启动u-boot</li>\n</ul>\n<blockquote>\n<p>ROM中的代码是固化的，无法修改</p>\n</blockquote>\n<h1 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h1><blockquote>\n<p>FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。</p>\n<p>uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  </p>\n</blockquote>\n<blockquote>\n<p>U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc&#x2F;README.fdt-control</p>\n</blockquote>\n<h3 id=\"dtb在U-boot中的位置\"><a href=\"#dtb在U-boot中的位置\" class=\"headerlink\" title=\"dtb在U-boot中的位置\"></a>dtb在U-boot中的位置</h3><ul>\n<li>dtb能够以两种形式编译到U-boot的镜像中</li>\n</ul>\n<ol>\n<li>dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址</p>\n</blockquote>\n<ol>\n<li>dtb集成到u-boot的bin文件内部</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb</p>\n</blockquote>\n<ol>\n<li>获取dts文件的地址gd-&gt;fdt_blob</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 宏用来表示是否把dtb文件放在uboot.bin的文件中</span><br><span class=\"line\">CONFIG_OF_EMBED</span><br><span class=\"line\"></span><br><span class=\"line\">// 单独编译dtb文件</span><br><span class=\"line\">CONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址</span><br><span class=\"line\"></span><br><span class=\"line\">gd-&gt;fdt_blob = (ulong *)&amp;_end;</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以通过fdtcontroladdr环境变量来指定fdt的地址</span><br><span class=\"line\">gd-&gt;fdt_blob = (void *)getenv_ulong(&quot;fdtcontroladdr&quot;, 16,</span><br><span class=\"line\">\t\t\t\t\t\t(uintptr_t)gd-&gt;fdt_blob); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dtb解析接口\"><a href=\"#dtb解析接口\" class=\"headerlink\" title=\"dtb解析接口\"></a>dtb解析接口</h3><ul>\n<li>定义在lib&#x2F;fdtdec.c文件中，节点变量node中存放的是偏移地址</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点</span><br><span class=\"line\">int fdt_path_offset(const void *fdt, const char *path)</span><br><span class=\"line\">eg：node = fdt_path_offset(gd-&gt;fdt_blob, “/aliases”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个字符串属性值</span><br><span class=\"line\">const void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)</span><br><span class=\"line\">eg： mac = fdt_getprop(gd-&gt;fdt_blob, node, “mac-address”, &amp;len);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个整形数组属性值</span><br><span class=\"line\">int fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)</span><br><span class=\"line\">eg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的地址属性值</span><br><span class=\"line\">fdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)</span><br><span class=\"line\">eg：fdtdec_get_addr(blob, node, “reg”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得config节点下的整形属性、bool属性、字符串等等</span><br><span class=\"line\">fdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下的name节点的偏移</span><br><span class=\"line\">int fdtdec_get_chosen_node(const void *blob, const char *name)</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下name属性的值</span><br><span class=\"line\">const char *fdtdec_get_chosen_prop(const void *blob, const char *name)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义在lib&#x2F;fdtdec_common.c文件中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得节点node的某个整形属性值</span><br><span class=\"line\">int fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)</span><br><span class=\"line\">eg： bus-&gt;udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个无符号整形属性值</span><br><span class=\"line\">fdtdec_get_uint</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fdt-命令\"><a href=\"#fdt-命令\" class=\"headerlink\" title=\"fdt 命令\"></a>fdt 命令</h2><p>对于u-boot提供了fdt的相关命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdt - flattened device tree utility commands</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">fdt addr [-c]  &lt;addr&gt; [&lt;length&gt;]   - Set the [control] fdt location to &lt;addr&gt;</span><br><span class=\"line\">fdt apply &lt;addr&gt;                    - Apply overlay to the DT</span><br><span class=\"line\">fdt move   &lt;fdt&gt; &lt;newaddr&gt; &lt;length&gt; - Copy the fdt to &lt;addr&gt; and make it active</span><br><span class=\"line\">fdt resize [&lt;extrasize&gt;]            - Resize fdt to size + padding to 4k addr + some optional &lt;extrasize&gt; if needed</span><br><span class=\"line\">fdt print  &lt;path&gt; [&lt;prop&gt;]          - Recursive print starting at &lt;path&gt;</span><br><span class=\"line\">fdt list   &lt;path&gt; [&lt;prop&gt;]          - Print one level starting at &lt;path&gt;</span><br><span class=\"line\">fdt get value &lt;var&gt; &lt;path&gt; &lt;prop&gt;   - Get &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get name &lt;var&gt; &lt;path&gt; &lt;index&gt;   - Get name of node &lt;index&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get addr &lt;var&gt; &lt;path&gt; &lt;prop&gt;    - Get start address of &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get size &lt;var&gt; &lt;path&gt; [&lt;prop&gt;]  - Get size of [&lt;property&gt;] or num nodes and store in &lt;var&gt;</span><br><span class=\"line\">fdt set    &lt;path&gt; &lt;prop&gt; [&lt;val&gt;]    - Set &lt;property&gt; [to &lt;val&gt;]</span><br><span class=\"line\">fdt mknode &lt;path&gt; &lt;node&gt;            - Create a new node after &lt;path&gt;</span><br><span class=\"line\">fdt rm     &lt;path&gt; [&lt;prop&gt;]          - Delete the node or &lt;property&gt;</span><br><span class=\"line\">fdt header                          - Display header info</span><br><span class=\"line\">fdt bootcpu &lt;id&gt;                    - Set boot cpuid</span><br><span class=\"line\">fdt memory &lt;addr&gt; &lt;size&gt;            - Add/Update memory node</span><br><span class=\"line\">fdt rsvmem print                    - Show current mem reserves</span><br><span class=\"line\">fdt rsvmem add &lt;addr&gt; &lt;size&gt;        - Add a mem reserve</span><br><span class=\"line\">fdt rsvmem delete &lt;index&gt;           - Delete a mem reserves</span><br><span class=\"line\">fdt chosen [&lt;start&gt; &lt;end&gt;]          - Add/update the /chosen branch in the tree</span><br><span class=\"line\">                                        &lt;start&gt;/&lt;end&gt; - initrd start/end addr</span><br><span class=\"line\">NOTE: Dereference aliases by omitting the leading &#x27;/&#x27;, e.g. fdt print ethernet0.</span><br></pre></td></tr></table></figure>\n\n<p>fdt print加path参数，则打path内容，如下(其中&#x2F;memory是path)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">U-Boot&gt; fdt print /memory</span><br><span class=\"line\">memory &#123;</span><br><span class=\"line\">device_type = <span class=\"string\">&quot;memory&quot;</span>;</span><br><span class=\"line\">reg = &lt;<span class=\"number\">0x70000000</span> <span class=\"number\">0x4000000</span>&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot&gt; fdt print #不加参数时，打印出整颗树</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"二、u-boot-获取GPT分区表\"><a href=\"#二、u-boot-获取GPT分区表\" class=\"headerlink\" title=\"二、u-boot 获取GPT分区表\"></a>二、u-boot 获取GPT分区表</h1><p>在uboot中通过命令打印分区表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">part list mmc 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3588-android-uboot\"><a href=\"#3588-android-uboot\" class=\"headerlink\" title=\"3588-android-uboot\"></a>3588-android-uboot</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;common.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;command.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;android_image.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mmc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memalign.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fdtdec.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PART_MAX_COUNT  128</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tLAB_SIZE\t\t512</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tHEADER_OFFSET\tLAB_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tENTRY_OFFSET\t(2 * LAB_SIZE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL1_OFFSET\t\tsizeof(u64)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL2_OFFSET\t\t(2 * sizeof(u64))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">get_gpt_blk_cnt_and_print</span><span class=\"params\">(<span class=\"keyword\">struct</span> blk_desc *dev_desc,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> efi_str[PARTNAME_SZ + <span class=\"number\">1</span>];</span><br><span class=\"line\">\tu64 gpt_part_size, gpt_blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tgpt_entry *gpt_e;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_e = *gpt_pte;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; gpt_head-&gt;num_partition_entries; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,</span><br><span class=\"line\">\t\t\t\t\t     PARTNAME_SZ + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s: part: %2d name - GPT: %16s &quot;</span>,</span><br><span class=\"line\">\t\t      __func__, i, efi_str);</span><br><span class=\"line\">\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -</span><br><span class=\"line\">\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tgpt_blk_cnt += gpt_part_size;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(gpt_part_size == <span class=\"number\">1</span>) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size(LBA) - GPT: %8llu &quot;</span>,</span><br><span class=\"line\">\t\t      (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)gpt_part_size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start LBA - GPT: %8llu \\n&quot;</span>,</span><br><span class=\"line\">\t\t      le64_to_cpu(gpt_e[i].starting_lba));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gpt_blk_cnt + gpt_e[<span class=\"number\">0</span>].starting_lba - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">get_gpt_meta_data</span><span class=\"params\">(u64 *data_size, <span class=\"type\">void</span> **data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gpt_header *pgpt_head;</span><br><span class=\"line\">\tgpt_entry *entries;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *meta_data;</span><br><span class=\"line\">\tu64 meta_data_size, gpt_entries_size;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_desc</span> *<span class=\"title\">dev_desc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mmc</span> *<span class=\"title\">mmc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tu64 blk_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 tag = <span class=\"number\">0x55AA</span>;</span><br><span class=\"line\">\t<span class=\"type\">lbaint_t</span> lba;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!data_size || !data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Invalid Argument(s) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mmc = do_returnmmc();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!mmc)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> CMD_RET_FAILURE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    dev_desc = mmc_get_blk_desc(mmc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!dev_desc) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: mmc_get_blk_desc err ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_entries_size = <span class=\"keyword\">sizeof</span>(gpt_entry) * PART_MAX_COUNT;</span><br><span class=\"line\">\tmeta_data_size = LAB_SIZE + <span class=\"keyword\">sizeof</span>(gpt_header) + gpt_entries_size;</span><br><span class=\"line\">\tmeta_data = <span class=\"built_in\">malloc</span>(meta_data_size);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!meta_data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: malloc memory (gpt meta data) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(meta_data, <span class=\"number\">0</span>, meta_data_size);</span><br><span class=\"line\">\tpgpt_head = (gpt_header *)((<span class=\"type\">char</span> *)meta_data + HEADER_OFFSET);</span><br><span class=\"line\">\tentries = (gpt_entry *)((<span class=\"type\">char</span> *)meta_data + ENTRY_OFFSET);</span><br><span class=\"line\">\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc-&gt;blksz);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read MBR Header from device */</span></span><br><span class=\"line\">\tlba = <span class=\"number\">0</span>; <span class=\"comment\">/* MBR is always at 0 */</span></span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* MBR (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*** ERROR: Can&#x27;t read MBR header ***\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Header from device */</span></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* GPT Header (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Can&#x27;t read GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (validate_gpt_header(pgpt_head, lba, dev_desc-&gt;lba)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: validate_gpt_header GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dev_desc-&gt;sig_type == SIG_TYPE_NONE) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">efi_guid_t</span> empty = &#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">memcmp</span>(&amp;pgpt_head-&gt;disk_guid, &amp;empty, <span class=\"keyword\">sizeof</span>(empty))) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_GUID;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(&amp;dev_desc-&gt;guid_sig, &amp;pgpt_head-&gt;disk_guid,</span><br><span class=\"line\">\t\t\t      <span class=\"keyword\">sizeof</span>(empty));</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mbr-&gt;unique_mbr_signature != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_MBR;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;mbr_sig = mbr-&gt;unique_mbr_signature;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Entries from device */</span></span><br><span class=\"line\">\tlba = le64_to_cpu(pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head-&gt;num_partition_entries) *</span><br><span class=\"line\">\t\t\t\t   \tle32_to_cpu(pgpt_head-&gt;sizeof_partition_entry)),</span><br><span class=\"line\">\t\t\t\t  \tdev_desc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR:read entries (lba=%llu) ***\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_size = dev_desc-&gt;blksz;</span><br><span class=\"line\">\tvalidate_gpt_entries(pgpt_head, entries);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdebug(<span class=\"string\">&quot;%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)(ulong)lba, blk_cnt, blk_size);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">\t * build info, layout of meta_data:</span></span><br><span class=\"line\"><span class=\"comment\">\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">\t<span class=\"comment\">/*this value makes we known the reserved memory is available*/</span></span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data, (<span class=\"type\">void</span> *)&amp;tag, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL1_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_size, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL2_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_cnt, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data_size = meta_data_size;</span><br><span class=\"line\">\t*data = meta_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR_OUT:</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(meta_data);</span><br><span class=\"line\">\tmeta_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参考：</p>\n<p><a href=\"http://www.wowotech.net/device_model/dt-code-file-struct-parse.html\">Device Tree（四）：文件结构解析 (wowotech.net)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376295326\">Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376296222\">Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/solo666/p/16518154.html\">https://www.cnblogs.com/solo666/p/16518154.html</a></p>\n"},{"title":"cgroup","categories":["kernel"],"tags":["cgroup"],"date":"2024-05-16T07:30:33.000Z","_content":"\n[toc]\n\ncgroup是linux内核实现、用于控制linux系统资源的组件。因此要了解cgroup，首先从引入这个组件的kernel文档中寻找。\n\n去到举世闻名的www.kernel.org\n\n找到介绍文档：Documentation/cgroup-v1/cgroups.txt\n\n## 1 什么是cgroup?\n\n>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup绑定一个进程集合到一个或多个子系统上。\n>\n>subsystem，子系统，一个通过cgroup提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。\n>\n>hierarchy，层级树，多个cgroup的集合，这些集合构成的树叫hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy上的层次关系通过cgroupfs虚拟文件系统显示。系统允许多个hierarchy同时存在，每个hierachy包含系统中的部分或者全部进程集合。\n>\n>cgroupfs是用户管理操纵cgroup的主要接口：通过在cgroupfs文件系统中创建目录，实现cgroup的创建；通过向目录下的属性文件写入内容，设置cgroup对资源的控制；向task属性文件写入进程ID，可以将进程绑定到某个cgroup，以此达到控制进程资源使用的目的；也可以列出cgroup包含的进程pid。这些操作影响的是sysfs关联的hierarchy，对其它hierarchy没有影响。\n>\n>对于cgroup，其本身的作用只是任务跟踪。但其它系统（比如cpusets，cpuacct），可以利用cgroup的这个功能实现一些新的属性，比如统计或者控制一个cgroup中进程可以访问的资源。举个例子，cpusets子系统可以将进程绑定到特定的cpu和内存节点上。\n\n2 为什么需要cgroup?\n\n>\n>\n>这个问题相当于问cgroup重要吗？有哪些地方用到了。回答是重要，又不重要。如果你用到了，那就重要，如果没有用到，那就不重要。呵呵呵~~~~其实挺重要的。cgroup的主要运用是资源跟踪。我接触的场景就是用cgroup控制虚拟机进程或者docker进程可以使用的资源。当你想在linux对应用进程做资源访问控制的时候，cgroup就派上用场了。\n\n## 3 cgroup怎么实现的？\n\n>——    系统中的每个进程（task_struct，后面用task代指）都持有一个指向css_set结构的指针。\n>\n>——    一个css_set结构体包含了一组指向cgroup_subsys_state对象的指针（所以一个task可以附加到多个cgroup上），每个cgroup_subsys_state在系统中都有注册。task结构体没有直接指向hierarchy中一个节点（cgroup）的指针。但可以通过其包含的cgroup_subsys_state间接确定。这样设计的原因是cpu对subsystem state的访问很频繁，但涉及到将task绑定到cgroup的操作却不多。task中还有个双向链表cg_list，这个链表维护所有同属于一个css_set的tasks。\n>\n>——    用户可以通过cgroupfs文件系统来浏览cgroup hierarchy。\n>\n>——    用户可以列出任意一个cgroup上附着的task PID\n>\n>cgroup在kernel中除了本身功能的实现外，在kernel中还有两处修改：\n>\n>——    在kernel启动时对root cgroup的初始化和css_set结构体的初始化。这个在init/main.c文件中实现。\n>\n>——    在task的创建（fork）和退出（exit）阶段，对应地将task与css_set进行绑定和解绑。\n>\n>另外，cgroup为了向用户提供操作接口，特别开发了一个虚拟文件系统类型（cgroupfs），这个文件系统与sysfs，proc类似。cgroupfs是向用户展示cgroup的hierarchy，通知kernel用户对cgroup改动的窗口。挂载cgroupfs时通过选项（-otype）指定要挂载的子系统类型，如果不指定，默认挂载所有的注册的子系统。\n>\n>如果新挂载的cgroup关联的hierachy与系统中存在的hierarchy完全一样，那么cgroupfs会拒绝挂载。如果没有匹配到相同的hierarchy，但新挂载hierachy声明的资源正在被已经存在的hierarchy使用，挂载会报-EBUSY错误。\n>\n>当前cgroup还没有实现向已经存在的cgroup hierarchy绑定新子系统的操作，将子系统从cgroup hierachy解绑也不允许。这些操作在未来也许会支持，但也可能会进一步产生错误恢复的一系列问题。\n>\n>卸载cgroupfs时，如果它的子cgroupfs还在活动，那么子cgroupfs还是会持续生效。直到所有的子cgroupfs不再活动，卸载cgroupfs才会真正生效。\n>\n>cgroupfs下不能再挂载其它类型的文件系统。所有对cgroup的查询修改都只通过cgroupfs文件系统来完成。\n>\n>系统中的所有task，在/proc/pid目录下都有一个名为cgroup的文件，这个文件展示了该task相对cgroupfs 根的路径。通过查看这个文件，可以了解一个进程在cgroup hierarchy的位置。以此得到task可以使用的资源信息。\n>\n>cgroupfs中目录表示cgroup，每个目录在创建时默认生成如下的属性文件，这些文件描述了cgroup的信息：\n>\n>——    tasks: 所有附属于这个cgroup的进程ID列表。tasks文件中增加进程ID，表示将进程加入这个cgroup，进程能够使用的资源受cgroup限制。\n>\n>——    cgroup.procs: 所有附属于这个cgroup线程组ID，将TGID写入这个文件后，TGID所在进程包含的所有线程都加入这个cgroup，这些线程受cgroup限制。\n\n> PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。\n> TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。\n> PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。\n> SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。\n> ——    notify_on_release flag: 标记退出时是否运行release agent\n>\n> ——    release_agent: 制定要运行的release agent的路径，这个属性文件只在cgroup的顶层目录中存在。\n>\n> 以上文件是每个cgroup基本的属性文件，对于不同的子系统，对应的cgroup可能会有其它附加的属性文件，存在于其对应的cgroup目录之下。\n>\n> 通过mkdir命令创建cgroup，通过向目录下的文件写入适当的数值设置修改cgroup的属性。\n>\n> 嵌套的cgroups，指定了层级结构，以此将系统资源划分成嵌套的，动态可变的更小的资源块。\n>\n> 一个进程可以附加到多个不同的cgroup中，只要这些cgroup不在同一个层级树上即可。因为cgroupfs会保证新挂载的cgroup关联的层级树全局唯一。子进程在被创建后默认附加到父进程所在的cgroup，后面用户可以根据需要将其移动到别的cgroup。\n>\n> 当进程从一个cgroup被移动到另一个cgroup。进程的task_struct会获取一个新的css_set指针：如果这个cgroup所在的css_set已经存在就重用这个css_set，否则就新分配一个css_set。kernel会在全局的hash表中查找确认cgroup所属的css_set是否存在。\n\n## 4 notify_on_release 是做什么的？\n\n>如果cgroup中使能notify_on_release，cgroup中的最后一个进程被移除，最后一个子cgroup也被删除时，cgroup会主动通知kernel。接收到消息的kernel会执行release_agent文件中指定的程序。notify_on_release默认是关闭的，release_agent的内容默认为空，子cgroup在创建时会继承父cgroup中notify_on_relase和release_agent的属性。所以这两个文件只存在于cgroupfs的顶层目录中。\n\n\n\n## 5 clone_children有什么用？\n\n> clone_chilren仅针对cpu绑定（cpuset），如果clone_children使能，新的cpuset cgroup在初始化时会继承父cgroup的属性。\n\n## 6 cgroup怎么用？\n\n>\n>\n>假设现在要将一个新的任务加入到cgroup，功能是将该任务的进程在指定的cpu上运行，因此我们使用\"cpuset\"cgroup 子系统，操作的大致步骤如下：\n>\n>1）mount -t tmpfs cgroup_root /sys/fs/cgroup \n>\n>挂载cgroup根文件系统，类型为tmpfs\n>\n>2）mkdir /sys/fs/cgroup/cpuset\n>\n>在cgroupfs根目录下创建子cgroup，名为cpuset\n>\n>3）mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset\n>\n>将名为cpuset的cgroup关联到cpuset子系统\n>\n>4）在cpuset目录下创建目录，生成一个子cgroup，属性文件中写入相应内容，设置属性。\n>\n>5）启动需要限制的进程，查找其对应的进程ID，将其写入对应的task文件中\n>\n>以下操作步骤是创建一个名为\"Charlie\"的cgroup，这个cgroup的资源包含cpu2，cpu3和内存节点1，将shell进程附加到这个cgroup。\n>\n>mount -t tmpfs cgroup_root /sys/fs/cgroup\n>\n>mkdir /sys/fs/cgroup/cpuset\n>\n>mount -t cgroup cpuset -o cpuset /sys/fs/cgroup/cpuset\n>\n>cd /sys/fs/cgroup/cpuset\n>\n>mkdir Charlie\n>\n>cd Charlie\n>\n>echo 2-3 > cpuset.cpus\n>\n>echo 1 > cpuset.mems\n>\n>echo $$ > tasks\n>\n>sh\n>\n>cat /proc/self/cgroup\n\n转：\n\n https://blog.csdn.net/huang987246510/article/details/80765628\n","source":"back_posts/cgroup.md","raw":"---\ntitle: cgroup\ncategories:\n  - kernel\ntags:\n  - cgroup\ndate: 2024-05-16 15:30:33\n---\n\n[toc]\n\ncgroup是linux内核实现、用于控制linux系统资源的组件。因此要了解cgroup，首先从引入这个组件的kernel文档中寻找。\n\n去到举世闻名的www.kernel.org\n\n找到介绍文档：Documentation/cgroup-v1/cgroups.txt\n\n## 1 什么是cgroup?\n\n>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup绑定一个进程集合到一个或多个子系统上。\n>\n>subsystem，子系统，一个通过cgroup提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。\n>\n>hierarchy，层级树，多个cgroup的集合，这些集合构成的树叫hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy上的层次关系通过cgroupfs虚拟文件系统显示。系统允许多个hierarchy同时存在，每个hierachy包含系统中的部分或者全部进程集合。\n>\n>cgroupfs是用户管理操纵cgroup的主要接口：通过在cgroupfs文件系统中创建目录，实现cgroup的创建；通过向目录下的属性文件写入内容，设置cgroup对资源的控制；向task属性文件写入进程ID，可以将进程绑定到某个cgroup，以此达到控制进程资源使用的目的；也可以列出cgroup包含的进程pid。这些操作影响的是sysfs关联的hierarchy，对其它hierarchy没有影响。\n>\n>对于cgroup，其本身的作用只是任务跟踪。但其它系统（比如cpusets，cpuacct），可以利用cgroup的这个功能实现一些新的属性，比如统计或者控制一个cgroup中进程可以访问的资源。举个例子，cpusets子系统可以将进程绑定到特定的cpu和内存节点上。\n\n2 为什么需要cgroup?\n\n>\n>\n>这个问题相当于问cgroup重要吗？有哪些地方用到了。回答是重要，又不重要。如果你用到了，那就重要，如果没有用到，那就不重要。呵呵呵~~~~其实挺重要的。cgroup的主要运用是资源跟踪。我接触的场景就是用cgroup控制虚拟机进程或者docker进程可以使用的资源。当你想在linux对应用进程做资源访问控制的时候，cgroup就派上用场了。\n\n## 3 cgroup怎么实现的？\n\n>——    系统中的每个进程（task_struct，后面用task代指）都持有一个指向css_set结构的指针。\n>\n>——    一个css_set结构体包含了一组指向cgroup_subsys_state对象的指针（所以一个task可以附加到多个cgroup上），每个cgroup_subsys_state在系统中都有注册。task结构体没有直接指向hierarchy中一个节点（cgroup）的指针。但可以通过其包含的cgroup_subsys_state间接确定。这样设计的原因是cpu对subsystem state的访问很频繁，但涉及到将task绑定到cgroup的操作却不多。task中还有个双向链表cg_list，这个链表维护所有同属于一个css_set的tasks。\n>\n>——    用户可以通过cgroupfs文件系统来浏览cgroup hierarchy。\n>\n>——    用户可以列出任意一个cgroup上附着的task PID\n>\n>cgroup在kernel中除了本身功能的实现外，在kernel中还有两处修改：\n>\n>——    在kernel启动时对root cgroup的初始化和css_set结构体的初始化。这个在init/main.c文件中实现。\n>\n>——    在task的创建（fork）和退出（exit）阶段，对应地将task与css_set进行绑定和解绑。\n>\n>另外，cgroup为了向用户提供操作接口，特别开发了一个虚拟文件系统类型（cgroupfs），这个文件系统与sysfs，proc类似。cgroupfs是向用户展示cgroup的hierarchy，通知kernel用户对cgroup改动的窗口。挂载cgroupfs时通过选项（-otype）指定要挂载的子系统类型，如果不指定，默认挂载所有的注册的子系统。\n>\n>如果新挂载的cgroup关联的hierachy与系统中存在的hierarchy完全一样，那么cgroupfs会拒绝挂载。如果没有匹配到相同的hierarchy，但新挂载hierachy声明的资源正在被已经存在的hierarchy使用，挂载会报-EBUSY错误。\n>\n>当前cgroup还没有实现向已经存在的cgroup hierarchy绑定新子系统的操作，将子系统从cgroup hierachy解绑也不允许。这些操作在未来也许会支持，但也可能会进一步产生错误恢复的一系列问题。\n>\n>卸载cgroupfs时，如果它的子cgroupfs还在活动，那么子cgroupfs还是会持续生效。直到所有的子cgroupfs不再活动，卸载cgroupfs才会真正生效。\n>\n>cgroupfs下不能再挂载其它类型的文件系统。所有对cgroup的查询修改都只通过cgroupfs文件系统来完成。\n>\n>系统中的所有task，在/proc/pid目录下都有一个名为cgroup的文件，这个文件展示了该task相对cgroupfs 根的路径。通过查看这个文件，可以了解一个进程在cgroup hierarchy的位置。以此得到task可以使用的资源信息。\n>\n>cgroupfs中目录表示cgroup，每个目录在创建时默认生成如下的属性文件，这些文件描述了cgroup的信息：\n>\n>——    tasks: 所有附属于这个cgroup的进程ID列表。tasks文件中增加进程ID，表示将进程加入这个cgroup，进程能够使用的资源受cgroup限制。\n>\n>——    cgroup.procs: 所有附属于这个cgroup线程组ID，将TGID写入这个文件后，TGID所在进程包含的所有线程都加入这个cgroup，这些线程受cgroup限制。\n\n> PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。\n> TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。\n> PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。\n> SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。\n> ——    notify_on_release flag: 标记退出时是否运行release agent\n>\n> ——    release_agent: 制定要运行的release agent的路径，这个属性文件只在cgroup的顶层目录中存在。\n>\n> 以上文件是每个cgroup基本的属性文件，对于不同的子系统，对应的cgroup可能会有其它附加的属性文件，存在于其对应的cgroup目录之下。\n>\n> 通过mkdir命令创建cgroup，通过向目录下的文件写入适当的数值设置修改cgroup的属性。\n>\n> 嵌套的cgroups，指定了层级结构，以此将系统资源划分成嵌套的，动态可变的更小的资源块。\n>\n> 一个进程可以附加到多个不同的cgroup中，只要这些cgroup不在同一个层级树上即可。因为cgroupfs会保证新挂载的cgroup关联的层级树全局唯一。子进程在被创建后默认附加到父进程所在的cgroup，后面用户可以根据需要将其移动到别的cgroup。\n>\n> 当进程从一个cgroup被移动到另一个cgroup。进程的task_struct会获取一个新的css_set指针：如果这个cgroup所在的css_set已经存在就重用这个css_set，否则就新分配一个css_set。kernel会在全局的hash表中查找确认cgroup所属的css_set是否存在。\n\n## 4 notify_on_release 是做什么的？\n\n>如果cgroup中使能notify_on_release，cgroup中的最后一个进程被移除，最后一个子cgroup也被删除时，cgroup会主动通知kernel。接收到消息的kernel会执行release_agent文件中指定的程序。notify_on_release默认是关闭的，release_agent的内容默认为空，子cgroup在创建时会继承父cgroup中notify_on_relase和release_agent的属性。所以这两个文件只存在于cgroupfs的顶层目录中。\n\n\n\n## 5 clone_children有什么用？\n\n> clone_chilren仅针对cpu绑定（cpuset），如果clone_children使能，新的cpuset cgroup在初始化时会继承父cgroup的属性。\n\n## 6 cgroup怎么用？\n\n>\n>\n>假设现在要将一个新的任务加入到cgroup，功能是将该任务的进程在指定的cpu上运行，因此我们使用\"cpuset\"cgroup 子系统，操作的大致步骤如下：\n>\n>1）mount -t tmpfs cgroup_root /sys/fs/cgroup \n>\n>挂载cgroup根文件系统，类型为tmpfs\n>\n>2）mkdir /sys/fs/cgroup/cpuset\n>\n>在cgroupfs根目录下创建子cgroup，名为cpuset\n>\n>3）mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset\n>\n>将名为cpuset的cgroup关联到cpuset子系统\n>\n>4）在cpuset目录下创建目录，生成一个子cgroup，属性文件中写入相应内容，设置属性。\n>\n>5）启动需要限制的进程，查找其对应的进程ID，将其写入对应的task文件中\n>\n>以下操作步骤是创建一个名为\"Charlie\"的cgroup，这个cgroup的资源包含cpu2，cpu3和内存节点1，将shell进程附加到这个cgroup。\n>\n>mount -t tmpfs cgroup_root /sys/fs/cgroup\n>\n>mkdir /sys/fs/cgroup/cpuset\n>\n>mount -t cgroup cpuset -o cpuset /sys/fs/cgroup/cpuset\n>\n>cd /sys/fs/cgroup/cpuset\n>\n>mkdir Charlie\n>\n>cd Charlie\n>\n>echo 2-3 > cpuset.cpus\n>\n>echo 1 > cpuset.mems\n>\n>echo $$ > tasks\n>\n>sh\n>\n>cat /proc/self/cgroup\n\n转：\n\n https://blog.csdn.net/huang987246510/article/details/80765628\n","updated":"2024-05-16T11:01:26.743Z","path":"back_posts/cgroup.html","_id":"clw95434h0000auw06l6s63cc","comments":1,"layout":"page","content":"<p>[toc]</p>\n<p>cgroup是linux内核实现、用于控制linux系统资源的组件。因此要了解cgroup，首先从引入这个组件的kernel文档中寻找。</p>\n<p>去到举世闻名的<a href=\"http://www.kernel.org/\">www.kernel.org</a></p>\n<p>找到介绍文档：Documentation&#x2F;cgroup-v1&#x2F;cgroups.txt</p>\n<h2 id=\"1-什么是cgroup\"><a href=\"#1-什么是cgroup\" class=\"headerlink\" title=\"1 什么是cgroup?\"></a>1 什么是cgroup?</h2><blockquote>\n<p>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup绑定一个进程集合到一个或多个子系统上。</p>\n<p>subsystem，子系统，一个通过cgroup提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。</p>\n<p>hierarchy，层级树，多个cgroup的集合，这些集合构成的树叫hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy上的层次关系通过cgroupfs虚拟文件系统显示。系统允许多个hierarchy同时存在，每个hierachy包含系统中的部分或者全部进程集合。</p>\n<p>cgroupfs是用户管理操纵cgroup的主要接口：通过在cgroupfs文件系统中创建目录，实现cgroup的创建；通过向目录下的属性文件写入内容，设置cgroup对资源的控制；向task属性文件写入进程ID，可以将进程绑定到某个cgroup，以此达到控制进程资源使用的目的；也可以列出cgroup包含的进程pid。这些操作影响的是sysfs关联的hierarchy，对其它hierarchy没有影响。</p>\n<p>对于cgroup，其本身的作用只是任务跟踪。但其它系统（比如cpusets，cpuacct），可以利用cgroup的这个功能实现一些新的属性，比如统计或者控制一个cgroup中进程可以访问的资源。举个例子，cpusets子系统可以将进程绑定到特定的cpu和内存节点上。</p>\n</blockquote>\n<p>2 为什么需要cgroup?</p>\n<blockquote>\n<p>这个问题相当于问cgroup重要吗？有哪些地方用到了。回答是重要，又不重要。如果你用到了，那就重要，如果没有用到，那就不重要。呵呵呵~~~~其实挺重要的。cgroup的主要运用是资源跟踪。我接触的场景就是用cgroup控制虚拟机进程或者docker进程可以使用的资源。当你想在linux对应用进程做资源访问控制的时候，cgroup就派上用场了。</p>\n</blockquote>\n<h2 id=\"3-cgroup怎么实现的？\"><a href=\"#3-cgroup怎么实现的？\" class=\"headerlink\" title=\"3 cgroup怎么实现的？\"></a>3 cgroup怎么实现的？</h2><blockquote>\n<p>——    系统中的每个进程（task_struct，后面用task代指）都持有一个指向css_set结构的指针。</p>\n<p>——    一个css_set结构体包含了一组指向cgroup_subsys_state对象的指针（所以一个task可以附加到多个cgroup上），每个cgroup_subsys_state在系统中都有注册。task结构体没有直接指向hierarchy中一个节点（cgroup）的指针。但可以通过其包含的cgroup_subsys_state间接确定。这样设计的原因是cpu对subsystem state的访问很频繁，但涉及到将task绑定到cgroup的操作却不多。task中还有个双向链表cg_list，这个链表维护所有同属于一个css_set的tasks。</p>\n<p>——    用户可以通过cgroupfs文件系统来浏览cgroup hierarchy。</p>\n<p>——    用户可以列出任意一个cgroup上附着的task PID</p>\n<p>cgroup在kernel中除了本身功能的实现外，在kernel中还有两处修改：</p>\n<p>——    在kernel启动时对root cgroup的初始化和css_set结构体的初始化。这个在init&#x2F;main.c文件中实现。</p>\n<p>——    在task的创建（fork）和退出（exit）阶段，对应地将task与css_set进行绑定和解绑。</p>\n<p>另外，cgroup为了向用户提供操作接口，特别开发了一个虚拟文件系统类型（cgroupfs），这个文件系统与sysfs，proc类似。cgroupfs是向用户展示cgroup的hierarchy，通知kernel用户对cgroup改动的窗口。挂载cgroupfs时通过选项（-otype）指定要挂载的子系统类型，如果不指定，默认挂载所有的注册的子系统。</p>\n<p>如果新挂载的cgroup关联的hierachy与系统中存在的hierarchy完全一样，那么cgroupfs会拒绝挂载。如果没有匹配到相同的hierarchy，但新挂载hierachy声明的资源正在被已经存在的hierarchy使用，挂载会报-EBUSY错误。</p>\n<p>当前cgroup还没有实现向已经存在的cgroup hierarchy绑定新子系统的操作，将子系统从cgroup hierachy解绑也不允许。这些操作在未来也许会支持，但也可能会进一步产生错误恢复的一系列问题。</p>\n<p>卸载cgroupfs时，如果它的子cgroupfs还在活动，那么子cgroupfs还是会持续生效。直到所有的子cgroupfs不再活动，卸载cgroupfs才会真正生效。</p>\n<p>cgroupfs下不能再挂载其它类型的文件系统。所有对cgroup的查询修改都只通过cgroupfs文件系统来完成。</p>\n<p>系统中的所有task，在&#x2F;proc&#x2F;pid目录下都有一个名为cgroup的文件，这个文件展示了该task相对cgroupfs 根的路径。通过查看这个文件，可以了解一个进程在cgroup hierarchy的位置。以此得到task可以使用的资源信息。</p>\n<p>cgroupfs中目录表示cgroup，每个目录在创建时默认生成如下的属性文件，这些文件描述了cgroup的信息：</p>\n<p>——    tasks: 所有附属于这个cgroup的进程ID列表。tasks文件中增加进程ID，表示将进程加入这个cgroup，进程能够使用的资源受cgroup限制。</p>\n<p>——    cgroup.procs: 所有附属于这个cgroup线程组ID，将TGID写入这个文件后，TGID所在进程包含的所有线程都加入这个cgroup，这些线程受cgroup限制。</p>\n</blockquote>\n<blockquote>\n<p>PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。<br>TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。<br>PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。<br>SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。<br>——    notify_on_release flag: 标记退出时是否运行release agent</p>\n<p>——    release_agent: 制定要运行的release agent的路径，这个属性文件只在cgroup的顶层目录中存在。</p>\n<p>以上文件是每个cgroup基本的属性文件，对于不同的子系统，对应的cgroup可能会有其它附加的属性文件，存在于其对应的cgroup目录之下。</p>\n<p>通过mkdir命令创建cgroup，通过向目录下的文件写入适当的数值设置修改cgroup的属性。</p>\n<p>嵌套的cgroups，指定了层级结构，以此将系统资源划分成嵌套的，动态可变的更小的资源块。</p>\n<p>一个进程可以附加到多个不同的cgroup中，只要这些cgroup不在同一个层级树上即可。因为cgroupfs会保证新挂载的cgroup关联的层级树全局唯一。子进程在被创建后默认附加到父进程所在的cgroup，后面用户可以根据需要将其移动到别的cgroup。</p>\n<p>当进程从一个cgroup被移动到另一个cgroup。进程的task_struct会获取一个新的css_set指针：如果这个cgroup所在的css_set已经存在就重用这个css_set，否则就新分配一个css_set。kernel会在全局的hash表中查找确认cgroup所属的css_set是否存在。</p>\n</blockquote>\n<h2 id=\"4-notify-on-release-是做什么的？\"><a href=\"#4-notify-on-release-是做什么的？\" class=\"headerlink\" title=\"4 notify_on_release 是做什么的？\"></a>4 notify_on_release 是做什么的？</h2><blockquote>\n<p>如果cgroup中使能notify_on_release，cgroup中的最后一个进程被移除，最后一个子cgroup也被删除时，cgroup会主动通知kernel。接收到消息的kernel会执行release_agent文件中指定的程序。notify_on_release默认是关闭的，release_agent的内容默认为空，子cgroup在创建时会继承父cgroup中notify_on_relase和release_agent的属性。所以这两个文件只存在于cgroupfs的顶层目录中。</p>\n</blockquote>\n<h2 id=\"5-clone-children有什么用？\"><a href=\"#5-clone-children有什么用？\" class=\"headerlink\" title=\"5 clone_children有什么用？\"></a>5 clone_children有什么用？</h2><blockquote>\n<p>clone_chilren仅针对cpu绑定（cpuset），如果clone_children使能，新的cpuset cgroup在初始化时会继承父cgroup的属性。</p>\n</blockquote>\n<h2 id=\"6-cgroup怎么用？\"><a href=\"#6-cgroup怎么用？\" class=\"headerlink\" title=\"6 cgroup怎么用？\"></a>6 cgroup怎么用？</h2><blockquote>\n<p>假设现在要将一个新的任务加入到cgroup，功能是将该任务的进程在指定的cpu上运行，因此我们使用”cpuset”cgroup 子系统，操作的大致步骤如下：</p>\n<p>1）mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup </p>\n<p>挂载cgroup根文件系统，类型为tmpfs</p>\n<p>2）mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>在cgroupfs根目录下创建子cgroup，名为cpuset</p>\n<p>3）mount -t cgroup -o cpuset cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>将名为cpuset的cgroup关联到cpuset子系统</p>\n<p>4）在cpuset目录下创建目录，生成一个子cgroup，属性文件中写入相应内容，设置属性。</p>\n<p>5）启动需要限制的进程，查找其对应的进程ID，将其写入对应的task文件中</p>\n<p>以下操作步骤是创建一个名为”Charlie”的cgroup，这个cgroup的资源包含cpu2，cpu3和内存节点1，将shell进程附加到这个cgroup。</p>\n<p>mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup</p>\n<p>mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>mount -t cgroup cpuset -o cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>cd &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>mkdir Charlie</p>\n<p>cd Charlie</p>\n<p>echo 2-3 &gt; cpuset.cpus</p>\n<p>echo 1 &gt; cpuset.mems</p>\n<p>echo $$ &gt; tasks</p>\n<p>sh</p>\n<p>cat &#x2F;proc&#x2F;self&#x2F;cgroup</p>\n</blockquote>\n<p>转：</p>\n<p> <a href=\"https://blog.csdn.net/huang987246510/article/details/80765628\">https://blog.csdn.net/huang987246510/article/details/80765628</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p>cgroup是linux内核实现、用于控制linux系统资源的组件。因此要了解cgroup，首先从引入这个组件的kernel文档中寻找。</p>\n<p>去到举世闻名的<a href=\"http://www.kernel.org/\">www.kernel.org</a></p>\n<p>找到介绍文档：Documentation&#x2F;cgroup-v1&#x2F;cgroups.txt</p>\n<h2 id=\"1-什么是cgroup\"><a href=\"#1-什么是cgroup\" class=\"headerlink\" title=\"1 什么是cgroup?\"></a>1 什么是cgroup?</h2><blockquote>\n<p>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup绑定一个进程集合到一个或多个子系统上。</p>\n<p>subsystem，子系统，一个通过cgroup提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。</p>\n<p>hierarchy，层级树，多个cgroup的集合，这些集合构成的树叫hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy上的层次关系通过cgroupfs虚拟文件系统显示。系统允许多个hierarchy同时存在，每个hierachy包含系统中的部分或者全部进程集合。</p>\n<p>cgroupfs是用户管理操纵cgroup的主要接口：通过在cgroupfs文件系统中创建目录，实现cgroup的创建；通过向目录下的属性文件写入内容，设置cgroup对资源的控制；向task属性文件写入进程ID，可以将进程绑定到某个cgroup，以此达到控制进程资源使用的目的；也可以列出cgroup包含的进程pid。这些操作影响的是sysfs关联的hierarchy，对其它hierarchy没有影响。</p>\n<p>对于cgroup，其本身的作用只是任务跟踪。但其它系统（比如cpusets，cpuacct），可以利用cgroup的这个功能实现一些新的属性，比如统计或者控制一个cgroup中进程可以访问的资源。举个例子，cpusets子系统可以将进程绑定到特定的cpu和内存节点上。</p>\n</blockquote>\n<p>2 为什么需要cgroup?</p>\n<blockquote>\n<p>这个问题相当于问cgroup重要吗？有哪些地方用到了。回答是重要，又不重要。如果你用到了，那就重要，如果没有用到，那就不重要。呵呵呵~~~~其实挺重要的。cgroup的主要运用是资源跟踪。我接触的场景就是用cgroup控制虚拟机进程或者docker进程可以使用的资源。当你想在linux对应用进程做资源访问控制的时候，cgroup就派上用场了。</p>\n</blockquote>\n<h2 id=\"3-cgroup怎么实现的？\"><a href=\"#3-cgroup怎么实现的？\" class=\"headerlink\" title=\"3 cgroup怎么实现的？\"></a>3 cgroup怎么实现的？</h2><blockquote>\n<p>——    系统中的每个进程（task_struct，后面用task代指）都持有一个指向css_set结构的指针。</p>\n<p>——    一个css_set结构体包含了一组指向cgroup_subsys_state对象的指针（所以一个task可以附加到多个cgroup上），每个cgroup_subsys_state在系统中都有注册。task结构体没有直接指向hierarchy中一个节点（cgroup）的指针。但可以通过其包含的cgroup_subsys_state间接确定。这样设计的原因是cpu对subsystem state的访问很频繁，但涉及到将task绑定到cgroup的操作却不多。task中还有个双向链表cg_list，这个链表维护所有同属于一个css_set的tasks。</p>\n<p>——    用户可以通过cgroupfs文件系统来浏览cgroup hierarchy。</p>\n<p>——    用户可以列出任意一个cgroup上附着的task PID</p>\n<p>cgroup在kernel中除了本身功能的实现外，在kernel中还有两处修改：</p>\n<p>——    在kernel启动时对root cgroup的初始化和css_set结构体的初始化。这个在init&#x2F;main.c文件中实现。</p>\n<p>——    在task的创建（fork）和退出（exit）阶段，对应地将task与css_set进行绑定和解绑。</p>\n<p>另外，cgroup为了向用户提供操作接口，特别开发了一个虚拟文件系统类型（cgroupfs），这个文件系统与sysfs，proc类似。cgroupfs是向用户展示cgroup的hierarchy，通知kernel用户对cgroup改动的窗口。挂载cgroupfs时通过选项（-otype）指定要挂载的子系统类型，如果不指定，默认挂载所有的注册的子系统。</p>\n<p>如果新挂载的cgroup关联的hierachy与系统中存在的hierarchy完全一样，那么cgroupfs会拒绝挂载。如果没有匹配到相同的hierarchy，但新挂载hierachy声明的资源正在被已经存在的hierarchy使用，挂载会报-EBUSY错误。</p>\n<p>当前cgroup还没有实现向已经存在的cgroup hierarchy绑定新子系统的操作，将子系统从cgroup hierachy解绑也不允许。这些操作在未来也许会支持，但也可能会进一步产生错误恢复的一系列问题。</p>\n<p>卸载cgroupfs时，如果它的子cgroupfs还在活动，那么子cgroupfs还是会持续生效。直到所有的子cgroupfs不再活动，卸载cgroupfs才会真正生效。</p>\n<p>cgroupfs下不能再挂载其它类型的文件系统。所有对cgroup的查询修改都只通过cgroupfs文件系统来完成。</p>\n<p>系统中的所有task，在&#x2F;proc&#x2F;pid目录下都有一个名为cgroup的文件，这个文件展示了该task相对cgroupfs 根的路径。通过查看这个文件，可以了解一个进程在cgroup hierarchy的位置。以此得到task可以使用的资源信息。</p>\n<p>cgroupfs中目录表示cgroup，每个目录在创建时默认生成如下的属性文件，这些文件描述了cgroup的信息：</p>\n<p>——    tasks: 所有附属于这个cgroup的进程ID列表。tasks文件中增加进程ID，表示将进程加入这个cgroup，进程能够使用的资源受cgroup限制。</p>\n<p>——    cgroup.procs: 所有附属于这个cgroup线程组ID，将TGID写入这个文件后，TGID所在进程包含的所有线程都加入这个cgroup，这些线程受cgroup限制。</p>\n</blockquote>\n<blockquote>\n<p>PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。<br>TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。<br>PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。<br>SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。<br>——    notify_on_release flag: 标记退出时是否运行release agent</p>\n<p>——    release_agent: 制定要运行的release agent的路径，这个属性文件只在cgroup的顶层目录中存在。</p>\n<p>以上文件是每个cgroup基本的属性文件，对于不同的子系统，对应的cgroup可能会有其它附加的属性文件，存在于其对应的cgroup目录之下。</p>\n<p>通过mkdir命令创建cgroup，通过向目录下的文件写入适当的数值设置修改cgroup的属性。</p>\n<p>嵌套的cgroups，指定了层级结构，以此将系统资源划分成嵌套的，动态可变的更小的资源块。</p>\n<p>一个进程可以附加到多个不同的cgroup中，只要这些cgroup不在同一个层级树上即可。因为cgroupfs会保证新挂载的cgroup关联的层级树全局唯一。子进程在被创建后默认附加到父进程所在的cgroup，后面用户可以根据需要将其移动到别的cgroup。</p>\n<p>当进程从一个cgroup被移动到另一个cgroup。进程的task_struct会获取一个新的css_set指针：如果这个cgroup所在的css_set已经存在就重用这个css_set，否则就新分配一个css_set。kernel会在全局的hash表中查找确认cgroup所属的css_set是否存在。</p>\n</blockquote>\n<h2 id=\"4-notify-on-release-是做什么的？\"><a href=\"#4-notify-on-release-是做什么的？\" class=\"headerlink\" title=\"4 notify_on_release 是做什么的？\"></a>4 notify_on_release 是做什么的？</h2><blockquote>\n<p>如果cgroup中使能notify_on_release，cgroup中的最后一个进程被移除，最后一个子cgroup也被删除时，cgroup会主动通知kernel。接收到消息的kernel会执行release_agent文件中指定的程序。notify_on_release默认是关闭的，release_agent的内容默认为空，子cgroup在创建时会继承父cgroup中notify_on_relase和release_agent的属性。所以这两个文件只存在于cgroupfs的顶层目录中。</p>\n</blockquote>\n<h2 id=\"5-clone-children有什么用？\"><a href=\"#5-clone-children有什么用？\" class=\"headerlink\" title=\"5 clone_children有什么用？\"></a>5 clone_children有什么用？</h2><blockquote>\n<p>clone_chilren仅针对cpu绑定（cpuset），如果clone_children使能，新的cpuset cgroup在初始化时会继承父cgroup的属性。</p>\n</blockquote>\n<h2 id=\"6-cgroup怎么用？\"><a href=\"#6-cgroup怎么用？\" class=\"headerlink\" title=\"6 cgroup怎么用？\"></a>6 cgroup怎么用？</h2><blockquote>\n<p>假设现在要将一个新的任务加入到cgroup，功能是将该任务的进程在指定的cpu上运行，因此我们使用”cpuset”cgroup 子系统，操作的大致步骤如下：</p>\n<p>1）mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup </p>\n<p>挂载cgroup根文件系统，类型为tmpfs</p>\n<p>2）mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>在cgroupfs根目录下创建子cgroup，名为cpuset</p>\n<p>3）mount -t cgroup -o cpuset cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>将名为cpuset的cgroup关联到cpuset子系统</p>\n<p>4）在cpuset目录下创建目录，生成一个子cgroup，属性文件中写入相应内容，设置属性。</p>\n<p>5）启动需要限制的进程，查找其对应的进程ID，将其写入对应的task文件中</p>\n<p>以下操作步骤是创建一个名为”Charlie”的cgroup，这个cgroup的资源包含cpu2，cpu3和内存节点1，将shell进程附加到这个cgroup。</p>\n<p>mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup</p>\n<p>mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>mount -t cgroup cpuset -o cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>cd &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>mkdir Charlie</p>\n<p>cd Charlie</p>\n<p>echo 2-3 &gt; cpuset.cpus</p>\n<p>echo 1 &gt; cpuset.mems</p>\n<p>echo $$ &gt; tasks</p>\n<p>sh</p>\n<p>cat &#x2F;proc&#x2F;self&#x2F;cgroup</p>\n</blockquote>\n<p>转：</p>\n<p> <a href=\"https://blog.csdn.net/huang987246510/article/details/80765628\">https://blog.csdn.net/huang987246510/article/details/80765628</a></p>\n"},{"title":"uboot-01-概念","categories":["uboot"],"tags":["uboot概念"],"date":"2024-05-15T13:59:01.000Z","_content":"\nuboot(Universal Boot Loader)\n\nuboot 官网为 http://www.denx.de/wiki/U-Boot/\n\nLinux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段\nbootloader 程序。这段 bootloader 程序会先初始化DDR 等外设，然后将 Linux 内核从 flash(NAND，\nNOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核\n\nuboot主要目的是为系统启动做准备\n\nuboot是一种通用的bootloader，支持多种架构\n\n\n\n\n\n\n\n# uboot常见命令\n\n\n\n\n\n","source":"back_posts/uboot-01-概念.md","raw":"---\ntitle: uboot-01-概念\ncategories:\n  - uboot\ntags:\n  - uboot概念\ndate: 2024-05-15 21:59:01\n\n---\n\nuboot(Universal Boot Loader)\n\nuboot 官网为 http://www.denx.de/wiki/U-Boot/\n\nLinux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段\nbootloader 程序。这段 bootloader 程序会先初始化DDR 等外设，然后将 Linux 内核从 flash(NAND，\nNOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核\n\nuboot主要目的是为系统启动做准备\n\nuboot是一种通用的bootloader，支持多种架构\n\n\n\n\n\n\n\n# uboot常见命令\n\n\n\n\n\n","updated":"2024-05-16T07:35:43.760Z","path":"back_posts/uboot-01-概念.html","comments":1,"layout":"page","_id":"clw95434p0002auw01duxgfqw","content":"<p>uboot(Universal Boot Loader)</p>\n<p>uboot 官网为 <a href=\"http://www.denx.de/wiki/U-Boot/\">http://www.denx.de/wiki/U-Boot/</a></p>\n<p>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段<br>bootloader 程序。这段 bootloader 程序会先初始化DDR 等外设，然后将 Linux 内核从 flash(NAND，<br>NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核</p>\n<p>uboot主要目的是为系统启动做准备</p>\n<p>uboot是一种通用的bootloader，支持多种架构</p>\n<h1 id=\"uboot常见命令\"><a href=\"#uboot常见命令\" class=\"headerlink\" title=\"uboot常见命令\"></a>uboot常见命令</h1>","site":{"data":{}},"excerpt":"","more":"<p>uboot(Universal Boot Loader)</p>\n<p>uboot 官网为 <a href=\"http://www.denx.de/wiki/U-Boot/\">http://www.denx.de/wiki/U-Boot/</a></p>\n<p>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段<br>bootloader 程序。这段 bootloader 程序会先初始化DDR 等外设，然后将 Linux 内核从 flash(NAND，<br>NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核</p>\n<p>uboot主要目的是为系统启动做准备</p>\n<p>uboot是一种通用的bootloader，支持多种架构</p>\n<h1 id=\"uboot常见命令\"><a href=\"#uboot常见命令\" class=\"headerlink\" title=\"uboot常见命令\"></a>uboot常见命令</h1>"},{"title":"pinctrl","categories":["kernel"],"tags":["pinctrl"],"date":"2024-05-16T05:33:03.000Z","_content":"\n\n\n查看具体设备树中的宏定义\n\ninclude/dt-bindings/gpio/gpio.h\n\ninclude/dt-bindings/pinctrl/rockchip.h\n\ndt-bindings/clock/rk3588-cru.h\n\n\n\n查看物理单系统中的pinctrl配置，获取物理外设真实的device name\n\n  cat /sys/kernel/debug/pinctrl/pinctrl-maps\n\n\n\n\n\npinctrl的三大作用,有助于理解相关结构体\n\n1.引脚枚举与命名 enumerating and naming\n\n2.引脚服用 Multiplexing：比如用作GPIO、I2C或其他功能\n\n3.引脚配置 Configuration：比如上拉、下拉、open drain、驱动强度等\n\n\n\n\n\nrk3588s.dtsi\nrk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例\n\n查看引脚的复用情况\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins\n\nRK3588频脚计算方式与一般的计算方式没有区别：\nGPIO pin脚计算公式：pin = bank * 32 + number\nGPIO 小组编号计算公式：number = group * 8 + X\n\n摘自官网：\n\n下面演示GPIO1_D0 pin脚计算方法：\n\nbank = 1;      //GPIO1_D0 => 1, bank ∈ [0,4]\n\ngroup = 3;      //GPIO1_D0 => 3, group ∈ {(A=0), (B=1), (C=2), (D=3)}\n\nX = 0;       //GPIO1_D0 => 0, X ∈ [0,7]\n\nnumber = group * 8 + X = 3 * 8 + 0 = 24\n\npin = bank*32 + number= 1 * 32 + 24 = 56;\n\nGPIO1_D0 对应的设备树属性描述为:<&gpio1 24 GPIO_ACTIVE_HIGH>,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的\n的宏定义可知，也可以将GPIO1_D0描述为<&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>。\n\n\n\n## client端相关结构体\n\nhttps://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&icon_type=3&file_type=20 \n\n![image-20240530170508734](../imgs/image-20240530170508734.png)\n\n\n\n\n\nrk3588-pinctrl-pin-config-debug\n\n```\ncd /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl \ncat pinmux-pins  \ncat ../pinctrl-handles\t#查看所有pinctrl client state\n```\n\n\n\n```\n\nrk3588s.dtsi\nrk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例\n\n查看引脚的复用情况\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins\n\nRK3588频脚计算方式与一般的计算方式没有区别：\nGPIO pin脚计算公式：pin = bank * 32 + number\nGPIO 小组编号计算公式：number = group * 8 + X\n\n摘自官网：\n\n下面演示GPIO1_D0 pin脚计算方法：\n\nbank = 1;      //GPIO1_D0 => 1, bank ∈ [0,4]\n\ngroup = 3;      //GPIO1_D0 => 3, group ∈ {(A=0), (B=1), (C=2), (D=3)}\n\nX = 0;       //GPIO1_D0 => 0, X ∈ [0,7]\n\nnumber = group * 8 + X = 3 * 8 + 0 = 24\n\npin = bank*32 + number= 1 * 32 + 24 = 56;\n\nGPIO1_D0 对应的设备树属性描述为:<&gpio1 24 GPIO_ACTIVE_HIGH>,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的\n的宏定义可知，也可以将GPIO1_D0描述为<&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>。\n\n\nrockchip_pinctrl_parse_dt\n\tinfo->groups = devm_kcalloc(dev, info->ngroups, sizeof(*info->groups), GFP_KERNEL);\n\trockchip_pinctrl_parse_functions\n\t\trockchip_pinctrl_parse_groups\n\t\t\tpinconf_generic_parse_dt_config\n\t\t\t\tparse_dt_cfg\n\t\t\t\t\tpinconf_to_config_packed\n\t\t\t\t\t\tPIN_CONF_PACKED\n\n#define PIN_CONF_PACKED(p, a) ((a << 8) | ((unsigned long) p & 0xffUL))\n5,1\n105\n\n\nof_property_read_u32(np, par->property, &val);\n\tof_property_read_u32_array(np, property, val, 1);\n\t\tof_property_read_variable_u32_array(np, property, val, 1, 0);\n\t\tof_find_property_value_of_size(np, property, 4, 0, &sz);\n\n\tpinctrl_show\n\t\tpinconf_show_setting\n\t\t\tpinconf_show_config\n\t\t\t\tsetting->data.configs.configs\n\nadd_setting\n\tpinconf_map_to_setting\n\n\t\tsetting->data.configs.configs = map->data.configs.configs;\n\nrockchip_dt_node_to_map\n\tpinctrl_name_to_group\n\t\trockchip_pin_group * grp = info->groups[i]\n\n\tnew_map[i].data.configs.configs = grp->data[i].configs;\n\n\nrockchip_pmx_set\n\tconst struct rockchip_pin_config *data = info->groups[group].data;\n\n\nrockchip_pin_group\n\n\nuart1 {\n\t\t/omit-if-no-ref/\n\t\tuart1m1_xfer: uart1m1-xfer {\n\t\t\trockchip,pins =\n\t\t\t\t/* uart1_rx_m1 */\n\t\t\t\t<1 RK_PB7 10 &pcfg_pull_up>,\n\t\t\t\t/* uart1_tx_m1 */\n\t\t\t\t<1 RK_PB6 10 &pcfg_pull_up>;\n\t\t};\n\n\npcfg_pull_up\n\tbias-pull-up;\n\t\tstatic const struct pinconf_generic_params dt_params[] = {\n\t\t\t{ \"bias-bus-hold\", PIN_CONFIG_BIAS_BUS_HOLD, 0 },\n\t\t\t{ \"bias-disable\", PIN_CONFIG_BIAS_DISABLE, 0 },\n\t\t\t{ \"bias-high-impedance\", PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 },\n\t\t\t{ \"bias-pull-up\", PIN_CONFIG_BIAS_PULL_UP, 1 },\n\n\t\tstatic const struct pin_config_item conf_items[] = {\n\t\t\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, \"input bias pull up\", \"ohms\", true),\n\n\t\tenum pin_config_param {\n\t\t\tPIN_CONFIG_BIAS_BUS_HOLD,\n\t\t\tPIN_CONFIG_BIAS_DISABLE,\n\t\t\tPIN_CONFIG_BIAS_HIGH_IMPEDANCE,\n\t\t\tPIN_CONFIG_BIAS_PULL_DOWN,\n\t\t\tPIN_CONFIG_BIAS_PULL_PIN_DEFAULT,\n\t\t\tPIN_CONFIG_BIAS_PULL_UP,\t//5\n```\n\n","source":"back_posts/pinctrl.md","raw":"---\ntitle: pinctrl\ncategories:\n  - kernel\ntags:\n  - pinctrl\ndate: 2024-05-16 13:33:03\n---\n\n\n\n查看具体设备树中的宏定义\n\ninclude/dt-bindings/gpio/gpio.h\n\ninclude/dt-bindings/pinctrl/rockchip.h\n\ndt-bindings/clock/rk3588-cru.h\n\n\n\n查看物理单系统中的pinctrl配置，获取物理外设真实的device name\n\n  cat /sys/kernel/debug/pinctrl/pinctrl-maps\n\n\n\n\n\npinctrl的三大作用,有助于理解相关结构体\n\n1.引脚枚举与命名 enumerating and naming\n\n2.引脚服用 Multiplexing：比如用作GPIO、I2C或其他功能\n\n3.引脚配置 Configuration：比如上拉、下拉、open drain、驱动强度等\n\n\n\n\n\nrk3588s.dtsi\nrk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例\n\n查看引脚的复用情况\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins\n\nRK3588频脚计算方式与一般的计算方式没有区别：\nGPIO pin脚计算公式：pin = bank * 32 + number\nGPIO 小组编号计算公式：number = group * 8 + X\n\n摘自官网：\n\n下面演示GPIO1_D0 pin脚计算方法：\n\nbank = 1;      //GPIO1_D0 => 1, bank ∈ [0,4]\n\ngroup = 3;      //GPIO1_D0 => 3, group ∈ {(A=0), (B=1), (C=2), (D=3)}\n\nX = 0;       //GPIO1_D0 => 0, X ∈ [0,7]\n\nnumber = group * 8 + X = 3 * 8 + 0 = 24\n\npin = bank*32 + number= 1 * 32 + 24 = 56;\n\nGPIO1_D0 对应的设备树属性描述为:<&gpio1 24 GPIO_ACTIVE_HIGH>,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的\n的宏定义可知，也可以将GPIO1_D0描述为<&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>。\n\n\n\n## client端相关结构体\n\nhttps://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&icon_type=3&file_type=20 \n\n![image-20240530170508734](../imgs/image-20240530170508734.png)\n\n\n\n\n\nrk3588-pinctrl-pin-config-debug\n\n```\ncd /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl \ncat pinmux-pins  \ncat ../pinctrl-handles\t#查看所有pinctrl client state\n```\n\n\n\n```\n\nrk3588s.dtsi\nrk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例\n\n查看引脚的复用情况\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins\n\nRK3588频脚计算方式与一般的计算方式没有区别：\nGPIO pin脚计算公式：pin = bank * 32 + number\nGPIO 小组编号计算公式：number = group * 8 + X\n\n摘自官网：\n\n下面演示GPIO1_D0 pin脚计算方法：\n\nbank = 1;      //GPIO1_D0 => 1, bank ∈ [0,4]\n\ngroup = 3;      //GPIO1_D0 => 3, group ∈ {(A=0), (B=1), (C=2), (D=3)}\n\nX = 0;       //GPIO1_D0 => 0, X ∈ [0,7]\n\nnumber = group * 8 + X = 3 * 8 + 0 = 24\n\npin = bank*32 + number= 1 * 32 + 24 = 56;\n\nGPIO1_D0 对应的设备树属性描述为:<&gpio1 24 GPIO_ACTIVE_HIGH>,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的\n的宏定义可知，也可以将GPIO1_D0描述为<&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>。\n\n\nrockchip_pinctrl_parse_dt\n\tinfo->groups = devm_kcalloc(dev, info->ngroups, sizeof(*info->groups), GFP_KERNEL);\n\trockchip_pinctrl_parse_functions\n\t\trockchip_pinctrl_parse_groups\n\t\t\tpinconf_generic_parse_dt_config\n\t\t\t\tparse_dt_cfg\n\t\t\t\t\tpinconf_to_config_packed\n\t\t\t\t\t\tPIN_CONF_PACKED\n\n#define PIN_CONF_PACKED(p, a) ((a << 8) | ((unsigned long) p & 0xffUL))\n5,1\n105\n\n\nof_property_read_u32(np, par->property, &val);\n\tof_property_read_u32_array(np, property, val, 1);\n\t\tof_property_read_variable_u32_array(np, property, val, 1, 0);\n\t\tof_find_property_value_of_size(np, property, 4, 0, &sz);\n\n\tpinctrl_show\n\t\tpinconf_show_setting\n\t\t\tpinconf_show_config\n\t\t\t\tsetting->data.configs.configs\n\nadd_setting\n\tpinconf_map_to_setting\n\n\t\tsetting->data.configs.configs = map->data.configs.configs;\n\nrockchip_dt_node_to_map\n\tpinctrl_name_to_group\n\t\trockchip_pin_group * grp = info->groups[i]\n\n\tnew_map[i].data.configs.configs = grp->data[i].configs;\n\n\nrockchip_pmx_set\n\tconst struct rockchip_pin_config *data = info->groups[group].data;\n\n\nrockchip_pin_group\n\n\nuart1 {\n\t\t/omit-if-no-ref/\n\t\tuart1m1_xfer: uart1m1-xfer {\n\t\t\trockchip,pins =\n\t\t\t\t/* uart1_rx_m1 */\n\t\t\t\t<1 RK_PB7 10 &pcfg_pull_up>,\n\t\t\t\t/* uart1_tx_m1 */\n\t\t\t\t<1 RK_PB6 10 &pcfg_pull_up>;\n\t\t};\n\n\npcfg_pull_up\n\tbias-pull-up;\n\t\tstatic const struct pinconf_generic_params dt_params[] = {\n\t\t\t{ \"bias-bus-hold\", PIN_CONFIG_BIAS_BUS_HOLD, 0 },\n\t\t\t{ \"bias-disable\", PIN_CONFIG_BIAS_DISABLE, 0 },\n\t\t\t{ \"bias-high-impedance\", PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 },\n\t\t\t{ \"bias-pull-up\", PIN_CONFIG_BIAS_PULL_UP, 1 },\n\n\t\tstatic const struct pin_config_item conf_items[] = {\n\t\t\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, \"input bias pull up\", \"ohms\", true),\n\n\t\tenum pin_config_param {\n\t\t\tPIN_CONFIG_BIAS_BUS_HOLD,\n\t\t\tPIN_CONFIG_BIAS_DISABLE,\n\t\t\tPIN_CONFIG_BIAS_HIGH_IMPEDANCE,\n\t\t\tPIN_CONFIG_BIAS_PULL_DOWN,\n\t\t\tPIN_CONFIG_BIAS_PULL_PIN_DEFAULT,\n\t\t\tPIN_CONFIG_BIAS_PULL_UP,\t//5\n```\n\n","updated":"2024-06-04T05:58:31.119Z","path":"back_posts/pinctrl.html","_id":"clw95434s0004auw02e62a41x","comments":1,"layout":"page","content":"<p>查看具体设备树中的宏定义</p>\n<p>include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h</p>\n<p>include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h</p>\n<p>dt-bindings&#x2F;clock&#x2F;rk3588-cru.h</p>\n<p>查看物理单系统中的pinctrl配置，获取物理外设真实的device name</p>\n<p>  cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;pinctrl&#x2F;pinctrl-maps</p>\n<p>pinctrl的三大作用,有助于理解相关结构体</p>\n<p>1.引脚枚举与命名 enumerating and naming</p>\n<p>2.引脚服用 Multiplexing：比如用作GPIO、I2C或其他功能</p>\n<p>3.引脚配置 Configuration：比如上拉、下拉、open drain、驱动强度等</p>\n<p>rk3588s.dtsi<br>rk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例</p>\n<p>查看引脚的复用情况<br>cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;pinctrl&#x2F;pinctrl-rockchip-pinctrl&#x2F;pinmux-pins</p>\n<p>RK3588频脚计算方式与一般的计算方式没有区别：<br>GPIO pin脚计算公式：pin &#x3D; bank * 32 + number<br>GPIO 小组编号计算公式：number &#x3D; group * 8 + X</p>\n<p>摘自官网：</p>\n<p>下面演示GPIO1_D0 pin脚计算方法：</p>\n<p>bank &#x3D; 1;      &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 1, bank ∈ [0,4]</p>\n<p>group &#x3D; 3;      &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 3, group ∈ {(A&#x3D;0), (B&#x3D;1), (C&#x3D;2), (D&#x3D;3)}</p>\n<p>X &#x3D; 0;       &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 0, X ∈ [0,7]</p>\n<p>number &#x3D; group * 8 + X &#x3D; 3 * 8 + 0 &#x3D; 24</p>\n<p>pin &#x3D; bank*32 + number&#x3D; 1 * 32 + 24 &#x3D; 56;</p>\n<p>GPIO1_D0 对应的设备树属性描述为:&lt;&amp;gpio1 24 GPIO_ACTIVE_HIGH&gt;,由kernel-5.10&#x2F;include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h的<br>的宏定义可知，也可以将GPIO1_D0描述为&lt;&amp;gpio1 RK_PD0 GPIO_ACTIVE_HIGH&gt;。</p>\n<h2 id=\"client端相关结构体\"><a href=\"#client端相关结构体\" class=\"headerlink\" title=\"client端相关结构体\"></a>client端相关结构体</h2><p><a href=\"https://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&icon_type=3&file_type=20\">https://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&amp;icon_type=3&amp;file_type=20</a> </p>\n<p><img src=\"/../imgs/image-20240530170508734.png\" alt=\"image-20240530170508734\"></p>\n<p>rk3588-pinctrl-pin-config-debug</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl </span><br><span class=\"line\">cat pinmux-pins  </span><br><span class=\"line\">cat ../pinctrl-handles\t#查看所有pinctrl client state</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">rk3588s.dtsi</span><br><span class=\"line\">rk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例</span><br><span class=\"line\"></span><br><span class=\"line\">查看引脚的复用情况</span><br><span class=\"line\">cat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins</span><br><span class=\"line\"></span><br><span class=\"line\">RK3588频脚计算方式与一般的计算方式没有区别：</span><br><span class=\"line\">GPIO pin脚计算公式：pin = bank * 32 + number</span><br><span class=\"line\">GPIO 小组编号计算公式：number = group * 8 + X</span><br><span class=\"line\"></span><br><span class=\"line\">摘自官网：</span><br><span class=\"line\"></span><br><span class=\"line\">下面演示GPIO1_D0 pin脚计算方法：</span><br><span class=\"line\"></span><br><span class=\"line\">bank = 1;      //GPIO1_D0 =&gt; 1, bank ∈ [0,4]</span><br><span class=\"line\"></span><br><span class=\"line\">group = 3;      //GPIO1_D0 =&gt; 3, group ∈ &#123;(A=0), (B=1), (C=2), (D=3)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">X = 0;       //GPIO1_D0 =&gt; 0, X ∈ [0,7]</span><br><span class=\"line\"></span><br><span class=\"line\">number = group * 8 + X = 3 * 8 + 0 = 24</span><br><span class=\"line\"></span><br><span class=\"line\">pin = bank*32 + number= 1 * 32 + 24 = 56;</span><br><span class=\"line\"></span><br><span class=\"line\">GPIO1_D0 对应的设备树属性描述为:&lt;&amp;gpio1 24 GPIO_ACTIVE_HIGH&gt;,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的</span><br><span class=\"line\">的宏定义可知，也可以将GPIO1_D0描述为&lt;&amp;gpio1 RK_PD0 GPIO_ACTIVE_HIGH&gt;。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pinctrl_parse_dt</span><br><span class=\"line\">\tinfo-&gt;groups = devm_kcalloc(dev, info-&gt;ngroups, sizeof(*info-&gt;groups), GFP_KERNEL);</span><br><span class=\"line\">\trockchip_pinctrl_parse_functions</span><br><span class=\"line\">\t\trockchip_pinctrl_parse_groups</span><br><span class=\"line\">\t\t\tpinconf_generic_parse_dt_config</span><br><span class=\"line\">\t\t\t\tparse_dt_cfg</span><br><span class=\"line\">\t\t\t\t\tpinconf_to_config_packed</span><br><span class=\"line\">\t\t\t\t\t\tPIN_CONF_PACKED</span><br><span class=\"line\"></span><br><span class=\"line\">#define PIN_CONF_PACKED(p, a) ((a &lt;&lt; 8) | ((unsigned long) p &amp; 0xffUL))</span><br><span class=\"line\">5,1</span><br><span class=\"line\">105</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">of_property_read_u32(np, par-&gt;property, &amp;val);</span><br><span class=\"line\">\tof_property_read_u32_array(np, property, val, 1);</span><br><span class=\"line\">\t\tof_property_read_variable_u32_array(np, property, val, 1, 0);</span><br><span class=\"line\">\t\tof_find_property_value_of_size(np, property, 4, 0, &amp;sz);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpinctrl_show</span><br><span class=\"line\">\t\tpinconf_show_setting</span><br><span class=\"line\">\t\t\tpinconf_show_config</span><br><span class=\"line\">\t\t\t\tsetting-&gt;data.configs.configs</span><br><span class=\"line\"></span><br><span class=\"line\">add_setting</span><br><span class=\"line\">\tpinconf_map_to_setting</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsetting-&gt;data.configs.configs = map-&gt;data.configs.configs;</span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_dt_node_to_map</span><br><span class=\"line\">\tpinctrl_name_to_group</span><br><span class=\"line\">\t\trockchip_pin_group * grp = info-&gt;groups[i]</span><br><span class=\"line\"></span><br><span class=\"line\">\tnew_map[i].data.configs.configs = grp-&gt;data[i].configs;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pmx_set</span><br><span class=\"line\">\tconst struct rockchip_pin_config *data = info-&gt;groups[group].data;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pin_group</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">uart1 &#123;</span><br><span class=\"line\">\t\t/omit-if-no-ref/</span><br><span class=\"line\">\t\tuart1m1_xfer: uart1m1-xfer &#123;</span><br><span class=\"line\">\t\t\trockchip,pins =</span><br><span class=\"line\">\t\t\t\t/* uart1_rx_m1 */</span><br><span class=\"line\">\t\t\t\t&lt;1 RK_PB7 10 &amp;pcfg_pull_up&gt;,</span><br><span class=\"line\">\t\t\t\t/* uart1_tx_m1 */</span><br><span class=\"line\">\t\t\t\t&lt;1 RK_PB6 10 &amp;pcfg_pull_up&gt;;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">pcfg_pull_up</span><br><span class=\"line\">\tbias-pull-up;</span><br><span class=\"line\">\t\tstatic const struct pinconf_generic_params dt_params[] = &#123;</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-bus-hold&quot;, PIN_CONFIG_BIAS_BUS_HOLD, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-disable&quot;, PIN_CONFIG_BIAS_DISABLE, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-high-impedance&quot;, PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-pull-up&quot;, PIN_CONFIG_BIAS_PULL_UP, 1 &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tstatic const struct pin_config_item conf_items[] = &#123;</span><br><span class=\"line\">\t\t\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, &quot;input bias pull up&quot;, &quot;ohms&quot;, true),</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tenum pin_config_param &#123;</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_BUS_HOLD,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_DISABLE,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_HIGH_IMPEDANCE,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_DOWN,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_PIN_DEFAULT,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_UP,\t//5</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>查看具体设备树中的宏定义</p>\n<p>include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h</p>\n<p>include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h</p>\n<p>dt-bindings&#x2F;clock&#x2F;rk3588-cru.h</p>\n<p>查看物理单系统中的pinctrl配置，获取物理外设真实的device name</p>\n<p>  cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;pinctrl&#x2F;pinctrl-maps</p>\n<p>pinctrl的三大作用,有助于理解相关结构体</p>\n<p>1.引脚枚举与命名 enumerating and naming</p>\n<p>2.引脚服用 Multiplexing：比如用作GPIO、I2C或其他功能</p>\n<p>3.引脚配置 Configuration：比如上拉、下拉、open drain、驱动强度等</p>\n<p>rk3588s.dtsi<br>rk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例</p>\n<p>查看引脚的复用情况<br>cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;pinctrl&#x2F;pinctrl-rockchip-pinctrl&#x2F;pinmux-pins</p>\n<p>RK3588频脚计算方式与一般的计算方式没有区别：<br>GPIO pin脚计算公式：pin &#x3D; bank * 32 + number<br>GPIO 小组编号计算公式：number &#x3D; group * 8 + X</p>\n<p>摘自官网：</p>\n<p>下面演示GPIO1_D0 pin脚计算方法：</p>\n<p>bank &#x3D; 1;      &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 1, bank ∈ [0,4]</p>\n<p>group &#x3D; 3;      &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 3, group ∈ {(A&#x3D;0), (B&#x3D;1), (C&#x3D;2), (D&#x3D;3)}</p>\n<p>X &#x3D; 0;       &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 0, X ∈ [0,7]</p>\n<p>number &#x3D; group * 8 + X &#x3D; 3 * 8 + 0 &#x3D; 24</p>\n<p>pin &#x3D; bank*32 + number&#x3D; 1 * 32 + 24 &#x3D; 56;</p>\n<p>GPIO1_D0 对应的设备树属性描述为:&lt;&amp;gpio1 24 GPIO_ACTIVE_HIGH&gt;,由kernel-5.10&#x2F;include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h的<br>的宏定义可知，也可以将GPIO1_D0描述为&lt;&amp;gpio1 RK_PD0 GPIO_ACTIVE_HIGH&gt;。</p>\n<h2 id=\"client端相关结构体\"><a href=\"#client端相关结构体\" class=\"headerlink\" title=\"client端相关结构体\"></a>client端相关结构体</h2><p><a href=\"https://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&icon_type=3&file_type=20\">https://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&amp;icon_type=3&amp;file_type=20</a> </p>\n<p><img src=\"/../imgs/image-20240530170508734.png\" alt=\"image-20240530170508734\"></p>\n<p>rk3588-pinctrl-pin-config-debug</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl </span><br><span class=\"line\">cat pinmux-pins  </span><br><span class=\"line\">cat ../pinctrl-handles\t#查看所有pinctrl client state</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">rk3588s.dtsi</span><br><span class=\"line\">rk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例</span><br><span class=\"line\"></span><br><span class=\"line\">查看引脚的复用情况</span><br><span class=\"line\">cat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins</span><br><span class=\"line\"></span><br><span class=\"line\">RK3588频脚计算方式与一般的计算方式没有区别：</span><br><span class=\"line\">GPIO pin脚计算公式：pin = bank * 32 + number</span><br><span class=\"line\">GPIO 小组编号计算公式：number = group * 8 + X</span><br><span class=\"line\"></span><br><span class=\"line\">摘自官网：</span><br><span class=\"line\"></span><br><span class=\"line\">下面演示GPIO1_D0 pin脚计算方法：</span><br><span class=\"line\"></span><br><span class=\"line\">bank = 1;      //GPIO1_D0 =&gt; 1, bank ∈ [0,4]</span><br><span class=\"line\"></span><br><span class=\"line\">group = 3;      //GPIO1_D0 =&gt; 3, group ∈ &#123;(A=0), (B=1), (C=2), (D=3)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">X = 0;       //GPIO1_D0 =&gt; 0, X ∈ [0,7]</span><br><span class=\"line\"></span><br><span class=\"line\">number = group * 8 + X = 3 * 8 + 0 = 24</span><br><span class=\"line\"></span><br><span class=\"line\">pin = bank*32 + number= 1 * 32 + 24 = 56;</span><br><span class=\"line\"></span><br><span class=\"line\">GPIO1_D0 对应的设备树属性描述为:&lt;&amp;gpio1 24 GPIO_ACTIVE_HIGH&gt;,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的</span><br><span class=\"line\">的宏定义可知，也可以将GPIO1_D0描述为&lt;&amp;gpio1 RK_PD0 GPIO_ACTIVE_HIGH&gt;。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pinctrl_parse_dt</span><br><span class=\"line\">\tinfo-&gt;groups = devm_kcalloc(dev, info-&gt;ngroups, sizeof(*info-&gt;groups), GFP_KERNEL);</span><br><span class=\"line\">\trockchip_pinctrl_parse_functions</span><br><span class=\"line\">\t\trockchip_pinctrl_parse_groups</span><br><span class=\"line\">\t\t\tpinconf_generic_parse_dt_config</span><br><span class=\"line\">\t\t\t\tparse_dt_cfg</span><br><span class=\"line\">\t\t\t\t\tpinconf_to_config_packed</span><br><span class=\"line\">\t\t\t\t\t\tPIN_CONF_PACKED</span><br><span class=\"line\"></span><br><span class=\"line\">#define PIN_CONF_PACKED(p, a) ((a &lt;&lt; 8) | ((unsigned long) p &amp; 0xffUL))</span><br><span class=\"line\">5,1</span><br><span class=\"line\">105</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">of_property_read_u32(np, par-&gt;property, &amp;val);</span><br><span class=\"line\">\tof_property_read_u32_array(np, property, val, 1);</span><br><span class=\"line\">\t\tof_property_read_variable_u32_array(np, property, val, 1, 0);</span><br><span class=\"line\">\t\tof_find_property_value_of_size(np, property, 4, 0, &amp;sz);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpinctrl_show</span><br><span class=\"line\">\t\tpinconf_show_setting</span><br><span class=\"line\">\t\t\tpinconf_show_config</span><br><span class=\"line\">\t\t\t\tsetting-&gt;data.configs.configs</span><br><span class=\"line\"></span><br><span class=\"line\">add_setting</span><br><span class=\"line\">\tpinconf_map_to_setting</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsetting-&gt;data.configs.configs = map-&gt;data.configs.configs;</span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_dt_node_to_map</span><br><span class=\"line\">\tpinctrl_name_to_group</span><br><span class=\"line\">\t\trockchip_pin_group * grp = info-&gt;groups[i]</span><br><span class=\"line\"></span><br><span class=\"line\">\tnew_map[i].data.configs.configs = grp-&gt;data[i].configs;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pmx_set</span><br><span class=\"line\">\tconst struct rockchip_pin_config *data = info-&gt;groups[group].data;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pin_group</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">uart1 &#123;</span><br><span class=\"line\">\t\t/omit-if-no-ref/</span><br><span class=\"line\">\t\tuart1m1_xfer: uart1m1-xfer &#123;</span><br><span class=\"line\">\t\t\trockchip,pins =</span><br><span class=\"line\">\t\t\t\t/* uart1_rx_m1 */</span><br><span class=\"line\">\t\t\t\t&lt;1 RK_PB7 10 &amp;pcfg_pull_up&gt;,</span><br><span class=\"line\">\t\t\t\t/* uart1_tx_m1 */</span><br><span class=\"line\">\t\t\t\t&lt;1 RK_PB6 10 &amp;pcfg_pull_up&gt;;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">pcfg_pull_up</span><br><span class=\"line\">\tbias-pull-up;</span><br><span class=\"line\">\t\tstatic const struct pinconf_generic_params dt_params[] = &#123;</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-bus-hold&quot;, PIN_CONFIG_BIAS_BUS_HOLD, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-disable&quot;, PIN_CONFIG_BIAS_DISABLE, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-high-impedance&quot;, PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-pull-up&quot;, PIN_CONFIG_BIAS_PULL_UP, 1 &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tstatic const struct pin_config_item conf_items[] = &#123;</span><br><span class=\"line\">\t\t\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, &quot;input bias pull up&quot;, &quot;ohms&quot;, true),</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tenum pin_config_param &#123;</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_BUS_HOLD,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_DISABLE,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_HIGH_IMPEDANCE,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_DOWN,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_PIN_DEFAULT,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_UP,\t//5</span><br></pre></td></tr></table></figure>\n\n"},{"title":"PHY芯片","categories":["test"],"tags":["PHY芯片"],"date":"2024-05-16T10:58:06.000Z","_content":"\n[toc]\n\n# PHY（physical Layer，PHY）\n\n## 什么是PHY？\n\n物理层芯片称为PHY、数据链路层芯片称为MAC\n\n可以看到PHY的数据是[RJ45](https://so.csdn.net/so/search?q=RJ45&spm=1001.2101.3001.7020)网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。\n\n那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）\n\n## 什么是RJ45接口？\n\nRJ45接口通常用于数据传输，最常见的应用为网卡接口。RJ-45端口是我们最常见的端口之一，是比较常见的[双绞线](https://www.zhihu.com/search?q=双绞线&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A3477234795})以太网端口，因为在快速以太网中也主要采用双绞线作为传输介质。\n\nRJ45型网线插头又称水晶头，共由八芯做成，广泛应用于局域网和ADSL宽带上网用户的网络设备间网线（称作五类线或双绞线）的连接。\n\nRJ45接头根据线的排序不同主要分两种，一种是橙白、橙、绿白、蓝、蓝白、绿、棕白、棕；另一种是绿白、绿、橙白、蓝、蓝白、橙、棕白、棕；因此使用RJ45接头的线也有两种即：直通线、交叉线。分别称作[T568A线序](https://www.zhihu.com/search?q=T568A线序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A3477234795})和T568B线序。\n\nRJ45插座连接器接口内部是金属，注意不能受潮或者接触到水，否则会造成短路现象。\n\n## 为什么要熟悉RJ45网口\n\n上面说到针对phy芯片我们只要进行模式选择（下文会介绍使用[mdio](https://so.csdn.net/so/search?q=mdio&spm=1001.2101.3001.7020)接口，通过寄存器控制）\n\n那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看\n\n![img](../imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png)\n\nRJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，**绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信**，**黄灯闪动频率快表示网速**好，这两个灯由 PHY 芯片控制。\n\n## 网络七层协议\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png)\n\n## 两个模块进行通信\n\n下图是两个主控直接的通信，比如我们的电脑 和 路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的\n\n如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西\n\n比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。\n\n（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）\n\n![img](../img/84b0b5e31bb246c0a970ace7c71a3f82.png)\n\n## 什么是MDIO协议\n\nmido协议即SMI协议\n\nSMI协议也是一种通信协议类似与I2C协议但是通信方式不一样\n\nSMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，\n\n如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png)\n\n\n\n## MDIO的作用 \n\n从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据\n\n那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率[休眠状态](https://baike.baidu.com/item/休眠状态?fromModule=lemma_inlink)、TX/RX模式选择、[自动协商](https://baike.baidu.com/item/自动协商/7765053?fromModule=lemma_inlink)控制、环回模式控制等。\n\n\n\n### MDIO没那么重要\n\nMDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！\n\n换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。\n\n但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。\n\n如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！\n\n\n## MDIO读写时序\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png)\n\nPreamble：32bits的前导码\n\nStart：2bit的开始位。\n\nOP Code：2bits的操作码，10表示读，01表示写。\n\nPHYAD：5bits的PHY地址。\n\nREGAD：5bits的寄存器地址，即要读或写的寄存器。\n\nTurn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。\n\nData：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。\n\nIdle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。\n为什么说读取的phy最多32个\n因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为\n\n## 为什么说reg地址最多32个\n\n同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个\n\n PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16`~`31 这 16 个寄存器由厂商自行实现。 也就是说不管你用的哪个厂家的 PHY 芯片，其中 0`~`15 这 16 个寄存器是一模一样的。 仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。\n\n \n\n\n\n转：\n\n[PHY芯片快速深度理解（持续更新中……）-CSDN博客](https://blog.csdn.net/qq_40715266/article/details/124095801)\n\n\n\n[PHY（Physical Layer，PHY） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/148538791)\n","source":"back_posts/PHY芯片.md","raw":"---\ntitle: PHY芯片\ncategories:\n  - test\ntags:\n  - PHY芯片\ndate: 2024-05-16 18:58:06\n---\n\n[toc]\n\n# PHY（physical Layer，PHY）\n\n## 什么是PHY？\n\n物理层芯片称为PHY、数据链路层芯片称为MAC\n\n可以看到PHY的数据是[RJ45](https://so.csdn.net/so/search?q=RJ45&spm=1001.2101.3001.7020)网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。\n\n那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）\n\n## 什么是RJ45接口？\n\nRJ45接口通常用于数据传输，最常见的应用为网卡接口。RJ-45端口是我们最常见的端口之一，是比较常见的[双绞线](https://www.zhihu.com/search?q=双绞线&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A3477234795})以太网端口，因为在快速以太网中也主要采用双绞线作为传输介质。\n\nRJ45型网线插头又称水晶头，共由八芯做成，广泛应用于局域网和ADSL宽带上网用户的网络设备间网线（称作五类线或双绞线）的连接。\n\nRJ45接头根据线的排序不同主要分两种，一种是橙白、橙、绿白、蓝、蓝白、绿、棕白、棕；另一种是绿白、绿、橙白、蓝、蓝白、橙、棕白、棕；因此使用RJ45接头的线也有两种即：直通线、交叉线。分别称作[T568A线序](https://www.zhihu.com/search?q=T568A线序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A3477234795})和T568B线序。\n\nRJ45插座连接器接口内部是金属，注意不能受潮或者接触到水，否则会造成短路现象。\n\n## 为什么要熟悉RJ45网口\n\n上面说到针对phy芯片我们只要进行模式选择（下文会介绍使用[mdio](https://so.csdn.net/so/search?q=mdio&spm=1001.2101.3001.7020)接口，通过寄存器控制）\n\n那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看\n\n![img](../imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png)\n\nRJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，**绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信**，**黄灯闪动频率快表示网速**好，这两个灯由 PHY 芯片控制。\n\n## 网络七层协议\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png)\n\n## 两个模块进行通信\n\n下图是两个主控直接的通信，比如我们的电脑 和 路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的\n\n如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西\n\n比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。\n\n（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）\n\n![img](../img/84b0b5e31bb246c0a970ace7c71a3f82.png)\n\n## 什么是MDIO协议\n\nmido协议即SMI协议\n\nSMI协议也是一种通信协议类似与I2C协议但是通信方式不一样\n\nSMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，\n\n如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png)\n\n\n\n## MDIO的作用 \n\n从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据\n\n那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率[休眠状态](https://baike.baidu.com/item/休眠状态?fromModule=lemma_inlink)、TX/RX模式选择、[自动协商](https://baike.baidu.com/item/自动协商/7765053?fromModule=lemma_inlink)控制、环回模式控制等。\n\n\n\n### MDIO没那么重要\n\nMDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！\n\n换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。\n\n但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。\n\n如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！\n\n\n## MDIO读写时序\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png)\n\nPreamble：32bits的前导码\n\nStart：2bit的开始位。\n\nOP Code：2bits的操作码，10表示读，01表示写。\n\nPHYAD：5bits的PHY地址。\n\nREGAD：5bits的寄存器地址，即要读或写的寄存器。\n\nTurn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。\n\nData：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。\n\nIdle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。\n为什么说读取的phy最多32个\n因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为\n\n## 为什么说reg地址最多32个\n\n同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个\n\n PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16`~`31 这 16 个寄存器由厂商自行实现。 也就是说不管你用的哪个厂家的 PHY 芯片，其中 0`~`15 这 16 个寄存器是一模一样的。 仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。\n\n \n\n\n\n转：\n\n[PHY芯片快速深度理解（持续更新中……）-CSDN博客](https://blog.csdn.net/qq_40715266/article/details/124095801)\n\n\n\n[PHY（Physical Layer，PHY） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/148538791)\n","updated":"2024-05-16T11:53:19.725Z","path":"back_posts/PHY芯片.html","_id":"clw96lvxr0000bpw0g20t03s2","comments":1,"layout":"page","content":"<p>[toc]</p>\n<h1 id=\"PHY（physical-Layer，PHY）\"><a href=\"#PHY（physical-Layer，PHY）\" class=\"headerlink\" title=\"PHY（physical Layer，PHY）\"></a>PHY（physical Layer，PHY）</h1><h2 id=\"什么是PHY？\"><a href=\"#什么是PHY？\" class=\"headerlink\" title=\"什么是PHY？\"></a>什么是PHY？</h2><p>物理层芯片称为PHY、数据链路层芯片称为MAC</p>\n<p>可以看到PHY的数据是<a href=\"https://so.csdn.net/so/search?q=RJ45&spm=1001.2101.3001.7020\">RJ45</a>网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。</p>\n<p>那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）</p>\n<h2 id=\"什么是RJ45接口？\"><a href=\"#什么是RJ45接口？\" class=\"headerlink\" title=\"什么是RJ45接口？\"></a>什么是RJ45接口？</h2><p>RJ45接口通常用于数据传输，最常见的应用为网卡接口。RJ-45端口是我们最常见的端口之一，是比较常见的<a href=\"https://www.zhihu.com/search?q=%E5%8F%8C%E7%BB%9E%E7%BA%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D\">双绞线</a>以太网端口，因为在快速以太网中也主要采用双绞线作为传输介质。</p>\n<p>RJ45型网线插头又称水晶头，共由八芯做成，广泛应用于局域网和ADSL宽带上网用户的网络设备间网线（称作五类线或双绞线）的连接。</p>\n<p>RJ45接头根据线的排序不同主要分两种，一种是橙白、橙、绿白、蓝、蓝白、绿、棕白、棕；另一种是绿白、绿、橙白、蓝、蓝白、橙、棕白、棕；因此使用RJ45接头的线也有两种即：直通线、交叉线。分别称作<a href=\"https://www.zhihu.com/search?q=T568A%E7%BA%BF%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D\">T568A线序</a>和T568B线序。</p>\n<p>RJ45插座连接器接口内部是金属，注意不能受潮或者接触到水，否则会造成短路现象。</p>\n<h2 id=\"为什么要熟悉RJ45网口\"><a href=\"#为什么要熟悉RJ45网口\" class=\"headerlink\" title=\"为什么要熟悉RJ45网口\"></a>为什么要熟悉RJ45网口</h2><p>上面说到针对phy芯片我们只要进行模式选择（下文会介绍使用<a href=\"https://so.csdn.net/so/search?q=mdio&spm=1001.2101.3001.7020\">mdio</a>接口，通过寄存器控制）</p>\n<p>那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看</p>\n<p><img src=\"/../imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png\" alt=\"img\"></p>\n<p>RJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，<strong>绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信</strong>，<strong>黄灯闪动频率快表示网速</strong>好，这两个灯由 PHY 芯片控制。</p>\n<h2 id=\"网络七层协议\"><a href=\"#网络七层协议\" class=\"headerlink\" title=\"网络七层协议\"></a>网络七层协议</h2><p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<h2 id=\"两个模块进行通信\"><a href=\"#两个模块进行通信\" class=\"headerlink\" title=\"两个模块进行通信\"></a>两个模块进行通信</h2><p>下图是两个主控直接的通信，比如我们的电脑 和 路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的</p>\n<p>如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西</p>\n<p>比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。</p>\n<p>（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）</p>\n<p><img src=\"/../img/84b0b5e31bb246c0a970ace7c71a3f82.png\" alt=\"img\"></p>\n<h2 id=\"什么是MDIO协议\"><a href=\"#什么是MDIO协议\" class=\"headerlink\" title=\"什么是MDIO协议\"></a>什么是MDIO协议</h2><p>mido协议即SMI协议</p>\n<p>SMI协议也是一种通信协议类似与I2C协议但是通信方式不一样</p>\n<p>SMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，</p>\n<p>如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。</p>\n<p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<h2 id=\"MDIO的作用\"><a href=\"#MDIO的作用\" class=\"headerlink\" title=\"MDIO的作用\"></a>MDIO的作用</h2><p>从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据</p>\n<p>那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率<a href=\"https://baike.baidu.com/item/%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%80%81?fromModule=lemma_inlink\">休眠状态</a>、TX&#x2F;RX模式选择、<a href=\"https://baike.baidu.com/item/%E8%87%AA%E5%8A%A8%E5%8D%8F%E5%95%86/7765053?fromModule=lemma_inlink\">自动协商</a>控制、环回模式控制等。</p>\n<h3 id=\"MDIO没那么重要\"><a href=\"#MDIO没那么重要\" class=\"headerlink\" title=\"MDIO没那么重要\"></a>MDIO没那么重要</h3><p>MDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！</p>\n<p>换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。</p>\n<p>但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。</p>\n<p>如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！</p>\n<h2 id=\"MDIO读写时序\"><a href=\"#MDIO读写时序\" class=\"headerlink\" title=\"MDIO读写时序\"></a>MDIO读写时序</h2><p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<p>Preamble：32bits的前导码</p>\n<p>Start：2bit的开始位。</p>\n<p>OP Code：2bits的操作码，10表示读，01表示写。</p>\n<p>PHYAD：5bits的PHY地址。</p>\n<p>REGAD：5bits的寄存器地址，即要读或写的寄存器。</p>\n<p>Turn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。</p>\n<p>Data：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。</p>\n<p>Idle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。<br>为什么说读取的phy最多32个<br>因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为</p>\n<h2 id=\"为什么说reg地址最多32个\"><a href=\"#为什么说reg地址最多32个\" class=\"headerlink\" title=\"为什么说reg地址最多32个\"></a>为什么说reg地址最多32个</h2><p>同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个</p>\n<p> PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16<code>~</code>31 这 16 个寄存器由厂商自行实现。 也就是说不管你用的哪个厂家的 PHY 芯片，其中 0<code>~</code>15 这 16 个寄存器是一模一样的。 仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。</p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/qq_40715266/article/details/124095801\">PHY芯片快速深度理解（持续更新中……）-CSDN博客</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/148538791\">PHY（Physical Layer，PHY） - 知乎 (zhihu.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"PHY（physical-Layer，PHY）\"><a href=\"#PHY（physical-Layer，PHY）\" class=\"headerlink\" title=\"PHY（physical Layer，PHY）\"></a>PHY（physical Layer，PHY）</h1><h2 id=\"什么是PHY？\"><a href=\"#什么是PHY？\" class=\"headerlink\" title=\"什么是PHY？\"></a>什么是PHY？</h2><p>物理层芯片称为PHY、数据链路层芯片称为MAC</p>\n<p>可以看到PHY的数据是<a href=\"https://so.csdn.net/so/search?q=RJ45&spm=1001.2101.3001.7020\">RJ45</a>网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。</p>\n<p>那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）</p>\n<h2 id=\"什么是RJ45接口？\"><a href=\"#什么是RJ45接口？\" class=\"headerlink\" title=\"什么是RJ45接口？\"></a>什么是RJ45接口？</h2><p>RJ45接口通常用于数据传输，最常见的应用为网卡接口。RJ-45端口是我们最常见的端口之一，是比较常见的<a href=\"https://www.zhihu.com/search?q=%E5%8F%8C%E7%BB%9E%E7%BA%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D\">双绞线</a>以太网端口，因为在快速以太网中也主要采用双绞线作为传输介质。</p>\n<p>RJ45型网线插头又称水晶头，共由八芯做成，广泛应用于局域网和ADSL宽带上网用户的网络设备间网线（称作五类线或双绞线）的连接。</p>\n<p>RJ45接头根据线的排序不同主要分两种，一种是橙白、橙、绿白、蓝、蓝白、绿、棕白、棕；另一种是绿白、绿、橙白、蓝、蓝白、橙、棕白、棕；因此使用RJ45接头的线也有两种即：直通线、交叉线。分别称作<a href=\"https://www.zhihu.com/search?q=T568A%E7%BA%BF%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D\">T568A线序</a>和T568B线序。</p>\n<p>RJ45插座连接器接口内部是金属，注意不能受潮或者接触到水，否则会造成短路现象。</p>\n<h2 id=\"为什么要熟悉RJ45网口\"><a href=\"#为什么要熟悉RJ45网口\" class=\"headerlink\" title=\"为什么要熟悉RJ45网口\"></a>为什么要熟悉RJ45网口</h2><p>上面说到针对phy芯片我们只要进行模式选择（下文会介绍使用<a href=\"https://so.csdn.net/so/search?q=mdio&spm=1001.2101.3001.7020\">mdio</a>接口，通过寄存器控制）</p>\n<p>那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看</p>\n<p><img src=\"/../imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png\" alt=\"img\"></p>\n<p>RJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，<strong>绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信</strong>，<strong>黄灯闪动频率快表示网速</strong>好，这两个灯由 PHY 芯片控制。</p>\n<h2 id=\"网络七层协议\"><a href=\"#网络七层协议\" class=\"headerlink\" title=\"网络七层协议\"></a>网络七层协议</h2><p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<h2 id=\"两个模块进行通信\"><a href=\"#两个模块进行通信\" class=\"headerlink\" title=\"两个模块进行通信\"></a>两个模块进行通信</h2><p>下图是两个主控直接的通信，比如我们的电脑 和 路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的</p>\n<p>如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西</p>\n<p>比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。</p>\n<p>（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）</p>\n<p><img src=\"/../img/84b0b5e31bb246c0a970ace7c71a3f82.png\" alt=\"img\"></p>\n<h2 id=\"什么是MDIO协议\"><a href=\"#什么是MDIO协议\" class=\"headerlink\" title=\"什么是MDIO协议\"></a>什么是MDIO协议</h2><p>mido协议即SMI协议</p>\n<p>SMI协议也是一种通信协议类似与I2C协议但是通信方式不一样</p>\n<p>SMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，</p>\n<p>如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。</p>\n<p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<h2 id=\"MDIO的作用\"><a href=\"#MDIO的作用\" class=\"headerlink\" title=\"MDIO的作用\"></a>MDIO的作用</h2><p>从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据</p>\n<p>那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率<a href=\"https://baike.baidu.com/item/%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%80%81?fromModule=lemma_inlink\">休眠状态</a>、TX&#x2F;RX模式选择、<a href=\"https://baike.baidu.com/item/%E8%87%AA%E5%8A%A8%E5%8D%8F%E5%95%86/7765053?fromModule=lemma_inlink\">自动协商</a>控制、环回模式控制等。</p>\n<h3 id=\"MDIO没那么重要\"><a href=\"#MDIO没那么重要\" class=\"headerlink\" title=\"MDIO没那么重要\"></a>MDIO没那么重要</h3><p>MDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！</p>\n<p>换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。</p>\n<p>但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。</p>\n<p>如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！</p>\n<h2 id=\"MDIO读写时序\"><a href=\"#MDIO读写时序\" class=\"headerlink\" title=\"MDIO读写时序\"></a>MDIO读写时序</h2><p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<p>Preamble：32bits的前导码</p>\n<p>Start：2bit的开始位。</p>\n<p>OP Code：2bits的操作码，10表示读，01表示写。</p>\n<p>PHYAD：5bits的PHY地址。</p>\n<p>REGAD：5bits的寄存器地址，即要读或写的寄存器。</p>\n<p>Turn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。</p>\n<p>Data：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。</p>\n<p>Idle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。<br>为什么说读取的phy最多32个<br>因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为</p>\n<h2 id=\"为什么说reg地址最多32个\"><a href=\"#为什么说reg地址最多32个\" class=\"headerlink\" title=\"为什么说reg地址最多32个\"></a>为什么说reg地址最多32个</h2><p>同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个</p>\n<p> PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16<code>~</code>31 这 16 个寄存器由厂商自行实现。 也就是说不管你用的哪个厂家的 PHY 芯片，其中 0<code>~</code>15 这 16 个寄存器是一模一样的。 仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。</p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/qq_40715266/article/details/124095801\">PHY芯片快速深度理解（持续更新中……）-CSDN博客</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/148538791\">PHY（Physical Layer，PHY） - 知乎 (zhihu.com)</a></p>\n"},{"title":"Clion202204-破解","categories":["test"],"tags":["Clion"],"date":"2024-05-17T02:10:50.000Z","_content":"\n\n\n## 下载与安装\n\n此教程为CLion 2022.2.4 破解教程，且此教程以及下面提供的破解补丁适用与2022.2以后的新版本。\n2022年11月10日亲测有效，mac与windows均测试完美破解\n\n### CLion 下载\n\nClion官网下载地址：https://www.jetbrains.com.cn/clion/download/other.html\n\n![image](../imgs/1894089-20230211102247487-1038132289.png)\n\n找到2022.2.4的，然后根据自己的电脑系统选择。Windows的下载Windows，Mac的下载Mac的。\n\n### 安装\n\n直接上面的地址下载安装即可，安装完后记得不要打开，打开后也要先关闭，这里步骤就忽略了，安装很简单。\n\n- **卸载老版本 CLion(未安装则不用管，跳过看下面步骤)**\n  注意，安装新版本之前，如果本机安装过老版本的, 需要先彻底卸载，以免两者冲突，导致破解失败。\n  **安装太简单了，步骤就忽略了。**\n\n## 破解\n\n### 破解补丁下载\n\n破解补丁下载地址：https://kohler.lanzouo.com/iS5E40n7ojba\n\n### Windows版破解\n\n下载破解补丁后，解压得到，如下图：\n\n![image](../imgs/1894089-20230211102659035-421863408.png)\n\n将上面图示的补丁的所属文件夹 `/jetbra` 复制电脑某个位置，我是放置到了 桌面目录下（不推荐，自己选个D盘目录或者其他位置），\n点击进入`/jetbra` 补丁目录，再点击进入`/scripts` 文件夹，双击执行 `install-all-user.vbs` 破解脚本：\n\n![image](../imgs/1894089-20230211102807063-1324567688.png)\n\n**注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。**\n\n![image](../imgs/1894089-20230211102825164-1230499662.png)\n\n会提示安装补丁需要等待数秒。点击**【确定】**按钮后，过程大概 10 - 30 秒，如看到弹框提示 Done 时，表示激活破解成功：\n\n![image](../imgs/1894089-20230211102841861-1500251037.png)\n\n### mac版破解\n\n**Mac / Linux** 系统与上面 Windows 系统一样，需将补丁所属文件`/jetbra` 复制到某个路径，且**路径不能包含空格与中文**。\n\n之后，打开终端，进入到`/jetbra/scripts` 文件夹， 执行 `install.sh`脚本, 命令如下：\n\n\n\n```shell\nsudo bash install.sh\n```\n\n看到提示 Done , 表示激活成功。\n\n![image](../imgs/1894089-20230211104108634-1740893276.png)\n\n**Mac / Linux** 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，**Mac / Linux 需重启系统**，以确保环境变量生效。\n\n### linux版破解\n\n和mac版一样，参考mac,这里就不做介绍了。\n\n### 重启 CLion\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n## 填入指定激活码完成激活\n\n打开文件夹里的激活码，粘贴到输入框内，点击 `Activate` 按钮，就激活成功了。\n\n![image](../imgs/1894089-20230211104238842-2069324840.png)\n\n![image](../imgs/1894089-20230211104310444-38131101.png)\n\n激活成功后，就可以开心的 coding 了 ~\n\n![image](../imgs/1894089-20230211104336300-896542684.png)\n\n转：\n\n[CLion 2022.2.4破解教程详细图解mac,windows,linux均适用 - 愚生浅末 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kohler21/p/17111018.html)\n\n参考：\n\n[使用Clion优雅的完全远程自动同步和远程调试c++-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1406250)\n","source":"back_posts/Clion202204-破解.md","raw":"---\ntitle: Clion202204-破解\ncategories:\n  - test\ntags:\n  - Clion\ndate: 2024-05-17 10:10:50\n---\n\n\n\n## 下载与安装\n\n此教程为CLion 2022.2.4 破解教程，且此教程以及下面提供的破解补丁适用与2022.2以后的新版本。\n2022年11月10日亲测有效，mac与windows均测试完美破解\n\n### CLion 下载\n\nClion官网下载地址：https://www.jetbrains.com.cn/clion/download/other.html\n\n![image](../imgs/1894089-20230211102247487-1038132289.png)\n\n找到2022.2.4的，然后根据自己的电脑系统选择。Windows的下载Windows，Mac的下载Mac的。\n\n### 安装\n\n直接上面的地址下载安装即可，安装完后记得不要打开，打开后也要先关闭，这里步骤就忽略了，安装很简单。\n\n- **卸载老版本 CLion(未安装则不用管，跳过看下面步骤)**\n  注意，安装新版本之前，如果本机安装过老版本的, 需要先彻底卸载，以免两者冲突，导致破解失败。\n  **安装太简单了，步骤就忽略了。**\n\n## 破解\n\n### 破解补丁下载\n\n破解补丁下载地址：https://kohler.lanzouo.com/iS5E40n7ojba\n\n### Windows版破解\n\n下载破解补丁后，解压得到，如下图：\n\n![image](../imgs/1894089-20230211102659035-421863408.png)\n\n将上面图示的补丁的所属文件夹 `/jetbra` 复制电脑某个位置，我是放置到了 桌面目录下（不推荐，自己选个D盘目录或者其他位置），\n点击进入`/jetbra` 补丁目录，再点击进入`/scripts` 文件夹，双击执行 `install-all-user.vbs` 破解脚本：\n\n![image](../imgs/1894089-20230211102807063-1324567688.png)\n\n**注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。**\n\n![image](../imgs/1894089-20230211102825164-1230499662.png)\n\n会提示安装补丁需要等待数秒。点击**【确定】**按钮后，过程大概 10 - 30 秒，如看到弹框提示 Done 时，表示激活破解成功：\n\n![image](../imgs/1894089-20230211102841861-1500251037.png)\n\n### mac版破解\n\n**Mac / Linux** 系统与上面 Windows 系统一样，需将补丁所属文件`/jetbra` 复制到某个路径，且**路径不能包含空格与中文**。\n\n之后，打开终端，进入到`/jetbra/scripts` 文件夹， 执行 `install.sh`脚本, 命令如下：\n\n\n\n```shell\nsudo bash install.sh\n```\n\n看到提示 Done , 表示激活成功。\n\n![image](../imgs/1894089-20230211104108634-1740893276.png)\n\n**Mac / Linux** 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，**Mac / Linux 需重启系统**，以确保环境变量生效。\n\n### linux版破解\n\n和mac版一样，参考mac,这里就不做介绍了。\n\n### 重启 CLion\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n## 填入指定激活码完成激活\n\n打开文件夹里的激活码，粘贴到输入框内，点击 `Activate` 按钮，就激活成功了。\n\n![image](../imgs/1894089-20230211104238842-2069324840.png)\n\n![image](../imgs/1894089-20230211104310444-38131101.png)\n\n激活成功后，就可以开心的 coding 了 ~\n\n![image](../imgs/1894089-20230211104336300-896542684.png)\n\n转：\n\n[CLion 2022.2.4破解教程详细图解mac,windows,linux均适用 - 愚生浅末 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kohler21/p/17111018.html)\n\n参考：\n\n[使用Clion优雅的完全远程自动同步和远程调试c++-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1406250)\n","updated":"2024-05-17T02:15:41.294Z","path":"back_posts/Clion202204-破解.html","comments":1,"layout":"page","_id":"clwabwixu0000ygw08orz95qg","content":"<h2 id=\"下载与安装\"><a href=\"#下载与安装\" class=\"headerlink\" title=\"下载与安装\"></a>下载与安装</h2><p>此教程为CLion 2022.2.4 破解教程，且此教程以及下面提供的破解补丁适用与2022.2以后的新版本。<br>2022年11月10日亲测有效，mac与windows均测试完美破解</p>\n<h3 id=\"CLion-下载\"><a href=\"#CLion-下载\" class=\"headerlink\" title=\"CLion 下载\"></a>CLion 下载</h3><p>Clion官网下载地址：<a href=\"https://www.jetbrains.com.cn/clion/download/other.html\">https://www.jetbrains.com.cn/clion/download/other.html</a></p>\n<p><img src=\"/../imgs/1894089-20230211102247487-1038132289.png\" alt=\"image\"></p>\n<p>找到2022.2.4的，然后根据自己的电脑系统选择。Windows的下载Windows，Mac的下载Mac的。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>直接上面的地址下载安装即可，安装完后记得不要打开，打开后也要先关闭，这里步骤就忽略了，安装很简单。</p>\n<ul>\n<li><strong>卸载老版本 CLion(未安装则不用管，跳过看下面步骤)</strong><br>注意，安装新版本之前，如果本机安装过老版本的, 需要先彻底卸载，以免两者冲突，导致破解失败。<br><strong>安装太简单了，步骤就忽略了。</strong></li>\n</ul>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><h3 id=\"破解补丁下载\"><a href=\"#破解补丁下载\" class=\"headerlink\" title=\"破解补丁下载\"></a>破解补丁下载</h3><p>破解补丁下载地址：<a href=\"https://kohler.lanzouo.com/iS5E40n7ojba\">https://kohler.lanzouo.com/iS5E40n7ojba</a></p>\n<h3 id=\"Windows版破解\"><a href=\"#Windows版破解\" class=\"headerlink\" title=\"Windows版破解\"></a>Windows版破解</h3><p>下载破解补丁后，解压得到，如下图：</p>\n<p><img src=\"/../imgs/1894089-20230211102659035-421863408.png\" alt=\"image\"></p>\n<p>将上面图示的补丁的所属文件夹 <code>/jetbra</code> 复制电脑某个位置，我是放置到了 桌面目录下（不推荐，自己选个D盘目录或者其他位置），<br>点击进入<code>/jetbra</code> 补丁目录，再点击进入<code>/scripts</code> 文件夹，双击执行 <code>install-all-user.vbs</code> 破解脚本：</p>\n<p><img src=\"/../imgs/1894089-20230211102807063-1324567688.png\" alt=\"image\"></p>\n<p><strong>注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。</strong></p>\n<p><img src=\"/../imgs/1894089-20230211102825164-1230499662.png\" alt=\"image\"></p>\n<p>会提示安装补丁需要等待数秒。点击<strong>【确定】</strong>按钮后，过程大概 10 - 30 秒，如看到弹框提示 Done 时，表示激活破解成功：</p>\n<p><img src=\"/../imgs/1894089-20230211102841861-1500251037.png\" alt=\"image\"></p>\n<h3 id=\"mac版破解\"><a href=\"#mac版破解\" class=\"headerlink\" title=\"mac版破解\"></a>mac版破解</h3><p><strong>Mac &#x2F; Linux</strong> 系统与上面 Windows 系统一样，需将补丁所属文件<code>/jetbra</code> 复制到某个路径，且<strong>路径不能包含空格与中文</strong>。</p>\n<p>之后，打开终端，进入到<code>/jetbra/scripts</code> 文件夹， 执行 <code>install.sh</code>脚本, 命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo bash install.sh</span><br></pre></td></tr></table></figure>\n\n<p>看到提示 Done , 表示激活成功。</p>\n<p><img src=\"/../imgs/1894089-20230211104108634-1740893276.png\" alt=\"image\"></p>\n<p><strong>Mac &#x2F; Linux</strong> 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，<strong>Mac &#x2F; Linux 需重启系统</strong>，以确保环境变量生效。</p>\n<h3 id=\"linux版破解\"><a href=\"#linux版破解\" class=\"headerlink\" title=\"linux版破解\"></a>linux版破解</h3><p>和mac版一样，参考mac,这里就不做介绍了。</p>\n<h3 id=\"重启-CLion\"><a href=\"#重启-CLion\" class=\"headerlink\" title=\"重启 CLion\"></a>重启 CLion</h3><p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<h2 id=\"填入指定激活码完成激活\"><a href=\"#填入指定激活码完成激活\" class=\"headerlink\" title=\"填入指定激活码完成激活\"></a>填入指定激活码完成激活</h2><p>打开文件夹里的激活码，粘贴到输入框内，点击 <code>Activate</code> 按钮，就激活成功了。</p>\n<p><img src=\"/../imgs/1894089-20230211104238842-2069324840.png\" alt=\"image\"></p>\n<p><img src=\"/../imgs/1894089-20230211104310444-38131101.png\" alt=\"image\"></p>\n<p>激活成功后，就可以开心的 coding 了 ~</p>\n<p><img src=\"/../imgs/1894089-20230211104336300-896542684.png\" alt=\"image\"></p>\n<p>转：</p>\n<p><a href=\"https://www.cnblogs.com/kohler21/p/17111018.html\">CLion 2022.2.4破解教程详细图解mac,windows,linux均适用 - 愚生浅末 - 博客园 (cnblogs.com)</a></p>\n<p>参考：</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1406250\">使用Clion优雅的完全远程自动同步和远程调试c++-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"下载与安装\"><a href=\"#下载与安装\" class=\"headerlink\" title=\"下载与安装\"></a>下载与安装</h2><p>此教程为CLion 2022.2.4 破解教程，且此教程以及下面提供的破解补丁适用与2022.2以后的新版本。<br>2022年11月10日亲测有效，mac与windows均测试完美破解</p>\n<h3 id=\"CLion-下载\"><a href=\"#CLion-下载\" class=\"headerlink\" title=\"CLion 下载\"></a>CLion 下载</h3><p>Clion官网下载地址：<a href=\"https://www.jetbrains.com.cn/clion/download/other.html\">https://www.jetbrains.com.cn/clion/download/other.html</a></p>\n<p><img src=\"/../imgs/1894089-20230211102247487-1038132289.png\" alt=\"image\"></p>\n<p>找到2022.2.4的，然后根据自己的电脑系统选择。Windows的下载Windows，Mac的下载Mac的。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>直接上面的地址下载安装即可，安装完后记得不要打开，打开后也要先关闭，这里步骤就忽略了，安装很简单。</p>\n<ul>\n<li><strong>卸载老版本 CLion(未安装则不用管，跳过看下面步骤)</strong><br>注意，安装新版本之前，如果本机安装过老版本的, 需要先彻底卸载，以免两者冲突，导致破解失败。<br><strong>安装太简单了，步骤就忽略了。</strong></li>\n</ul>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><h3 id=\"破解补丁下载\"><a href=\"#破解补丁下载\" class=\"headerlink\" title=\"破解补丁下载\"></a>破解补丁下载</h3><p>破解补丁下载地址：<a href=\"https://kohler.lanzouo.com/iS5E40n7ojba\">https://kohler.lanzouo.com/iS5E40n7ojba</a></p>\n<h3 id=\"Windows版破解\"><a href=\"#Windows版破解\" class=\"headerlink\" title=\"Windows版破解\"></a>Windows版破解</h3><p>下载破解补丁后，解压得到，如下图：</p>\n<p><img src=\"/../imgs/1894089-20230211102659035-421863408.png\" alt=\"image\"></p>\n<p>将上面图示的补丁的所属文件夹 <code>/jetbra</code> 复制电脑某个位置，我是放置到了 桌面目录下（不推荐，自己选个D盘目录或者其他位置），<br>点击进入<code>/jetbra</code> 补丁目录，再点击进入<code>/scripts</code> 文件夹，双击执行 <code>install-all-user.vbs</code> 破解脚本：</p>\n<p><img src=\"/../imgs/1894089-20230211102807063-1324567688.png\" alt=\"image\"></p>\n<p><strong>注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。</strong></p>\n<p><img src=\"/../imgs/1894089-20230211102825164-1230499662.png\" alt=\"image\"></p>\n<p>会提示安装补丁需要等待数秒。点击<strong>【确定】</strong>按钮后，过程大概 10 - 30 秒，如看到弹框提示 Done 时，表示激活破解成功：</p>\n<p><img src=\"/../imgs/1894089-20230211102841861-1500251037.png\" alt=\"image\"></p>\n<h3 id=\"mac版破解\"><a href=\"#mac版破解\" class=\"headerlink\" title=\"mac版破解\"></a>mac版破解</h3><p><strong>Mac &#x2F; Linux</strong> 系统与上面 Windows 系统一样，需将补丁所属文件<code>/jetbra</code> 复制到某个路径，且<strong>路径不能包含空格与中文</strong>。</p>\n<p>之后，打开终端，进入到<code>/jetbra/scripts</code> 文件夹， 执行 <code>install.sh</code>脚本, 命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo bash install.sh</span><br></pre></td></tr></table></figure>\n\n<p>看到提示 Done , 表示激活成功。</p>\n<p><img src=\"/../imgs/1894089-20230211104108634-1740893276.png\" alt=\"image\"></p>\n<p><strong>Mac &#x2F; Linux</strong> 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，<strong>Mac &#x2F; Linux 需重启系统</strong>，以确保环境变量生效。</p>\n<h3 id=\"linux版破解\"><a href=\"#linux版破解\" class=\"headerlink\" title=\"linux版破解\"></a>linux版破解</h3><p>和mac版一样，参考mac,这里就不做介绍了。</p>\n<h3 id=\"重启-CLion\"><a href=\"#重启-CLion\" class=\"headerlink\" title=\"重启 CLion\"></a>重启 CLion</h3><p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<h2 id=\"填入指定激活码完成激活\"><a href=\"#填入指定激活码完成激活\" class=\"headerlink\" title=\"填入指定激活码完成激活\"></a>填入指定激活码完成激活</h2><p>打开文件夹里的激活码，粘贴到输入框内，点击 <code>Activate</code> 按钮，就激活成功了。</p>\n<p><img src=\"/../imgs/1894089-20230211104238842-2069324840.png\" alt=\"image\"></p>\n<p><img src=\"/../imgs/1894089-20230211104310444-38131101.png\" alt=\"image\"></p>\n<p>激活成功后，就可以开心的 coding 了 ~</p>\n<p><img src=\"/../imgs/1894089-20230211104336300-896542684.png\" alt=\"image\"></p>\n<p>转：</p>\n<p><a href=\"https://www.cnblogs.com/kohler21/p/17111018.html\">CLion 2022.2.4破解教程详细图解mac,windows,linux均适用 - 愚生浅末 - 博客园 (cnblogs.com)</a></p>\n<p>参考：</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1406250\">使用Clion优雅的完全远程自动同步和远程调试c++-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n"},{"title":"ARMv8架构-内存虚拟化","categories":["test"],"tags":["test"],"date":"2024-05-17T06:45:28.000Z","_content":"\nARM64为支持内存虚拟化，可以将地址类型分为如下三种：\n\n- **VA（虚拟地址）**\n\n   最大宽度为48bit，VA地址空间可分为底部VA和顶部VA两个子区域，每个VM子区域最大支持256T\n   底部VA：0x0000_0000_0000_0000 =>0x0000_FFFF_FFFF_FFFF\n   顶部VA：0xFFFF_0000_0000_0000 =>0xFFFF_FFFF_FFFF_FFFF\n\n- **IPA（中间物理地址）**\n\n   如果不支持Stage 2转换，那么IPA==PA。如果支持Stage 2，IPA作为Stage 1的OA(Output Adress)，IPA作为Stage 2的IA(Input Adress)。它最大支持48bit。\n\n- **PA（物理地址）**\n\n   物理内存单元映射中地址，可以看做是PE到内存系统的输出地址(OA)，其最大支持48bit。\n\n![图2 ARM64内存虚拟化](..\\imgs\\image2019-5-10_14-22-29.png)\n\n 上图是ARM64内存虚拟化的框图，虚拟机通过TTBRn_EL1完成Stage 1的地址转换，将虚拟机使用的VA转换成IPA。然后再通过VTTBR_EL2完成Stage 2的地址转换，将IPA转换成PA。\n\n![ 图2 Stage 1地址转换](../imgs/image2019-5-10_14-24-0.png)\n\n上图是Stage 1（一阶地址转换图）图解，其转换过程如下：\n\n| TTBR 寄存器提供Level 0查找的基地址，通过此基地址和IA[n:39] => 查找到Level 1基地址 |\n| ------------------------------------------------------------ |\n| Level 1基地址结合IA[38：30]=> 查找到Level2 的基地址          |\n| Level 2基地址结合IA[29：21]=> 查找到Level3 的基地址          |\n| Level 3基地址结合IA[20：12]=> 查找物理页框所在地址OA         |\n| 最后得到需要的物理地址PA[47：0] <= OA[47:12] + IA[11：0]     |\n\n![ 图3 Stage 2地址转换](../imgs/image2019-5-10_14-24-58.png)\n\n 上图是Stage 2（二阶地址转换图）图解，，其转换过程如下：\n\n| Stage 2有级联table的概念，可以减少level的级数                |\n| ------------------------------------------------------------ |\n| 所谓级联就是假如有IA[40:0]，而Level1解析地址段为IA[38:30]，超过了2个bit，而2^40 = 2^2*2^38，所以相当于要2^2个这样的translation table来实现级联解析。ARMv8规定，Stage 2最多支持4-bit级联，也就是最大级联2^4 == 16个translation table级联解析.以达到减少查找level的目的. |\n| VTTBR_EL2寄存器提供初始Level查找基地址，Stage 2只为EL2服务   |\n| 同Stage 1，Level 1支持1GB的内存block，Level 2支持2MB的内存block |\n","source":"back_posts/ARMv8架构-内存虚拟化.md","raw":"---\ntitle: ARMv8架构-内存虚拟化\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-05-17 14:45:28\n---\n\nARM64为支持内存虚拟化，可以将地址类型分为如下三种：\n\n- **VA（虚拟地址）**\n\n   最大宽度为48bit，VA地址空间可分为底部VA和顶部VA两个子区域，每个VM子区域最大支持256T\n   底部VA：0x0000_0000_0000_0000 =>0x0000_FFFF_FFFF_FFFF\n   顶部VA：0xFFFF_0000_0000_0000 =>0xFFFF_FFFF_FFFF_FFFF\n\n- **IPA（中间物理地址）**\n\n   如果不支持Stage 2转换，那么IPA==PA。如果支持Stage 2，IPA作为Stage 1的OA(Output Adress)，IPA作为Stage 2的IA(Input Adress)。它最大支持48bit。\n\n- **PA（物理地址）**\n\n   物理内存单元映射中地址，可以看做是PE到内存系统的输出地址(OA)，其最大支持48bit。\n\n![图2 ARM64内存虚拟化](..\\imgs\\image2019-5-10_14-22-29.png)\n\n 上图是ARM64内存虚拟化的框图，虚拟机通过TTBRn_EL1完成Stage 1的地址转换，将虚拟机使用的VA转换成IPA。然后再通过VTTBR_EL2完成Stage 2的地址转换，将IPA转换成PA。\n\n![ 图2 Stage 1地址转换](../imgs/image2019-5-10_14-24-0.png)\n\n上图是Stage 1（一阶地址转换图）图解，其转换过程如下：\n\n| TTBR 寄存器提供Level 0查找的基地址，通过此基地址和IA[n:39] => 查找到Level 1基地址 |\n| ------------------------------------------------------------ |\n| Level 1基地址结合IA[38：30]=> 查找到Level2 的基地址          |\n| Level 2基地址结合IA[29：21]=> 查找到Level3 的基地址          |\n| Level 3基地址结合IA[20：12]=> 查找物理页框所在地址OA         |\n| 最后得到需要的物理地址PA[47：0] <= OA[47:12] + IA[11：0]     |\n\n![ 图3 Stage 2地址转换](../imgs/image2019-5-10_14-24-58.png)\n\n 上图是Stage 2（二阶地址转换图）图解，，其转换过程如下：\n\n| Stage 2有级联table的概念，可以减少level的级数                |\n| ------------------------------------------------------------ |\n| 所谓级联就是假如有IA[40:0]，而Level1解析地址段为IA[38:30]，超过了2个bit，而2^40 = 2^2*2^38，所以相当于要2^2个这样的translation table来实现级联解析。ARMv8规定，Stage 2最多支持4-bit级联，也就是最大级联2^4 == 16个translation table级联解析.以达到减少查找level的目的. |\n| VTTBR_EL2寄存器提供初始Level查找基地址，Stage 2只为EL2服务   |\n| 同Stage 1，Level 1支持1GB的内存block，Level 2支持2MB的内存block |\n","updated":"2024-05-17T06:59:10.584Z","path":"back_posts/ARMv8架构-内存虚拟化.html","comments":1,"layout":"page","_id":"clwadqd7300007pw07l3q6sls","content":"<p>ARM64为支持内存虚拟化，可以将地址类型分为如下三种：</p>\n<ul>\n<li><p><strong>VA（虚拟地址）</strong></p>\n<p> 最大宽度为48bit，VA地址空间可分为底部VA和顶部VA两个子区域，每个VM子区域最大支持256T<br> 底部VA：0x0000_0000_0000_0000 &#x3D;&gt;0x0000_FFFF_FFFF_FFFF<br> 顶部VA：0xFFFF_0000_0000_0000 &#x3D;&gt;0xFFFF_FFFF_FFFF_FFFF</p>\n</li>\n<li><p><strong>IPA（中间物理地址）</strong></p>\n<p> 如果不支持Stage 2转换，那么IPA&#x3D;&#x3D;PA。如果支持Stage 2，IPA作为Stage 1的OA(Output Adress)，IPA作为Stage 2的IA(Input Adress)。它最大支持48bit。</p>\n</li>\n<li><p><strong>PA（物理地址）</strong></p>\n<p> 物理内存单元映射中地址，可以看做是PE到内存系统的输出地址(OA)，其最大支持48bit。</p>\n</li>\n</ul>\n<p><img src=\"/..%5Cimgs%5Cimage2019-5-10_14-22-29.png\" alt=\"图2 ARM64内存虚拟化\"></p>\n<p> 上图是ARM64内存虚拟化的框图，虚拟机通过TTBRn_EL1完成Stage 1的地址转换，将虚拟机使用的VA转换成IPA。然后再通过VTTBR_EL2完成Stage 2的地址转换，将IPA转换成PA。</p>\n<p><img src=\"/../imgs/image2019-5-10_14-24-0.png\" alt=\" 图2 Stage 1地址转换\"></p>\n<p>上图是Stage 1（一阶地址转换图）图解，其转换过程如下：</p>\n<table>\n<thead>\n<tr>\n<th>TTBR 寄存器提供Level 0查找的基地址，通过此基地址和IA[n:39] &#x3D;&gt; 查找到Level 1基地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Level 1基地址结合IA[38：30]&#x3D;&gt; 查找到Level2 的基地址</td>\n</tr>\n<tr>\n<td>Level 2基地址结合IA[29：21]&#x3D;&gt; 查找到Level3 的基地址</td>\n</tr>\n<tr>\n<td>Level 3基地址结合IA[20：12]&#x3D;&gt; 查找物理页框所在地址OA</td>\n</tr>\n<tr>\n<td>最后得到需要的物理地址PA[47：0] &lt;&#x3D; OA[47:12] + IA[11：0]</td>\n</tr>\n</tbody></table>\n<p><img src=\"/../imgs/image2019-5-10_14-24-58.png\" alt=\" 图3 Stage 2地址转换\"></p>\n<p> 上图是Stage 2（二阶地址转换图）图解，，其转换过程如下：</p>\n<table>\n<thead>\n<tr>\n<th>Stage 2有级联table的概念，可以减少level的级数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>所谓级联就是假如有IA[40:0]，而Level1解析地址段为IA[38:30]，超过了2个bit，而2^40 &#x3D; 2^2*2^38，所以相当于要2^2个这样的translation table来实现级联解析。ARMv8规定，Stage 2最多支持4-bit级联，也就是最大级联2^4 &#x3D;&#x3D; 16个translation table级联解析.以达到减少查找level的目的.</td>\n</tr>\n<tr>\n<td>VTTBR_EL2寄存器提供初始Level查找基地址，Stage 2只为EL2服务</td>\n</tr>\n<tr>\n<td>同Stage 1，Level 1支持1GB的内存block，Level 2支持2MB的内存block</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>ARM64为支持内存虚拟化，可以将地址类型分为如下三种：</p>\n<ul>\n<li><p><strong>VA（虚拟地址）</strong></p>\n<p> 最大宽度为48bit，VA地址空间可分为底部VA和顶部VA两个子区域，每个VM子区域最大支持256T<br> 底部VA：0x0000_0000_0000_0000 &#x3D;&gt;0x0000_FFFF_FFFF_FFFF<br> 顶部VA：0xFFFF_0000_0000_0000 &#x3D;&gt;0xFFFF_FFFF_FFFF_FFFF</p>\n</li>\n<li><p><strong>IPA（中间物理地址）</strong></p>\n<p> 如果不支持Stage 2转换，那么IPA&#x3D;&#x3D;PA。如果支持Stage 2，IPA作为Stage 1的OA(Output Adress)，IPA作为Stage 2的IA(Input Adress)。它最大支持48bit。</p>\n</li>\n<li><p><strong>PA（物理地址）</strong></p>\n<p> 物理内存单元映射中地址，可以看做是PE到内存系统的输出地址(OA)，其最大支持48bit。</p>\n</li>\n</ul>\n<p><img src=\"/..%5Cimgs%5Cimage2019-5-10_14-22-29.png\" alt=\"图2 ARM64内存虚拟化\"></p>\n<p> 上图是ARM64内存虚拟化的框图，虚拟机通过TTBRn_EL1完成Stage 1的地址转换，将虚拟机使用的VA转换成IPA。然后再通过VTTBR_EL2完成Stage 2的地址转换，将IPA转换成PA。</p>\n<p><img src=\"/../imgs/image2019-5-10_14-24-0.png\" alt=\" 图2 Stage 1地址转换\"></p>\n<p>上图是Stage 1（一阶地址转换图）图解，其转换过程如下：</p>\n<table>\n<thead>\n<tr>\n<th>TTBR 寄存器提供Level 0查找的基地址，通过此基地址和IA[n:39] &#x3D;&gt; 查找到Level 1基地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Level 1基地址结合IA[38：30]&#x3D;&gt; 查找到Level2 的基地址</td>\n</tr>\n<tr>\n<td>Level 2基地址结合IA[29：21]&#x3D;&gt; 查找到Level3 的基地址</td>\n</tr>\n<tr>\n<td>Level 3基地址结合IA[20：12]&#x3D;&gt; 查找物理页框所在地址OA</td>\n</tr>\n<tr>\n<td>最后得到需要的物理地址PA[47：0] &lt;&#x3D; OA[47:12] + IA[11：0]</td>\n</tr>\n</tbody></table>\n<p><img src=\"/../imgs/image2019-5-10_14-24-58.png\" alt=\" 图3 Stage 2地址转换\"></p>\n<p> 上图是Stage 2（二阶地址转换图）图解，，其转换过程如下：</p>\n<table>\n<thead>\n<tr>\n<th>Stage 2有级联table的概念，可以减少level的级数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>所谓级联就是假如有IA[40:0]，而Level1解析地址段为IA[38:30]，超过了2个bit，而2^40 &#x3D; 2^2*2^38，所以相当于要2^2个这样的translation table来实现级联解析。ARMv8规定，Stage 2最多支持4-bit级联，也就是最大级联2^4 &#x3D;&#x3D; 16个translation table级联解析.以达到减少查找level的目的.</td>\n</tr>\n<tr>\n<td>VTTBR_EL2寄存器提供初始Level查找基地址，Stage 2只为EL2服务</td>\n</tr>\n<tr>\n<td>同Stage 1，Level 1支持1GB的内存block，Level 2支持2MB的内存block</td>\n</tr>\n</tbody></table>\n"},{"title":"vscode-安装-卸载","categories":["test"],"tags":["vscode"],"date":"2024-05-17T07:17:18.000Z","_content":"\n\n\n\n\n\n\n1.安装vscode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 一、安装vscode\n\n1.安装vscode\n\n下载链接：https://code.visualstudio.com/Download#\n\n2.安装VScode插件\n\nhttps://marketplace.visualstudio.com\n\n[Search results - remote | Visual Studio Code , Visual Studio Marketplace](https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All categories&sortBy=Relevance)\n\n安装vscode时选择默认路径，安装完成后打开，安装扩展：\n1、 C/C++（就是有些教程里的cpptools）\n2、 C/C++ Clang Command Adapter：提供静态检测（Lint），很重要\n3、 Code Runner：右键即可编译运行单文件，很方便\n4、 Bracket Pair Colorizer：彩虹花括号\n5、 Include Autocomplete：提供头文件名字的补全\n6、 C/C++ Snippets：Snippets 即重用代码块，\n7、 One Dark Pro：大概是VS Code安装量最高的主题\n8、 python\n9、Clang-Format\n10、Chinese （Simplified）Language Pack for Visual Studio Code：汉化包\n\n# 二、卸载\n\n1、打开控制面板的程序，卸载安装的vscode\n\n或者\n\n找到安装目录点击unins000\n\n![image-20240517154457324](../imgs/image-20240517154457324-17159319055301.png)\n\n2.删除相关配置文件\n\n```\nC: \\ Users \\ .vscode\nC: \\ Users \\ AppData \\ Roaming \\ Code \n```\n\n或者\n\nwin+r输入以下内容\n\n```c\n%appdata%\t\t#删除 Code目录\n%userprofile%\t#删除 .vscode\n```\n\n\n\n[彻底卸载VScode并重置本地配置数据-CSDN博客](https://blog.csdn.net/2301_80868127/article/details/136386915)\n\n[vsCode离线安装remote-ssh插件搭建远程开发环境 (qq.com)](https://mp.weixin.qq.com/s/n7zyDFOeHd9K5oSKz7Zg9Q)\n","source":"back_posts/vscode-安装-卸载.md","raw":"---\ntitle: vscode-安装-卸载\ncategories:\n  - test\ntags:\n  - vscode\ndate: 2024-05-17 15:17:18\n---\n\n\n\n\n\n\n\n1.安装vscode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 一、安装vscode\n\n1.安装vscode\n\n下载链接：https://code.visualstudio.com/Download#\n\n2.安装VScode插件\n\nhttps://marketplace.visualstudio.com\n\n[Search results - remote | Visual Studio Code , Visual Studio Marketplace](https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All categories&sortBy=Relevance)\n\n安装vscode时选择默认路径，安装完成后打开，安装扩展：\n1、 C/C++（就是有些教程里的cpptools）\n2、 C/C++ Clang Command Adapter：提供静态检测（Lint），很重要\n3、 Code Runner：右键即可编译运行单文件，很方便\n4、 Bracket Pair Colorizer：彩虹花括号\n5、 Include Autocomplete：提供头文件名字的补全\n6、 C/C++ Snippets：Snippets 即重用代码块，\n7、 One Dark Pro：大概是VS Code安装量最高的主题\n8、 python\n9、Clang-Format\n10、Chinese （Simplified）Language Pack for Visual Studio Code：汉化包\n\n# 二、卸载\n\n1、打开控制面板的程序，卸载安装的vscode\n\n或者\n\n找到安装目录点击unins000\n\n![image-20240517154457324](../imgs/image-20240517154457324-17159319055301.png)\n\n2.删除相关配置文件\n\n```\nC: \\ Users \\ .vscode\nC: \\ Users \\ AppData \\ Roaming \\ Code \n```\n\n或者\n\nwin+r输入以下内容\n\n```c\n%appdata%\t\t#删除 Code目录\n%userprofile%\t#删除 .vscode\n```\n\n\n\n[彻底卸载VScode并重置本地配置数据-CSDN博客](https://blog.csdn.net/2301_80868127/article/details/136386915)\n\n[vsCode离线安装remote-ssh插件搭建远程开发环境 (qq.com)](https://mp.weixin.qq.com/s/n7zyDFOeHd9K5oSKz7Zg9Q)\n","updated":"2024-05-17T07:50:23.361Z","path":"back_posts/vscode-安装-卸载.html","comments":1,"layout":"page","_id":"clwagumwb0000npw03pftd3js","content":"<p>1.安装vscode</p>\n<h1 id=\"一、安装vscode\"><a href=\"#一、安装vscode\" class=\"headerlink\" title=\"一、安装vscode\"></a>一、安装vscode</h1><p>1.安装vscode</p>\n<p>下载链接：<a href=\"https://code.visualstudio.com/Download#\">https://code.visualstudio.com/Download#</a></p>\n<p>2.安装VScode插件</p>\n<p><a href=\"https://marketplace.visualstudio.com/\">https://marketplace.visualstudio.com</a></p>\n<p>[Search results - remote | Visual Studio Code , Visual Studio Marketplace](<a href=\"https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All\">https://marketplace.visualstudio.com/search?term=remote&amp;target=VSCode&amp;category=All</a> categories&amp;sortBy&#x3D;Relevance)</p>\n<p>安装vscode时选择默认路径，安装完成后打开，安装扩展：<br>1、 C&#x2F;C++（就是有些教程里的cpptools）<br>2、 C&#x2F;C++ Clang Command Adapter：提供静态检测（Lint），很重要<br>3、 Code Runner：右键即可编译运行单文件，很方便<br>4、 Bracket Pair Colorizer：彩虹花括号<br>5、 Include Autocomplete：提供头文件名字的补全<br>6、 C&#x2F;C++ Snippets：Snippets 即重用代码块，<br>7、 One Dark Pro：大概是VS Code安装量最高的主题<br>8、 python<br>9、Clang-Format<br>10、Chinese （Simplified）Language Pack for Visual Studio Code：汉化包</p>\n<h1 id=\"二、卸载\"><a href=\"#二、卸载\" class=\"headerlink\" title=\"二、卸载\"></a>二、卸载</h1><p>1、打开控制面板的程序，卸载安装的vscode</p>\n<p>或者</p>\n<p>找到安装目录点击unins000</p>\n<p><img src=\"/../imgs/image-20240517154457324-17159319055301.png\" alt=\"image-20240517154457324\"></p>\n<p>2.删除相关配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C: \\ Users \\ .vscode</span><br><span class=\"line\">C: \\ Users \\ AppData \\ Roaming \\ Code </span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<p>win+r输入以下内容</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%appdata%\t\t#删除 Code目录</span><br><span class=\"line\">%userprofile%\t#删除 .vscode</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://blog.csdn.net/2301_80868127/article/details/136386915\">彻底卸载VScode并重置本地配置数据-CSDN博客</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/n7zyDFOeHd9K5oSKz7Zg9Q\">vsCode离线安装remote-ssh插件搭建远程开发环境 (qq.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.安装vscode</p>\n<h1 id=\"一、安装vscode\"><a href=\"#一、安装vscode\" class=\"headerlink\" title=\"一、安装vscode\"></a>一、安装vscode</h1><p>1.安装vscode</p>\n<p>下载链接：<a href=\"https://code.visualstudio.com/Download#\">https://code.visualstudio.com/Download#</a></p>\n<p>2.安装VScode插件</p>\n<p><a href=\"https://marketplace.visualstudio.com/\">https://marketplace.visualstudio.com</a></p>\n<p>[Search results - remote | Visual Studio Code , Visual Studio Marketplace](<a href=\"https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All\">https://marketplace.visualstudio.com/search?term=remote&amp;target=VSCode&amp;category=All</a> categories&amp;sortBy&#x3D;Relevance)</p>\n<p>安装vscode时选择默认路径，安装完成后打开，安装扩展：<br>1、 C&#x2F;C++（就是有些教程里的cpptools）<br>2、 C&#x2F;C++ Clang Command Adapter：提供静态检测（Lint），很重要<br>3、 Code Runner：右键即可编译运行单文件，很方便<br>4、 Bracket Pair Colorizer：彩虹花括号<br>5、 Include Autocomplete：提供头文件名字的补全<br>6、 C&#x2F;C++ Snippets：Snippets 即重用代码块，<br>7、 One Dark Pro：大概是VS Code安装量最高的主题<br>8、 python<br>9、Clang-Format<br>10、Chinese （Simplified）Language Pack for Visual Studio Code：汉化包</p>\n<h1 id=\"二、卸载\"><a href=\"#二、卸载\" class=\"headerlink\" title=\"二、卸载\"></a>二、卸载</h1><p>1、打开控制面板的程序，卸载安装的vscode</p>\n<p>或者</p>\n<p>找到安装目录点击unins000</p>\n<p><img src=\"/../imgs/image-20240517154457324-17159319055301.png\" alt=\"image-20240517154457324\"></p>\n<p>2.删除相关配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C: \\ Users \\ .vscode</span><br><span class=\"line\">C: \\ Users \\ AppData \\ Roaming \\ Code </span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<p>win+r输入以下内容</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%appdata%\t\t#删除 Code目录</span><br><span class=\"line\">%userprofile%\t#删除 .vscode</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://blog.csdn.net/2301_80868127/article/details/136386915\">彻底卸载VScode并重置本地配置数据-CSDN博客</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/n7zyDFOeHd9K5oSKz7Zg9Q\">vsCode离线安装remote-ssh插件搭建远程开发环境 (qq.com)</a></p>\n"},{"title":"Windows下通过ssh挂载远程服务器目录","categories":["test"],"tags":["test"],"date":"2024-05-25T03:27:05.000Z","_content":"\n\n\n\n\n### 下载\n\n直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。\n\n- sshfs-win：https://github.com/billziss-gh/sshfs-win/releases\n- winfsp：https://github.com/billziss-gh/winfsp/releases\n- SSHFS-Win Manager：https://github.com/evsar3/sshfs-win-manager/releases (GUI，可选)\n\n### 快速使用\n\n可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。\n\n#### 方式A：使用GUI（推荐）\n\n新建连接\n\n安装好上述3个软件后，打开 GUI 界面如下，点击 `Add Connection`：\n\n![img](../imgs/38433cbf3936910bd982dbe3edad457f.png)\n\nSSHFS-Win Manager GUI 主界面\n\n依次填写每一项内容：\n\n- NAME：给远程服务器取个名字\n- Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：[SSH密钥管理及免密码登陆](https://blog.xieqk.com/posts/3517905979.html)]）\n- Remote：远程目录配置，挂载后将成为本地对应盘符的根目录\n- Local：本地盘符设置（注意不要与现有盘符冲突）\n\n示例如下：\n\n![img](../imgs/10679e86d7d5de085f10f418602d3fc0.png)\n\n添加连接\n\n点击 `Save` 保存。\n\n挂在远程目录\n\n在主界面中点击`连接`按钮，即可将远程目录挂在到本地：\n\n![img](../imgs/b5509514fe3ed5e171527650e89113df.png)\n\n添加新连接后的主界面\n\n此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面`连接`按钮左边的`打开文件夹`按钮即可进入目录。\n\n![img](../imgs/9a41a7910eae90cbc4133263b56065b4.png)\n\n本地挂载成功\n\n长期使用建议在主界面的设置中打开`开机自启`：\n\n打开开机启动\n\n![img](../imgs/8191070c413a2f5053f4fa1fff32375d.png)\n\n\n\n#### 方式B：手动挂载\n\n挂载路径\n\n**1. SSH 使用默认端口（22）**\n\n此时，对应的 ssh 登陆命令为 `ssh username@remote_ip`，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：\n\n```\n# 根目录\n\\\\sshfs.r\\username@remote_ip\\\n\n# home 目录\n\\\\sshfs\\username@remote_ip\\\n# 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\\n```\n\n例如：`\\\\sshfs.r\\xieqk@10.168.9.87\\`，注意路径里面的分隔符为 windows 使用的反斜杠 `\\`。\n\n**2. SSH 使用其它端口（外网端口转发连接内网服务器）**\n\n此时，ssh 登陆命令为 `ssh -p port username@remote_ip`，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 `remote_ip` 后加上 `!port` 即可：\n\n```\n# 根目录\n\\\\sshfs.r\\username@remote_ip\\\n\n# home 目录\n\\\\sshfs\\username@remote_ip\\\n# 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\\n```\n\n例如：`\\\\sshfs.r\\xieqk@168.10.9.87!34567\\`。\n\n登陆挂载远程目录\n\n将上述 `sshfs` 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（**注意：**弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 `sshfs` 路径之中，所以此处只需正常输入远程用户对应的密码即可。）\n\n对于常用的远程目录，建议通过 `映射网络驱动器` 长期挂载于本地。\n\n![img](../imgs/a1e47db6d3e144affe47566fed629e9e.png)\n\n映射网络驱动器\n\n在 `映射网络驱动器` 中，可自行分配驱动器盘号，然后在 `文件夹` 处输入上述 `sshfs` 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。\n\n![img](../imgs/675b07d51113aeaf1b18b08b1fda130b.png)\n\n输入 sshfs 路径\n\n之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：\n\n![img](../imgs/84fe4ccf655091b45ffcad9c61def517.png)\n\n本地挂载成功\n\n详细参数（可跳过，需要时再查看）\n\nsshfs-win 具体语法形式如下，其中 `[]` 中的内容为选填项，若为默认值可不填：\n\n```\n\\\\sshfs\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n\\\\sshfs.r\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n\\\\sshfs.k\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n```\n\n\n\n- `REMUSER`: 即 remote user，指 SSH 登陆远程主机时的用户名。\n- `HOST`：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址\n- `PORT`：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).\n- `PATH`：进入的远程服务器路径，可按照如下设置:\n  - 前缀 `sshfs` 对应为 `HOST:~REMUSER/PATH`，即远程服务器上相对于该用户 `home` 目录的相对路径：`/home/remote_user/PATH`。\n  - 前缀 `sshfs.r` 对应为 `HOST:/PATH` 即远程服务器上相对于根(root)目录的路径：`/PATH`。\n  - 前缀 `sshfs.k` 与第一项相同，对应为 `HOST:~REMUSER/PATH`，但它使用 Windows 本地当前用户位于 `%USERPROFILE%/.ssh/id_rsa` 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠[SSH 密钥管理及免密码登陆](https://blog.xieqk.com/posts/3517905979.html)），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可）\n- `LOCUSER` windows本地用户名，可不填。\n\n\n\n\n\n转：\n\nhttps://blog.csdn.net/qq_31811537/article/details/124721621\n","source":"back_posts/Windows下通过ssh挂载远程服务器目录.md","raw":"---\ntitle: Windows下通过ssh挂载远程服务器目录\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-05-25 11:27:05\n---\n\n\n\n\n\n### 下载\n\n直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。\n\n- sshfs-win：https://github.com/billziss-gh/sshfs-win/releases\n- winfsp：https://github.com/billziss-gh/winfsp/releases\n- SSHFS-Win Manager：https://github.com/evsar3/sshfs-win-manager/releases (GUI，可选)\n\n### 快速使用\n\n可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。\n\n#### 方式A：使用GUI（推荐）\n\n新建连接\n\n安装好上述3个软件后，打开 GUI 界面如下，点击 `Add Connection`：\n\n![img](../imgs/38433cbf3936910bd982dbe3edad457f.png)\n\nSSHFS-Win Manager GUI 主界面\n\n依次填写每一项内容：\n\n- NAME：给远程服务器取个名字\n- Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：[SSH密钥管理及免密码登陆](https://blog.xieqk.com/posts/3517905979.html)]）\n- Remote：远程目录配置，挂载后将成为本地对应盘符的根目录\n- Local：本地盘符设置（注意不要与现有盘符冲突）\n\n示例如下：\n\n![img](../imgs/10679e86d7d5de085f10f418602d3fc0.png)\n\n添加连接\n\n点击 `Save` 保存。\n\n挂在远程目录\n\n在主界面中点击`连接`按钮，即可将远程目录挂在到本地：\n\n![img](../imgs/b5509514fe3ed5e171527650e89113df.png)\n\n添加新连接后的主界面\n\n此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面`连接`按钮左边的`打开文件夹`按钮即可进入目录。\n\n![img](../imgs/9a41a7910eae90cbc4133263b56065b4.png)\n\n本地挂载成功\n\n长期使用建议在主界面的设置中打开`开机自启`：\n\n打开开机启动\n\n![img](../imgs/8191070c413a2f5053f4fa1fff32375d.png)\n\n\n\n#### 方式B：手动挂载\n\n挂载路径\n\n**1. SSH 使用默认端口（22）**\n\n此时，对应的 ssh 登陆命令为 `ssh username@remote_ip`，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：\n\n```\n# 根目录\n\\\\sshfs.r\\username@remote_ip\\\n\n# home 目录\n\\\\sshfs\\username@remote_ip\\\n# 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\\n```\n\n例如：`\\\\sshfs.r\\xieqk@10.168.9.87\\`，注意路径里面的分隔符为 windows 使用的反斜杠 `\\`。\n\n**2. SSH 使用其它端口（外网端口转发连接内网服务器）**\n\n此时，ssh 登陆命令为 `ssh -p port username@remote_ip`，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 `remote_ip` 后加上 `!port` 即可：\n\n```\n# 根目录\n\\\\sshfs.r\\username@remote_ip\\\n\n# home 目录\n\\\\sshfs\\username@remote_ip\\\n# 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\\n```\n\n例如：`\\\\sshfs.r\\xieqk@168.10.9.87!34567\\`。\n\n登陆挂载远程目录\n\n将上述 `sshfs` 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（**注意：**弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 `sshfs` 路径之中，所以此处只需正常输入远程用户对应的密码即可。）\n\n对于常用的远程目录，建议通过 `映射网络驱动器` 长期挂载于本地。\n\n![img](../imgs/a1e47db6d3e144affe47566fed629e9e.png)\n\n映射网络驱动器\n\n在 `映射网络驱动器` 中，可自行分配驱动器盘号，然后在 `文件夹` 处输入上述 `sshfs` 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。\n\n![img](../imgs/675b07d51113aeaf1b18b08b1fda130b.png)\n\n输入 sshfs 路径\n\n之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：\n\n![img](../imgs/84fe4ccf655091b45ffcad9c61def517.png)\n\n本地挂载成功\n\n详细参数（可跳过，需要时再查看）\n\nsshfs-win 具体语法形式如下，其中 `[]` 中的内容为选填项，若为默认值可不填：\n\n```\n\\\\sshfs\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n\\\\sshfs.r\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n\\\\sshfs.k\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n```\n\n\n\n- `REMUSER`: 即 remote user，指 SSH 登陆远程主机时的用户名。\n- `HOST`：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址\n- `PORT`：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).\n- `PATH`：进入的远程服务器路径，可按照如下设置:\n  - 前缀 `sshfs` 对应为 `HOST:~REMUSER/PATH`，即远程服务器上相对于该用户 `home` 目录的相对路径：`/home/remote_user/PATH`。\n  - 前缀 `sshfs.r` 对应为 `HOST:/PATH` 即远程服务器上相对于根(root)目录的路径：`/PATH`。\n  - 前缀 `sshfs.k` 与第一项相同，对应为 `HOST:~REMUSER/PATH`，但它使用 Windows 本地当前用户位于 `%USERPROFILE%/.ssh/id_rsa` 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠[SSH 密钥管理及免密码登陆](https://blog.xieqk.com/posts/3517905979.html)），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可）\n- `LOCUSER` windows本地用户名，可不填。\n\n\n\n\n\n转：\n\nhttps://blog.csdn.net/qq_31811537/article/details/124721621\n","updated":"2024-05-25T03:33:25.837Z","path":"back_posts/Windows下通过ssh挂载远程服务器目录.html","comments":1,"layout":"page","_id":"clwlkcz2e0000r3w01vim6pdb","content":"<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。</p>\n<ul>\n<li>sshfs-win：<a href=\"https://github.com/billziss-gh/sshfs-win/releases\">https://github.com/billziss-gh/sshfs-win/releases</a></li>\n<li>winfsp：<a href=\"https://github.com/billziss-gh/winfsp/releases\">https://github.com/billziss-gh/winfsp/releases</a></li>\n<li>SSHFS-Win Manager：<a href=\"https://github.com/evsar3/sshfs-win-manager/releases\">https://github.com/evsar3/sshfs-win-manager/releases</a> (GUI，可选)</li>\n</ul>\n<h3 id=\"快速使用\"><a href=\"#快速使用\" class=\"headerlink\" title=\"快速使用\"></a>快速使用</h3><p>可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。</p>\n<h4 id=\"方式A：使用GUI（推荐）\"><a href=\"#方式A：使用GUI（推荐）\" class=\"headerlink\" title=\"方式A：使用GUI（推荐）\"></a>方式A：使用GUI（推荐）</h4><p>新建连接</p>\n<p>安装好上述3个软件后，打开 GUI 界面如下，点击 <code>Add Connection</code>：</p>\n<p><img src=\"/../imgs/38433cbf3936910bd982dbe3edad457f.png\" alt=\"img\"></p>\n<p>SSHFS-Win Manager GUI 主界面</p>\n<p>依次填写每一项内容：</p>\n<ul>\n<li>NAME：给远程服务器取个名字</li>\n<li>Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：<a href=\"https://blog.xieqk.com/posts/3517905979.html\">SSH密钥管理及免密码登陆</a>]）</li>\n<li>Remote：远程目录配置，挂载后将成为本地对应盘符的根目录</li>\n<li>Local：本地盘符设置（注意不要与现有盘符冲突）</li>\n</ul>\n<p>示例如下：</p>\n<p><img src=\"/../imgs/10679e86d7d5de085f10f418602d3fc0.png\" alt=\"img\"></p>\n<p>添加连接</p>\n<p>点击 <code>Save</code> 保存。</p>\n<p>挂在远程目录</p>\n<p>在主界面中点击<code>连接</code>按钮，即可将远程目录挂在到本地：</p>\n<p><img src=\"/../imgs/b5509514fe3ed5e171527650e89113df.png\" alt=\"img\"></p>\n<p>添加新连接后的主界面</p>\n<p>此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面<code>连接</code>按钮左边的<code>打开文件夹</code>按钮即可进入目录。</p>\n<p><img src=\"/../imgs/9a41a7910eae90cbc4133263b56065b4.png\" alt=\"img\"></p>\n<p>本地挂载成功</p>\n<p>长期使用建议在主界面的设置中打开<code>开机自启</code>：</p>\n<p>打开开机启动</p>\n<p><img src=\"/../imgs/8191070c413a2f5053f4fa1fff32375d.png\" alt=\"img\"></p>\n<h4 id=\"方式B：手动挂载\"><a href=\"#方式B：手动挂载\" class=\"headerlink\" title=\"方式B：手动挂载\"></a>方式B：手动挂载</h4><p>挂载路径</p>\n<p><strong>1. SSH 使用默认端口（22）</strong></p>\n<p>此时，对应的 ssh 登陆命令为 <code>ssh username@remote_ip</code>，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 根目录</span><br><span class=\"line\">\\\\sshfs.r\\username@remote_ip\\</span><br><span class=\"line\"></span><br><span class=\"line\"># home 目录</span><br><span class=\"line\">\\\\sshfs\\username@remote_ip\\</span><br><span class=\"line\"># 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\</span><br></pre></td></tr></table></figure>\n\n<p>例如：<code>\\\\sshfs.r\\xieqk@10.168.9.87\\</code>，注意路径里面的分隔符为 windows 使用的反斜杠 <code>\\</code>。</p>\n<p><strong>2. SSH 使用其它端口（外网端口转发连接内网服务器）</strong></p>\n<p>此时，ssh 登陆命令为 <code>ssh -p port username@remote_ip</code>，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 <code>remote_ip</code> 后加上 <code>!port</code> 即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 根目录</span><br><span class=\"line\">\\\\sshfs.r\\username@remote_ip\\</span><br><span class=\"line\"></span><br><span class=\"line\"># home 目录</span><br><span class=\"line\">\\\\sshfs\\username@remote_ip\\</span><br><span class=\"line\"># 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\</span><br></pre></td></tr></table></figure>\n\n<p>例如：<code>\\\\sshfs.r\\xieqk@168.10.9.87!34567\\</code>。</p>\n<p>登陆挂载远程目录</p>\n<p>将上述 <code>sshfs</code> 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（<strong>注意：</strong>弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 <code>sshfs</code> 路径之中，所以此处只需正常输入远程用户对应的密码即可。）</p>\n<p>对于常用的远程目录，建议通过 <code>映射网络驱动器</code> 长期挂载于本地。</p>\n<p><img src=\"/../imgs/a1e47db6d3e144affe47566fed629e9e.png\" alt=\"img\"></p>\n<p>映射网络驱动器</p>\n<p>在 <code>映射网络驱动器</code> 中，可自行分配驱动器盘号，然后在 <code>文件夹</code> 处输入上述 <code>sshfs</code> 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。</p>\n<p><img src=\"/../imgs/675b07d51113aeaf1b18b08b1fda130b.png\" alt=\"img\"></p>\n<p>输入 sshfs 路径</p>\n<p>之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：</p>\n<p><img src=\"/../imgs/84fe4ccf655091b45ffcad9c61def517.png\" alt=\"img\"></p>\n<p>本地挂载成功</p>\n<p>详细参数（可跳过，需要时再查看）</p>\n<p>sshfs-win 具体语法形式如下，其中 <code>[]</code> 中的内容为选填项，若为默认值可不填：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\sshfs\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br><span class=\"line\">\\\\sshfs.r\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br><span class=\"line\">\\\\sshfs.k\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><code>REMUSER</code>: 即 remote user，指 SSH 登陆远程主机时的用户名。</li>\n<li><code>HOST</code>：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址</li>\n<li><code>PORT</code>：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).</li>\n<li><code>PATH</code>：进入的远程服务器路径，可按照如下设置:<ul>\n<li>前缀 <code>sshfs</code> 对应为 <code>HOST:~REMUSER/PATH</code>，即远程服务器上相对于该用户 <code>home</code> 目录的相对路径：<code>/home/remote_user/PATH</code>。</li>\n<li>前缀 <code>sshfs.r</code> 对应为 <code>HOST:/PATH</code> 即远程服务器上相对于根(root)目录的路径：<code>/PATH</code>。</li>\n<li>前缀 <code>sshfs.k</code> 与第一项相同，对应为 <code>HOST:~REMUSER/PATH</code>，但它使用 Windows 本地当前用户位于 <code>%USERPROFILE%/.ssh/id_rsa</code> 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠<a href=\"https://blog.xieqk.com/posts/3517905979.html\">SSH 密钥管理及免密码登陆</a>），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可）</li>\n</ul>\n</li>\n<li><code>LOCUSER</code> windows本地用户名，可不填。</li>\n</ul>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/qq_31811537/article/details/124721621\">https://blog.csdn.net/qq_31811537/article/details/124721621</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。</p>\n<ul>\n<li>sshfs-win：<a href=\"https://github.com/billziss-gh/sshfs-win/releases\">https://github.com/billziss-gh/sshfs-win/releases</a></li>\n<li>winfsp：<a href=\"https://github.com/billziss-gh/winfsp/releases\">https://github.com/billziss-gh/winfsp/releases</a></li>\n<li>SSHFS-Win Manager：<a href=\"https://github.com/evsar3/sshfs-win-manager/releases\">https://github.com/evsar3/sshfs-win-manager/releases</a> (GUI，可选)</li>\n</ul>\n<h3 id=\"快速使用\"><a href=\"#快速使用\" class=\"headerlink\" title=\"快速使用\"></a>快速使用</h3><p>可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。</p>\n<h4 id=\"方式A：使用GUI（推荐）\"><a href=\"#方式A：使用GUI（推荐）\" class=\"headerlink\" title=\"方式A：使用GUI（推荐）\"></a>方式A：使用GUI（推荐）</h4><p>新建连接</p>\n<p>安装好上述3个软件后，打开 GUI 界面如下，点击 <code>Add Connection</code>：</p>\n<p><img src=\"/../imgs/38433cbf3936910bd982dbe3edad457f.png\" alt=\"img\"></p>\n<p>SSHFS-Win Manager GUI 主界面</p>\n<p>依次填写每一项内容：</p>\n<ul>\n<li>NAME：给远程服务器取个名字</li>\n<li>Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：<a href=\"https://blog.xieqk.com/posts/3517905979.html\">SSH密钥管理及免密码登陆</a>]）</li>\n<li>Remote：远程目录配置，挂载后将成为本地对应盘符的根目录</li>\n<li>Local：本地盘符设置（注意不要与现有盘符冲突）</li>\n</ul>\n<p>示例如下：</p>\n<p><img src=\"/../imgs/10679e86d7d5de085f10f418602d3fc0.png\" alt=\"img\"></p>\n<p>添加连接</p>\n<p>点击 <code>Save</code> 保存。</p>\n<p>挂在远程目录</p>\n<p>在主界面中点击<code>连接</code>按钮，即可将远程目录挂在到本地：</p>\n<p><img src=\"/../imgs/b5509514fe3ed5e171527650e89113df.png\" alt=\"img\"></p>\n<p>添加新连接后的主界面</p>\n<p>此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面<code>连接</code>按钮左边的<code>打开文件夹</code>按钮即可进入目录。</p>\n<p><img src=\"/../imgs/9a41a7910eae90cbc4133263b56065b4.png\" alt=\"img\"></p>\n<p>本地挂载成功</p>\n<p>长期使用建议在主界面的设置中打开<code>开机自启</code>：</p>\n<p>打开开机启动</p>\n<p><img src=\"/../imgs/8191070c413a2f5053f4fa1fff32375d.png\" alt=\"img\"></p>\n<h4 id=\"方式B：手动挂载\"><a href=\"#方式B：手动挂载\" class=\"headerlink\" title=\"方式B：手动挂载\"></a>方式B：手动挂载</h4><p>挂载路径</p>\n<p><strong>1. SSH 使用默认端口（22）</strong></p>\n<p>此时，对应的 ssh 登陆命令为 <code>ssh username@remote_ip</code>，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 根目录</span><br><span class=\"line\">\\\\sshfs.r\\username@remote_ip\\</span><br><span class=\"line\"></span><br><span class=\"line\"># home 目录</span><br><span class=\"line\">\\\\sshfs\\username@remote_ip\\</span><br><span class=\"line\"># 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\</span><br></pre></td></tr></table></figure>\n\n<p>例如：<code>\\\\sshfs.r\\xieqk@10.168.9.87\\</code>，注意路径里面的分隔符为 windows 使用的反斜杠 <code>\\</code>。</p>\n<p><strong>2. SSH 使用其它端口（外网端口转发连接内网服务器）</strong></p>\n<p>此时，ssh 登陆命令为 <code>ssh -p port username@remote_ip</code>，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 <code>remote_ip</code> 后加上 <code>!port</code> 即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 根目录</span><br><span class=\"line\">\\\\sshfs.r\\username@remote_ip\\</span><br><span class=\"line\"></span><br><span class=\"line\"># home 目录</span><br><span class=\"line\">\\\\sshfs\\username@remote_ip\\</span><br><span class=\"line\"># 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\</span><br></pre></td></tr></table></figure>\n\n<p>例如：<code>\\\\sshfs.r\\xieqk@168.10.9.87!34567\\</code>。</p>\n<p>登陆挂载远程目录</p>\n<p>将上述 <code>sshfs</code> 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（<strong>注意：</strong>弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 <code>sshfs</code> 路径之中，所以此处只需正常输入远程用户对应的密码即可。）</p>\n<p>对于常用的远程目录，建议通过 <code>映射网络驱动器</code> 长期挂载于本地。</p>\n<p><img src=\"/../imgs/a1e47db6d3e144affe47566fed629e9e.png\" alt=\"img\"></p>\n<p>映射网络驱动器</p>\n<p>在 <code>映射网络驱动器</code> 中，可自行分配驱动器盘号，然后在 <code>文件夹</code> 处输入上述 <code>sshfs</code> 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。</p>\n<p><img src=\"/../imgs/675b07d51113aeaf1b18b08b1fda130b.png\" alt=\"img\"></p>\n<p>输入 sshfs 路径</p>\n<p>之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：</p>\n<p><img src=\"/../imgs/84fe4ccf655091b45ffcad9c61def517.png\" alt=\"img\"></p>\n<p>本地挂载成功</p>\n<p>详细参数（可跳过，需要时再查看）</p>\n<p>sshfs-win 具体语法形式如下，其中 <code>[]</code> 中的内容为选填项，若为默认值可不填：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\sshfs\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br><span class=\"line\">\\\\sshfs.r\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br><span class=\"line\">\\\\sshfs.k\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><code>REMUSER</code>: 即 remote user，指 SSH 登陆远程主机时的用户名。</li>\n<li><code>HOST</code>：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址</li>\n<li><code>PORT</code>：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).</li>\n<li><code>PATH</code>：进入的远程服务器路径，可按照如下设置:<ul>\n<li>前缀 <code>sshfs</code> 对应为 <code>HOST:~REMUSER/PATH</code>，即远程服务器上相对于该用户 <code>home</code> 目录的相对路径：<code>/home/remote_user/PATH</code>。</li>\n<li>前缀 <code>sshfs.r</code> 对应为 <code>HOST:/PATH</code> 即远程服务器上相对于根(root)目录的路径：<code>/PATH</code>。</li>\n<li>前缀 <code>sshfs.k</code> 与第一项相同，对应为 <code>HOST:~REMUSER/PATH</code>，但它使用 Windows 本地当前用户位于 <code>%USERPROFILE%/.ssh/id_rsa</code> 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠<a href=\"https://blog.xieqk.com/posts/3517905979.html\">SSH 密钥管理及免密码登陆</a>），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可）</li>\n</ul>\n</li>\n<li><code>LOCUSER</code> windows本地用户名，可不填。</li>\n</ul>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/qq_31811537/article/details/124721621\">https://blog.csdn.net/qq_31811537/article/details/124721621</a></p>\n"},{"title":"vscode-远程连接失败","categories":["test"],"tags":["vscode"],"date":"2024-05-17T09:14:04.000Z","_content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n可能在服务端/root/.vscode-server/bin这个目录存在一个与你本地vscode版本不一致的文件夹，删除这个对应的文件夹重新连接就行了\n\n# 先删除本地和服务端的know_hosts \n\n![image-20240517171503577](../imgs/image-20240517171503577.png)\n\n\n\n[vscode远程连接提示过程试图写入的管道不存在_过程试图写入的管道不存在vscode-CSDN博客](https://blog.csdn.net/baidu_39131915/article/details/116302847)\n","source":"back_posts/vscode-远程连接失败.md","raw":"---\ntitle: vscode-远程连接失败\ncategories:\n  - test\ntags:\n  - vscode\ndate: 2024-05-17 17:14:4\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n可能在服务端/root/.vscode-server/bin这个目录存在一个与你本地vscode版本不一致的文件夹，删除这个对应的文件夹重新连接就行了\n\n# 先删除本地和服务端的know_hosts \n\n![image-20240517171503577](../imgs/image-20240517171503577.png)\n\n\n\n[vscode远程连接提示过程试图写入的管道不存在_过程试图写入的管道不存在vscode-CSDN博客](https://blog.csdn.net/baidu_39131915/article/details/116302847)\n","updated":"2024-05-25T03:33:25.895Z","path":"back_posts/vscode-远程连接失败.html","comments":1,"layout":"page","_id":"clwlkcz2g0001r3w0cqfw8kh9","content":"<p>可能在服务端&#x2F;root&#x2F;.vscode-server&#x2F;bin这个目录存在一个与你本地vscode版本不一致的文件夹，删除这个对应的文件夹重新连接就行了</p>\n<h1 id=\"先删除本地和服务端的know-hosts\"><a href=\"#先删除本地和服务端的know-hosts\" class=\"headerlink\" title=\"先删除本地和服务端的know_hosts\"></a>先删除本地和服务端的know_hosts</h1><p><img src=\"/../imgs/image-20240517171503577.png\" alt=\"image-20240517171503577\"></p>\n<p><a href=\"https://blog.csdn.net/baidu_39131915/article/details/116302847\">vscode远程连接提示过程试图写入的管道不存在_过程试图写入的管道不存在vscode-CSDN博客</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>可能在服务端&#x2F;root&#x2F;.vscode-server&#x2F;bin这个目录存在一个与你本地vscode版本不一致的文件夹，删除这个对应的文件夹重新连接就行了</p>\n<h1 id=\"先删除本地和服务端的know-hosts\"><a href=\"#先删除本地和服务端的know-hosts\" class=\"headerlink\" title=\"先删除本地和服务端的know_hosts\"></a>先删除本地和服务端的know_hosts</h1><p><img src=\"/../imgs/image-20240517171503577.png\" alt=\"image-20240517171503577\"></p>\n<p><a href=\"https://blog.csdn.net/baidu_39131915/article/details/116302847\">vscode远程连接提示过程试图写入的管道不存在_过程试图写入的管道不存在vscode-CSDN博客</a></p>\n"},{"title":"01以太网ethernet-概念","categories":["driver"],"tags":["ethrnet"],"date":"2024-05-23T07:30:58.000Z","_content":"\n\n\n## stmmac\n\ndrivers/net/stmicro/stmmac\n\n> stmmac 是一种以太网媒体访问控制器(Ethernet MAC, EMAC)的实现,由ST Microelectronics公司开发和维护\n\n## dwmac\n\n>`dwmac` 是由 Synopsys 公司开发的一种广泛应用于系统芯片 (SoC) 设计中的以太网媒体访问控制器 (Ethernet MAC, EMAC) 实现\n\n## rgmii\n\n>RGMII(Reduced Gigabit Media Independent Interface)是一种以太网物理层(PHY)接口标准,主要用于连接系统芯片(SoC)与以太网收发器(PHY)之间。\n>\n>1. 接口速率:\n>   - RGMII 支持 10/100/1000Mbps 三种以太网速率。\n>2. 引脚数量:\n>   - RGMII 使用 24 个引脚(双向各 12 个)来传输数据和控制信号。\n>3. 时序要求:\n>   - RGMII 接口需要严格的时序要求,包括数据和时钟之间的相位关系等。\n>4. 信号类型:\n>   - RGMII 使用LVCMOS电平的并行数据信号,以及独立的发送和接收时钟信号。\n\n\n\n## cru\n\n>CRU 是 Clock and Reset Unit 的缩写,指时钟和复位单元。它在系统芯片(SoC)中扮演着非常重要的角色。\n>\n>CRU 的主要功能包括:\n>\n>1. 时钟生成和管理:\n>   - 生成和分配各种内部时钟信号,如 CPU 时钟、总线时钟等。\n>   - 提供时钟切换和动态调频等功能,用于电源管理和性能优化。\n>2. 复位控制:\n>   - 生成和分配各种内部复位信号,如系统复位、模块复位等。\n>   - 提供复位同步和延迟功能,确保复位信号的正确传播。\n>3. 时钟/复位状态监控:\n>   - 监控时钟和复位信号的状态,并提供相关中断和状态寄存器。\n>   - 用于诊断和调试时钟/复位相关的问题。\n>\n>CRU 通常作为 SoC 中的一个独立模块,集中管理整个系统的时钟和复位相关功能。它与 CPU、内存、外设等模块紧密交互,确保系统稳定可靠地运行。\n>\n>CRU 的设计和实现通常由 SoC 设计团队负责,需要考虑时钟源、复位策略、功耗、时序等多方面因素。它是构建高性能、低功耗 SoC 的关键组件之一。\n\n\n\n\n\n## rk3588-gmac驱动\n\nkernel-5.10\n\nkernel/drivers/net/ethernet/stmicro/stmmac\n\n```\nrk_gmac_probe\n\tstmmac_probe_config_dt\n\t\tstmmac_dt_phy\n```\n\n\n\n","source":"back_posts/01以太网ethernet-概念.md","raw":"---\ntitle: 01以太网ethernet-概念\ncategories:\n  - driver\ntags:\n  - ethrnet\ndate: 2024-05-23 15:30:58\n---\n\n\n\n## stmmac\n\ndrivers/net/stmicro/stmmac\n\n> stmmac 是一种以太网媒体访问控制器(Ethernet MAC, EMAC)的实现,由ST Microelectronics公司开发和维护\n\n## dwmac\n\n>`dwmac` 是由 Synopsys 公司开发的一种广泛应用于系统芯片 (SoC) 设计中的以太网媒体访问控制器 (Ethernet MAC, EMAC) 实现\n\n## rgmii\n\n>RGMII(Reduced Gigabit Media Independent Interface)是一种以太网物理层(PHY)接口标准,主要用于连接系统芯片(SoC)与以太网收发器(PHY)之间。\n>\n>1. 接口速率:\n>   - RGMII 支持 10/100/1000Mbps 三种以太网速率。\n>2. 引脚数量:\n>   - RGMII 使用 24 个引脚(双向各 12 个)来传输数据和控制信号。\n>3. 时序要求:\n>   - RGMII 接口需要严格的时序要求,包括数据和时钟之间的相位关系等。\n>4. 信号类型:\n>   - RGMII 使用LVCMOS电平的并行数据信号,以及独立的发送和接收时钟信号。\n\n\n\n## cru\n\n>CRU 是 Clock and Reset Unit 的缩写,指时钟和复位单元。它在系统芯片(SoC)中扮演着非常重要的角色。\n>\n>CRU 的主要功能包括:\n>\n>1. 时钟生成和管理:\n>   - 生成和分配各种内部时钟信号,如 CPU 时钟、总线时钟等。\n>   - 提供时钟切换和动态调频等功能,用于电源管理和性能优化。\n>2. 复位控制:\n>   - 生成和分配各种内部复位信号,如系统复位、模块复位等。\n>   - 提供复位同步和延迟功能,确保复位信号的正确传播。\n>3. 时钟/复位状态监控:\n>   - 监控时钟和复位信号的状态,并提供相关中断和状态寄存器。\n>   - 用于诊断和调试时钟/复位相关的问题。\n>\n>CRU 通常作为 SoC 中的一个独立模块,集中管理整个系统的时钟和复位相关功能。它与 CPU、内存、外设等模块紧密交互,确保系统稳定可靠地运行。\n>\n>CRU 的设计和实现通常由 SoC 设计团队负责,需要考虑时钟源、复位策略、功耗、时序等多方面因素。它是构建高性能、低功耗 SoC 的关键组件之一。\n\n\n\n\n\n## rk3588-gmac驱动\n\nkernel-5.10\n\nkernel/drivers/net/ethernet/stmicro/stmmac\n\n```\nrk_gmac_probe\n\tstmmac_probe_config_dt\n\t\tstmmac_dt_phy\n```\n\n\n\n","updated":"2024-05-25T05:23:56.132Z","path":"back_posts/01以太网ethernet-概念.html","comments":1,"layout":"page","_id":"clwoskra9000090w0bc3ydfra","content":"<h2 id=\"stmmac\"><a href=\"#stmmac\" class=\"headerlink\" title=\"stmmac\"></a>stmmac</h2><p>drivers&#x2F;net&#x2F;stmicro&#x2F;stmmac</p>\n<blockquote>\n<p>stmmac 是一种以太网媒体访问控制器(Ethernet MAC, EMAC)的实现,由ST Microelectronics公司开发和维护</p>\n</blockquote>\n<h2 id=\"dwmac\"><a href=\"#dwmac\" class=\"headerlink\" title=\"dwmac\"></a>dwmac</h2><blockquote>\n<p><code>dwmac</code> 是由 Synopsys 公司开发的一种广泛应用于系统芯片 (SoC) 设计中的以太网媒体访问控制器 (Ethernet MAC, EMAC) 实现</p>\n</blockquote>\n<h2 id=\"rgmii\"><a href=\"#rgmii\" class=\"headerlink\" title=\"rgmii\"></a>rgmii</h2><blockquote>\n<p>RGMII(Reduced Gigabit Media Independent Interface)是一种以太网物理层(PHY)接口标准,主要用于连接系统芯片(SoC)与以太网收发器(PHY)之间。</p>\n<ol>\n<li>接口速率:</li>\n</ol>\n<ul>\n<li>RGMII 支持 10&#x2F;100&#x2F;1000Mbps 三种以太网速率。</li>\n</ul>\n<ol start=\"2\">\n<li>引脚数量:</li>\n</ol>\n<ul>\n<li>RGMII 使用 24 个引脚(双向各 12 个)来传输数据和控制信号。</li>\n</ul>\n<ol start=\"3\">\n<li>时序要求:</li>\n</ol>\n<ul>\n<li>RGMII 接口需要严格的时序要求,包括数据和时钟之间的相位关系等。</li>\n</ul>\n<ol start=\"4\">\n<li>信号类型:</li>\n</ol>\n<ul>\n<li>RGMII 使用LVCMOS电平的并行数据信号,以及独立的发送和接收时钟信号。</li>\n</ul>\n</blockquote>\n<h2 id=\"cru\"><a href=\"#cru\" class=\"headerlink\" title=\"cru\"></a>cru</h2><blockquote>\n<p>CRU 是 Clock and Reset Unit 的缩写,指时钟和复位单元。它在系统芯片(SoC)中扮演着非常重要的角色。</p>\n<p>CRU 的主要功能包括:</p>\n<ol>\n<li>时钟生成和管理:</li>\n</ol>\n<ul>\n<li>生成和分配各种内部时钟信号,如 CPU 时钟、总线时钟等。</li>\n<li>提供时钟切换和动态调频等功能,用于电源管理和性能优化。</li>\n</ul>\n<ol start=\"2\">\n<li>复位控制:</li>\n</ol>\n<ul>\n<li>生成和分配各种内部复位信号,如系统复位、模块复位等。</li>\n<li>提供复位同步和延迟功能,确保复位信号的正确传播。</li>\n</ul>\n<ol start=\"3\">\n<li>时钟&#x2F;复位状态监控:</li>\n</ol>\n<ul>\n<li>监控时钟和复位信号的状态,并提供相关中断和状态寄存器。</li>\n<li>用于诊断和调试时钟&#x2F;复位相关的问题。</li>\n</ul>\n<p>CRU 通常作为 SoC 中的一个独立模块,集中管理整个系统的时钟和复位相关功能。它与 CPU、内存、外设等模块紧密交互,确保系统稳定可靠地运行。</p>\n<p>CRU 的设计和实现通常由 SoC 设计团队负责,需要考虑时钟源、复位策略、功耗、时序等多方面因素。它是构建高性能、低功耗 SoC 的关键组件之一。</p>\n</blockquote>\n<h2 id=\"rk3588-gmac驱动\"><a href=\"#rk3588-gmac驱动\" class=\"headerlink\" title=\"rk3588-gmac驱动\"></a>rk3588-gmac驱动</h2><p>kernel-5.10</p>\n<p>kernel&#x2F;drivers&#x2F;net&#x2F;ethernet&#x2F;stmicro&#x2F;stmmac</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rk_gmac_probe</span><br><span class=\"line\">\tstmmac_probe_config_dt</span><br><span class=\"line\">\t\tstmmac_dt_phy</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"stmmac\"><a href=\"#stmmac\" class=\"headerlink\" title=\"stmmac\"></a>stmmac</h2><p>drivers&#x2F;net&#x2F;stmicro&#x2F;stmmac</p>\n<blockquote>\n<p>stmmac 是一种以太网媒体访问控制器(Ethernet MAC, EMAC)的实现,由ST Microelectronics公司开发和维护</p>\n</blockquote>\n<h2 id=\"dwmac\"><a href=\"#dwmac\" class=\"headerlink\" title=\"dwmac\"></a>dwmac</h2><blockquote>\n<p><code>dwmac</code> 是由 Synopsys 公司开发的一种广泛应用于系统芯片 (SoC) 设计中的以太网媒体访问控制器 (Ethernet MAC, EMAC) 实现</p>\n</blockquote>\n<h2 id=\"rgmii\"><a href=\"#rgmii\" class=\"headerlink\" title=\"rgmii\"></a>rgmii</h2><blockquote>\n<p>RGMII(Reduced Gigabit Media Independent Interface)是一种以太网物理层(PHY)接口标准,主要用于连接系统芯片(SoC)与以太网收发器(PHY)之间。</p>\n<ol>\n<li>接口速率:</li>\n</ol>\n<ul>\n<li>RGMII 支持 10&#x2F;100&#x2F;1000Mbps 三种以太网速率。</li>\n</ul>\n<ol start=\"2\">\n<li>引脚数量:</li>\n</ol>\n<ul>\n<li>RGMII 使用 24 个引脚(双向各 12 个)来传输数据和控制信号。</li>\n</ul>\n<ol start=\"3\">\n<li>时序要求:</li>\n</ol>\n<ul>\n<li>RGMII 接口需要严格的时序要求,包括数据和时钟之间的相位关系等。</li>\n</ul>\n<ol start=\"4\">\n<li>信号类型:</li>\n</ol>\n<ul>\n<li>RGMII 使用LVCMOS电平的并行数据信号,以及独立的发送和接收时钟信号。</li>\n</ul>\n</blockquote>\n<h2 id=\"cru\"><a href=\"#cru\" class=\"headerlink\" title=\"cru\"></a>cru</h2><blockquote>\n<p>CRU 是 Clock and Reset Unit 的缩写,指时钟和复位单元。它在系统芯片(SoC)中扮演着非常重要的角色。</p>\n<p>CRU 的主要功能包括:</p>\n<ol>\n<li>时钟生成和管理:</li>\n</ol>\n<ul>\n<li>生成和分配各种内部时钟信号,如 CPU 时钟、总线时钟等。</li>\n<li>提供时钟切换和动态调频等功能,用于电源管理和性能优化。</li>\n</ul>\n<ol start=\"2\">\n<li>复位控制:</li>\n</ol>\n<ul>\n<li>生成和分配各种内部复位信号,如系统复位、模块复位等。</li>\n<li>提供复位同步和延迟功能,确保复位信号的正确传播。</li>\n</ul>\n<ol start=\"3\">\n<li>时钟&#x2F;复位状态监控:</li>\n</ol>\n<ul>\n<li>监控时钟和复位信号的状态,并提供相关中断和状态寄存器。</li>\n<li>用于诊断和调试时钟&#x2F;复位相关的问题。</li>\n</ul>\n<p>CRU 通常作为 SoC 中的一个独立模块,集中管理整个系统的时钟和复位相关功能。它与 CPU、内存、外设等模块紧密交互,确保系统稳定可靠地运行。</p>\n<p>CRU 的设计和实现通常由 SoC 设计团队负责,需要考虑时钟源、复位策略、功耗、时序等多方面因素。它是构建高性能、低功耗 SoC 的关键组件之一。</p>\n</blockquote>\n<h2 id=\"rk3588-gmac驱动\"><a href=\"#rk3588-gmac驱动\" class=\"headerlink\" title=\"rk3588-gmac驱动\"></a>rk3588-gmac驱动</h2><p>kernel-5.10</p>\n<p>kernel&#x2F;drivers&#x2F;net&#x2F;ethernet&#x2F;stmicro&#x2F;stmmac</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rk_gmac_probe</span><br><span class=\"line\">\tstmmac_probe_config_dt</span><br><span class=\"line\">\t\tstmmac_dt_phy</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"操作系统中的缺页","categories":["test"],"tags":["缺页"],"date":"2024-05-27T09:48:11.000Z","_content":"\n\n\n缺页是引入了虚拟内存后的一个概念。操作系统启动后，在内存中维护着一个虚拟地址表，进程需要的虚拟地址在虚拟地址表中记录。一个程序被加载运行时，只是加载了很少的一部分到内存，另外一部分在需要时再从磁盘载入。被加载到内存的部分标识为“驻留”，而未被加载到内存的部分标为“未驻留”。操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻留”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示\"缺页\"。这个时候，操作系统触发一个“缺页”的硬件陷阱，系统从磁盘换入这部分未“驻留”的代码。\n       引入了分页机制(也就有了缺页机制)，则系统只需要加载程序的部分代码到内存，就可以创建进程运行， 需要程序的另一部分时再从磁盘载入并运行，从而允许比内存大很多的程序同时在内存运行。\n\n转：\n\nhttps://blog.csdn.net/ComputerInBook/article/details/101112983\n","source":"back_posts/操作系统中的缺页.md","raw":"---\ntitle: 操作系统中的缺页\ncategories:\n  - test\ntags:\n  - 缺页\ndate: 2024-05-27 17:48:11\n---\n\n\n\n缺页是引入了虚拟内存后的一个概念。操作系统启动后，在内存中维护着一个虚拟地址表，进程需要的虚拟地址在虚拟地址表中记录。一个程序被加载运行时，只是加载了很少的一部分到内存，另外一部分在需要时再从磁盘载入。被加载到内存的部分标识为“驻留”，而未被加载到内存的部分标为“未驻留”。操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻留”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示\"缺页\"。这个时候，操作系统触发一个“缺页”的硬件陷阱，系统从磁盘换入这部分未“驻留”的代码。\n       引入了分页机制(也就有了缺页机制)，则系统只需要加载程序的部分代码到内存，就可以创建进程运行， 需要程序的另一部分时再从磁盘载入并运行，从而允许比内存大很多的程序同时在内存运行。\n\n转：\n\nhttps://blog.csdn.net/ComputerInBook/article/details/101112983\n","updated":"2024-05-27T09:55:01.763Z","path":"back_posts/操作系统中的缺页.html","comments":1,"layout":"page","_id":"clwrgv1zr0003o9w07ury0cpv","content":"<p>缺页是引入了虚拟内存后的一个概念。操作系统启动后，在内存中维护着一个虚拟地址表，进程需要的虚拟地址在虚拟地址表中记录。一个程序被加载运行时，只是加载了很少的一部分到内存，另外一部分在需要时再从磁盘载入。被加载到内存的部分标识为“驻留”，而未被加载到内存的部分标为“未驻留”。操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻留”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示”缺页”。这个时候，操作系统触发一个“缺页”的硬件陷阱，系统从磁盘换入这部分未“驻留”的代码。<br>       引入了分页机制(也就有了缺页机制)，则系统只需要加载程序的部分代码到内存，就可以创建进程运行， 需要程序的另一部分时再从磁盘载入并运行，从而允许比内存大很多的程序同时在内存运行。</p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/ComputerInBook/article/details/101112983\">https://blog.csdn.net/ComputerInBook/article/details/101112983</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>缺页是引入了虚拟内存后的一个概念。操作系统启动后，在内存中维护着一个虚拟地址表，进程需要的虚拟地址在虚拟地址表中记录。一个程序被加载运行时，只是加载了很少的一部分到内存，另外一部分在需要时再从磁盘载入。被加载到内存的部分标识为“驻留”，而未被加载到内存的部分标为“未驻留”。操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻留”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示”缺页”。这个时候，操作系统触发一个“缺页”的硬件陷阱，系统从磁盘换入这部分未“驻留”的代码。<br>       引入了分页机制(也就有了缺页机制)，则系统只需要加载程序的部分代码到内存，就可以创建进程运行， 需要程序的另一部分时再从磁盘载入并运行，从而允许比内存大很多的程序同时在内存运行。</p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/ComputerInBook/article/details/101112983\">https://blog.csdn.net/ComputerInBook/article/details/101112983</a></p>\n"},{"title":"shell脚本-符合意义","categories":["test"],"tags":["test"],"date":"2024-05-29T06:31:03.000Z","_content":"\n\n\n### 一、概述\n\nshell中有两类字符：普通字符、元字符。\n\n#### 1. 普通字符\n\n在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本；\n\n#### 2. 元字符\n\n是Shell的保留字符，在Shell中有着特殊的含义。\n\n![ ](../imgs/2ef32c1ce3654484b236af25368bdab1.png)\n\n![img](../imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png)\n\nshell中字符`$`的各种用法。\n\n### 二、[转义字符](https://so.csdn.net/so/search?q=转义字符&spm=1001.2101.3001.7020)$\n\n在linux shell脚本中经常用到字符`$`，下面是`$`的一些常见用法\n\n名称\t含义\n$#\t传给脚本的参数个数\n$0\t脚本本身的名字\n$1\t传递给该shell脚本的第一个参数\n$2\t传递给该shell脚本的第二个参数\n$@\t传给脚本的所有参数的列表\n$*\t以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个\n$$\t脚本运行的当前进程ID号\n$?\t显示最后命令的退出状态，0表示没有错误，其他表示有错误\n\n#### 实例1\n\n建立脚本peng.sh如下：\n\n```bash\n#/bin/bash\ntotal=$[ $1 * $2 + $3 ]\necho \"$1 * $2 + $3 = $total\"\n```\n\n运行如下：\n\n```bash\n./peng.sh 4 5 6\n1\n```\n\n结果如下：\n\n![ ](../imgs/efcc46bc1fb845e898a37da989107ef9.png)\n\n#### 实例2\n\n当把字符串输入给shell脚本的时候，注意是以空格作为分隔符，如果字符串本身就有空格的话，那么用双引号或者单引号，比如\n\n```bash\n#/bin/bash\necho \"$1 is pretty nice!\"\n```\n\n运行如下：\n\n```bash\n./peng.sh 一口Linux\n```\n\n结果如下：\n![ ](../imgs/0a6cf9231486414a8095f6dd113a2c7d.png)\n\n#### 实例3\n\n```bash\n#!/bin/sh\necho \"参数个数:$#\"\necho \"脚本名字:$0\"\necho \"参数1:$1\"\necho \"参数2:$2\"\necho \"所有参数列表:$@\"\necho \"pid:$$\"\nif [ $1 = 100 ]\nthen\n echo \"命令退出状态：$?\" \n exit 0 #参数正确，退出状态为0\nelse\n echo \"命令退出状态：$?\"\n exit 1 #参数错误，退出状态1\nfi\n```\n\n执行结果：\n\n![img](../imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png)\n\n#### 实例4\n\n使用for循环进行参数遍历\n\n示例：\n\n```\n#!/bin/bash\nnumber=65             #定义一个退出值\nindex=1               #定义一个计数器\nif [ -z \"$1\" ];then   #对用户输入的参数做判断，如果未输入参数则返回脚本的用法并退出，退出值65\n   echo \"Usage:$0 + 参数\"\n   exit $number\nfi\necho \"listing args with \\$*:\"    #在屏幕输入，在$*中遍历参数\nfor arg in $*                                          \ndo\n   echo \"arg: $index = $arg\"                 \n   let index+=1\ndone\necho\nindex=1                         #将计数器重新设置为1\necho \"listing args with \\\"\\$@\\\":\"    #在\"$@\"中遍历参数\nfor arg in \"$@\"\ndo\n   echo \"arg: $index = $arg\"\n   let index+=1\ndone\n\n```\n\n![ ](../imgs/36d83bdde0524001a910df7a8c9c3083.png)\n\n![ ](../imgs/2a8ad08662864bc293b3c520e486c473.png)\n\n#### 实例5\n\n小技巧1：在\"∗ \" 和 *\"和∗\"和*中遍历参数的区别\n\n示例：\n\n```\n#!/bin/bash\nnumber=11\nif [ $# -eq 0 ];then\n   echo \"Usage: $0 + 参数\"\n   exit $number\nfi\nfor i in $*               #在$*中遍历参数，此时每个参数都是独立的，会遍历$#次\ndo\n   echo $i\ndone\necho\nfor i in \"$*\"            #在\"$*\"中遍历参数，此时\"$*\"被扩展为包含所有位置参数的单个字符串，只遍历一次\ndo\n   echo $i\ndone\n\n```\n\n![ ](../imgs/325ec497200142f98be97ec17d2c9cf3.png)\n\n转：\n\n[shell脚本中$0 $1 $# $@ $* $? $$ 的各种符号意义详解_shell $0-CSDN博客](https://blog.csdn.net/daocaokafei/article/details/120050007)\n","source":"back_posts/shell脚本-符合意义.md","raw":"---\ntitle: shell脚本-符合意义\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-05-29 14:31:03\n---\n\n\n\n### 一、概述\n\nshell中有两类字符：普通字符、元字符。\n\n#### 1. 普通字符\n\n在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本；\n\n#### 2. 元字符\n\n是Shell的保留字符，在Shell中有着特殊的含义。\n\n![ ](../imgs/2ef32c1ce3654484b236af25368bdab1.png)\n\n![img](../imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png)\n\nshell中字符`$`的各种用法。\n\n### 二、[转义字符](https://so.csdn.net/so/search?q=转义字符&spm=1001.2101.3001.7020)$\n\n在linux shell脚本中经常用到字符`$`，下面是`$`的一些常见用法\n\n名称\t含义\n$#\t传给脚本的参数个数\n$0\t脚本本身的名字\n$1\t传递给该shell脚本的第一个参数\n$2\t传递给该shell脚本的第二个参数\n$@\t传给脚本的所有参数的列表\n$*\t以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个\n$$\t脚本运行的当前进程ID号\n$?\t显示最后命令的退出状态，0表示没有错误，其他表示有错误\n\n#### 实例1\n\n建立脚本peng.sh如下：\n\n```bash\n#/bin/bash\ntotal=$[ $1 * $2 + $3 ]\necho \"$1 * $2 + $3 = $total\"\n```\n\n运行如下：\n\n```bash\n./peng.sh 4 5 6\n1\n```\n\n结果如下：\n\n![ ](../imgs/efcc46bc1fb845e898a37da989107ef9.png)\n\n#### 实例2\n\n当把字符串输入给shell脚本的时候，注意是以空格作为分隔符，如果字符串本身就有空格的话，那么用双引号或者单引号，比如\n\n```bash\n#/bin/bash\necho \"$1 is pretty nice!\"\n```\n\n运行如下：\n\n```bash\n./peng.sh 一口Linux\n```\n\n结果如下：\n![ ](../imgs/0a6cf9231486414a8095f6dd113a2c7d.png)\n\n#### 实例3\n\n```bash\n#!/bin/sh\necho \"参数个数:$#\"\necho \"脚本名字:$0\"\necho \"参数1:$1\"\necho \"参数2:$2\"\necho \"所有参数列表:$@\"\necho \"pid:$$\"\nif [ $1 = 100 ]\nthen\n echo \"命令退出状态：$?\" \n exit 0 #参数正确，退出状态为0\nelse\n echo \"命令退出状态：$?\"\n exit 1 #参数错误，退出状态1\nfi\n```\n\n执行结果：\n\n![img](../imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png)\n\n#### 实例4\n\n使用for循环进行参数遍历\n\n示例：\n\n```\n#!/bin/bash\nnumber=65             #定义一个退出值\nindex=1               #定义一个计数器\nif [ -z \"$1\" ];then   #对用户输入的参数做判断，如果未输入参数则返回脚本的用法并退出，退出值65\n   echo \"Usage:$0 + 参数\"\n   exit $number\nfi\necho \"listing args with \\$*:\"    #在屏幕输入，在$*中遍历参数\nfor arg in $*                                          \ndo\n   echo \"arg: $index = $arg\"                 \n   let index+=1\ndone\necho\nindex=1                         #将计数器重新设置为1\necho \"listing args with \\\"\\$@\\\":\"    #在\"$@\"中遍历参数\nfor arg in \"$@\"\ndo\n   echo \"arg: $index = $arg\"\n   let index+=1\ndone\n\n```\n\n![ ](../imgs/36d83bdde0524001a910df7a8c9c3083.png)\n\n![ ](../imgs/2a8ad08662864bc293b3c520e486c473.png)\n\n#### 实例5\n\n小技巧1：在\"∗ \" 和 *\"和∗\"和*中遍历参数的区别\n\n示例：\n\n```\n#!/bin/bash\nnumber=11\nif [ $# -eq 0 ];then\n   echo \"Usage: $0 + 参数\"\n   exit $number\nfi\nfor i in $*               #在$*中遍历参数，此时每个参数都是独立的，会遍历$#次\ndo\n   echo $i\ndone\necho\nfor i in \"$*\"            #在\"$*\"中遍历参数，此时\"$*\"被扩展为包含所有位置参数的单个字符串，只遍历一次\ndo\n   echo $i\ndone\n\n```\n\n![ ](../imgs/325ec497200142f98be97ec17d2c9cf3.png)\n\n转：\n\n[shell脚本中$0 $1 $# $@ $* $? $$ 的各种符号意义详解_shell $0-CSDN博客](https://blog.csdn.net/daocaokafei/article/details/120050007)\n","updated":"2024-05-29T06:50:36.149Z","path":"back_posts/shell脚本-符合意义.html","comments":1,"layout":"page","_id":"clwsoctx800068iw04eoc1zhw","content":"<h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h3><p>shell中有两类字符：普通字符、元字符。</p>\n<h4 id=\"1-普通字符\"><a href=\"#1-普通字符\" class=\"headerlink\" title=\"1. 普通字符\"></a>1. 普通字符</h4><p>在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本；</p>\n<h4 id=\"2-元字符\"><a href=\"#2-元字符\" class=\"headerlink\" title=\"2. 元字符\"></a>2. 元字符</h4><p>是Shell的保留字符，在Shell中有着特殊的含义。</p>\n<p><img src=\"/../imgs/2ef32c1ce3654484b236af25368bdab1.png\" alt=\" \"></p>\n<p><img src=\"/../imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png\" alt=\"img\"></p>\n<p>shell中字符<code>$</code>的各种用法。</p>\n<h3 id=\"二、转义字符\"><a href=\"#二、转义字符\" class=\"headerlink\" title=\"二、转义字符$\"></a>二、<a href=\"https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6&spm=1001.2101.3001.7020\">转义字符</a>$</h3><p>在linux shell脚本中经常用到字符<code>$</code>，下面是<code>$</code>的一些常见用法</p>\n<p>名称\t含义<br>$#\t传给脚本的参数个数<br>$0\t脚本本身的名字<br>$1\t传递给该shell脚本的第一个参数<br>$2\t传递给该shell脚本的第二个参数<br>$@\t传给脚本的所有参数的列表<br>$*\t以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个<br>$$\t脚本运行的当前进程ID号<br>$?\t显示最后命令的退出状态，0表示没有错误，其他表示有错误</p>\n<h4 id=\"实例1\"><a href=\"#实例1\" class=\"headerlink\" title=\"实例1\"></a>实例1</h4><p>建立脚本peng.sh如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#/bin/bash</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> + <span class=\"variable\">$3</span> ]</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> + <span class=\"variable\">$3</span> = <span class=\"variable\">$total</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./peng.sh 4 5 6</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<p><img src=\"/../imgs/efcc46bc1fb845e898a37da989107ef9.png\" alt=\" \"></p>\n<h4 id=\"实例2\"><a href=\"#实例2\" class=\"headerlink\" title=\"实例2\"></a>实例2</h4><p>当把字符串输入给shell脚本的时候，注意是以空格作为分隔符，如果字符串本身就有空格的话，那么用双引号或者单引号，比如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#/bin/bash</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> is pretty nice!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./peng.sh 一口Linux</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：<br><img src=\"/../imgs/0a6cf9231486414a8095f6dd113a2c7d.png\" alt=\" \"></p>\n<h4 id=\"实例3\"><a href=\"#实例3\" class=\"headerlink\" title=\"实例3\"></a>实例3</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数个数:<span class=\"variable\">$#</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;脚本名字:<span class=\"variable\">$0</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数1:<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数2:<span class=\"variable\">$2</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;所有参数列表:<span class=\"variable\">$@</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;pid:$$&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> = 100 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;命令退出状态：$?&quot;</span> </span><br><span class=\"line\"> <span class=\"built_in\">exit</span> 0 <span class=\"comment\">#参数正确，退出状态为0</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;命令退出状态：$?&quot;</span></span><br><span class=\"line\"> <span class=\"built_in\">exit</span> 1 <span class=\"comment\">#参数错误，退出状态1</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<p><img src=\"/../imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png\" alt=\"img\"></p>\n<h4 id=\"实例4\"><a href=\"#实例4\" class=\"headerlink\" title=\"实例4\"></a>实例4</h4><p>使用for循环进行参数遍历</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">number=65             #定义一个退出值</span><br><span class=\"line\">index=1               #定义一个计数器</span><br><span class=\"line\">if [ -z &quot;$1&quot; ];then   #对用户输入的参数做判断，如果未输入参数则返回脚本的用法并退出，退出值65</span><br><span class=\"line\">   echo &quot;Usage:$0 + 参数&quot;</span><br><span class=\"line\">   exit $number</span><br><span class=\"line\">fi</span><br><span class=\"line\">echo &quot;listing args with \\$*:&quot;    #在屏幕输入，在$*中遍历参数</span><br><span class=\"line\">for arg in $*                                          </span><br><span class=\"line\">do</span><br><span class=\"line\">   echo &quot;arg: $index = $arg&quot;                 </span><br><span class=\"line\">   let index+=1</span><br><span class=\"line\">done</span><br><span class=\"line\">echo</span><br><span class=\"line\">index=1                         #将计数器重新设置为1</span><br><span class=\"line\">echo &quot;listing args with \\&quot;\\$@\\&quot;:&quot;    #在&quot;$@&quot;中遍历参数</span><br><span class=\"line\">for arg in &quot;$@&quot;</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo &quot;arg: $index = $arg&quot;</span><br><span class=\"line\">   let index+=1</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../imgs/36d83bdde0524001a910df7a8c9c3083.png\" alt=\" \"></p>\n<p><img src=\"/../imgs/2a8ad08662864bc293b3c520e486c473.png\" alt=\" \"></p>\n<h4 id=\"实例5\"><a href=\"#实例5\" class=\"headerlink\" title=\"实例5\"></a>实例5</h4><p>小技巧1：在”∗ “ 和 <em>“和∗”和</em>中遍历参数的区别</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">number=11</span><br><span class=\"line\">if [ $# -eq 0 ];then</span><br><span class=\"line\">   echo &quot;Usage: $0 + 参数&quot;</span><br><span class=\"line\">   exit $number</span><br><span class=\"line\">fi</span><br><span class=\"line\">for i in $*               #在$*中遍历参数，此时每个参数都是独立的，会遍历$#次</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\">echo</span><br><span class=\"line\">for i in &quot;$*&quot;            #在&quot;$*&quot;中遍历参数，此时&quot;$*&quot;被扩展为包含所有位置参数的单个字符串，只遍历一次</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../imgs/325ec497200142f98be97ec17d2c9cf3.png\" alt=\" \"></p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/daocaokafei/article/details/120050007\">shell脚本中$0 $1 $# $@ $* $? $$ 的各种符号意义详解_shell $0-CSDN博客</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h3><p>shell中有两类字符：普通字符、元字符。</p>\n<h4 id=\"1-普通字符\"><a href=\"#1-普通字符\" class=\"headerlink\" title=\"1. 普通字符\"></a>1. 普通字符</h4><p>在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本；</p>\n<h4 id=\"2-元字符\"><a href=\"#2-元字符\" class=\"headerlink\" title=\"2. 元字符\"></a>2. 元字符</h4><p>是Shell的保留字符，在Shell中有着特殊的含义。</p>\n<p><img src=\"/../imgs/2ef32c1ce3654484b236af25368bdab1.png\" alt=\" \"></p>\n<p><img src=\"/../imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png\" alt=\"img\"></p>\n<p>shell中字符<code>$</code>的各种用法。</p>\n<h3 id=\"二、转义字符\"><a href=\"#二、转义字符\" class=\"headerlink\" title=\"二、转义字符$\"></a>二、<a href=\"https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6&spm=1001.2101.3001.7020\">转义字符</a>$</h3><p>在linux shell脚本中经常用到字符<code>$</code>，下面是<code>$</code>的一些常见用法</p>\n<p>名称\t含义<br>$#\t传给脚本的参数个数<br>$0\t脚本本身的名字<br>$1\t传递给该shell脚本的第一个参数<br>$2\t传递给该shell脚本的第二个参数<br>$@\t传给脚本的所有参数的列表<br>$*\t以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个<br>$$\t脚本运行的当前进程ID号<br>$?\t显示最后命令的退出状态，0表示没有错误，其他表示有错误</p>\n<h4 id=\"实例1\"><a href=\"#实例1\" class=\"headerlink\" title=\"实例1\"></a>实例1</h4><p>建立脚本peng.sh如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#/bin/bash</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> + <span class=\"variable\">$3</span> ]</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> + <span class=\"variable\">$3</span> = <span class=\"variable\">$total</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./peng.sh 4 5 6</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<p><img src=\"/../imgs/efcc46bc1fb845e898a37da989107ef9.png\" alt=\" \"></p>\n<h4 id=\"实例2\"><a href=\"#实例2\" class=\"headerlink\" title=\"实例2\"></a>实例2</h4><p>当把字符串输入给shell脚本的时候，注意是以空格作为分隔符，如果字符串本身就有空格的话，那么用双引号或者单引号，比如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#/bin/bash</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> is pretty nice!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./peng.sh 一口Linux</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：<br><img src=\"/../imgs/0a6cf9231486414a8095f6dd113a2c7d.png\" alt=\" \"></p>\n<h4 id=\"实例3\"><a href=\"#实例3\" class=\"headerlink\" title=\"实例3\"></a>实例3</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数个数:<span class=\"variable\">$#</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;脚本名字:<span class=\"variable\">$0</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数1:<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数2:<span class=\"variable\">$2</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;所有参数列表:<span class=\"variable\">$@</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;pid:$$&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> = 100 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;命令退出状态：$?&quot;</span> </span><br><span class=\"line\"> <span class=\"built_in\">exit</span> 0 <span class=\"comment\">#参数正确，退出状态为0</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;命令退出状态：$?&quot;</span></span><br><span class=\"line\"> <span class=\"built_in\">exit</span> 1 <span class=\"comment\">#参数错误，退出状态1</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<p><img src=\"/../imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png\" alt=\"img\"></p>\n<h4 id=\"实例4\"><a href=\"#实例4\" class=\"headerlink\" title=\"实例4\"></a>实例4</h4><p>使用for循环进行参数遍历</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">number=65             #定义一个退出值</span><br><span class=\"line\">index=1               #定义一个计数器</span><br><span class=\"line\">if [ -z &quot;$1&quot; ];then   #对用户输入的参数做判断，如果未输入参数则返回脚本的用法并退出，退出值65</span><br><span class=\"line\">   echo &quot;Usage:$0 + 参数&quot;</span><br><span class=\"line\">   exit $number</span><br><span class=\"line\">fi</span><br><span class=\"line\">echo &quot;listing args with \\$*:&quot;    #在屏幕输入，在$*中遍历参数</span><br><span class=\"line\">for arg in $*                                          </span><br><span class=\"line\">do</span><br><span class=\"line\">   echo &quot;arg: $index = $arg&quot;                 </span><br><span class=\"line\">   let index+=1</span><br><span class=\"line\">done</span><br><span class=\"line\">echo</span><br><span class=\"line\">index=1                         #将计数器重新设置为1</span><br><span class=\"line\">echo &quot;listing args with \\&quot;\\$@\\&quot;:&quot;    #在&quot;$@&quot;中遍历参数</span><br><span class=\"line\">for arg in &quot;$@&quot;</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo &quot;arg: $index = $arg&quot;</span><br><span class=\"line\">   let index+=1</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../imgs/36d83bdde0524001a910df7a8c9c3083.png\" alt=\" \"></p>\n<p><img src=\"/../imgs/2a8ad08662864bc293b3c520e486c473.png\" alt=\" \"></p>\n<h4 id=\"实例5\"><a href=\"#实例5\" class=\"headerlink\" title=\"实例5\"></a>实例5</h4><p>小技巧1：在”∗ “ 和 <em>“和∗”和</em>中遍历参数的区别</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">number=11</span><br><span class=\"line\">if [ $# -eq 0 ];then</span><br><span class=\"line\">   echo &quot;Usage: $0 + 参数&quot;</span><br><span class=\"line\">   exit $number</span><br><span class=\"line\">fi</span><br><span class=\"line\">for i in $*               #在$*中遍历参数，此时每个参数都是独立的，会遍历$#次</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\">echo</span><br><span class=\"line\">for i in &quot;$*&quot;            #在&quot;$*&quot;中遍历参数，此时&quot;$*&quot;被扩展为包含所有位置参数的单个字符串，只遍历一次</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../imgs/325ec497200142f98be97ec17d2c9cf3.png\" alt=\" \"></p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/daocaokafei/article/details/120050007\">shell脚本中$0 $1 $# $@ $* $? $$ 的各种符号意义详解_shell $0-CSDN博客</a></p>\n"},{"title":"dtb to dts","categories":["kernel"],"tags":["dtb","dts"],"date":"2024-05-30T03:05:15.000Z","_content":"\n[toc]\n\n## [rk3588] dtc path\n\nlinux/kernel/scripts/dtc/dtc \n\nandroid/out/soong/host/linux-x86/bin/dtc\n\n## 使用[adb](https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020)获取fdt文件\n\n```\nadb root\nadb pull /sys/firmware/fdt d:\t\npwd\n```\n\n## 使用以下指令生成dts文件\n\n```\ncd ./out/soong/host/linux-x86/bin/dtc\n./dtc -I dtb -O dts –o fdt2dts.dts fdt\n```\n","source":"back_posts/dtb-to-dts.md","raw":"---\ntitle: dtb to dts\ncategories:\n  - kernel\ntags:\n  - dtb\n  - dts\ndate: 2024-05-30 11:05:15\n---\n\n[toc]\n\n## [rk3588] dtc path\n\nlinux/kernel/scripts/dtc/dtc \n\nandroid/out/soong/host/linux-x86/bin/dtc\n\n## 使用[adb](https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020)获取fdt文件\n\n```\nadb root\nadb pull /sys/firmware/fdt d:\t\npwd\n```\n\n## 使用以下指令生成dts文件\n\n```\ncd ./out/soong/host/linux-x86/bin/dtc\n./dtc -I dtb -O dts –o fdt2dts.dts fdt\n```\n","updated":"2024-05-30T03:08:09.007Z","path":"back_posts/dtb-to-dts.html","comments":1,"layout":"page","_id":"clwt16tol0000arw0h01n3w4v","content":"<p>[toc]</p>\n<h2 id=\"rk3588-dtc-path\"><a href=\"#rk3588-dtc-path\" class=\"headerlink\" title=\"[rk3588] dtc path\"></a>[rk3588] dtc path</h2><p>linux&#x2F;kernel&#x2F;scripts&#x2F;dtc&#x2F;dtc </p>\n<p>android&#x2F;out&#x2F;soong&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;dtc</p>\n<h2 id=\"使用adb获取fdt文件\"><a href=\"#使用adb获取fdt文件\" class=\"headerlink\" title=\"使用adb获取fdt文件\"></a>使用<a href=\"https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020\">adb</a>获取fdt文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb root</span><br><span class=\"line\">adb pull /sys/firmware/fdt d:\t</span><br><span class=\"line\">pwd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用以下指令生成dts文件\"><a href=\"#使用以下指令生成dts文件\" class=\"headerlink\" title=\"使用以下指令生成dts文件\"></a>使用以下指令生成dts文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ./out/soong/host/linux-x86/bin/dtc</span><br><span class=\"line\">./dtc -I dtb -O dts –o fdt2dts.dts fdt</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h2 id=\"rk3588-dtc-path\"><a href=\"#rk3588-dtc-path\" class=\"headerlink\" title=\"[rk3588] dtc path\"></a>[rk3588] dtc path</h2><p>linux&#x2F;kernel&#x2F;scripts&#x2F;dtc&#x2F;dtc </p>\n<p>android&#x2F;out&#x2F;soong&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;dtc</p>\n<h2 id=\"使用adb获取fdt文件\"><a href=\"#使用adb获取fdt文件\" class=\"headerlink\" title=\"使用adb获取fdt文件\"></a>使用<a href=\"https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020\">adb</a>获取fdt文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb root</span><br><span class=\"line\">adb pull /sys/firmware/fdt d:\t</span><br><span class=\"line\">pwd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用以下指令生成dts文件\"><a href=\"#使用以下指令生成dts文件\" class=\"headerlink\" title=\"使用以下指令生成dts文件\"></a>使用以下指令生成dts文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ./out/soong/host/linux-x86/bin/dtc</span><br><span class=\"line\">./dtc -I dtb -O dts –o fdt2dts.dts fdt</span><br></pre></td></tr></table></figure>\n"},{"title":"struct-dev-debug","categories":["test"],"tags":["debug"],"date":"2024-06-03T02:10:43.000Z","_content":"\n最近调试pinctrl时需要打印全部的state\n\n可以通过struct dev查看 pinctrl client的相关信息,因为pinctrl client是通过设备树配置的，通过probe会构造struct dev\n\n在设备树中,pinctrl client 设备节点会包含 `pinctrl-names` 和 `pinctrl-0` 等属性,用于描述引脚配置\n\n可以使用 `dev_dbg()`、`dev_info()` 等宏来打印这个 `struct device *dev` 的调试信息\n\n```\nstruct pinctrl_state *state;\nstruct pinctrl_desc *desc;\nstruct device *dev;\nstruct pinctrl *p;\n\t\ndev = pctldev->dev;\ndesc = pctldev->desc;\np = pctldev->p;\n\nprintk(KERN_ERR\"[%s][%d]Device name: %s\\n\", __func__, __LINE__, dev_name(dev));\nprintk(KERN_ERR\"[%s][%d]Device type: %s\\n\", __func__, __LINE__, dev->type ? dev->type->name : \"unknown\");\nprintk(KERN_ERR\"[%s][%d]Device driver: %s\\n\", __func__, __LINE__, dev->driver ? dev->driver->name : \"unknown\");\nprintk(KERN_ERR\"[%s][%d]desc->name %s\\n\", __func__, __LINE__, desc->name);\nlist_for_each_entry(state, &p->states, node) {\n\tprintk(KERN_ERR\"[%s][%d] state->name %s\\n\", __func__, __LINE__, state->name);\n}\n```\n\n","source":"back_posts/struct-dev-debug.md","raw":"---\ntitle: struct-dev-debug\ncategories:\n  - test\ntags:\n  - debug\ndate: 2024-06-03 10:10:43\n---\n\n最近调试pinctrl时需要打印全部的state\n\n可以通过struct dev查看 pinctrl client的相关信息,因为pinctrl client是通过设备树配置的，通过probe会构造struct dev\n\n在设备树中,pinctrl client 设备节点会包含 `pinctrl-names` 和 `pinctrl-0` 等属性,用于描述引脚配置\n\n可以使用 `dev_dbg()`、`dev_info()` 等宏来打印这个 `struct device *dev` 的调试信息\n\n```\nstruct pinctrl_state *state;\nstruct pinctrl_desc *desc;\nstruct device *dev;\nstruct pinctrl *p;\n\t\ndev = pctldev->dev;\ndesc = pctldev->desc;\np = pctldev->p;\n\nprintk(KERN_ERR\"[%s][%d]Device name: %s\\n\", __func__, __LINE__, dev_name(dev));\nprintk(KERN_ERR\"[%s][%d]Device type: %s\\n\", __func__, __LINE__, dev->type ? dev->type->name : \"unknown\");\nprintk(KERN_ERR\"[%s][%d]Device driver: %s\\n\", __func__, __LINE__, dev->driver ? dev->driver->name : \"unknown\");\nprintk(KERN_ERR\"[%s][%d]desc->name %s\\n\", __func__, __LINE__, desc->name);\nlist_for_each_entry(state, &p->states, node) {\n\tprintk(KERN_ERR\"[%s][%d] state->name %s\\n\", __func__, __LINE__, state->name);\n}\n```\n\n","updated":"2024-06-03T03:30:41.361Z","path":"back_posts/struct-dev-debug.html","comments":1,"layout":"page","_id":"clwyksjab0003ijw0etc35x11","content":"<p>最近调试pinctrl时需要打印全部的state</p>\n<p>可以通过struct dev查看 pinctrl client的相关信息,因为pinctrl client是通过设备树配置的，通过probe会构造struct dev</p>\n<p>在设备树中,pinctrl client 设备节点会包含 <code>pinctrl-names</code> 和 <code>pinctrl-0</code> 等属性,用于描述引脚配置</p>\n<p>可以使用 <code>dev_dbg()</code>、<code>dev_info()</code> 等宏来打印这个 <code>struct device *dev</code> 的调试信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct pinctrl_state *state;</span><br><span class=\"line\">struct pinctrl_desc *desc;</span><br><span class=\"line\">struct device *dev;</span><br><span class=\"line\">struct pinctrl *p;</span><br><span class=\"line\">\t</span><br><span class=\"line\">dev = pctldev-&gt;dev;</span><br><span class=\"line\">desc = pctldev-&gt;desc;</span><br><span class=\"line\">p = pctldev-&gt;p;</span><br><span class=\"line\"></span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device name: %s\\n&quot;, __func__, __LINE__, dev_name(dev));</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device type: %s\\n&quot;, __func__, __LINE__, dev-&gt;type ? dev-&gt;type-&gt;name : &quot;unknown&quot;);</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device driver: %s\\n&quot;, __func__, __LINE__, dev-&gt;driver ? dev-&gt;driver-&gt;name : &quot;unknown&quot;);</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]desc-&gt;name %s\\n&quot;, __func__, __LINE__, desc-&gt;name);</span><br><span class=\"line\">list_for_each_entry(state, &amp;p-&gt;states, node) &#123;</span><br><span class=\"line\">\tprintk(KERN_ERR&quot;[%s][%d] state-&gt;name %s\\n&quot;, __func__, __LINE__, state-&gt;name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>最近调试pinctrl时需要打印全部的state</p>\n<p>可以通过struct dev查看 pinctrl client的相关信息,因为pinctrl client是通过设备树配置的，通过probe会构造struct dev</p>\n<p>在设备树中,pinctrl client 设备节点会包含 <code>pinctrl-names</code> 和 <code>pinctrl-0</code> 等属性,用于描述引脚配置</p>\n<p>可以使用 <code>dev_dbg()</code>、<code>dev_info()</code> 等宏来打印这个 <code>struct device *dev</code> 的调试信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct pinctrl_state *state;</span><br><span class=\"line\">struct pinctrl_desc *desc;</span><br><span class=\"line\">struct device *dev;</span><br><span class=\"line\">struct pinctrl *p;</span><br><span class=\"line\">\t</span><br><span class=\"line\">dev = pctldev-&gt;dev;</span><br><span class=\"line\">desc = pctldev-&gt;desc;</span><br><span class=\"line\">p = pctldev-&gt;p;</span><br><span class=\"line\"></span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device name: %s\\n&quot;, __func__, __LINE__, dev_name(dev));</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device type: %s\\n&quot;, __func__, __LINE__, dev-&gt;type ? dev-&gt;type-&gt;name : &quot;unknown&quot;);</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device driver: %s\\n&quot;, __func__, __LINE__, dev-&gt;driver ? dev-&gt;driver-&gt;name : &quot;unknown&quot;);</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]desc-&gt;name %s\\n&quot;, __func__, __LINE__, desc-&gt;name);</span><br><span class=\"line\">list_for_each_entry(state, &amp;p-&gt;states, node) &#123;</span><br><span class=\"line\">\tprintk(KERN_ERR&quot;[%s][%d] state-&gt;name %s\\n&quot;, __func__, __LINE__, state-&gt;name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"systemctl-详解","categories":["test"],"tags":["test"],"date":"2024-06-03T06:10:50.000Z","_content":"\n## 一、Systemd简介\n\nSystemd是由红帽公司的一名叫做Lennart Poettering的员工开发，systemd是Linux系统中最新的初始化系统（init）,它主要的设计目的是克服Sys V 固有的缺点，提高系统的启动速度，systemd和upstart是竞争对手，ubantu上使用的是upstart的启动方式，centos7上使用systemd替换了Sys V，Systemd目录是要取代Unix时代依赖一直在使用的init系统，兼容SysV和LSB的启动脚本，而且能够在进程启动中更有效地引导加载服务。\nsystem：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其他进程，根据管理，字母d是守护进程（daemon）的缩写，systemd这个名字的含义就是它要守护整个系统。\n\n## 二、Systemd新特性\n\n- 系统引导时实现服务并行启动\n- 按需启动守护进程\n- 自动化的服务依赖关系管理\n- 同时采用socket式与D-Bus总线式激活服务\n- 系统状态快照和恢复\n- 利用Linux的cgroups监视进程\n- 维护挂载点和自动挂载点\n- 各服务间基于依赖关系进行精密控制\n\n\n\n## 三、Systemd核心概念\n\n- Unit\n  表示不同类型的sytemd对象，通过配置文件进行标识和配置，文件中主要包含了系统服务，监听socket、保存的系统快照以及其他与init相关的信息\n- 配置文件:\n  /usr/lib/systemd/system：每个服务最主要的启动脚本设置，类似于之前的/etc/initd.d\n  /run/system/system：系统执行过程中所产生的服务脚本，比上面的目录优先运行\n  /etc/system/system：管理员建立的执行脚本，类似于/etc/rc.d/rcN.d/Sxx类的功能，比上面目录优先运行，在三者之中，此目录优先级最高\n\n## 四、Unit类型\n\n- systemctl -t help ：查看unit类型\n\n- service unit：文件扩展名为.service，用于定义系统服务\n\n- target unit：文件扩展名为.target，用于模拟实现“运行级别”\n\n- device unit: .device,用于定义内核识别的设备\n\n- mount unit ：.mount，定义文件系统挂载点\n\n- socket unit ：.socket,用于标识进程间通信用的socket文件，也可以在系统启动时，延迟启动服务，实现按需启动\n\n- snapshot unit：.snapshot，关系系统快照\n\n- swap unit：.swap，用于表示swap设备\n\n- automount unit：.automount，文件系统的自动挂载点如：/misc目录\n\n- path unit：.path，用于定义文件系统中的一个文件或目录使用，常用于当文件系统变化时，延迟激活服务，如spool目录\n\n- time：.timer由systemd管理的计时器\n\n  注：使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式，如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的挂载点会自动转化为相应的.mount单元，例如/home等价于home.mount设备会自动转化为相应的.device单元，所以/dev/sd2等价于dev-sda2.device\n\n\n\n## 五、关键特性\n\n- 基于socket的激活机制：socket与服务进程分离\n- 基于D-Bus的激活机制\n- 基于device的激活机制\n- 基于path的激活机制\n- 系统快照：保存各unit的当前状态信息于持久存储设备中想后兼容sysv init脚本\n\n\n\n## 六、不兼容\n\n- systemctl命令固定不变，不可扩展\n- 非由systemd启动的服务，systemctl无语与之通信和控制，如：使用之前sys v风格管理的进程就无法收systemd控制\n\n\n\n## 七、Systemd基本工具\n\n监视和控制systemd的主要命令是systemctl。该命令可用于查看系统状态和管理系统及服务。\n\n- 管理服务\n\n命令：systemctl  command name.service\n\n启动：service name start –>systemctl start name.service\n\n停止：service name stop –>systemctl stop name.service\n\n重启：service name restart–>systemctl restart name.service\n\n状态：service name status–>systemctl status name.service\n\n- 条件式重启(已启动才重启，否则不做任何操作)\n  `systemctl try-restart name.service`\n\n- 重载或重启服务(先加载，然后再启动)\n  `systemctl reload-or-try-restart name.service`\n\n- 禁止自动和手动启动\n  `systemctl mask name.service` \n  执行此条命令实则创建了一个链接 ln -s '/dev/null' '/etc/systemd/system/sshd.service'\n\n- 取消禁止\n  `systemctl unmask name.service` \n  删除此前创建的链接\n\n- 服务查看(查看某服务当前激活与否的状态)\n  `systemctl is-active name.service` \n  如果启动会显示active，否则会显示unknown\n\n- 查看所有已经激活的服务\n  `systemctl list-units –t|–type service`\n\n- 查看所有服务\n\n  systemctl list-units –t service -a\n\n  设定某服务开机启动\n\n- `chkconfig name on–>systemctl enable name.service`\n\n设定某服务开机禁止启动\n`chkconfig name off –>systemctl disable name.service`\n\n查看所有服务的开机自启状态\n`chkconfig –list–>systemctl list-unit-files -t service` \n\n\n\n- 用来列出该服务在那些运行级别下启用或禁用\n\nchkconfig sshd –list –>ls /etc/system/system/*.wants/sshd.service\n\n[root@www ~]# ls /etc/systemd/system/*.wants/sshd.service\n\n/etc/systemd/system/multi-user.target.wants/sshd.service\n\n- 查看服务是否开机自启\n  `systemctl is-enabled name.servcice`\n- 查看服务的依赖关系\n  `systemctl list-dependencies`  \n\n- 查看启动失败的服务\n  `systemctl -failed -t service`\n- 查看服务单元的启用和禁用状态\n  `systemctl list-unit-files –t=service`\n- 杀死进程\n  `systemctl kill 进程名`   \n  [图片上传失败...(image-53509-1519920006718)]\n- 服务状态\n  systemctl list-units -t service -a 显示状态\n  loaded：unit配置文件已处理\n  active（running）：一次或多次持续处理的运行\n  active（exited）：成功完成一次性的配置\n  active（waiting）:运行中，等待一个事件\n  inactive：不运行\n  enabled：开机启动\n  disabled：开机不启动\n  static：开机不启动，但可以被另一个启用的服务激活\n\n- 运行级别\n  target units：\n  unit配置文件：.target 以target结尾的文件\n  ls /usr/lib/system/system/*.target\n  systemctl list-unit-files -type target -all\n  0–>runlevel0.target, poweroff.target\n  1–>runlevel1.target, rescue.target\n  2–>runlevel2.target, muti-user.target\n  3–>runlevel3.target, mutil-user.target\n  4–>runlevel4.target, multi-user.target\n  5–>runlevel5.target, graphical.target\n  6–>runlevel6.target, reboot.target\n\n  \n\n- 查看依赖性\n  `systemctl list-dependencies graphical.target`\n\n- 查看默认运行级别\n  systemctl get-default 在Sys V风格的系统上是查看/etc/inittab文件其中有一条id:5:initdefault:\n\n- 级别切换\n  `systemctl isolate muti-user.target` \n  注意：只有当/lib/system/system/*.target文件中AllowIsolate=yes时才能奇幻（修改文件需执行systemctl daemon-reload生效）\n\n- 设定默认运行级别\n  `systemctl set-default muti-user.target`     \n  实则将multi-user.target链接至default.target\n  `ls –l /etc/system/system/default.target`\n\n- 进入紧急救援模式\n  `systemctl rescue`\n\n- 切换至emergency模式\n  `systemctl emergency`\n\n- 在systemd风格的系统上还能使用sysv风格系统上的关机，重启等命令，指示将该命令链接到systemctl的一个软链接\n  关机：`systemctl halt systemctl poweroff` \n  重启：`systemctl reboot`   \n  挂起：`systemctl suspend`   \n  休眠：`systemctl hibernate`   \n  休眠并挂起：`systemctl hybrid-sleep`\n\n> 使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式\n>\n> 如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的\n>\n> 挂载点会自动转化为相应的.mount单元，例如/home等价于home.mount\n>\n> 设备会自动转化为相应的.device单元，所以/dev/sd2等价于dev-sda2.device\n> 加载initramfs驱动模块\n>\n> 加载内核选项\n>\n> 内核初始化，centos7使用systemd代替init\n>\n> 执行initrd.target所有单元，包括挂载/etc/fstab\n>\n> 从initramfs根文件系统切换到磁盘根目录\n>\n> systemd执行默认target配置，配置文件/etc/systemd/default.target /etc/systemd/system/\n>\n> systemd执行sysinit.target初始化系统及basic.target准备操作系统\n>\n> systemd启动multi-user.target下的本机与服务器服务\n>\n> systemd执行multi-user.target下的/etc/rc.d/rc.local\n>\n> systemd执行multi-user.target下的getty.target及登入服务\n>\n> systemd执行graphical需要的服务（此为图形界面所有）\n\n## unit文件格式\n\n以#开头的行后面的内容会被认为是注释\n相关布尔值，1、yes、on、ture都是开启，0、no、off、false都是关闭\n时间单位默认是秒\n\n\n\n## Unit文件组成\n\n- [Unit]：定义与Unit类型无关的通用选项，用于提供unit的扫描信息，unit行为及依赖关系等\n- [Service]：与特定类型相关的专用选项；此处为Service类型\n- [Install]：定义由“systemctl enable及systemctl disable”命令在实现服务启用或禁用时用到的一些选项\n\n## unit段常用选项\n\n- Description：描述信息\n\n  After：定义unit的启动次序，表示当前unit应该晚育那些unit启动，其功能与before相反\n  Requires：依赖到的其他units，强依赖，被一来的units无法激活时，当前unit即无法激活\n  Wants：依赖到的其他units，弱依赖\n  Conflicts：定义units间的冲突关系\n\n## Service段常用选项\n\n- Type：定义硬性ExecStart及相关参数的功能的unit进程启动类型\n- simple：默认值；这个daemon主要有ExecStart接的指令串来启动，启动后常驻于内存中\n- forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务原生父程序在启动结束后就会终止\n- onshot：用于执行一项任务，随后立即退出的服务，不会常驻于内存中\n- notify：与simple相同，但约定服务会在就绪后想systemd发送一个信号，需要配合NotifyAccess来让Systemd接收消息\n- idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才只能即可的服务\n- EnvironmentFile：环境配置文件\n- ExeStart：指明启动unit要运行命令或脚本的绝对路径\n- ExeStartPre：ExecStart前运行\n- ExeStartPost：ExecStart后运行\n- ExecStop：指明停止unit要运行的命令或脚本\n- Restart：当设定Restart=1时，则当次daemon服务意外终止后，会在此自动启动此服务\n\n## Install段常用选项\n\n- Alias：别名(可使用systemctl command Alial.service)\n  RequiredBy:被那些units所依赖，强依赖\n  WantedBy：被那些units所依赖，弱依赖\n  Also：安装本服务的时候还要安装别的相关服务\n  注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载次配置文件，而后可以选择重启：`systemctl daemon-reload`\n","source":"back_posts/systemctl-详解.md","raw":"---\ntitle: systemctl-详解\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-06-03 14:10:50\n---\n\n## 一、Systemd简介\n\nSystemd是由红帽公司的一名叫做Lennart Poettering的员工开发，systemd是Linux系统中最新的初始化系统（init）,它主要的设计目的是克服Sys V 固有的缺点，提高系统的启动速度，systemd和upstart是竞争对手，ubantu上使用的是upstart的启动方式，centos7上使用systemd替换了Sys V，Systemd目录是要取代Unix时代依赖一直在使用的init系统，兼容SysV和LSB的启动脚本，而且能够在进程启动中更有效地引导加载服务。\nsystem：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其他进程，根据管理，字母d是守护进程（daemon）的缩写，systemd这个名字的含义就是它要守护整个系统。\n\n## 二、Systemd新特性\n\n- 系统引导时实现服务并行启动\n- 按需启动守护进程\n- 自动化的服务依赖关系管理\n- 同时采用socket式与D-Bus总线式激活服务\n- 系统状态快照和恢复\n- 利用Linux的cgroups监视进程\n- 维护挂载点和自动挂载点\n- 各服务间基于依赖关系进行精密控制\n\n\n\n## 三、Systemd核心概念\n\n- Unit\n  表示不同类型的sytemd对象，通过配置文件进行标识和配置，文件中主要包含了系统服务，监听socket、保存的系统快照以及其他与init相关的信息\n- 配置文件:\n  /usr/lib/systemd/system：每个服务最主要的启动脚本设置，类似于之前的/etc/initd.d\n  /run/system/system：系统执行过程中所产生的服务脚本，比上面的目录优先运行\n  /etc/system/system：管理员建立的执行脚本，类似于/etc/rc.d/rcN.d/Sxx类的功能，比上面目录优先运行，在三者之中，此目录优先级最高\n\n## 四、Unit类型\n\n- systemctl -t help ：查看unit类型\n\n- service unit：文件扩展名为.service，用于定义系统服务\n\n- target unit：文件扩展名为.target，用于模拟实现“运行级别”\n\n- device unit: .device,用于定义内核识别的设备\n\n- mount unit ：.mount，定义文件系统挂载点\n\n- socket unit ：.socket,用于标识进程间通信用的socket文件，也可以在系统启动时，延迟启动服务，实现按需启动\n\n- snapshot unit：.snapshot，关系系统快照\n\n- swap unit：.swap，用于表示swap设备\n\n- automount unit：.automount，文件系统的自动挂载点如：/misc目录\n\n- path unit：.path，用于定义文件系统中的一个文件或目录使用，常用于当文件系统变化时，延迟激活服务，如spool目录\n\n- time：.timer由systemd管理的计时器\n\n  注：使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式，如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的挂载点会自动转化为相应的.mount单元，例如/home等价于home.mount设备会自动转化为相应的.device单元，所以/dev/sd2等价于dev-sda2.device\n\n\n\n## 五、关键特性\n\n- 基于socket的激活机制：socket与服务进程分离\n- 基于D-Bus的激活机制\n- 基于device的激活机制\n- 基于path的激活机制\n- 系统快照：保存各unit的当前状态信息于持久存储设备中想后兼容sysv init脚本\n\n\n\n## 六、不兼容\n\n- systemctl命令固定不变，不可扩展\n- 非由systemd启动的服务，systemctl无语与之通信和控制，如：使用之前sys v风格管理的进程就无法收systemd控制\n\n\n\n## 七、Systemd基本工具\n\n监视和控制systemd的主要命令是systemctl。该命令可用于查看系统状态和管理系统及服务。\n\n- 管理服务\n\n命令：systemctl  command name.service\n\n启动：service name start –>systemctl start name.service\n\n停止：service name stop –>systemctl stop name.service\n\n重启：service name restart–>systemctl restart name.service\n\n状态：service name status–>systemctl status name.service\n\n- 条件式重启(已启动才重启，否则不做任何操作)\n  `systemctl try-restart name.service`\n\n- 重载或重启服务(先加载，然后再启动)\n  `systemctl reload-or-try-restart name.service`\n\n- 禁止自动和手动启动\n  `systemctl mask name.service` \n  执行此条命令实则创建了一个链接 ln -s '/dev/null' '/etc/systemd/system/sshd.service'\n\n- 取消禁止\n  `systemctl unmask name.service` \n  删除此前创建的链接\n\n- 服务查看(查看某服务当前激活与否的状态)\n  `systemctl is-active name.service` \n  如果启动会显示active，否则会显示unknown\n\n- 查看所有已经激活的服务\n  `systemctl list-units –t|–type service`\n\n- 查看所有服务\n\n  systemctl list-units –t service -a\n\n  设定某服务开机启动\n\n- `chkconfig name on–>systemctl enable name.service`\n\n设定某服务开机禁止启动\n`chkconfig name off –>systemctl disable name.service`\n\n查看所有服务的开机自启状态\n`chkconfig –list–>systemctl list-unit-files -t service` \n\n\n\n- 用来列出该服务在那些运行级别下启用或禁用\n\nchkconfig sshd –list –>ls /etc/system/system/*.wants/sshd.service\n\n[root@www ~]# ls /etc/systemd/system/*.wants/sshd.service\n\n/etc/systemd/system/multi-user.target.wants/sshd.service\n\n- 查看服务是否开机自启\n  `systemctl is-enabled name.servcice`\n- 查看服务的依赖关系\n  `systemctl list-dependencies`  \n\n- 查看启动失败的服务\n  `systemctl -failed -t service`\n- 查看服务单元的启用和禁用状态\n  `systemctl list-unit-files –t=service`\n- 杀死进程\n  `systemctl kill 进程名`   \n  [图片上传失败...(image-53509-1519920006718)]\n- 服务状态\n  systemctl list-units -t service -a 显示状态\n  loaded：unit配置文件已处理\n  active（running）：一次或多次持续处理的运行\n  active（exited）：成功完成一次性的配置\n  active（waiting）:运行中，等待一个事件\n  inactive：不运行\n  enabled：开机启动\n  disabled：开机不启动\n  static：开机不启动，但可以被另一个启用的服务激活\n\n- 运行级别\n  target units：\n  unit配置文件：.target 以target结尾的文件\n  ls /usr/lib/system/system/*.target\n  systemctl list-unit-files -type target -all\n  0–>runlevel0.target, poweroff.target\n  1–>runlevel1.target, rescue.target\n  2–>runlevel2.target, muti-user.target\n  3–>runlevel3.target, mutil-user.target\n  4–>runlevel4.target, multi-user.target\n  5–>runlevel5.target, graphical.target\n  6–>runlevel6.target, reboot.target\n\n  \n\n- 查看依赖性\n  `systemctl list-dependencies graphical.target`\n\n- 查看默认运行级别\n  systemctl get-default 在Sys V风格的系统上是查看/etc/inittab文件其中有一条id:5:initdefault:\n\n- 级别切换\n  `systemctl isolate muti-user.target` \n  注意：只有当/lib/system/system/*.target文件中AllowIsolate=yes时才能奇幻（修改文件需执行systemctl daemon-reload生效）\n\n- 设定默认运行级别\n  `systemctl set-default muti-user.target`     \n  实则将multi-user.target链接至default.target\n  `ls –l /etc/system/system/default.target`\n\n- 进入紧急救援模式\n  `systemctl rescue`\n\n- 切换至emergency模式\n  `systemctl emergency`\n\n- 在systemd风格的系统上还能使用sysv风格系统上的关机，重启等命令，指示将该命令链接到systemctl的一个软链接\n  关机：`systemctl halt systemctl poweroff` \n  重启：`systemctl reboot`   \n  挂起：`systemctl suspend`   \n  休眠：`systemctl hibernate`   \n  休眠并挂起：`systemctl hybrid-sleep`\n\n> 使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式\n>\n> 如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的\n>\n> 挂载点会自动转化为相应的.mount单元，例如/home等价于home.mount\n>\n> 设备会自动转化为相应的.device单元，所以/dev/sd2等价于dev-sda2.device\n> 加载initramfs驱动模块\n>\n> 加载内核选项\n>\n> 内核初始化，centos7使用systemd代替init\n>\n> 执行initrd.target所有单元，包括挂载/etc/fstab\n>\n> 从initramfs根文件系统切换到磁盘根目录\n>\n> systemd执行默认target配置，配置文件/etc/systemd/default.target /etc/systemd/system/\n>\n> systemd执行sysinit.target初始化系统及basic.target准备操作系统\n>\n> systemd启动multi-user.target下的本机与服务器服务\n>\n> systemd执行multi-user.target下的/etc/rc.d/rc.local\n>\n> systemd执行multi-user.target下的getty.target及登入服务\n>\n> systemd执行graphical需要的服务（此为图形界面所有）\n\n## unit文件格式\n\n以#开头的行后面的内容会被认为是注释\n相关布尔值，1、yes、on、ture都是开启，0、no、off、false都是关闭\n时间单位默认是秒\n\n\n\n## Unit文件组成\n\n- [Unit]：定义与Unit类型无关的通用选项，用于提供unit的扫描信息，unit行为及依赖关系等\n- [Service]：与特定类型相关的专用选项；此处为Service类型\n- [Install]：定义由“systemctl enable及systemctl disable”命令在实现服务启用或禁用时用到的一些选项\n\n## unit段常用选项\n\n- Description：描述信息\n\n  After：定义unit的启动次序，表示当前unit应该晚育那些unit启动，其功能与before相反\n  Requires：依赖到的其他units，强依赖，被一来的units无法激活时，当前unit即无法激活\n  Wants：依赖到的其他units，弱依赖\n  Conflicts：定义units间的冲突关系\n\n## Service段常用选项\n\n- Type：定义硬性ExecStart及相关参数的功能的unit进程启动类型\n- simple：默认值；这个daemon主要有ExecStart接的指令串来启动，启动后常驻于内存中\n- forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务原生父程序在启动结束后就会终止\n- onshot：用于执行一项任务，随后立即退出的服务，不会常驻于内存中\n- notify：与simple相同，但约定服务会在就绪后想systemd发送一个信号，需要配合NotifyAccess来让Systemd接收消息\n- idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才只能即可的服务\n- EnvironmentFile：环境配置文件\n- ExeStart：指明启动unit要运行命令或脚本的绝对路径\n- ExeStartPre：ExecStart前运行\n- ExeStartPost：ExecStart后运行\n- ExecStop：指明停止unit要运行的命令或脚本\n- Restart：当设定Restart=1时，则当次daemon服务意外终止后，会在此自动启动此服务\n\n## Install段常用选项\n\n- Alias：别名(可使用systemctl command Alial.service)\n  RequiredBy:被那些units所依赖，强依赖\n  WantedBy：被那些units所依赖，弱依赖\n  Also：安装本服务的时候还要安装别的相关服务\n  注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载次配置文件，而后可以选择重启：`systemctl daemon-reload`\n","updated":"2024-06-03T06:14:49.315Z","path":"back_posts/systemctl-详解.html","comments":1,"layout":"page","_id":"clwzypy2t0000srw07qap4zpa","content":"<h2 id=\"一、Systemd简介\"><a href=\"#一、Systemd简介\" class=\"headerlink\" title=\"一、Systemd简介\"></a>一、Systemd简介</h2><p>Systemd是由红帽公司的一名叫做Lennart Poettering的员工开发，systemd是Linux系统中最新的初始化系统（init）,它主要的设计目的是克服Sys V 固有的缺点，提高系统的启动速度，systemd和upstart是竞争对手，ubantu上使用的是upstart的启动方式，centos7上使用systemd替换了Sys V，Systemd目录是要取代Unix时代依赖一直在使用的init系统，兼容SysV和LSB的启动脚本，而且能够在进程启动中更有效地引导加载服务。<br>system：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其他进程，根据管理，字母d是守护进程（daemon）的缩写，systemd这个名字的含义就是它要守护整个系统。</p>\n<h2 id=\"二、Systemd新特性\"><a href=\"#二、Systemd新特性\" class=\"headerlink\" title=\"二、Systemd新特性\"></a>二、Systemd新特性</h2><ul>\n<li>系统引导时实现服务并行启动</li>\n<li>按需启动守护进程</li>\n<li>自动化的服务依赖关系管理</li>\n<li>同时采用socket式与D-Bus总线式激活服务</li>\n<li>系统状态快照和恢复</li>\n<li>利用Linux的cgroups监视进程</li>\n<li>维护挂载点和自动挂载点</li>\n<li>各服务间基于依赖关系进行精密控制</li>\n</ul>\n<h2 id=\"三、Systemd核心概念\"><a href=\"#三、Systemd核心概念\" class=\"headerlink\" title=\"三、Systemd核心概念\"></a>三、Systemd核心概念</h2><ul>\n<li>Unit<br>表示不同类型的sytemd对象，通过配置文件进行标识和配置，文件中主要包含了系统服务，监听socket、保存的系统快照以及其他与init相关的信息</li>\n<li>配置文件:<br>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system：每个服务最主要的启动脚本设置，类似于之前的&#x2F;etc&#x2F;initd.d<br>&#x2F;run&#x2F;system&#x2F;system：系统执行过程中所产生的服务脚本，比上面的目录优先运行<br>&#x2F;etc&#x2F;system&#x2F;system：管理员建立的执行脚本，类似于&#x2F;etc&#x2F;rc.d&#x2F;rcN.d&#x2F;Sxx类的功能，比上面目录优先运行，在三者之中，此目录优先级最高</li>\n</ul>\n<h2 id=\"四、Unit类型\"><a href=\"#四、Unit类型\" class=\"headerlink\" title=\"四、Unit类型\"></a>四、Unit类型</h2><ul>\n<li><p>systemctl -t help ：查看unit类型</p>\n</li>\n<li><p>service unit：文件扩展名为.service，用于定义系统服务</p>\n</li>\n<li><p>target unit：文件扩展名为.target，用于模拟实现“运行级别”</p>\n</li>\n<li><p>device unit: .device,用于定义内核识别的设备</p>\n</li>\n<li><p>mount unit ：.mount，定义文件系统挂载点</p>\n</li>\n<li><p>socket unit ：.socket,用于标识进程间通信用的socket文件，也可以在系统启动时，延迟启动服务，实现按需启动</p>\n</li>\n<li><p>snapshot unit：.snapshot，关系系统快照</p>\n</li>\n<li><p>swap unit：.swap，用于表示swap设备</p>\n</li>\n<li><p>automount unit：.automount，文件系统的自动挂载点如：&#x2F;misc目录</p>\n</li>\n<li><p>path unit：.path，用于定义文件系统中的一个文件或目录使用，常用于当文件系统变化时，延迟激活服务，如spool目录</p>\n</li>\n<li><p>time：.timer由systemd管理的计时器</p>\n<p>注：使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式，如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的挂载点会自动转化为相应的.mount单元，例如&#x2F;home等价于home.mount设备会自动转化为相应的.device单元，所以&#x2F;dev&#x2F;sd2等价于dev-sda2.device</p>\n</li>\n</ul>\n<h2 id=\"五、关键特性\"><a href=\"#五、关键特性\" class=\"headerlink\" title=\"五、关键特性\"></a>五、关键特性</h2><ul>\n<li>基于socket的激活机制：socket与服务进程分离</li>\n<li>基于D-Bus的激活机制</li>\n<li>基于device的激活机制</li>\n<li>基于path的激活机制</li>\n<li>系统快照：保存各unit的当前状态信息于持久存储设备中想后兼容sysv init脚本</li>\n</ul>\n<h2 id=\"六、不兼容\"><a href=\"#六、不兼容\" class=\"headerlink\" title=\"六、不兼容\"></a>六、不兼容</h2><ul>\n<li>systemctl命令固定不变，不可扩展</li>\n<li>非由systemd启动的服务，systemctl无语与之通信和控制，如：使用之前sys v风格管理的进程就无法收systemd控制</li>\n</ul>\n<h2 id=\"七、Systemd基本工具\"><a href=\"#七、Systemd基本工具\" class=\"headerlink\" title=\"七、Systemd基本工具\"></a>七、Systemd基本工具</h2><p>监视和控制systemd的主要命令是systemctl。该命令可用于查看系统状态和管理系统及服务。</p>\n<ul>\n<li>管理服务</li>\n</ul>\n<p>命令：systemctl  command name.service</p>\n<p>启动：service name start –&gt;systemctl start name.service</p>\n<p>停止：service name stop –&gt;systemctl stop name.service</p>\n<p>重启：service name restart–&gt;systemctl restart name.service</p>\n<p>状态：service name status–&gt;systemctl status name.service</p>\n<ul>\n<li><p>条件式重启(已启动才重启，否则不做任何操作)<br><code>systemctl try-restart name.service</code></p>\n</li>\n<li><p>重载或重启服务(先加载，然后再启动)<br><code>systemctl reload-or-try-restart name.service</code></p>\n</li>\n<li><p>禁止自动和手动启动<br><code>systemctl mask name.service</code><br>执行此条命令实则创建了一个链接 ln -s ‘&#x2F;dev&#x2F;null’ ‘&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;sshd.service’</p>\n</li>\n<li><p>取消禁止<br><code>systemctl unmask name.service</code><br>删除此前创建的链接</p>\n</li>\n<li><p>服务查看(查看某服务当前激活与否的状态)<br><code>systemctl is-active name.service</code><br>如果启动会显示active，否则会显示unknown</p>\n</li>\n<li><p>查看所有已经激活的服务<br><code>systemctl list-units –t|–type service</code></p>\n</li>\n<li><p>查看所有服务</p>\n<p>systemctl list-units –t service -a</p>\n<p>设定某服务开机启动</p>\n</li>\n<li><p><code>chkconfig name on–&gt;systemctl enable name.service</code></p>\n</li>\n</ul>\n<p>设定某服务开机禁止启动<br><code>chkconfig name off –&gt;systemctl disable name.service</code></p>\n<p>查看所有服务的开机自启状态<br><code>chkconfig –list–&gt;systemctl list-unit-files -t service</code> </p>\n<ul>\n<li>用来列出该服务在那些运行级别下启用或禁用</li>\n</ul>\n<p>chkconfig sshd –list –&gt;ls &#x2F;etc&#x2F;system&#x2F;system&#x2F;*.wants&#x2F;sshd.service</p>\n<p>[root@www ~]# ls &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;*.wants&#x2F;sshd.service</p>\n<p>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;sshd.service</p>\n<ul>\n<li><p>查看服务是否开机自启<br><code>systemctl is-enabled name.servcice</code></p>\n</li>\n<li><p>查看服务的依赖关系<br><code>systemctl list-dependencies</code>  </p>\n</li>\n<li><p>查看启动失败的服务<br><code>systemctl -failed -t service</code></p>\n</li>\n<li><p>查看服务单元的启用和禁用状态<br><code>systemctl list-unit-files –t=service</code></p>\n</li>\n<li><p>杀死进程<br><code>systemctl kill 进程名</code><br>[图片上传失败…(image-53509-1519920006718)]</p>\n</li>\n<li><p>服务状态<br>systemctl list-units -t service -a 显示状态<br>loaded：unit配置文件已处理<br>active（running）：一次或多次持续处理的运行<br>active（exited）：成功完成一次性的配置<br>active（waiting）:运行中，等待一个事件<br>inactive：不运行<br>enabled：开机启动<br>disabled：开机不启动<br>static：开机不启动，但可以被另一个启用的服务激活</p>\n</li>\n<li><p>运行级别<br>target units：<br>unit配置文件：.target 以target结尾的文件<br>ls &#x2F;usr&#x2F;lib&#x2F;system&#x2F;system&#x2F;*.target<br>systemctl list-unit-files -type target -all<br>0–&gt;runlevel0.target, poweroff.target<br>1–&gt;runlevel1.target, rescue.target<br>2–&gt;runlevel2.target, muti-user.target<br>3–&gt;runlevel3.target, mutil-user.target<br>4–&gt;runlevel4.target, multi-user.target<br>5–&gt;runlevel5.target, graphical.target<br>6–&gt;runlevel6.target, reboot.target</p>\n</li>\n<li><p>查看依赖性<br><code>systemctl list-dependencies graphical.target</code></p>\n</li>\n<li><p>查看默认运行级别<br>systemctl get-default 在Sys V风格的系统上是查看&#x2F;etc&#x2F;inittab文件其中有一条id:5:initdefault:</p>\n</li>\n<li><p>级别切换<br><code>systemctl isolate muti-user.target</code><br>注意：只有当&#x2F;lib&#x2F;system&#x2F;system&#x2F;*.target文件中AllowIsolate&#x3D;yes时才能奇幻（修改文件需执行systemctl daemon-reload生效）</p>\n</li>\n<li><p>设定默认运行级别<br><code>systemctl set-default muti-user.target</code><br>实则将multi-user.target链接至default.target<br><code>ls –l /etc/system/system/default.target</code></p>\n</li>\n<li><p>进入紧急救援模式<br><code>systemctl rescue</code></p>\n</li>\n<li><p>切换至emergency模式<br><code>systemctl emergency</code></p>\n</li>\n<li><p>在systemd风格的系统上还能使用sysv风格系统上的关机，重启等命令，指示将该命令链接到systemctl的一个软链接<br>关机：<code>systemctl halt systemctl poweroff</code><br>重启：<code>systemctl reboot</code><br>挂起：<code>systemctl suspend</code><br>休眠：<code>systemctl hibernate</code><br>休眠并挂起：<code>systemctl hybrid-sleep</code></p>\n</li>\n</ul>\n<blockquote>\n<p>使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式</p>\n<p>如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的</p>\n<p>挂载点会自动转化为相应的.mount单元，例如&#x2F;home等价于home.mount</p>\n<p>设备会自动转化为相应的.device单元，所以&#x2F;dev&#x2F;sd2等价于dev-sda2.device<br>加载initramfs驱动模块</p>\n<p>加载内核选项</p>\n<p>内核初始化，centos7使用systemd代替init</p>\n<p>执行initrd.target所有单元，包括挂载&#x2F;etc&#x2F;fstab</p>\n<p>从initramfs根文件系统切换到磁盘根目录</p>\n<p>systemd执行默认target配置，配置文件&#x2F;etc&#x2F;systemd&#x2F;default.target &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;</p>\n<p>systemd执行sysinit.target初始化系统及basic.target准备操作系统</p>\n<p>systemd启动multi-user.target下的本机与服务器服务</p>\n<p>systemd执行multi-user.target下的&#x2F;etc&#x2F;rc.d&#x2F;rc.local</p>\n<p>systemd执行multi-user.target下的getty.target及登入服务</p>\n<p>systemd执行graphical需要的服务（此为图形界面所有）</p>\n</blockquote>\n<h2 id=\"unit文件格式\"><a href=\"#unit文件格式\" class=\"headerlink\" title=\"unit文件格式\"></a>unit文件格式</h2><p>以#开头的行后面的内容会被认为是注释<br>相关布尔值，1、yes、on、ture都是开启，0、no、off、false都是关闭<br>时间单位默认是秒</p>\n<h2 id=\"Unit文件组成\"><a href=\"#Unit文件组成\" class=\"headerlink\" title=\"Unit文件组成\"></a>Unit文件组成</h2><ul>\n<li>[Unit]：定义与Unit类型无关的通用选项，用于提供unit的扫描信息，unit行为及依赖关系等</li>\n<li>[Service]：与特定类型相关的专用选项；此处为Service类型</li>\n<li>[Install]：定义由“systemctl enable及systemctl disable”命令在实现服务启用或禁用时用到的一些选项</li>\n</ul>\n<h2 id=\"unit段常用选项\"><a href=\"#unit段常用选项\" class=\"headerlink\" title=\"unit段常用选项\"></a>unit段常用选项</h2><ul>\n<li><p>Description：描述信息</p>\n<p>After：定义unit的启动次序，表示当前unit应该晚育那些unit启动，其功能与before相反<br>Requires：依赖到的其他units，强依赖，被一来的units无法激活时，当前unit即无法激活<br>Wants：依赖到的其他units，弱依赖<br>Conflicts：定义units间的冲突关系</p>\n</li>\n</ul>\n<h2 id=\"Service段常用选项\"><a href=\"#Service段常用选项\" class=\"headerlink\" title=\"Service段常用选项\"></a>Service段常用选项</h2><ul>\n<li>Type：定义硬性ExecStart及相关参数的功能的unit进程启动类型</li>\n<li>simple：默认值；这个daemon主要有ExecStart接的指令串来启动，启动后常驻于内存中</li>\n<li>forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务原生父程序在启动结束后就会终止</li>\n<li>onshot：用于执行一项任务，随后立即退出的服务，不会常驻于内存中</li>\n<li>notify：与simple相同，但约定服务会在就绪后想systemd发送一个信号，需要配合NotifyAccess来让Systemd接收消息</li>\n<li>idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才只能即可的服务</li>\n<li>EnvironmentFile：环境配置文件</li>\n<li>ExeStart：指明启动unit要运行命令或脚本的绝对路径</li>\n<li>ExeStartPre：ExecStart前运行</li>\n<li>ExeStartPost：ExecStart后运行</li>\n<li>ExecStop：指明停止unit要运行的命令或脚本</li>\n<li>Restart：当设定Restart&#x3D;1时，则当次daemon服务意外终止后，会在此自动启动此服务</li>\n</ul>\n<h2 id=\"Install段常用选项\"><a href=\"#Install段常用选项\" class=\"headerlink\" title=\"Install段常用选项\"></a>Install段常用选项</h2><ul>\n<li>Alias：别名(可使用systemctl command Alial.service)<br>RequiredBy:被那些units所依赖，强依赖<br>WantedBy：被那些units所依赖，弱依赖<br>Also：安装本服务的时候还要安装别的相关服务<br>注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载次配置文件，而后可以选择重启：<code>systemctl daemon-reload</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、Systemd简介\"><a href=\"#一、Systemd简介\" class=\"headerlink\" title=\"一、Systemd简介\"></a>一、Systemd简介</h2><p>Systemd是由红帽公司的一名叫做Lennart Poettering的员工开发，systemd是Linux系统中最新的初始化系统（init）,它主要的设计目的是克服Sys V 固有的缺点，提高系统的启动速度，systemd和upstart是竞争对手，ubantu上使用的是upstart的启动方式，centos7上使用systemd替换了Sys V，Systemd目录是要取代Unix时代依赖一直在使用的init系统，兼容SysV和LSB的启动脚本，而且能够在进程启动中更有效地引导加载服务。<br>system：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其他进程，根据管理，字母d是守护进程（daemon）的缩写，systemd这个名字的含义就是它要守护整个系统。</p>\n<h2 id=\"二、Systemd新特性\"><a href=\"#二、Systemd新特性\" class=\"headerlink\" title=\"二、Systemd新特性\"></a>二、Systemd新特性</h2><ul>\n<li>系统引导时实现服务并行启动</li>\n<li>按需启动守护进程</li>\n<li>自动化的服务依赖关系管理</li>\n<li>同时采用socket式与D-Bus总线式激活服务</li>\n<li>系统状态快照和恢复</li>\n<li>利用Linux的cgroups监视进程</li>\n<li>维护挂载点和自动挂载点</li>\n<li>各服务间基于依赖关系进行精密控制</li>\n</ul>\n<h2 id=\"三、Systemd核心概念\"><a href=\"#三、Systemd核心概念\" class=\"headerlink\" title=\"三、Systemd核心概念\"></a>三、Systemd核心概念</h2><ul>\n<li>Unit<br>表示不同类型的sytemd对象，通过配置文件进行标识和配置，文件中主要包含了系统服务，监听socket、保存的系统快照以及其他与init相关的信息</li>\n<li>配置文件:<br>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system：每个服务最主要的启动脚本设置，类似于之前的&#x2F;etc&#x2F;initd.d<br>&#x2F;run&#x2F;system&#x2F;system：系统执行过程中所产生的服务脚本，比上面的目录优先运行<br>&#x2F;etc&#x2F;system&#x2F;system：管理员建立的执行脚本，类似于&#x2F;etc&#x2F;rc.d&#x2F;rcN.d&#x2F;Sxx类的功能，比上面目录优先运行，在三者之中，此目录优先级最高</li>\n</ul>\n<h2 id=\"四、Unit类型\"><a href=\"#四、Unit类型\" class=\"headerlink\" title=\"四、Unit类型\"></a>四、Unit类型</h2><ul>\n<li><p>systemctl -t help ：查看unit类型</p>\n</li>\n<li><p>service unit：文件扩展名为.service，用于定义系统服务</p>\n</li>\n<li><p>target unit：文件扩展名为.target，用于模拟实现“运行级别”</p>\n</li>\n<li><p>device unit: .device,用于定义内核识别的设备</p>\n</li>\n<li><p>mount unit ：.mount，定义文件系统挂载点</p>\n</li>\n<li><p>socket unit ：.socket,用于标识进程间通信用的socket文件，也可以在系统启动时，延迟启动服务，实现按需启动</p>\n</li>\n<li><p>snapshot unit：.snapshot，关系系统快照</p>\n</li>\n<li><p>swap unit：.swap，用于表示swap设备</p>\n</li>\n<li><p>automount unit：.automount，文件系统的自动挂载点如：&#x2F;misc目录</p>\n</li>\n<li><p>path unit：.path，用于定义文件系统中的一个文件或目录使用，常用于当文件系统变化时，延迟激活服务，如spool目录</p>\n</li>\n<li><p>time：.timer由systemd管理的计时器</p>\n<p>注：使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式，如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的挂载点会自动转化为相应的.mount单元，例如&#x2F;home等价于home.mount设备会自动转化为相应的.device单元，所以&#x2F;dev&#x2F;sd2等价于dev-sda2.device</p>\n</li>\n</ul>\n<h2 id=\"五、关键特性\"><a href=\"#五、关键特性\" class=\"headerlink\" title=\"五、关键特性\"></a>五、关键特性</h2><ul>\n<li>基于socket的激活机制：socket与服务进程分离</li>\n<li>基于D-Bus的激活机制</li>\n<li>基于device的激活机制</li>\n<li>基于path的激活机制</li>\n<li>系统快照：保存各unit的当前状态信息于持久存储设备中想后兼容sysv init脚本</li>\n</ul>\n<h2 id=\"六、不兼容\"><a href=\"#六、不兼容\" class=\"headerlink\" title=\"六、不兼容\"></a>六、不兼容</h2><ul>\n<li>systemctl命令固定不变，不可扩展</li>\n<li>非由systemd启动的服务，systemctl无语与之通信和控制，如：使用之前sys v风格管理的进程就无法收systemd控制</li>\n</ul>\n<h2 id=\"七、Systemd基本工具\"><a href=\"#七、Systemd基本工具\" class=\"headerlink\" title=\"七、Systemd基本工具\"></a>七、Systemd基本工具</h2><p>监视和控制systemd的主要命令是systemctl。该命令可用于查看系统状态和管理系统及服务。</p>\n<ul>\n<li>管理服务</li>\n</ul>\n<p>命令：systemctl  command name.service</p>\n<p>启动：service name start –&gt;systemctl start name.service</p>\n<p>停止：service name stop –&gt;systemctl stop name.service</p>\n<p>重启：service name restart–&gt;systemctl restart name.service</p>\n<p>状态：service name status–&gt;systemctl status name.service</p>\n<ul>\n<li><p>条件式重启(已启动才重启，否则不做任何操作)<br><code>systemctl try-restart name.service</code></p>\n</li>\n<li><p>重载或重启服务(先加载，然后再启动)<br><code>systemctl reload-or-try-restart name.service</code></p>\n</li>\n<li><p>禁止自动和手动启动<br><code>systemctl mask name.service</code><br>执行此条命令实则创建了一个链接 ln -s ‘&#x2F;dev&#x2F;null’ ‘&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;sshd.service’</p>\n</li>\n<li><p>取消禁止<br><code>systemctl unmask name.service</code><br>删除此前创建的链接</p>\n</li>\n<li><p>服务查看(查看某服务当前激活与否的状态)<br><code>systemctl is-active name.service</code><br>如果启动会显示active，否则会显示unknown</p>\n</li>\n<li><p>查看所有已经激活的服务<br><code>systemctl list-units –t|–type service</code></p>\n</li>\n<li><p>查看所有服务</p>\n<p>systemctl list-units –t service -a</p>\n<p>设定某服务开机启动</p>\n</li>\n<li><p><code>chkconfig name on–&gt;systemctl enable name.service</code></p>\n</li>\n</ul>\n<p>设定某服务开机禁止启动<br><code>chkconfig name off –&gt;systemctl disable name.service</code></p>\n<p>查看所有服务的开机自启状态<br><code>chkconfig –list–&gt;systemctl list-unit-files -t service</code> </p>\n<ul>\n<li>用来列出该服务在那些运行级别下启用或禁用</li>\n</ul>\n<p>chkconfig sshd –list –&gt;ls &#x2F;etc&#x2F;system&#x2F;system&#x2F;*.wants&#x2F;sshd.service</p>\n<p>[root@www ~]# ls &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;*.wants&#x2F;sshd.service</p>\n<p>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;sshd.service</p>\n<ul>\n<li><p>查看服务是否开机自启<br><code>systemctl is-enabled name.servcice</code></p>\n</li>\n<li><p>查看服务的依赖关系<br><code>systemctl list-dependencies</code>  </p>\n</li>\n<li><p>查看启动失败的服务<br><code>systemctl -failed -t service</code></p>\n</li>\n<li><p>查看服务单元的启用和禁用状态<br><code>systemctl list-unit-files –t=service</code></p>\n</li>\n<li><p>杀死进程<br><code>systemctl kill 进程名</code><br>[图片上传失败…(image-53509-1519920006718)]</p>\n</li>\n<li><p>服务状态<br>systemctl list-units -t service -a 显示状态<br>loaded：unit配置文件已处理<br>active（running）：一次或多次持续处理的运行<br>active（exited）：成功完成一次性的配置<br>active（waiting）:运行中，等待一个事件<br>inactive：不运行<br>enabled：开机启动<br>disabled：开机不启动<br>static：开机不启动，但可以被另一个启用的服务激活</p>\n</li>\n<li><p>运行级别<br>target units：<br>unit配置文件：.target 以target结尾的文件<br>ls &#x2F;usr&#x2F;lib&#x2F;system&#x2F;system&#x2F;*.target<br>systemctl list-unit-files -type target -all<br>0–&gt;runlevel0.target, poweroff.target<br>1–&gt;runlevel1.target, rescue.target<br>2–&gt;runlevel2.target, muti-user.target<br>3–&gt;runlevel3.target, mutil-user.target<br>4–&gt;runlevel4.target, multi-user.target<br>5–&gt;runlevel5.target, graphical.target<br>6–&gt;runlevel6.target, reboot.target</p>\n</li>\n<li><p>查看依赖性<br><code>systemctl list-dependencies graphical.target</code></p>\n</li>\n<li><p>查看默认运行级别<br>systemctl get-default 在Sys V风格的系统上是查看&#x2F;etc&#x2F;inittab文件其中有一条id:5:initdefault:</p>\n</li>\n<li><p>级别切换<br><code>systemctl isolate muti-user.target</code><br>注意：只有当&#x2F;lib&#x2F;system&#x2F;system&#x2F;*.target文件中AllowIsolate&#x3D;yes时才能奇幻（修改文件需执行systemctl daemon-reload生效）</p>\n</li>\n<li><p>设定默认运行级别<br><code>systemctl set-default muti-user.target</code><br>实则将multi-user.target链接至default.target<br><code>ls –l /etc/system/system/default.target</code></p>\n</li>\n<li><p>进入紧急救援模式<br><code>systemctl rescue</code></p>\n</li>\n<li><p>切换至emergency模式<br><code>systemctl emergency</code></p>\n</li>\n<li><p>在systemd风格的系统上还能使用sysv风格系统上的关机，重启等命令，指示将该命令链接到systemctl的一个软链接<br>关机：<code>systemctl halt systemctl poweroff</code><br>重启：<code>systemctl reboot</code><br>挂起：<code>systemctl suspend</code><br>休眠：<code>systemctl hibernate</code><br>休眠并挂起：<code>systemctl hybrid-sleep</code></p>\n</li>\n</ul>\n<blockquote>\n<p>使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式</p>\n<p>如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的</p>\n<p>挂载点会自动转化为相应的.mount单元，例如&#x2F;home等价于home.mount</p>\n<p>设备会自动转化为相应的.device单元，所以&#x2F;dev&#x2F;sd2等价于dev-sda2.device<br>加载initramfs驱动模块</p>\n<p>加载内核选项</p>\n<p>内核初始化，centos7使用systemd代替init</p>\n<p>执行initrd.target所有单元，包括挂载&#x2F;etc&#x2F;fstab</p>\n<p>从initramfs根文件系统切换到磁盘根目录</p>\n<p>systemd执行默认target配置，配置文件&#x2F;etc&#x2F;systemd&#x2F;default.target &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;</p>\n<p>systemd执行sysinit.target初始化系统及basic.target准备操作系统</p>\n<p>systemd启动multi-user.target下的本机与服务器服务</p>\n<p>systemd执行multi-user.target下的&#x2F;etc&#x2F;rc.d&#x2F;rc.local</p>\n<p>systemd执行multi-user.target下的getty.target及登入服务</p>\n<p>systemd执行graphical需要的服务（此为图形界面所有）</p>\n</blockquote>\n<h2 id=\"unit文件格式\"><a href=\"#unit文件格式\" class=\"headerlink\" title=\"unit文件格式\"></a>unit文件格式</h2><p>以#开头的行后面的内容会被认为是注释<br>相关布尔值，1、yes、on、ture都是开启，0、no、off、false都是关闭<br>时间单位默认是秒</p>\n<h2 id=\"Unit文件组成\"><a href=\"#Unit文件组成\" class=\"headerlink\" title=\"Unit文件组成\"></a>Unit文件组成</h2><ul>\n<li>[Unit]：定义与Unit类型无关的通用选项，用于提供unit的扫描信息，unit行为及依赖关系等</li>\n<li>[Service]：与特定类型相关的专用选项；此处为Service类型</li>\n<li>[Install]：定义由“systemctl enable及systemctl disable”命令在实现服务启用或禁用时用到的一些选项</li>\n</ul>\n<h2 id=\"unit段常用选项\"><a href=\"#unit段常用选项\" class=\"headerlink\" title=\"unit段常用选项\"></a>unit段常用选项</h2><ul>\n<li><p>Description：描述信息</p>\n<p>After：定义unit的启动次序，表示当前unit应该晚育那些unit启动，其功能与before相反<br>Requires：依赖到的其他units，强依赖，被一来的units无法激活时，当前unit即无法激活<br>Wants：依赖到的其他units，弱依赖<br>Conflicts：定义units间的冲突关系</p>\n</li>\n</ul>\n<h2 id=\"Service段常用选项\"><a href=\"#Service段常用选项\" class=\"headerlink\" title=\"Service段常用选项\"></a>Service段常用选项</h2><ul>\n<li>Type：定义硬性ExecStart及相关参数的功能的unit进程启动类型</li>\n<li>simple：默认值；这个daemon主要有ExecStart接的指令串来启动，启动后常驻于内存中</li>\n<li>forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务原生父程序在启动结束后就会终止</li>\n<li>onshot：用于执行一项任务，随后立即退出的服务，不会常驻于内存中</li>\n<li>notify：与simple相同，但约定服务会在就绪后想systemd发送一个信号，需要配合NotifyAccess来让Systemd接收消息</li>\n<li>idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才只能即可的服务</li>\n<li>EnvironmentFile：环境配置文件</li>\n<li>ExeStart：指明启动unit要运行命令或脚本的绝对路径</li>\n<li>ExeStartPre：ExecStart前运行</li>\n<li>ExeStartPost：ExecStart后运行</li>\n<li>ExecStop：指明停止unit要运行的命令或脚本</li>\n<li>Restart：当设定Restart&#x3D;1时，则当次daemon服务意外终止后，会在此自动启动此服务</li>\n</ul>\n<h2 id=\"Install段常用选项\"><a href=\"#Install段常用选项\" class=\"headerlink\" title=\"Install段常用选项\"></a>Install段常用选项</h2><ul>\n<li>Alias：别名(可使用systemctl command Alial.service)<br>RequiredBy:被那些units所依赖，强依赖<br>WantedBy：被那些units所依赖，弱依赖<br>Also：安装本服务的时候还要安装别的相关服务<br>注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载次配置文件，而后可以选择重启：<code>systemctl daemon-reload</code></li>\n</ul>\n"},{"title":"linux-内存管理","categories":["kernel"],"tags":["内存管理"],"date":"2024-06-17T08:21:33.000Z","_content":"\n## 一、内存寻址\n\n## 1.内存地址\n\n### 逻辑地址(logical address)\n\n包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离\n\n### 线性地址（linear address）（也称虚拟地址  virtual address）\n\n是一个32位无符号整数，可以用来表示最高达4G的地址。线性地址通常用十六进制数字来表示，值的范围从0x0000 0000 到 0xffff ffff\n\n### 物理地址（physical address）\n\n用于内存芯片级内存单元寻址。它们与从处理器的地址引脚发送到内存总线的电信号相对应\n\n### 内存控制单元（MMU）\n\n通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址；接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换位一个物理地址\n\n逻辑地址--->`分页单元`--->线性地址--->`分页单元`--->物理地址\n\n\n\n分段：\n\nGDT\n\nLDT\n\n逻辑地址是段内的偏移\n\n能够跑最大进程数 = （256 - 4）/ 2 = 126个进程\n\n一个进程的逻辑地址 分配虚拟地址位64M\n\n所以可以分配的最大地址为126 * 64 = 8G\n\n但是0.11的内核规定最多为NR_TASKS=64\n\n所以线性地址为64*64 = 4G\n\n分段机制：逻辑地址 ---》线性地址\n\n分页机制：线性地址 ---》物理内存的映射\n\n在操作系统中有多个页目录表，但是当前使用的只有一个，并且这个页目录表存储地址在CR3寄存器中，表在head.S中被创建\n\n\n\n\n\n1.在运行应用程序的时候，是把所有的代码和数据全部加载到内存中么?如果不是那么在用到一些代码而这些代码不在内存中该怎么办?\n\n2.在fork一个进程的时候，我们完全的为子进程拷贝了父进程的内存空间，那么这个进程的拷贝\n是真的创建了两个完全一个的内存块在物理内存中么?如果不是那操作系统是怎么做的（写时拷贝)\n\n \n\n","source":"back_posts/linux-内存管理.md","raw":"---\ntitle: linux-内存管理\ncategories:\n  - kernel\ntags:\n  - 内存管理\ndate: 2024-06-17 16:21:33\n---\n\n## 一、内存寻址\n\n## 1.内存地址\n\n### 逻辑地址(logical address)\n\n包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离\n\n### 线性地址（linear address）（也称虚拟地址  virtual address）\n\n是一个32位无符号整数，可以用来表示最高达4G的地址。线性地址通常用十六进制数字来表示，值的范围从0x0000 0000 到 0xffff ffff\n\n### 物理地址（physical address）\n\n用于内存芯片级内存单元寻址。它们与从处理器的地址引脚发送到内存总线的电信号相对应\n\n### 内存控制单元（MMU）\n\n通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址；接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换位一个物理地址\n\n逻辑地址--->`分页单元`--->线性地址--->`分页单元`--->物理地址\n\n\n\n分段：\n\nGDT\n\nLDT\n\n逻辑地址是段内的偏移\n\n能够跑最大进程数 = （256 - 4）/ 2 = 126个进程\n\n一个进程的逻辑地址 分配虚拟地址位64M\n\n所以可以分配的最大地址为126 * 64 = 8G\n\n但是0.11的内核规定最多为NR_TASKS=64\n\n所以线性地址为64*64 = 4G\n\n分段机制：逻辑地址 ---》线性地址\n\n分页机制：线性地址 ---》物理内存的映射\n\n在操作系统中有多个页目录表，但是当前使用的只有一个，并且这个页目录表存储地址在CR3寄存器中，表在head.S中被创建\n\n\n\n\n\n1.在运行应用程序的时候，是把所有的代码和数据全部加载到内存中么?如果不是那么在用到一些代码而这些代码不在内存中该怎么办?\n\n2.在fork一个进程的时候，我们完全的为子进程拷贝了父进程的内存空间，那么这个进程的拷贝\n是真的创建了两个完全一个的内存块在物理内存中么?如果不是那操作系统是怎么做的（写时拷贝)\n\n \n\n","updated":"2024-06-18T11:34:53.270Z","path":"back_posts/linux-内存管理.html","_id":"clxkbtvgq0000isw04en79j7v","comments":1,"layout":"page","content":"<h2 id=\"一、内存寻址\"><a href=\"#一、内存寻址\" class=\"headerlink\" title=\"一、内存寻址\"></a>一、内存寻址</h2><h2 id=\"1-内存地址\"><a href=\"#1-内存地址\" class=\"headerlink\" title=\"1.内存地址\"></a>1.内存地址</h2><h3 id=\"逻辑地址-logical-address\"><a href=\"#逻辑地址-logical-address\" class=\"headerlink\" title=\"逻辑地址(logical address)\"></a>逻辑地址(logical address)</h3><p>包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离</p>\n<h3 id=\"线性地址（linear-address）（也称虚拟地址-virtual-address）\"><a href=\"#线性地址（linear-address）（也称虚拟地址-virtual-address）\" class=\"headerlink\" title=\"线性地址（linear address）（也称虚拟地址  virtual address）\"></a>线性地址（linear address）（也称虚拟地址  virtual address）</h3><p>是一个32位无符号整数，可以用来表示最高达4G的地址。线性地址通常用十六进制数字来表示，值的范围从0x0000 0000 到 0xffff ffff</p>\n<h3 id=\"物理地址（physical-address）\"><a href=\"#物理地址（physical-address）\" class=\"headerlink\" title=\"物理地址（physical address）\"></a>物理地址（physical address）</h3><p>用于内存芯片级内存单元寻址。它们与从处理器的地址引脚发送到内存总线的电信号相对应</p>\n<h3 id=\"内存控制单元（MMU）\"><a href=\"#内存控制单元（MMU）\" class=\"headerlink\" title=\"内存控制单元（MMU）\"></a>内存控制单元（MMU）</h3><p>通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址；接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换位一个物理地址</p>\n<p>逻辑地址—&gt;<code>分页单元</code>—&gt;线性地址—&gt;<code>分页单元</code>—&gt;物理地址</p>\n<p>分段：</p>\n<p>GDT</p>\n<p>LDT</p>\n<p>逻辑地址是段内的偏移</p>\n<p>能够跑最大进程数 &#x3D; （256 - 4）&#x2F; 2 &#x3D; 126个进程</p>\n<p>一个进程的逻辑地址 分配虚拟地址位64M</p>\n<p>所以可以分配的最大地址为126 * 64 &#x3D; 8G</p>\n<p>但是0.11的内核规定最多为NR_TASKS&#x3D;64</p>\n<p>所以线性地址为64*64 &#x3D; 4G</p>\n<p>分段机制：逻辑地址 —》线性地址</p>\n<p>分页机制：线性地址 —》物理内存的映射</p>\n<p>在操作系统中有多个页目录表，但是当前使用的只有一个，并且这个页目录表存储地址在CR3寄存器中，表在head.S中被创建</p>\n<p>1.在运行应用程序的时候，是把所有的代码和数据全部加载到内存中么?如果不是那么在用到一些代码而这些代码不在内存中该怎么办?</p>\n<p>2.在fork一个进程的时候，我们完全的为子进程拷贝了父进程的内存空间，那么这个进程的拷贝<br>是真的创建了两个完全一个的内存块在物理内存中么?如果不是那操作系统是怎么做的（写时拷贝)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、内存寻址\"><a href=\"#一、内存寻址\" class=\"headerlink\" title=\"一、内存寻址\"></a>一、内存寻址</h2><h2 id=\"1-内存地址\"><a href=\"#1-内存地址\" class=\"headerlink\" title=\"1.内存地址\"></a>1.内存地址</h2><h3 id=\"逻辑地址-logical-address\"><a href=\"#逻辑地址-logical-address\" class=\"headerlink\" title=\"逻辑地址(logical address)\"></a>逻辑地址(logical address)</h3><p>包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离</p>\n<h3 id=\"线性地址（linear-address）（也称虚拟地址-virtual-address）\"><a href=\"#线性地址（linear-address）（也称虚拟地址-virtual-address）\" class=\"headerlink\" title=\"线性地址（linear address）（也称虚拟地址  virtual address）\"></a>线性地址（linear address）（也称虚拟地址  virtual address）</h3><p>是一个32位无符号整数，可以用来表示最高达4G的地址。线性地址通常用十六进制数字来表示，值的范围从0x0000 0000 到 0xffff ffff</p>\n<h3 id=\"物理地址（physical-address）\"><a href=\"#物理地址（physical-address）\" class=\"headerlink\" title=\"物理地址（physical address）\"></a>物理地址（physical address）</h3><p>用于内存芯片级内存单元寻址。它们与从处理器的地址引脚发送到内存总线的电信号相对应</p>\n<h3 id=\"内存控制单元（MMU）\"><a href=\"#内存控制单元（MMU）\" class=\"headerlink\" title=\"内存控制单元（MMU）\"></a>内存控制单元（MMU）</h3><p>通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址；接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换位一个物理地址</p>\n<p>逻辑地址—&gt;<code>分页单元</code>—&gt;线性地址—&gt;<code>分页单元</code>—&gt;物理地址</p>\n<p>分段：</p>\n<p>GDT</p>\n<p>LDT</p>\n<p>逻辑地址是段内的偏移</p>\n<p>能够跑最大进程数 &#x3D; （256 - 4）&#x2F; 2 &#x3D; 126个进程</p>\n<p>一个进程的逻辑地址 分配虚拟地址位64M</p>\n<p>所以可以分配的最大地址为126 * 64 &#x3D; 8G</p>\n<p>但是0.11的内核规定最多为NR_TASKS&#x3D;64</p>\n<p>所以线性地址为64*64 &#x3D; 4G</p>\n<p>分段机制：逻辑地址 —》线性地址</p>\n<p>分页机制：线性地址 —》物理内存的映射</p>\n<p>在操作系统中有多个页目录表，但是当前使用的只有一个，并且这个页目录表存储地址在CR3寄存器中，表在head.S中被创建</p>\n<p>1.在运行应用程序的时候，是把所有的代码和数据全部加载到内存中么?如果不是那么在用到一些代码而这些代码不在内存中该怎么办?</p>\n<p>2.在fork一个进程的时候，我们完全的为子进程拷贝了父进程的内存空间，那么这个进程的拷贝<br>是真的创建了两个完全一个的内存块在物理内存中么?如果不是那操作系统是怎么做的（写时拷贝)</p>\n"},{"title":"设备驱动-reversed-memory-预留内存","categories":["test"],"tags":["test"],"date":"2024-06-19T01:56:22.000Z","_content":"\nRESERVEDMEM_OF_DECLARE 对 dts 中预留的内存进行匹配和初始化\n\n在 include/linux/of_reserved_mem.h \n\n```\nstruct reserved_mem {\n\tconst char\t\t\t*name;\n\tunsigned long\t\t\tfdt_node;\n\tunsigned long\t\t\tphandle;\n\tconst struct reserved_mem_ops\t*ops;\n\tphys_addr_t\t\t\tbase;\n\tphys_addr_t\t\t\tsize;\n\tvoid\t\t\t\t*priv;\n};\n\nstruct reserved_mem_ops {\n\tint\t(*device_init)(struct reserved_mem *rmem,\n\t\t\t       struct device *dev);\n\tvoid\t(*device_release)(struct reserved_mem *rmem,\n\t\t\t\t  struct device *dev);\n};\n\ntypedef int (*reservedmem_of_init_fn)(struct reserved_mem *rmem);\n\n#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  \n\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)\n\n```\n\n## RESERVEDMEM_OF_DECLARE\n\nRESERVEDMEM_OF_DECLARE 在 include/linux/of_reserved_mem.h \n\n_OF_DECLARE 在 include/linux/of.h \n\n```\n\n#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  \n\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)\n//name 就是一个名称 ， 用来构建变量名称 \n//compat 是字符串，和 dts 中的 compatible  字符串匹配 \n//init 是一个函数 ， 这个函数 类型 需要 是  reservedmem_of_init_fn 这样的类型，即 返回 int , 参数为  reserved_mem 指针； \n\n#if defined(CONFIG_OF) && !defined(MODULE)\t//确保不是在内核模块中使用\n#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__used __section(\"__\" #table \"_of_table\")\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn  }\n#else\n#define _OF_DECLARE(table, name, compat, fn, fn_type)//如果是在内核模块中使用\t\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__attribute__((unused))\t\t\t\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn }\n#endif\n//构建一个 static 的 struct of_device_id  对象  __of_table__name  ，这个对象放在   __reservedmem_of_table   这个 section  里面 \n//对象的 compatible 赋值为  compat 字符串；   .data 赋值为  fn \n//(fn==(fn_type)NULL)?  这个 检查， 主要作用就是 检查  fn 函数 类型  是 fn_type 。 如果不是，编译就会报错 \n\n```\n\n示例：\n\n```\n\n.dts\n\n/{\n\treserved-memory {\n\t\t#address-cells = <0x2>;\n\t\t#size-cells = <0x2>;\n\t\tranges;\n\n\t\tminidump-elf-mem {\n\t\t\tcompatible = \"minidump-elf-reserved-memory\";\n\t\t\tno-map;\t//保留内存区域不应该被内核映射到虚拟地址空间，应用程序无法直接访问这块内存区域,它是专门留给内核使用的\n\t\t\tsize = <0x0 0x1300000>;\t//保留内存区域的大小\n\t\t\talignment = <0x0 0x100000>;\t//(1MB)对齐\n\t\t\talloc-ranges = <0x0 0x40000000 0x0 0x40000000>;\t//可以在物理地址范围0x40000000到0x80000000内分配\n\t\t};\n\t};\n};\n\n.c\n\nphys_addr_t g_mindump_ram_phy_base;\nEXPORT_SYMBOL(g_mindump_ram_phy_base);\nunsigned long g_mindump_ram_len;\nEXPORT_SYMBOL(g_mindump_ram_len);\n\nint reserve_memory_minidump_elf_fn(struct reserved_mem *rmem)\n{\n\tpr_info(DFT_TAG \"[W]%s: name: %s,base: 0x%llx,size: 0x%llx\\n\",\n\t\t__func__, rmem->name, (unsigned long long)rmem->base,\n\t\t(unsigned long long)rmem->size);\n\tg_mindump_ram_phy_base = rmem->base;\n\tg_mindump_ram_len = rmem->size;\n\treturn 0;\n}\n\nRESERVEDMEM_OF_DECLARE(minidump_elf_reserve_memory, \"minidump-elf-reserved-memory\",\n\t\t\treserve_memory_minidump_elf_fn);\n\t\t\t\n定义了 一个  \nstruct of_device_id    __of_device_minidump_elf_reserve_memory  =  {\n\t.compatible = \"minidump-elf-reserved-memory\" , \n\t.data = reserve_memory_minidump_elf_fn \n} ; \n```\n\n## dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数\n\n```\n setup_arch\n  --->arm64_memblock_init\n         --->early_init_fdt_scan_reserved_mem\n              --->fdt_init_reserved_mem\n                    --->__reserved_mem_init_node\n```\n\n### fdt_init_reserved_mem\n\ndrivers/of/of_reserved_mem.c\n\n```\nvoid __init fdt_init_reserved_mem(void)\n{\n\tint i;\n\n\t/* check for overlapping reserved regions */\n\t__rmem_check_for_overlap();\n\n\tfor (i = 0; i < reserved_mem_count; i++) {\t//处理每一块 reserved memory \n\t\tstruct reserved_mem *rmem = &reserved_mem[i];\n\t\tunsigned long node = rmem->fdt_node;\n\t\tint len;\n\t\tconst __be32 *prop;\n\t\tint err = 0;\n\t\tbool nomap;\n\n\t\tnomap = of_get_flat_dt_prop(node, \"no-map\", NULL) != NULL;\n\t\tprop = of_get_flat_dt_prop(node, \"phandle\", &len);\n\t\tif (!prop)\n\t\t\tprop = of_get_flat_dt_prop(node, \"linux,phandle\", &len);\n\t\tif (prop)\n\t\t\trmem->phandle = of_read_number(prop, len/4);\n\n\t\tif (rmem->size == 0) //如果还没有为 node 预留内存，则使用  __reserved_mem_alloc_size ，继续解析 node 的 dts 中的 参数，预留内存。\n\t\t\terr = __reserved_mem_alloc_size(node, rmem->name,\n\t\t\t\t\t\t &rmem->base, &rmem->size);\n\t\tif (err == 0) { //说明预留内存成功， 对预留的这部分内存   调用 __reserved_mem_init_node 函数（下面详述） \n\t\t\terr = __reserved_mem_init_node(rmem);\n\t\t\tif (err != 0 && err != -ENOENT) {\t// 如果 __reserved_mem init node 失败了， 则需要释放 预留的这部分内存 先 memblock free \n\t\t\t\tpr_info(\"node %s compatible matching fail\\n\",\n\t\t\t\t\trmem->name);\n\t\t\t\tmemblock_free(rmem->base, rmem->size);\n\t\t\t\tif (nomap)\t\t\t\t\t\t//如果 有 nomap 属性，则还需要进一步把这块内存 add 到 memblock 的memory type 的 链表中\n\t\t\t\t\tmemblock_add(rmem->base, rmem->size);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n###  __reserved_mem_init_node \n\ndrivers/of/of_reserved_mem.c\n\n```\nstatic int __init __reserved_mem_init_node(struct reserved_mem *rmem)\n{\n\textern const struct of_device_id __reservedmem_of_table[];\n\tconst struct of_device_id *i;\n\tint ret = -ENOENT;\n\n\tfor (i = __reservedmem_of_table; i < &__rmem_of_table_sentinel; i++) {\n\t\t//对 rmem ，遍历    __reservedmem_of_table   这个 section  里面 的所有 of_device_id  对象 \n\t\treservedmem_of_init_fn initfn = i->data;\n\t\tconst char *compat = i->compatible;\n\t\t// rmem 的 fdt_node 和  of_device_id 对象的 compat  （char * 字符串）   进行匹配 \n\t\tif (!of_flat_dt_is_compatible(rmem->fdt_node, compat))\n\t\t\tcontinue;\n\t\t//匹配成功，调用 of_device_id 的 data 字段 里面存放的函数 。 initfn( rmem )\n\t\tret = initfn(rmem);\n\t\tif (ret == 0) {\n\t\t\tpr_info(\"initialized node %s, compatible id %s\\n\",\n\t\t\t\trmem->name, compat);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n```\n\ndts 中，通常使用 memory-region 将设备和 reserved memory 关联起来，如下：\n\n![img](../imgs/2704972-20220410142315999-1415044429.jpg)\n\n fb0 通过 memory-region 关联到 display_reserved 这块 reserved memory 上面；\n\n## of_reserved_mem_device_init\n\ninclude/linux/of_reserved_mem.h \n\n传入参数 dev， 找到 dev 中 memory-region 对应的 reserved memory .\n\n然后调用 reserved_memory 对象的 ops->device_init( reserved_memory * rmem, device * dev );\n\n```\nstatic inline int of_reserved_mem_device_init(struct device *dev)\n{\n\treturn of_reserved_mem_device_init_by_idx(dev, dev->of_node, 0);\n}\n```\n\n## of_reserved_mem_device_init_by_idx \n\n从 of_reserved_mem_device_init 进入时，dev , dev_node, idx = 0 ;\n\n```\nint of_reserved_mem_device_init_by_idx(struct device *dev,\n\t\t\t\t       struct device_node *np, int idx)\n{\n\tstruct rmem_assigned_device *rd;\n\tstruct device_node *target;\n\tstruct reserved_mem *rmem;\n\tint ret;\n\n\tif (!np || !dev)\n\t\treturn -EINVAL;\n\n\ttarget = of_parse_phandle(np, \"memory-region\", idx); //通过 memory-region 找对应的 reserved memory \n\tif (!target)\n\t\treturn -ENODEV;\n\n\tif (!of_device_is_available(target)) {\n\t\tof_node_put(target);\n\t\treturn 0;\n\t}\n\n\trmem = __find_rmem(target);\n\tof_node_put(target);\n\n\tif (!rmem || !rmem->ops || !rmem->ops->device_init) //检查 有 rmem->ops   rmem->ops->device_init 函数 \n\t\treturn -EINVAL;\n\n\trd = kmalloc(sizeof(struct rmem_assigned_device), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\tret = rmem->ops->device_init(rmem, dev); //调用  rmem->ops->device_init(rmem, dev) \n\tif (ret == 0) { \t\t\t\t\t\t//成功的话，就 将 建立的对象 reserved_memory_device \n\t\trd->dev = dev; \n\t\trd->rmem = rmem;\n\n\t\tmutex_lock(&of_rmem_assigned_device_mutex);\n\t\tlist_add(&rd->list, &of_rmem_assigned_device_list);//加入到  of_rmem_assigned_device_list 里面 ,记录 rmem 分配到 device 里面\n\t\tmutex_unlock(&of_rmem_assigned_device_mutex);\n\n\t\tdev_info(dev, \"assigned reserved memory node %s\\n\", rmem->name);\n\t} else {\n\t\tkfree(rd);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);\n```\n","source":"back_posts/设备驱动-reversed-memory-预留内存.md","raw":"---\ntitle: 设备驱动-reversed-memory-预留内存\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-06-19 09:56:22\n---\n\nRESERVEDMEM_OF_DECLARE 对 dts 中预留的内存进行匹配和初始化\n\n在 include/linux/of_reserved_mem.h \n\n```\nstruct reserved_mem {\n\tconst char\t\t\t*name;\n\tunsigned long\t\t\tfdt_node;\n\tunsigned long\t\t\tphandle;\n\tconst struct reserved_mem_ops\t*ops;\n\tphys_addr_t\t\t\tbase;\n\tphys_addr_t\t\t\tsize;\n\tvoid\t\t\t\t*priv;\n};\n\nstruct reserved_mem_ops {\n\tint\t(*device_init)(struct reserved_mem *rmem,\n\t\t\t       struct device *dev);\n\tvoid\t(*device_release)(struct reserved_mem *rmem,\n\t\t\t\t  struct device *dev);\n};\n\ntypedef int (*reservedmem_of_init_fn)(struct reserved_mem *rmem);\n\n#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  \n\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)\n\n```\n\n## RESERVEDMEM_OF_DECLARE\n\nRESERVEDMEM_OF_DECLARE 在 include/linux/of_reserved_mem.h \n\n_OF_DECLARE 在 include/linux/of.h \n\n```\n\n#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  \n\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)\n//name 就是一个名称 ， 用来构建变量名称 \n//compat 是字符串，和 dts 中的 compatible  字符串匹配 \n//init 是一个函数 ， 这个函数 类型 需要 是  reservedmem_of_init_fn 这样的类型，即 返回 int , 参数为  reserved_mem 指针； \n\n#if defined(CONFIG_OF) && !defined(MODULE)\t//确保不是在内核模块中使用\n#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__used __section(\"__\" #table \"_of_table\")\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn  }\n#else\n#define _OF_DECLARE(table, name, compat, fn, fn_type)//如果是在内核模块中使用\t\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__attribute__((unused))\t\t\t\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn }\n#endif\n//构建一个 static 的 struct of_device_id  对象  __of_table__name  ，这个对象放在   __reservedmem_of_table   这个 section  里面 \n//对象的 compatible 赋值为  compat 字符串；   .data 赋值为  fn \n//(fn==(fn_type)NULL)?  这个 检查， 主要作用就是 检查  fn 函数 类型  是 fn_type 。 如果不是，编译就会报错 \n\n```\n\n示例：\n\n```\n\n.dts\n\n/{\n\treserved-memory {\n\t\t#address-cells = <0x2>;\n\t\t#size-cells = <0x2>;\n\t\tranges;\n\n\t\tminidump-elf-mem {\n\t\t\tcompatible = \"minidump-elf-reserved-memory\";\n\t\t\tno-map;\t//保留内存区域不应该被内核映射到虚拟地址空间，应用程序无法直接访问这块内存区域,它是专门留给内核使用的\n\t\t\tsize = <0x0 0x1300000>;\t//保留内存区域的大小\n\t\t\talignment = <0x0 0x100000>;\t//(1MB)对齐\n\t\t\talloc-ranges = <0x0 0x40000000 0x0 0x40000000>;\t//可以在物理地址范围0x40000000到0x80000000内分配\n\t\t};\n\t};\n};\n\n.c\n\nphys_addr_t g_mindump_ram_phy_base;\nEXPORT_SYMBOL(g_mindump_ram_phy_base);\nunsigned long g_mindump_ram_len;\nEXPORT_SYMBOL(g_mindump_ram_len);\n\nint reserve_memory_minidump_elf_fn(struct reserved_mem *rmem)\n{\n\tpr_info(DFT_TAG \"[W]%s: name: %s,base: 0x%llx,size: 0x%llx\\n\",\n\t\t__func__, rmem->name, (unsigned long long)rmem->base,\n\t\t(unsigned long long)rmem->size);\n\tg_mindump_ram_phy_base = rmem->base;\n\tg_mindump_ram_len = rmem->size;\n\treturn 0;\n}\n\nRESERVEDMEM_OF_DECLARE(minidump_elf_reserve_memory, \"minidump-elf-reserved-memory\",\n\t\t\treserve_memory_minidump_elf_fn);\n\t\t\t\n定义了 一个  \nstruct of_device_id    __of_device_minidump_elf_reserve_memory  =  {\n\t.compatible = \"minidump-elf-reserved-memory\" , \n\t.data = reserve_memory_minidump_elf_fn \n} ; \n```\n\n## dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数\n\n```\n setup_arch\n  --->arm64_memblock_init\n         --->early_init_fdt_scan_reserved_mem\n              --->fdt_init_reserved_mem\n                    --->__reserved_mem_init_node\n```\n\n### fdt_init_reserved_mem\n\ndrivers/of/of_reserved_mem.c\n\n```\nvoid __init fdt_init_reserved_mem(void)\n{\n\tint i;\n\n\t/* check for overlapping reserved regions */\n\t__rmem_check_for_overlap();\n\n\tfor (i = 0; i < reserved_mem_count; i++) {\t//处理每一块 reserved memory \n\t\tstruct reserved_mem *rmem = &reserved_mem[i];\n\t\tunsigned long node = rmem->fdt_node;\n\t\tint len;\n\t\tconst __be32 *prop;\n\t\tint err = 0;\n\t\tbool nomap;\n\n\t\tnomap = of_get_flat_dt_prop(node, \"no-map\", NULL) != NULL;\n\t\tprop = of_get_flat_dt_prop(node, \"phandle\", &len);\n\t\tif (!prop)\n\t\t\tprop = of_get_flat_dt_prop(node, \"linux,phandle\", &len);\n\t\tif (prop)\n\t\t\trmem->phandle = of_read_number(prop, len/4);\n\n\t\tif (rmem->size == 0) //如果还没有为 node 预留内存，则使用  __reserved_mem_alloc_size ，继续解析 node 的 dts 中的 参数，预留内存。\n\t\t\terr = __reserved_mem_alloc_size(node, rmem->name,\n\t\t\t\t\t\t &rmem->base, &rmem->size);\n\t\tif (err == 0) { //说明预留内存成功， 对预留的这部分内存   调用 __reserved_mem_init_node 函数（下面详述） \n\t\t\terr = __reserved_mem_init_node(rmem);\n\t\t\tif (err != 0 && err != -ENOENT) {\t// 如果 __reserved_mem init node 失败了， 则需要释放 预留的这部分内存 先 memblock free \n\t\t\t\tpr_info(\"node %s compatible matching fail\\n\",\n\t\t\t\t\trmem->name);\n\t\t\t\tmemblock_free(rmem->base, rmem->size);\n\t\t\t\tif (nomap)\t\t\t\t\t\t//如果 有 nomap 属性，则还需要进一步把这块内存 add 到 memblock 的memory type 的 链表中\n\t\t\t\t\tmemblock_add(rmem->base, rmem->size);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n###  __reserved_mem_init_node \n\ndrivers/of/of_reserved_mem.c\n\n```\nstatic int __init __reserved_mem_init_node(struct reserved_mem *rmem)\n{\n\textern const struct of_device_id __reservedmem_of_table[];\n\tconst struct of_device_id *i;\n\tint ret = -ENOENT;\n\n\tfor (i = __reservedmem_of_table; i < &__rmem_of_table_sentinel; i++) {\n\t\t//对 rmem ，遍历    __reservedmem_of_table   这个 section  里面 的所有 of_device_id  对象 \n\t\treservedmem_of_init_fn initfn = i->data;\n\t\tconst char *compat = i->compatible;\n\t\t// rmem 的 fdt_node 和  of_device_id 对象的 compat  （char * 字符串）   进行匹配 \n\t\tif (!of_flat_dt_is_compatible(rmem->fdt_node, compat))\n\t\t\tcontinue;\n\t\t//匹配成功，调用 of_device_id 的 data 字段 里面存放的函数 。 initfn( rmem )\n\t\tret = initfn(rmem);\n\t\tif (ret == 0) {\n\t\t\tpr_info(\"initialized node %s, compatible id %s\\n\",\n\t\t\t\trmem->name, compat);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n```\n\ndts 中，通常使用 memory-region 将设备和 reserved memory 关联起来，如下：\n\n![img](../imgs/2704972-20220410142315999-1415044429.jpg)\n\n fb0 通过 memory-region 关联到 display_reserved 这块 reserved memory 上面；\n\n## of_reserved_mem_device_init\n\ninclude/linux/of_reserved_mem.h \n\n传入参数 dev， 找到 dev 中 memory-region 对应的 reserved memory .\n\n然后调用 reserved_memory 对象的 ops->device_init( reserved_memory * rmem, device * dev );\n\n```\nstatic inline int of_reserved_mem_device_init(struct device *dev)\n{\n\treturn of_reserved_mem_device_init_by_idx(dev, dev->of_node, 0);\n}\n```\n\n## of_reserved_mem_device_init_by_idx \n\n从 of_reserved_mem_device_init 进入时，dev , dev_node, idx = 0 ;\n\n```\nint of_reserved_mem_device_init_by_idx(struct device *dev,\n\t\t\t\t       struct device_node *np, int idx)\n{\n\tstruct rmem_assigned_device *rd;\n\tstruct device_node *target;\n\tstruct reserved_mem *rmem;\n\tint ret;\n\n\tif (!np || !dev)\n\t\treturn -EINVAL;\n\n\ttarget = of_parse_phandle(np, \"memory-region\", idx); //通过 memory-region 找对应的 reserved memory \n\tif (!target)\n\t\treturn -ENODEV;\n\n\tif (!of_device_is_available(target)) {\n\t\tof_node_put(target);\n\t\treturn 0;\n\t}\n\n\trmem = __find_rmem(target);\n\tof_node_put(target);\n\n\tif (!rmem || !rmem->ops || !rmem->ops->device_init) //检查 有 rmem->ops   rmem->ops->device_init 函数 \n\t\treturn -EINVAL;\n\n\trd = kmalloc(sizeof(struct rmem_assigned_device), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\tret = rmem->ops->device_init(rmem, dev); //调用  rmem->ops->device_init(rmem, dev) \n\tif (ret == 0) { \t\t\t\t\t\t//成功的话，就 将 建立的对象 reserved_memory_device \n\t\trd->dev = dev; \n\t\trd->rmem = rmem;\n\n\t\tmutex_lock(&of_rmem_assigned_device_mutex);\n\t\tlist_add(&rd->list, &of_rmem_assigned_device_list);//加入到  of_rmem_assigned_device_list 里面 ,记录 rmem 分配到 device 里面\n\t\tmutex_unlock(&of_rmem_assigned_device_mutex);\n\n\t\tdev_info(dev, \"assigned reserved memory node %s\\n\", rmem->name);\n\t} else {\n\t\tkfree(rd);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);\n```\n","updated":"2024-06-19T08:32:03.282Z","path":"back_posts/设备驱动-reversed-memory-预留内存.html","comments":1,"layout":"page","_id":"clxss7yyd00008jw02yje86qq","content":"<p>RESERVEDMEM_OF_DECLARE 对 dts 中预留的内存进行匹配和初始化</p>\n<p>在 include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct reserved_mem &#123;</span><br><span class=\"line\">\tconst char\t\t\t*name;</span><br><span class=\"line\">\tunsigned long\t\t\tfdt_node;</span><br><span class=\"line\">\tunsigned long\t\t\tphandle;</span><br><span class=\"line\">\tconst struct reserved_mem_ops\t*ops;</span><br><span class=\"line\">\tphys_addr_t\t\t\tbase;</span><br><span class=\"line\">\tphys_addr_t\t\t\tsize;</span><br><span class=\"line\">\tvoid\t\t\t\t*priv;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct reserved_mem_ops &#123;</span><br><span class=\"line\">\tint\t(*device_init)(struct reserved_mem *rmem,</span><br><span class=\"line\">\t\t\t       struct device *dev);</span><br><span class=\"line\">\tvoid\t(*device_release)(struct reserved_mem *rmem,</span><br><span class=\"line\">\t\t\t\t  struct device *dev);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef int (*reservedmem_of_init_fn)(struct reserved_mem *rmem);</span><br><span class=\"line\"></span><br><span class=\"line\">#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  </span><br><span class=\"line\">\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RESERVEDMEM-OF-DECLARE\"><a href=\"#RESERVEDMEM-OF-DECLARE\" class=\"headerlink\" title=\"RESERVEDMEM_OF_DECLARE\"></a>RESERVEDMEM_OF_DECLARE</h2><p>RESERVEDMEM_OF_DECLARE 在 include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<p>_OF_DECLARE 在 include&#x2F;linux&#x2F;of.h </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  </span><br><span class=\"line\">\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)</span><br><span class=\"line\">//name 就是一个名称 ， 用来构建变量名称 </span><br><span class=\"line\">//compat 是字符串，和 dts 中的 compatible  字符串匹配 </span><br><span class=\"line\">//init 是一个函数 ， 这个函数 类型 需要 是  reservedmem_of_init_fn 这样的类型，即 返回 int , 参数为  reserved_mem 指针； </span><br><span class=\"line\"></span><br><span class=\"line\">#if defined(CONFIG_OF) &amp;&amp; !defined(MODULE)\t//确保不是在内核模块中使用</span><br><span class=\"line\">#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\</span><br><span class=\"line\">\tstatic const struct of_device_id __of_table_##name\t\t\\</span><br><span class=\"line\">\t\t__used __section(&quot;__&quot; #table &quot;_of_table&quot;)\t\t\\</span><br><span class=\"line\">\t\t = &#123; .compatible = compat,\t\t\t\t\\</span><br><span class=\"line\">\t\t     .data = (fn == (fn_type)NULL) ? fn : fn  &#125;</span><br><span class=\"line\">#else</span><br><span class=\"line\">#define _OF_DECLARE(table, name, compat, fn, fn_type)//如果是在内核模块中使用\t\t\t\\</span><br><span class=\"line\">\tstatic const struct of_device_id __of_table_##name\t\t\\</span><br><span class=\"line\">\t\t__attribute__((unused))\t\t\t\t\t\\</span><br><span class=\"line\">\t\t = &#123; .compatible = compat,\t\t\t\t\\</span><br><span class=\"line\">\t\t     .data = (fn == (fn_type)NULL) ? fn : fn &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">//构建一个 static 的 struct of_device_id  对象  __of_table__name  ，这个对象放在   __reservedmem_of_table   这个 section  里面 </span><br><span class=\"line\">//对象的 compatible 赋值为  compat 字符串；   .data 赋值为  fn </span><br><span class=\"line\">//(fn==(fn_type)NULL)?  这个 检查， 主要作用就是 检查  fn 函数 类型  是 fn_type 。 如果不是，编译就会报错 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.dts</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;</span><br><span class=\"line\">\treserved-memory &#123;</span><br><span class=\"line\">\t\t#address-cells = &lt;0x2&gt;;</span><br><span class=\"line\">\t\t#size-cells = &lt;0x2&gt;;</span><br><span class=\"line\">\t\tranges;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tminidump-elf-mem &#123;</span><br><span class=\"line\">\t\t\tcompatible = &quot;minidump-elf-reserved-memory&quot;;</span><br><span class=\"line\">\t\t\tno-map;\t//保留内存区域不应该被内核映射到虚拟地址空间，应用程序无法直接访问这块内存区域,它是专门留给内核使用的</span><br><span class=\"line\">\t\t\tsize = &lt;0x0 0x1300000&gt;;\t//保留内存区域的大小</span><br><span class=\"line\">\t\t\talignment = &lt;0x0 0x100000&gt;;\t//(1MB)对齐</span><br><span class=\"line\">\t\t\talloc-ranges = &lt;0x0 0x40000000 0x0 0x40000000&gt;;\t//可以在物理地址范围0x40000000到0x80000000内分配</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">.c</span><br><span class=\"line\"></span><br><span class=\"line\">phys_addr_t g_mindump_ram_phy_base;</span><br><span class=\"line\">EXPORT_SYMBOL(g_mindump_ram_phy_base);</span><br><span class=\"line\">unsigned long g_mindump_ram_len;</span><br><span class=\"line\">EXPORT_SYMBOL(g_mindump_ram_len);</span><br><span class=\"line\"></span><br><span class=\"line\">int reserve_memory_minidump_elf_fn(struct reserved_mem *rmem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpr_info(DFT_TAG &quot;[W]%s: name: %s,base: 0x%llx,size: 0x%llx\\n&quot;,</span><br><span class=\"line\">\t\t__func__, rmem-&gt;name, (unsigned long long)rmem-&gt;base,</span><br><span class=\"line\">\t\t(unsigned long long)rmem-&gt;size);</span><br><span class=\"line\">\tg_mindump_ram_phy_base = rmem-&gt;base;</span><br><span class=\"line\">\tg_mindump_ram_len = rmem-&gt;size;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">RESERVEDMEM_OF_DECLARE(minidump_elf_reserve_memory, &quot;minidump-elf-reserved-memory&quot;,</span><br><span class=\"line\">\t\t\treserve_memory_minidump_elf_fn);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">定义了 一个  </span><br><span class=\"line\">struct of_device_id    __of_device_minidump_elf_reserve_memory  =  &#123;</span><br><span class=\"line\">\t.compatible = &quot;minidump-elf-reserved-memory&quot; , </span><br><span class=\"line\">\t.data = reserve_memory_minidump_elf_fn </span><br><span class=\"line\">&#125; ; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"dts-中reserved-memory-解析和调用匹配的-of-device-id-的-data-函数\"><a href=\"#dts-中reserved-memory-解析和调用匹配的-of-device-id-的-data-函数\" class=\"headerlink\" title=\"dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数\"></a>dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup_arch</span><br><span class=\"line\"> ---&gt;arm64_memblock_init</span><br><span class=\"line\">        ---&gt;early_init_fdt_scan_reserved_mem</span><br><span class=\"line\">             ---&gt;fdt_init_reserved_mem</span><br><span class=\"line\">                   ---&gt;__reserved_mem_init_node</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fdt-init-reserved-mem\"><a href=\"#fdt-init-reserved-mem\" class=\"headerlink\" title=\"fdt_init_reserved_mem\"></a>fdt_init_reserved_mem</h3><p>drivers&#x2F;of&#x2F;of_reserved_mem.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void __init fdt_init_reserved_mem(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/* check for overlapping reserved regions */</span><br><span class=\"line\">\t__rmem_check_for_overlap();</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (i = 0; i &lt; reserved_mem_count; i++) &#123;\t//处理每一块 reserved memory </span><br><span class=\"line\">\t\tstruct reserved_mem *rmem = &amp;reserved_mem[i];</span><br><span class=\"line\">\t\tunsigned long node = rmem-&gt;fdt_node;</span><br><span class=\"line\">\t\tint len;</span><br><span class=\"line\">\t\tconst __be32 *prop;</span><br><span class=\"line\">\t\tint err = 0;</span><br><span class=\"line\">\t\tbool nomap;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnomap = of_get_flat_dt_prop(node, &quot;no-map&quot;, NULL) != NULL;</span><br><span class=\"line\">\t\tprop = of_get_flat_dt_prop(node, &quot;phandle&quot;, &amp;len);</span><br><span class=\"line\">\t\tif (!prop)</span><br><span class=\"line\">\t\t\tprop = of_get_flat_dt_prop(node, &quot;linux,phandle&quot;, &amp;len);</span><br><span class=\"line\">\t\tif (prop)</span><br><span class=\"line\">\t\t\trmem-&gt;phandle = of_read_number(prop, len/4);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (rmem-&gt;size == 0) //如果还没有为 node 预留内存，则使用  __reserved_mem_alloc_size ，继续解析 node 的 dts 中的 参数，预留内存。</span><br><span class=\"line\">\t\t\terr = __reserved_mem_alloc_size(node, rmem-&gt;name,</span><br><span class=\"line\">\t\t\t\t\t\t &amp;rmem-&gt;base, &amp;rmem-&gt;size);</span><br><span class=\"line\">\t\tif (err == 0) &#123; //说明预留内存成功， 对预留的这部分内存   调用 __reserved_mem_init_node 函数（下面详述） </span><br><span class=\"line\">\t\t\terr = __reserved_mem_init_node(rmem);</span><br><span class=\"line\">\t\t\tif (err != 0 &amp;&amp; err != -ENOENT) &#123;\t// 如果 __reserved_mem init node 失败了， 则需要释放 预留的这部分内存 先 memblock free </span><br><span class=\"line\">\t\t\t\tpr_info(&quot;node %s compatible matching fail\\n&quot;,</span><br><span class=\"line\">\t\t\t\t\trmem-&gt;name);</span><br><span class=\"line\">\t\t\t\tmemblock_free(rmem-&gt;base, rmem-&gt;size);</span><br><span class=\"line\">\t\t\t\tif (nomap)\t\t\t\t\t\t//如果 有 nomap 属性，则还需要进一步把这块内存 add 到 memblock 的memory type 的 链表中</span><br><span class=\"line\">\t\t\t\t\tmemblock_add(rmem-&gt;base, rmem-&gt;size);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reserved-mem-init-node\"><a href=\"#reserved-mem-init-node\" class=\"headerlink\" title=\"__reserved_mem_init_node\"></a>__reserved_mem_init_node</h3><p>drivers&#x2F;of&#x2F;of_reserved_mem.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int __init __reserved_mem_init_node(struct reserved_mem *rmem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\textern const struct of_device_id __reservedmem_of_table[];</span><br><span class=\"line\">\tconst struct of_device_id *i;</span><br><span class=\"line\">\tint ret = -ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (i = __reservedmem_of_table; i &lt; &amp;__rmem_of_table_sentinel; i++) &#123;</span><br><span class=\"line\">\t\t//对 rmem ，遍历    __reservedmem_of_table   这个 section  里面 的所有 of_device_id  对象 </span><br><span class=\"line\">\t\treservedmem_of_init_fn initfn = i-&gt;data;</span><br><span class=\"line\">\t\tconst char *compat = i-&gt;compatible;</span><br><span class=\"line\">\t\t// rmem 的 fdt_node 和  of_device_id 对象的 compat  （char * 字符串）   进行匹配 </span><br><span class=\"line\">\t\tif (!of_flat_dt_is_compatible(rmem-&gt;fdt_node, compat))</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t//匹配成功，调用 of_device_id 的 data 字段 里面存放的函数 。 initfn( rmem )</span><br><span class=\"line\">\t\tret = initfn(rmem);</span><br><span class=\"line\">\t\tif (ret == 0) &#123;</span><br><span class=\"line\">\t\t\tpr_info(&quot;initialized node %s, compatible id %s\\n&quot;,</span><br><span class=\"line\">\t\t\t\trmem-&gt;name, compat);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>dts 中，通常使用 memory-region 将设备和 reserved memory 关联起来，如下：</p>\n<p><img src=\"/../imgs/2704972-20220410142315999-1415044429.jpg\" alt=\"img\"></p>\n<p> fb0 通过 memory-region 关联到 display_reserved 这块 reserved memory 上面；</p>\n<h2 id=\"of-reserved-mem-device-init\"><a href=\"#of-reserved-mem-device-init\" class=\"headerlink\" title=\"of_reserved_mem_device_init\"></a>of_reserved_mem_device_init</h2><p>include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<p>传入参数 dev， 找到 dev 中 memory-region 对应的 reserved memory .</p>\n<p>然后调用 reserved_memory 对象的 ops-&gt;device_init( reserved_memory * rmem, device * dev );</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline int of_reserved_mem_device_init(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn of_reserved_mem_device_init_by_idx(dev, dev-&gt;of_node, 0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"of-reserved-mem-device-init-by-idx\"><a href=\"#of-reserved-mem-device-init-by-idx\" class=\"headerlink\" title=\"of_reserved_mem_device_init_by_idx\"></a>of_reserved_mem_device_init_by_idx</h2><p>从 of_reserved_mem_device_init 进入时，dev , dev_node, idx &#x3D; 0 ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int of_reserved_mem_device_init_by_idx(struct device *dev,</span><br><span class=\"line\">\t\t\t\t       struct device_node *np, int idx)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstruct rmem_assigned_device *rd;</span><br><span class=\"line\">\tstruct device_node *target;</span><br><span class=\"line\">\tstruct reserved_mem *rmem;</span><br><span class=\"line\">\tint ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!np || !dev)</span><br><span class=\"line\">\t\treturn -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttarget = of_parse_phandle(np, &quot;memory-region&quot;, idx); //通过 memory-region 找对应的 reserved memory </span><br><span class=\"line\">\tif (!target)</span><br><span class=\"line\">\t\treturn -ENODEV;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!of_device_is_available(target)) &#123;</span><br><span class=\"line\">\t\tof_node_put(target);</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trmem = __find_rmem(target);</span><br><span class=\"line\">\tof_node_put(target);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!rmem || !rmem-&gt;ops || !rmem-&gt;ops-&gt;device_init) //检查 有 rmem-&gt;ops   rmem-&gt;ops-&gt;device_init 函数 </span><br><span class=\"line\">\t\treturn -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\trd = kmalloc(sizeof(struct rmem_assigned_device), GFP_KERNEL);</span><br><span class=\"line\">\tif (!rd)</span><br><span class=\"line\">\t\treturn -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = rmem-&gt;ops-&gt;device_init(rmem, dev); //调用  rmem-&gt;ops-&gt;device_init(rmem, dev) </span><br><span class=\"line\">\tif (ret == 0) &#123; \t\t\t\t\t\t//成功的话，就 将 建立的对象 reserved_memory_device </span><br><span class=\"line\">\t\trd-&gt;dev = dev; </span><br><span class=\"line\">\t\trd-&gt;rmem = rmem;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmutex_lock(&amp;of_rmem_assigned_device_mutex);</span><br><span class=\"line\">\t\tlist_add(&amp;rd-&gt;list, &amp;of_rmem_assigned_device_list);//加入到  of_rmem_assigned_device_list 里面 ,记录 rmem 分配到 device 里面</span><br><span class=\"line\">\t\tmutex_unlock(&amp;of_rmem_assigned_device_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdev_info(dev, &quot;assigned reserved memory node %s\\n&quot;, rmem-&gt;name);</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tkfree(rd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>RESERVEDMEM_OF_DECLARE 对 dts 中预留的内存进行匹配和初始化</p>\n<p>在 include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct reserved_mem &#123;</span><br><span class=\"line\">\tconst char\t\t\t*name;</span><br><span class=\"line\">\tunsigned long\t\t\tfdt_node;</span><br><span class=\"line\">\tunsigned long\t\t\tphandle;</span><br><span class=\"line\">\tconst struct reserved_mem_ops\t*ops;</span><br><span class=\"line\">\tphys_addr_t\t\t\tbase;</span><br><span class=\"line\">\tphys_addr_t\t\t\tsize;</span><br><span class=\"line\">\tvoid\t\t\t\t*priv;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct reserved_mem_ops &#123;</span><br><span class=\"line\">\tint\t(*device_init)(struct reserved_mem *rmem,</span><br><span class=\"line\">\t\t\t       struct device *dev);</span><br><span class=\"line\">\tvoid\t(*device_release)(struct reserved_mem *rmem,</span><br><span class=\"line\">\t\t\t\t  struct device *dev);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef int (*reservedmem_of_init_fn)(struct reserved_mem *rmem);</span><br><span class=\"line\"></span><br><span class=\"line\">#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  </span><br><span class=\"line\">\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RESERVEDMEM-OF-DECLARE\"><a href=\"#RESERVEDMEM-OF-DECLARE\" class=\"headerlink\" title=\"RESERVEDMEM_OF_DECLARE\"></a>RESERVEDMEM_OF_DECLARE</h2><p>RESERVEDMEM_OF_DECLARE 在 include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<p>_OF_DECLARE 在 include&#x2F;linux&#x2F;of.h </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  </span><br><span class=\"line\">\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)</span><br><span class=\"line\">//name 就是一个名称 ， 用来构建变量名称 </span><br><span class=\"line\">//compat 是字符串，和 dts 中的 compatible  字符串匹配 </span><br><span class=\"line\">//init 是一个函数 ， 这个函数 类型 需要 是  reservedmem_of_init_fn 这样的类型，即 返回 int , 参数为  reserved_mem 指针； </span><br><span class=\"line\"></span><br><span class=\"line\">#if defined(CONFIG_OF) &amp;&amp; !defined(MODULE)\t//确保不是在内核模块中使用</span><br><span class=\"line\">#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\</span><br><span class=\"line\">\tstatic const struct of_device_id __of_table_##name\t\t\\</span><br><span class=\"line\">\t\t__used __section(&quot;__&quot; #table &quot;_of_table&quot;)\t\t\\</span><br><span class=\"line\">\t\t = &#123; .compatible = compat,\t\t\t\t\\</span><br><span class=\"line\">\t\t     .data = (fn == (fn_type)NULL) ? fn : fn  &#125;</span><br><span class=\"line\">#else</span><br><span class=\"line\">#define _OF_DECLARE(table, name, compat, fn, fn_type)//如果是在内核模块中使用\t\t\t\\</span><br><span class=\"line\">\tstatic const struct of_device_id __of_table_##name\t\t\\</span><br><span class=\"line\">\t\t__attribute__((unused))\t\t\t\t\t\\</span><br><span class=\"line\">\t\t = &#123; .compatible = compat,\t\t\t\t\\</span><br><span class=\"line\">\t\t     .data = (fn == (fn_type)NULL) ? fn : fn &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">//构建一个 static 的 struct of_device_id  对象  __of_table__name  ，这个对象放在   __reservedmem_of_table   这个 section  里面 </span><br><span class=\"line\">//对象的 compatible 赋值为  compat 字符串；   .data 赋值为  fn </span><br><span class=\"line\">//(fn==(fn_type)NULL)?  这个 检查， 主要作用就是 检查  fn 函数 类型  是 fn_type 。 如果不是，编译就会报错 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.dts</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;</span><br><span class=\"line\">\treserved-memory &#123;</span><br><span class=\"line\">\t\t#address-cells = &lt;0x2&gt;;</span><br><span class=\"line\">\t\t#size-cells = &lt;0x2&gt;;</span><br><span class=\"line\">\t\tranges;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tminidump-elf-mem &#123;</span><br><span class=\"line\">\t\t\tcompatible = &quot;minidump-elf-reserved-memory&quot;;</span><br><span class=\"line\">\t\t\tno-map;\t//保留内存区域不应该被内核映射到虚拟地址空间，应用程序无法直接访问这块内存区域,它是专门留给内核使用的</span><br><span class=\"line\">\t\t\tsize = &lt;0x0 0x1300000&gt;;\t//保留内存区域的大小</span><br><span class=\"line\">\t\t\talignment = &lt;0x0 0x100000&gt;;\t//(1MB)对齐</span><br><span class=\"line\">\t\t\talloc-ranges = &lt;0x0 0x40000000 0x0 0x40000000&gt;;\t//可以在物理地址范围0x40000000到0x80000000内分配</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">.c</span><br><span class=\"line\"></span><br><span class=\"line\">phys_addr_t g_mindump_ram_phy_base;</span><br><span class=\"line\">EXPORT_SYMBOL(g_mindump_ram_phy_base);</span><br><span class=\"line\">unsigned long g_mindump_ram_len;</span><br><span class=\"line\">EXPORT_SYMBOL(g_mindump_ram_len);</span><br><span class=\"line\"></span><br><span class=\"line\">int reserve_memory_minidump_elf_fn(struct reserved_mem *rmem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpr_info(DFT_TAG &quot;[W]%s: name: %s,base: 0x%llx,size: 0x%llx\\n&quot;,</span><br><span class=\"line\">\t\t__func__, rmem-&gt;name, (unsigned long long)rmem-&gt;base,</span><br><span class=\"line\">\t\t(unsigned long long)rmem-&gt;size);</span><br><span class=\"line\">\tg_mindump_ram_phy_base = rmem-&gt;base;</span><br><span class=\"line\">\tg_mindump_ram_len = rmem-&gt;size;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">RESERVEDMEM_OF_DECLARE(minidump_elf_reserve_memory, &quot;minidump-elf-reserved-memory&quot;,</span><br><span class=\"line\">\t\t\treserve_memory_minidump_elf_fn);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">定义了 一个  </span><br><span class=\"line\">struct of_device_id    __of_device_minidump_elf_reserve_memory  =  &#123;</span><br><span class=\"line\">\t.compatible = &quot;minidump-elf-reserved-memory&quot; , </span><br><span class=\"line\">\t.data = reserve_memory_minidump_elf_fn </span><br><span class=\"line\">&#125; ; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"dts-中reserved-memory-解析和调用匹配的-of-device-id-的-data-函数\"><a href=\"#dts-中reserved-memory-解析和调用匹配的-of-device-id-的-data-函数\" class=\"headerlink\" title=\"dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数\"></a>dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup_arch</span><br><span class=\"line\"> ---&gt;arm64_memblock_init</span><br><span class=\"line\">        ---&gt;early_init_fdt_scan_reserved_mem</span><br><span class=\"line\">             ---&gt;fdt_init_reserved_mem</span><br><span class=\"line\">                   ---&gt;__reserved_mem_init_node</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fdt-init-reserved-mem\"><a href=\"#fdt-init-reserved-mem\" class=\"headerlink\" title=\"fdt_init_reserved_mem\"></a>fdt_init_reserved_mem</h3><p>drivers&#x2F;of&#x2F;of_reserved_mem.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void __init fdt_init_reserved_mem(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/* check for overlapping reserved regions */</span><br><span class=\"line\">\t__rmem_check_for_overlap();</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (i = 0; i &lt; reserved_mem_count; i++) &#123;\t//处理每一块 reserved memory </span><br><span class=\"line\">\t\tstruct reserved_mem *rmem = &amp;reserved_mem[i];</span><br><span class=\"line\">\t\tunsigned long node = rmem-&gt;fdt_node;</span><br><span class=\"line\">\t\tint len;</span><br><span class=\"line\">\t\tconst __be32 *prop;</span><br><span class=\"line\">\t\tint err = 0;</span><br><span class=\"line\">\t\tbool nomap;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnomap = of_get_flat_dt_prop(node, &quot;no-map&quot;, NULL) != NULL;</span><br><span class=\"line\">\t\tprop = of_get_flat_dt_prop(node, &quot;phandle&quot;, &amp;len);</span><br><span class=\"line\">\t\tif (!prop)</span><br><span class=\"line\">\t\t\tprop = of_get_flat_dt_prop(node, &quot;linux,phandle&quot;, &amp;len);</span><br><span class=\"line\">\t\tif (prop)</span><br><span class=\"line\">\t\t\trmem-&gt;phandle = of_read_number(prop, len/4);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (rmem-&gt;size == 0) //如果还没有为 node 预留内存，则使用  __reserved_mem_alloc_size ，继续解析 node 的 dts 中的 参数，预留内存。</span><br><span class=\"line\">\t\t\terr = __reserved_mem_alloc_size(node, rmem-&gt;name,</span><br><span class=\"line\">\t\t\t\t\t\t &amp;rmem-&gt;base, &amp;rmem-&gt;size);</span><br><span class=\"line\">\t\tif (err == 0) &#123; //说明预留内存成功， 对预留的这部分内存   调用 __reserved_mem_init_node 函数（下面详述） </span><br><span class=\"line\">\t\t\terr = __reserved_mem_init_node(rmem);</span><br><span class=\"line\">\t\t\tif (err != 0 &amp;&amp; err != -ENOENT) &#123;\t// 如果 __reserved_mem init node 失败了， 则需要释放 预留的这部分内存 先 memblock free </span><br><span class=\"line\">\t\t\t\tpr_info(&quot;node %s compatible matching fail\\n&quot;,</span><br><span class=\"line\">\t\t\t\t\trmem-&gt;name);</span><br><span class=\"line\">\t\t\t\tmemblock_free(rmem-&gt;base, rmem-&gt;size);</span><br><span class=\"line\">\t\t\t\tif (nomap)\t\t\t\t\t\t//如果 有 nomap 属性，则还需要进一步把这块内存 add 到 memblock 的memory type 的 链表中</span><br><span class=\"line\">\t\t\t\t\tmemblock_add(rmem-&gt;base, rmem-&gt;size);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reserved-mem-init-node\"><a href=\"#reserved-mem-init-node\" class=\"headerlink\" title=\"__reserved_mem_init_node\"></a>__reserved_mem_init_node</h3><p>drivers&#x2F;of&#x2F;of_reserved_mem.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int __init __reserved_mem_init_node(struct reserved_mem *rmem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\textern const struct of_device_id __reservedmem_of_table[];</span><br><span class=\"line\">\tconst struct of_device_id *i;</span><br><span class=\"line\">\tint ret = -ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (i = __reservedmem_of_table; i &lt; &amp;__rmem_of_table_sentinel; i++) &#123;</span><br><span class=\"line\">\t\t//对 rmem ，遍历    __reservedmem_of_table   这个 section  里面 的所有 of_device_id  对象 </span><br><span class=\"line\">\t\treservedmem_of_init_fn initfn = i-&gt;data;</span><br><span class=\"line\">\t\tconst char *compat = i-&gt;compatible;</span><br><span class=\"line\">\t\t// rmem 的 fdt_node 和  of_device_id 对象的 compat  （char * 字符串）   进行匹配 </span><br><span class=\"line\">\t\tif (!of_flat_dt_is_compatible(rmem-&gt;fdt_node, compat))</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t//匹配成功，调用 of_device_id 的 data 字段 里面存放的函数 。 initfn( rmem )</span><br><span class=\"line\">\t\tret = initfn(rmem);</span><br><span class=\"line\">\t\tif (ret == 0) &#123;</span><br><span class=\"line\">\t\t\tpr_info(&quot;initialized node %s, compatible id %s\\n&quot;,</span><br><span class=\"line\">\t\t\t\trmem-&gt;name, compat);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>dts 中，通常使用 memory-region 将设备和 reserved memory 关联起来，如下：</p>\n<p><img src=\"/../imgs/2704972-20220410142315999-1415044429.jpg\" alt=\"img\"></p>\n<p> fb0 通过 memory-region 关联到 display_reserved 这块 reserved memory 上面；</p>\n<h2 id=\"of-reserved-mem-device-init\"><a href=\"#of-reserved-mem-device-init\" class=\"headerlink\" title=\"of_reserved_mem_device_init\"></a>of_reserved_mem_device_init</h2><p>include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<p>传入参数 dev， 找到 dev 中 memory-region 对应的 reserved memory .</p>\n<p>然后调用 reserved_memory 对象的 ops-&gt;device_init( reserved_memory * rmem, device * dev );</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline int of_reserved_mem_device_init(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn of_reserved_mem_device_init_by_idx(dev, dev-&gt;of_node, 0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"of-reserved-mem-device-init-by-idx\"><a href=\"#of-reserved-mem-device-init-by-idx\" class=\"headerlink\" title=\"of_reserved_mem_device_init_by_idx\"></a>of_reserved_mem_device_init_by_idx</h2><p>从 of_reserved_mem_device_init 进入时，dev , dev_node, idx &#x3D; 0 ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int of_reserved_mem_device_init_by_idx(struct device *dev,</span><br><span class=\"line\">\t\t\t\t       struct device_node *np, int idx)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstruct rmem_assigned_device *rd;</span><br><span class=\"line\">\tstruct device_node *target;</span><br><span class=\"line\">\tstruct reserved_mem *rmem;</span><br><span class=\"line\">\tint ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!np || !dev)</span><br><span class=\"line\">\t\treturn -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttarget = of_parse_phandle(np, &quot;memory-region&quot;, idx); //通过 memory-region 找对应的 reserved memory </span><br><span class=\"line\">\tif (!target)</span><br><span class=\"line\">\t\treturn -ENODEV;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!of_device_is_available(target)) &#123;</span><br><span class=\"line\">\t\tof_node_put(target);</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trmem = __find_rmem(target);</span><br><span class=\"line\">\tof_node_put(target);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!rmem || !rmem-&gt;ops || !rmem-&gt;ops-&gt;device_init) //检查 有 rmem-&gt;ops   rmem-&gt;ops-&gt;device_init 函数 </span><br><span class=\"line\">\t\treturn -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\trd = kmalloc(sizeof(struct rmem_assigned_device), GFP_KERNEL);</span><br><span class=\"line\">\tif (!rd)</span><br><span class=\"line\">\t\treturn -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = rmem-&gt;ops-&gt;device_init(rmem, dev); //调用  rmem-&gt;ops-&gt;device_init(rmem, dev) </span><br><span class=\"line\">\tif (ret == 0) &#123; \t\t\t\t\t\t//成功的话，就 将 建立的对象 reserved_memory_device </span><br><span class=\"line\">\t\trd-&gt;dev = dev; </span><br><span class=\"line\">\t\trd-&gt;rmem = rmem;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmutex_lock(&amp;of_rmem_assigned_device_mutex);</span><br><span class=\"line\">\t\tlist_add(&amp;rd-&gt;list, &amp;of_rmem_assigned_device_list);//加入到  of_rmem_assigned_device_list 里面 ,记录 rmem 分配到 device 里面</span><br><span class=\"line\">\t\tmutex_unlock(&amp;of_rmem_assigned_device_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdev_info(dev, &quot;assigned reserved memory node %s\\n&quot;, rmem-&gt;name);</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tkfree(rd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);</span><br></pre></td></tr></table></figure>\n"},{"title":"kernel-workqueue","categories":["test"],"tags":["test"],"date":"2024-06-21T09:26:17.000Z","_content":"\n一、workqueue的作用及在Linux中断处理中的应用\n1.1、workqueue的概述\nLinux工作队列（Workqueue）是一个内核中的机制，它可以异步执行一些任务。在Linux内核中，当需要处理一些不是紧急的、需要后台执行的任务时，就会将这些任务加入到工作队列中，然后由内核计划适当的时间来执行这些任务。\n\n工作队列的特点是异步执行，即任务的执行不会阻塞当前进程，而是交给后台线程进行处理。这种方式可以避免阻塞主线程，提高系统的响应速度和并发能力。\n\n工作队列具有多种使用场景，比如定时器事件、网络I/O事件、驱动程序事件等，都可以通过工作队列来异步处理。\n\n1.2、workqueue在Linux中断处理中的作用\nworkqueue是一种异步执行工作的机制，它可以在Linux中断处理中使用。当内核需要异步执行某些任务时，可以使用workqueue机制。\n\n在Linux中断处理中，有些操作不能直接执行，因为它们可能会阻塞中断处理程序。例如，如果一个中断处理程序需要访问磁盘，那么它可能需要等待磁盘访问完成才能继续执行，这将导致中断处理程序的延迟和性能下降。为了避免这种情况，可以使用workqueue机制。\n\nworkqueue机制允许中断处理程序将任务提交给工作队列，在稍后的时间异步执行。这样，中断处理程序可以立即返回，并且不会阻塞其他中断处理程序的执行。工作队列是一组线程，它们可以同时执行多个任务。当工作队列中有任务时，内核会自动调度线程来执行任务。\n\nworkqueue机制是一种非常有效的机制，可以帮助内核异步执行任务，提高系统的性能和可靠性。\n![在这里插入图片描述](../imgs/d32faea7d5004b979cc98527aa0973e8.png)\n\n二、workqueue的实现原理\nworkqueue通过使用worker线程池来执行延迟性任务，能够提高系统的吞吐量和响应速度，适用于需要进行异步任务调度的场景。\n\nworkqueue是Linux系统中用于实现异步任务调度的机制，它允许驱动程序和内核线程安排延迟执行的工作。\n\nworkqueue由一个或多个worker线程池组成，每个worker线程都会不断地从workqueue中获取需要执行的工作项。\n当驱动程序或内核模块需要执行一些延迟性的任务时，可以将这些任务封装成工作项（work）并添加到workqueue队列中。\nworker线程在空闲时，从workqueue队列中取出一个工作项，并将其放入自己的私有队列中，等待执行。\n一旦worker线程完成当前正在执行的工作项，就会从自己的私有队列中取出下一个工作项进行处理。\n若workqueue队列中没有可用的工作项，则worker线程会等待直到有新的工作项被添加到队列中。\n在workqueue中，还提供了几种不同的队列类型，如普通队列、高优先级队列和延迟队列等，以满足不同场景下的需求。\n2.1、工作队列和工作者线程的关系\n工作队列和工作者线程是相互依存的关系，它们通过协同工作来处理系统中的任务。\n\n工作队列是一个先进先出的任务列表，其中包含需要被执行的任务。工作者线程则是实际执行这些任务的线程。当有新的任务添加到工作队列中时，工作者线程会自动从队列中取出任务并执行。\n\n工作者线程通常是由内核创建的，其数量可以根据系统负载情况进行调整。当任务数量增加时，可以增加工作者线程的数量以加快任务处理速度。而当任务数量减少时，可以减少工作者线程的数量以节省系统资源。\n![在这里插入图片描述](../imgs/2b8686c61a24478a8112e4b83228f177.png)\n\n2.2、工作队列的创建和销毁\n在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：\n\n创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。\n销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。\n例如，创建和销毁一个名为“my_work”的工作队列：\n\n工作队列的创建和销毁\n在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：\n\n创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。\n销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。\n2.3、工作者线程的创建和销毁\nLinux 内核中的工作者线程是一种特殊的内核线程，用于执行一些异步的、需要花费较长时间或者需要消耗大量 CPU 资源的任务。它们主要用于处理 I/O 操作、网络操作、文件系统缓存等等。\n\n在 Linux 内核中，工作者线程的创建和销毁是由系统自动管理的。当进程请求创建一个工作者线程时，内核会检查当前是否有可用的空闲线程。如果没有，则会创建一个新的线程。当任务完成后，工作者线程会被回收并返回到线程池中，以备下次使用。\n\n为了提高效率，Linux 内核还可以在运行时动态地调整线程池中工作者线程的数量。当系统负载较高时，内核会增加线程池中的线程数量，以处理更多的任务。当负载降低时，内核会减少线程池中的线程数量，以节省资源。\n\n例如，展示如何在 Linux 内核中创建和销毁工作者线程：\n```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#if 1\n#define YYHDEBUG(fmt, ...) \\\n    printk(KERN_ERR \"yyh debug [%s][%d] \" fmt, __func__, __LINE__, ##__VA_ARGS__)\n#else \n#define YYHDEBUG(debug)\n#endif\nstatic struct workqueue_struct *my_wq;\n\ntypedef struct {\n    struct work_struct my_work;\n    int x;\n} my_work_t;\n\nstatic void my_work_handler(struct work_struct *work)\n{\n    my_work_t *my_work = (my_work_t *)work;\n    YYHDEBUG(\"my_work_handler: x=%d\\n\", my_work->x);\n    kfree(my_work);\n}\n\nstatic int __init my_module_init(void)\n{\n    my_work_t *my_work;\n\n    /* 创建工作者队列 */\n    my_wq = create_workqueue(\"my_queue\");\n    if (!my_wq) {\n        YYHDEBUG(\"create_workqueue failed!\\n\");\n        return -1;\n    }\n\n    /* 创建并提交工作者线程 */\n    my_work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);\n    if (!my_work) {\n        YYHDEBUG(\"kmalloc failed!\\n\");\n        return -1;\n    }\n    INIT_WORK((struct work_struct *)my_work, my_work_handler);\n    my_work->x = 1;\n    queue_work(my_wq, (struct work_struct *)my_work);\n\n    return 0;\n}\n\nstatic void __exit my_module_exit(void)\n{\n    /* 销毁工作者队列 */\n    flush_workqueue(my_wq);\n    destroy_workqueue(my_wq);\n}\n\nmodule_init(my_module_init);\nmodule_exit(my_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lion Long\");\nMODULE_DESCRIPTION(\"A simple example Linux module.\");\n```\n\n例子展示了如何创建一个名为“my_queue”的工作者队列，然后创建一个工作者线程来处理一个名为“my_work”的工作对象。“my_work_handler”函数将打印出传递给工作对象的参数“x”，并释放工作对象的内存。在模块初始化期间，创建工作者队列和工作对象，并提交工作对象到队列中。在模块退出期间，销毁工作者队列。\n\nLinux 内核中的工作者线程是一种非常重要的机制，能够显著提高系统的性能和响应速度。虽然用户无法直接控制工作者线程的创建和销毁，但可以通过一些系统调优技巧来优化工作者线程的使用效果。\n2.4、扩展知识：用户态线程的创建\n线程创建：\n\n```\n#include <pthread.h>\n\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                   void *(*start_routine)(void*), void *arg);\n```\n\n该函数用于创建一个新的线程，并将其添加到调用进程中。参数 thread 是指向新线程标识符的指针，参数 attr 是指向线程属性的指针（通常为 NULL），参数 start_routine 是指向线程执行函数的指针，参数 arg 是传递给线程执行函数的参数。\n\n线程销毁：\n\n```\nvoid pthread_exit(void *value_ptr);\n```\n\n该函数用于终止当前线程，并返回一个指针值。这个值可以由其他线程通过 pthread_join 函数获取，也可以被忽略。\n\n```\nint pthread_join(pthread_t thread, void **value_ptr);\n```\n\n\n\n该函数用于阻塞当前线程，直到指定的线程 thread 终止。如果指针 value_ptr 不为 NULL，则会将线程的返回值存储在 value_ptr 指向的位置中。\n\n注意：如果线程没有被显式地分离，则它将一直存在于内存中，直到进程结束。因此，在创建线程时，应该考虑是否需要将它们分离或者等待它们的结束。\n\n\n原文链接：https://blog.csdn.net/Long_xu/article/details/1314057422.2\n","source":"back_posts/kernel-workqueue.md","raw":"---\ntitle: kernel-workqueue\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-06-21 17:26:17\n---\n\n一、workqueue的作用及在Linux中断处理中的应用\n1.1、workqueue的概述\nLinux工作队列（Workqueue）是一个内核中的机制，它可以异步执行一些任务。在Linux内核中，当需要处理一些不是紧急的、需要后台执行的任务时，就会将这些任务加入到工作队列中，然后由内核计划适当的时间来执行这些任务。\n\n工作队列的特点是异步执行，即任务的执行不会阻塞当前进程，而是交给后台线程进行处理。这种方式可以避免阻塞主线程，提高系统的响应速度和并发能力。\n\n工作队列具有多种使用场景，比如定时器事件、网络I/O事件、驱动程序事件等，都可以通过工作队列来异步处理。\n\n1.2、workqueue在Linux中断处理中的作用\nworkqueue是一种异步执行工作的机制，它可以在Linux中断处理中使用。当内核需要异步执行某些任务时，可以使用workqueue机制。\n\n在Linux中断处理中，有些操作不能直接执行，因为它们可能会阻塞中断处理程序。例如，如果一个中断处理程序需要访问磁盘，那么它可能需要等待磁盘访问完成才能继续执行，这将导致中断处理程序的延迟和性能下降。为了避免这种情况，可以使用workqueue机制。\n\nworkqueue机制允许中断处理程序将任务提交给工作队列，在稍后的时间异步执行。这样，中断处理程序可以立即返回，并且不会阻塞其他中断处理程序的执行。工作队列是一组线程，它们可以同时执行多个任务。当工作队列中有任务时，内核会自动调度线程来执行任务。\n\nworkqueue机制是一种非常有效的机制，可以帮助内核异步执行任务，提高系统的性能和可靠性。\n![在这里插入图片描述](../imgs/d32faea7d5004b979cc98527aa0973e8.png)\n\n二、workqueue的实现原理\nworkqueue通过使用worker线程池来执行延迟性任务，能够提高系统的吞吐量和响应速度，适用于需要进行异步任务调度的场景。\n\nworkqueue是Linux系统中用于实现异步任务调度的机制，它允许驱动程序和内核线程安排延迟执行的工作。\n\nworkqueue由一个或多个worker线程池组成，每个worker线程都会不断地从workqueue中获取需要执行的工作项。\n当驱动程序或内核模块需要执行一些延迟性的任务时，可以将这些任务封装成工作项（work）并添加到workqueue队列中。\nworker线程在空闲时，从workqueue队列中取出一个工作项，并将其放入自己的私有队列中，等待执行。\n一旦worker线程完成当前正在执行的工作项，就会从自己的私有队列中取出下一个工作项进行处理。\n若workqueue队列中没有可用的工作项，则worker线程会等待直到有新的工作项被添加到队列中。\n在workqueue中，还提供了几种不同的队列类型，如普通队列、高优先级队列和延迟队列等，以满足不同场景下的需求。\n2.1、工作队列和工作者线程的关系\n工作队列和工作者线程是相互依存的关系，它们通过协同工作来处理系统中的任务。\n\n工作队列是一个先进先出的任务列表，其中包含需要被执行的任务。工作者线程则是实际执行这些任务的线程。当有新的任务添加到工作队列中时，工作者线程会自动从队列中取出任务并执行。\n\n工作者线程通常是由内核创建的，其数量可以根据系统负载情况进行调整。当任务数量增加时，可以增加工作者线程的数量以加快任务处理速度。而当任务数量减少时，可以减少工作者线程的数量以节省系统资源。\n![在这里插入图片描述](../imgs/2b8686c61a24478a8112e4b83228f177.png)\n\n2.2、工作队列的创建和销毁\n在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：\n\n创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。\n销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。\n例如，创建和销毁一个名为“my_work”的工作队列：\n\n工作队列的创建和销毁\n在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：\n\n创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。\n销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。\n2.3、工作者线程的创建和销毁\nLinux 内核中的工作者线程是一种特殊的内核线程，用于执行一些异步的、需要花费较长时间或者需要消耗大量 CPU 资源的任务。它们主要用于处理 I/O 操作、网络操作、文件系统缓存等等。\n\n在 Linux 内核中，工作者线程的创建和销毁是由系统自动管理的。当进程请求创建一个工作者线程时，内核会检查当前是否有可用的空闲线程。如果没有，则会创建一个新的线程。当任务完成后，工作者线程会被回收并返回到线程池中，以备下次使用。\n\n为了提高效率，Linux 内核还可以在运行时动态地调整线程池中工作者线程的数量。当系统负载较高时，内核会增加线程池中的线程数量，以处理更多的任务。当负载降低时，内核会减少线程池中的线程数量，以节省资源。\n\n例如，展示如何在 Linux 内核中创建和销毁工作者线程：\n```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#if 1\n#define YYHDEBUG(fmt, ...) \\\n    printk(KERN_ERR \"yyh debug [%s][%d] \" fmt, __func__, __LINE__, ##__VA_ARGS__)\n#else \n#define YYHDEBUG(debug)\n#endif\nstatic struct workqueue_struct *my_wq;\n\ntypedef struct {\n    struct work_struct my_work;\n    int x;\n} my_work_t;\n\nstatic void my_work_handler(struct work_struct *work)\n{\n    my_work_t *my_work = (my_work_t *)work;\n    YYHDEBUG(\"my_work_handler: x=%d\\n\", my_work->x);\n    kfree(my_work);\n}\n\nstatic int __init my_module_init(void)\n{\n    my_work_t *my_work;\n\n    /* 创建工作者队列 */\n    my_wq = create_workqueue(\"my_queue\");\n    if (!my_wq) {\n        YYHDEBUG(\"create_workqueue failed!\\n\");\n        return -1;\n    }\n\n    /* 创建并提交工作者线程 */\n    my_work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);\n    if (!my_work) {\n        YYHDEBUG(\"kmalloc failed!\\n\");\n        return -1;\n    }\n    INIT_WORK((struct work_struct *)my_work, my_work_handler);\n    my_work->x = 1;\n    queue_work(my_wq, (struct work_struct *)my_work);\n\n    return 0;\n}\n\nstatic void __exit my_module_exit(void)\n{\n    /* 销毁工作者队列 */\n    flush_workqueue(my_wq);\n    destroy_workqueue(my_wq);\n}\n\nmodule_init(my_module_init);\nmodule_exit(my_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lion Long\");\nMODULE_DESCRIPTION(\"A simple example Linux module.\");\n```\n\n例子展示了如何创建一个名为“my_queue”的工作者队列，然后创建一个工作者线程来处理一个名为“my_work”的工作对象。“my_work_handler”函数将打印出传递给工作对象的参数“x”，并释放工作对象的内存。在模块初始化期间，创建工作者队列和工作对象，并提交工作对象到队列中。在模块退出期间，销毁工作者队列。\n\nLinux 内核中的工作者线程是一种非常重要的机制，能够显著提高系统的性能和响应速度。虽然用户无法直接控制工作者线程的创建和销毁，但可以通过一些系统调优技巧来优化工作者线程的使用效果。\n2.4、扩展知识：用户态线程的创建\n线程创建：\n\n```\n#include <pthread.h>\n\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                   void *(*start_routine)(void*), void *arg);\n```\n\n该函数用于创建一个新的线程，并将其添加到调用进程中。参数 thread 是指向新线程标识符的指针，参数 attr 是指向线程属性的指针（通常为 NULL），参数 start_routine 是指向线程执行函数的指针，参数 arg 是传递给线程执行函数的参数。\n\n线程销毁：\n\n```\nvoid pthread_exit(void *value_ptr);\n```\n\n该函数用于终止当前线程，并返回一个指针值。这个值可以由其他线程通过 pthread_join 函数获取，也可以被忽略。\n\n```\nint pthread_join(pthread_t thread, void **value_ptr);\n```\n\n\n\n该函数用于阻塞当前线程，直到指定的线程 thread 终止。如果指针 value_ptr 不为 NULL，则会将线程的返回值存储在 value_ptr 指向的位置中。\n\n注意：如果线程没有被显式地分离，则它将一直存在于内存中，直到进程结束。因此，在创建线程时，应该考虑是否需要将它们分离或者等待它们的结束。\n\n\n原文链接：https://blog.csdn.net/Long_xu/article/details/1314057422.2\n","updated":"2024-07-02T14:41:27.731Z","path":"back_posts/kernel-workqueue.html","comments":1,"layout":"page","_id":"cly4iru9v0000uhjugszs0100","content":"<p>一、workqueue的作用及在Linux中断处理中的应用<br>1.1、workqueue的概述<br>Linux工作队列（Workqueue）是一个内核中的机制，它可以异步执行一些任务。在Linux内核中，当需要处理一些不是紧急的、需要后台执行的任务时，就会将这些任务加入到工作队列中，然后由内核计划适当的时间来执行这些任务。</p>\n<p>工作队列的特点是异步执行，即任务的执行不会阻塞当前进程，而是交给后台线程进行处理。这种方式可以避免阻塞主线程，提高系统的响应速度和并发能力。</p>\n<p>工作队列具有多种使用场景，比如定时器事件、网络I&#x2F;O事件、驱动程序事件等，都可以通过工作队列来异步处理。</p>\n<p>1.2、workqueue在Linux中断处理中的作用<br>workqueue是一种异步执行工作的机制，它可以在Linux中断处理中使用。当内核需要异步执行某些任务时，可以使用workqueue机制。</p>\n<p>在Linux中断处理中，有些操作不能直接执行，因为它们可能会阻塞中断处理程序。例如，如果一个中断处理程序需要访问磁盘，那么它可能需要等待磁盘访问完成才能继续执行，这将导致中断处理程序的延迟和性能下降。为了避免这种情况，可以使用workqueue机制。</p>\n<p>workqueue机制允许中断处理程序将任务提交给工作队列，在稍后的时间异步执行。这样，中断处理程序可以立即返回，并且不会阻塞其他中断处理程序的执行。工作队列是一组线程，它们可以同时执行多个任务。当工作队列中有任务时，内核会自动调度线程来执行任务。</p>\n<p>workqueue机制是一种非常有效的机制，可以帮助内核异步执行任务，提高系统的性能和可靠性。<br><img src=\"/../imgs/d32faea7d5004b979cc98527aa0973e8.png\" alt=\"在这里插入图片描述\"></p>\n<p>二、workqueue的实现原理<br>workqueue通过使用worker线程池来执行延迟性任务，能够提高系统的吞吐量和响应速度，适用于需要进行异步任务调度的场景。</p>\n<p>workqueue是Linux系统中用于实现异步任务调度的机制，它允许驱动程序和内核线程安排延迟执行的工作。</p>\n<p>workqueue由一个或多个worker线程池组成，每个worker线程都会不断地从workqueue中获取需要执行的工作项。<br>当驱动程序或内核模块需要执行一些延迟性的任务时，可以将这些任务封装成工作项（work）并添加到workqueue队列中。<br>worker线程在空闲时，从workqueue队列中取出一个工作项，并将其放入自己的私有队列中，等待执行。<br>一旦worker线程完成当前正在执行的工作项，就会从自己的私有队列中取出下一个工作项进行处理。<br>若workqueue队列中没有可用的工作项，则worker线程会等待直到有新的工作项被添加到队列中。<br>在workqueue中，还提供了几种不同的队列类型，如普通队列、高优先级队列和延迟队列等，以满足不同场景下的需求。<br>2.1、工作队列和工作者线程的关系<br>工作队列和工作者线程是相互依存的关系，它们通过协同工作来处理系统中的任务。</p>\n<p>工作队列是一个先进先出的任务列表，其中包含需要被执行的任务。工作者线程则是实际执行这些任务的线程。当有新的任务添加到工作队列中时，工作者线程会自动从队列中取出任务并执行。</p>\n<p>工作者线程通常是由内核创建的，其数量可以根据系统负载情况进行调整。当任务数量增加时，可以增加工作者线程的数量以加快任务处理速度。而当任务数量减少时，可以减少工作者线程的数量以节省系统资源。<br><img src=\"/../imgs/2b8686c61a24478a8112e4b83228f177.png\" alt=\"在这里插入图片描述\"></p>\n<p>2.2、工作队列的创建和销毁<br>在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：</p>\n<p>创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。<br>销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。<br>例如，创建和销毁一个名为“my_work”的工作队列：</p>\n<p>工作队列的创建和销毁<br>在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：</p>\n<p>创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。<br>销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。<br>2.3、工作者线程的创建和销毁<br>Linux 内核中的工作者线程是一种特殊的内核线程，用于执行一些异步的、需要花费较长时间或者需要消耗大量 CPU 资源的任务。它们主要用于处理 I&#x2F;O 操作、网络操作、文件系统缓存等等。</p>\n<p>在 Linux 内核中，工作者线程的创建和销毁是由系统自动管理的。当进程请求创建一个工作者线程时，内核会检查当前是否有可用的空闲线程。如果没有，则会创建一个新的线程。当任务完成后，工作者线程会被回收并返回到线程池中，以备下次使用。</p>\n<p>为了提高效率，Linux 内核还可以在运行时动态地调整线程池中工作者线程的数量。当系统负载较高时，内核会增加线程池中的线程数量，以处理更多的任务。当负载降低时，内核会减少线程池中的线程数量，以节省资源。</p>\n<p>例如，展示如何在 Linux 内核中创建和销毁工作者线程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;linux/module.h&gt;</span><br><span class=\"line\">#include &lt;linux/kernel.h&gt;</span><br><span class=\"line\">#include &lt;linux/workqueue.h&gt;</span><br><span class=\"line\">#if 1</span><br><span class=\"line\">#define YYHDEBUG(fmt, ...) \\</span><br><span class=\"line\">    printk(KERN_ERR &quot;yyh debug [%s][%d] &quot; fmt, __func__, __LINE__, ##__VA_ARGS__)</span><br><span class=\"line\">#else </span><br><span class=\"line\">#define YYHDEBUG(debug)</span><br><span class=\"line\">#endif</span><br><span class=\"line\">static struct workqueue_struct *my_wq;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    struct work_struct my_work;</span><br><span class=\"line\">    int x;</span><br><span class=\"line\">&#125; my_work_t;</span><br><span class=\"line\"></span><br><span class=\"line\">static void my_work_handler(struct work_struct *work)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    my_work_t *my_work = (my_work_t *)work;</span><br><span class=\"line\">    YYHDEBUG(&quot;my_work_handler: x=%d\\n&quot;, my_work-&gt;x);</span><br><span class=\"line\">    kfree(my_work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static int __init my_module_init(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    my_work_t *my_work;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 创建工作者队列 */</span><br><span class=\"line\">    my_wq = create_workqueue(&quot;my_queue&quot;);</span><br><span class=\"line\">    if (!my_wq) &#123;</span><br><span class=\"line\">        YYHDEBUG(&quot;create_workqueue failed!\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 创建并提交工作者线程 */</span><br><span class=\"line\">    my_work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);</span><br><span class=\"line\">    if (!my_work) &#123;</span><br><span class=\"line\">        YYHDEBUG(&quot;kmalloc failed!\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    INIT_WORK((struct work_struct *)my_work, my_work_handler);</span><br><span class=\"line\">    my_work-&gt;x = 1;</span><br><span class=\"line\">    queue_work(my_wq, (struct work_struct *)my_work);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __exit my_module_exit(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /* 销毁工作者队列 */</span><br><span class=\"line\">    flush_workqueue(my_wq);</span><br><span class=\"line\">    destroy_workqueue(my_wq);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_module_init);</span><br><span class=\"line\">module_exit(my_module_exit);</span><br><span class=\"line\"></span><br><span class=\"line\">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class=\"line\">MODULE_AUTHOR(&quot;Lion Long&quot;);</span><br><span class=\"line\">MODULE_DESCRIPTION(&quot;A simple example Linux module.&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>例子展示了如何创建一个名为“my_queue”的工作者队列，然后创建一个工作者线程来处理一个名为“my_work”的工作对象。“my_work_handler”函数将打印出传递给工作对象的参数“x”，并释放工作对象的内存。在模块初始化期间，创建工作者队列和工作对象，并提交工作对象到队列中。在模块退出期间，销毁工作者队列。</p>\n<p>Linux 内核中的工作者线程是一种非常重要的机制，能够显著提高系统的性能和响应速度。虽然用户无法直接控制工作者线程的创建和销毁，但可以通过一些系统调优技巧来优化工作者线程的使用效果。<br>2.4、扩展知识：用户态线程的创建<br>线程创建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;pthread.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span><br><span class=\"line\">                   void *(*start_routine)(void*), void *arg);</span><br></pre></td></tr></table></figure>\n\n<p>该函数用于创建一个新的线程，并将其添加到调用进程中。参数 thread 是指向新线程标识符的指针，参数 attr 是指向线程属性的指针（通常为 NULL），参数 start_routine 是指向线程执行函数的指针，参数 arg 是传递给线程执行函数的参数。</p>\n<p>线程销毁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void pthread_exit(void *value_ptr);</span><br></pre></td></tr></table></figure>\n\n<p>该函数用于终止当前线程，并返回一个指针值。这个值可以由其他线程通过 pthread_join 函数获取，也可以被忽略。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int pthread_join(pthread_t thread, void **value_ptr);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>该函数用于阻塞当前线程，直到指定的线程 thread 终止。如果指针 value_ptr 不为 NULL，则会将线程的返回值存储在 value_ptr 指向的位置中。</p>\n<p>注意：如果线程没有被显式地分离，则它将一直存在于内存中，直到进程结束。因此，在创建线程时，应该考虑是否需要将它们分离或者等待它们的结束。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Long_xu/article/details/1314057422.2\">https://blog.csdn.net/Long_xu/article/details/1314057422.2</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、workqueue的作用及在Linux中断处理中的应用<br>1.1、workqueue的概述<br>Linux工作队列（Workqueue）是一个内核中的机制，它可以异步执行一些任务。在Linux内核中，当需要处理一些不是紧急的、需要后台执行的任务时，就会将这些任务加入到工作队列中，然后由内核计划适当的时间来执行这些任务。</p>\n<p>工作队列的特点是异步执行，即任务的执行不会阻塞当前进程，而是交给后台线程进行处理。这种方式可以避免阻塞主线程，提高系统的响应速度和并发能力。</p>\n<p>工作队列具有多种使用场景，比如定时器事件、网络I&#x2F;O事件、驱动程序事件等，都可以通过工作队列来异步处理。</p>\n<p>1.2、workqueue在Linux中断处理中的作用<br>workqueue是一种异步执行工作的机制，它可以在Linux中断处理中使用。当内核需要异步执行某些任务时，可以使用workqueue机制。</p>\n<p>在Linux中断处理中，有些操作不能直接执行，因为它们可能会阻塞中断处理程序。例如，如果一个中断处理程序需要访问磁盘，那么它可能需要等待磁盘访问完成才能继续执行，这将导致中断处理程序的延迟和性能下降。为了避免这种情况，可以使用workqueue机制。</p>\n<p>workqueue机制允许中断处理程序将任务提交给工作队列，在稍后的时间异步执行。这样，中断处理程序可以立即返回，并且不会阻塞其他中断处理程序的执行。工作队列是一组线程，它们可以同时执行多个任务。当工作队列中有任务时，内核会自动调度线程来执行任务。</p>\n<p>workqueue机制是一种非常有效的机制，可以帮助内核异步执行任务，提高系统的性能和可靠性。<br><img src=\"/../imgs/d32faea7d5004b979cc98527aa0973e8.png\" alt=\"在这里插入图片描述\"></p>\n<p>二、workqueue的实现原理<br>workqueue通过使用worker线程池来执行延迟性任务，能够提高系统的吞吐量和响应速度，适用于需要进行异步任务调度的场景。</p>\n<p>workqueue是Linux系统中用于实现异步任务调度的机制，它允许驱动程序和内核线程安排延迟执行的工作。</p>\n<p>workqueue由一个或多个worker线程池组成，每个worker线程都会不断地从workqueue中获取需要执行的工作项。<br>当驱动程序或内核模块需要执行一些延迟性的任务时，可以将这些任务封装成工作项（work）并添加到workqueue队列中。<br>worker线程在空闲时，从workqueue队列中取出一个工作项，并将其放入自己的私有队列中，等待执行。<br>一旦worker线程完成当前正在执行的工作项，就会从自己的私有队列中取出下一个工作项进行处理。<br>若workqueue队列中没有可用的工作项，则worker线程会等待直到有新的工作项被添加到队列中。<br>在workqueue中，还提供了几种不同的队列类型，如普通队列、高优先级队列和延迟队列等，以满足不同场景下的需求。<br>2.1、工作队列和工作者线程的关系<br>工作队列和工作者线程是相互依存的关系，它们通过协同工作来处理系统中的任务。</p>\n<p>工作队列是一个先进先出的任务列表，其中包含需要被执行的任务。工作者线程则是实际执行这些任务的线程。当有新的任务添加到工作队列中时，工作者线程会自动从队列中取出任务并执行。</p>\n<p>工作者线程通常是由内核创建的，其数量可以根据系统负载情况进行调整。当任务数量增加时，可以增加工作者线程的数量以加快任务处理速度。而当任务数量减少时，可以减少工作者线程的数量以节省系统资源。<br><img src=\"/../imgs/2b8686c61a24478a8112e4b83228f177.png\" alt=\"在这里插入图片描述\"></p>\n<p>2.2、工作队列的创建和销毁<br>在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：</p>\n<p>创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。<br>销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。<br>例如，创建和销毁一个名为“my_work”的工作队列：</p>\n<p>工作队列的创建和销毁<br>在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：</p>\n<p>创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。<br>销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。<br>2.3、工作者线程的创建和销毁<br>Linux 内核中的工作者线程是一种特殊的内核线程，用于执行一些异步的、需要花费较长时间或者需要消耗大量 CPU 资源的任务。它们主要用于处理 I&#x2F;O 操作、网络操作、文件系统缓存等等。</p>\n<p>在 Linux 内核中，工作者线程的创建和销毁是由系统自动管理的。当进程请求创建一个工作者线程时，内核会检查当前是否有可用的空闲线程。如果没有，则会创建一个新的线程。当任务完成后，工作者线程会被回收并返回到线程池中，以备下次使用。</p>\n<p>为了提高效率，Linux 内核还可以在运行时动态地调整线程池中工作者线程的数量。当系统负载较高时，内核会增加线程池中的线程数量，以处理更多的任务。当负载降低时，内核会减少线程池中的线程数量，以节省资源。</p>\n<p>例如，展示如何在 Linux 内核中创建和销毁工作者线程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;linux/module.h&gt;</span><br><span class=\"line\">#include &lt;linux/kernel.h&gt;</span><br><span class=\"line\">#include &lt;linux/workqueue.h&gt;</span><br><span class=\"line\">#if 1</span><br><span class=\"line\">#define YYHDEBUG(fmt, ...) \\</span><br><span class=\"line\">    printk(KERN_ERR &quot;yyh debug [%s][%d] &quot; fmt, __func__, __LINE__, ##__VA_ARGS__)</span><br><span class=\"line\">#else </span><br><span class=\"line\">#define YYHDEBUG(debug)</span><br><span class=\"line\">#endif</span><br><span class=\"line\">static struct workqueue_struct *my_wq;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    struct work_struct my_work;</span><br><span class=\"line\">    int x;</span><br><span class=\"line\">&#125; my_work_t;</span><br><span class=\"line\"></span><br><span class=\"line\">static void my_work_handler(struct work_struct *work)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    my_work_t *my_work = (my_work_t *)work;</span><br><span class=\"line\">    YYHDEBUG(&quot;my_work_handler: x=%d\\n&quot;, my_work-&gt;x);</span><br><span class=\"line\">    kfree(my_work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static int __init my_module_init(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    my_work_t *my_work;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 创建工作者队列 */</span><br><span class=\"line\">    my_wq = create_workqueue(&quot;my_queue&quot;);</span><br><span class=\"line\">    if (!my_wq) &#123;</span><br><span class=\"line\">        YYHDEBUG(&quot;create_workqueue failed!\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 创建并提交工作者线程 */</span><br><span class=\"line\">    my_work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);</span><br><span class=\"line\">    if (!my_work) &#123;</span><br><span class=\"line\">        YYHDEBUG(&quot;kmalloc failed!\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    INIT_WORK((struct work_struct *)my_work, my_work_handler);</span><br><span class=\"line\">    my_work-&gt;x = 1;</span><br><span class=\"line\">    queue_work(my_wq, (struct work_struct *)my_work);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __exit my_module_exit(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /* 销毁工作者队列 */</span><br><span class=\"line\">    flush_workqueue(my_wq);</span><br><span class=\"line\">    destroy_workqueue(my_wq);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_module_init);</span><br><span class=\"line\">module_exit(my_module_exit);</span><br><span class=\"line\"></span><br><span class=\"line\">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class=\"line\">MODULE_AUTHOR(&quot;Lion Long&quot;);</span><br><span class=\"line\">MODULE_DESCRIPTION(&quot;A simple example Linux module.&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>例子展示了如何创建一个名为“my_queue”的工作者队列，然后创建一个工作者线程来处理一个名为“my_work”的工作对象。“my_work_handler”函数将打印出传递给工作对象的参数“x”，并释放工作对象的内存。在模块初始化期间，创建工作者队列和工作对象，并提交工作对象到队列中。在模块退出期间，销毁工作者队列。</p>\n<p>Linux 内核中的工作者线程是一种非常重要的机制，能够显著提高系统的性能和响应速度。虽然用户无法直接控制工作者线程的创建和销毁，但可以通过一些系统调优技巧来优化工作者线程的使用效果。<br>2.4、扩展知识：用户态线程的创建<br>线程创建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;pthread.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span><br><span class=\"line\">                   void *(*start_routine)(void*), void *arg);</span><br></pre></td></tr></table></figure>\n\n<p>该函数用于创建一个新的线程，并将其添加到调用进程中。参数 thread 是指向新线程标识符的指针，参数 attr 是指向线程属性的指针（通常为 NULL），参数 start_routine 是指向线程执行函数的指针，参数 arg 是传递给线程执行函数的参数。</p>\n<p>线程销毁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void pthread_exit(void *value_ptr);</span><br></pre></td></tr></table></figure>\n\n<p>该函数用于终止当前线程，并返回一个指针值。这个值可以由其他线程通过 pthread_join 函数获取，也可以被忽略。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int pthread_join(pthread_t thread, void **value_ptr);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>该函数用于阻塞当前线程，直到指定的线程 thread 终止。如果指针 value_ptr 不为 NULL，则会将线程的返回值存储在 value_ptr 指向的位置中。</p>\n<p>注意：如果线程没有被显式地分离，则它将一直存在于内存中，直到进程结束。因此，在创建线程时，应该考虑是否需要将它们分离或者等待它们的结束。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Long_xu/article/details/1314057422.2\">https://blog.csdn.net/Long_xu/article/details/1314057422.2</a></p>\n"},{"title":"小爱同学控制电脑开关","categories":["test"],"tags":["test","wol"],"date":"2024-07-02T12:50:22.000Z","_content":"\n\n\n# 一、环境准备\n\nwin11、小爱音箱、esp32(通过wol唤醒电脑)、巴法云平台注册\n\n这里使用的是esp32-cam\n\n![image-20240702211605888](../imgs/image-20240702211605888.png)\n\n# 二、开关机原理\n\n开机利用WOL技术，Wake-On-LAN简称WOL，是一种电源管理功能；如果存在网络活动，则允许设备将操作系统从待机或休眠模式中唤醒。许多主板厂商支持IBM提出的网络唤醒标准。该标准允许网络管理员远程打开PC机电源,以便进行文件升级、资源跟踪和设备清点等工作。WOL在还未广泛的采用,但在网络时代却具有广阔的发展前景。Wake-On-LAN的实现，主要是向目标主机发送特殊格式的数据包，是AMD公司制作的MagicPacket这套软件以生成网络唤醒所需要的特殊数据包，俗称魔术包（Magic Packet）。MagicPacket格式虽然只是AMD公司开发推广的技术，并非世界公认的标准，但是仍然受到很多网卡制造商的支持，因此许多具有网络唤醒功能的网卡都能与之兼容。wol基本实现原理实现是向需要被唤醒的终端网卡发送`FFFFFFFFFFFFFF+目标主机MAC地址(重复16次)`所组成的一个数据包，网卡收到数据后终端。（需要主板支持WOL，在BIOS中设置打开）\n\nwol参考：https://blog.csdn.net/a18359388932/article/details/126949062\n\n关机则通过获取巴法云获取关机指令，再通过python执行关机命令实现。\n\n## 数据传输框架\n\n小爱其实是不直接操作内网被控的电脑，而是通过小爱给一个第三方物联网平台巴法云发送一个消息，而你内网要部署一个用来接收巴法云下发的消息的程序，一旦接收到状态有发生变化，就执行一些执行，比如发送魔术包开机，再比如通过脚本ssh登录你的主机Windows主机执行关机命令.\n\n![xiaoaiui.png](../imgs/xiaoaiui.png)\n\n# 三、环境搭建\n\n## 1.巴法云平台设置\n\n打开巴法科技&巴法云-巴法设备云-巴法物联网云平台 (bemfa.com)，点击注册\n\nTCP创客云-》新建主题 pc006 -》设置昵称为电脑\n\n注意：\n\n新建主题的名称`pc`可以任意修改，但末尾必须是006，表示开关设备\n\n修改设备昵称，这个昵称`电脑`就是后面在米家中控制的名称\n\n记住私钥、主题（`pc006`）后续会用到\n\n![image-20240702214224123](../imgs/image-20240702214224123.png)\n\n## 2.米家设置\n\n打开手机app`米家`-我的-添加其他平台-添加-选择巴法-登录巴法账号-同步设备；\n\n同步成功后会显示出电脑图标，后面就可以通过小爱同学语音控制\"打开电脑\"\n\n## 3.windows网络唤醒设置\n\n进入BIOS设置wol（自行百度设置）\n\n1.打开设备管理器，点击网络适配器，右键属性，将电源管理的两个勾勾打上；\n\n![电源管理](../imgs/cce3ff865e6348cb9da8625fe5b92fe0.png)\n\n在高级设置里面将关机网络唤醒和魔术封包唤醒开启\n\n![网络唤醒](../imgs/82c684268ac443d191e73eb73b60aec4.png)\n\n## 4.搭建esp32开发环境并部署\n\n参考：\n\nhttps://blog.csdn.net/weixin_43935402/article/details/125590294\n\n环境搭建完毕后：\n\n本项目使用 Arduino 框架。\n\n- WakeOnLan : https://github.com/a7md0/WakeOnLan\n- AsyncTCP : https://github.com/me-no-dev/AsyncTCP\n\n参考：\n\nhttps://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main\n\n## （1）新建项目\n\n![image-20240702220340059](../imgs/image-20240702220340059.png)\n\n## （2）导入esp32库\n\n![image-20240702220502413](../imgs/image-20240702220502413.png)\n\n## （3） 添加库\n\n![image-20240702220705763](../imgs/image-20240702220705763.png)\n\n添加库WakeOnLan \n\n![image-20240702220828261](../imgs/image-20240702220828261.png)\n\n添加库AsyncTCP \n\n![image-20240702220932130](../imgs/image-20240702220932130.png)\n\n## （4）导入库\n\n![image-20240702221037900](../imgs/image-20240702221037900.png)\n\n添加文件bemfa_client.hpp、wifi_helper.hpp：\n\n![image-20240702221620487](../imgs/image-20240702221620487.png)\n\n将main.cpp拷贝到.ino文件中\n\n![image-20240702222853017](../imgs/image-20240702222853017.png)\n\n\n\n```\n#include \"bemfa_client.hpp\"\n#include \"WakeOnLan.h\"\n#include \"wifi_helper.hpp\"\n\nBemfaClient* bemfaClient;\nWifiHelper* wifiHelper;\n\nWiFiUDP UDP;\nWakeOnLan WOL(UDP);\n\nconst int LED_Pin = 2;\n\nconst char *SSID = \"xxx\";  // wifi名称\nconst char *PSW = \"xxx\";  // wifi密码\n\nconst char *UID = \"xxx\";  // 巴法云的UID\nconst char *TOPIC = \"pc006\";  // 巴法云中创建的TOPIC(不是昵称)\n\nconst char *TARGET_MAC_ADDR = \"xxx\";  // 要启动的电脑的MAC地址\n\nvoid blinkTwice() {\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n    delay(200);\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"Beginning...\");\n    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);\n    bemfaClient = new BemfaClient(UID, TOPIC);\n    bemfaClient->addCommand(\"on\", []{\n        Serial.println(\"Send magic packet\");\n        WOL.setRepeat(3, 100);\n        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());\n        WOL.sendMagicPacket(TARGET_MAC_ADDR);\n        blinkTwice();\n    });\n}\n\nvoid loop() {\n    wifiHelper->tick();\n    bemfaClient->tick();\n}\n```\n\n编译烧录即可，然后通过小爱同学“打开电脑”即可控制电脑开机\n\n## 5.关机python脚本配置\n\n安装python\n\n参考：https://docs.python.org/zh-cn/3/using/index.html\n\n```\n#安装相关依赖\npip install requests\npip install schedule\npip install pyinstaller\n```\n\npython打包\nhttps://www.cnblogs.com/weilaiqinkong/p/17240065.html\n\n如：pyinstaller -F -w main.py\n\n巴法云平台tcp连接参考：https://bbs.bemfa.com/81\n\n### main.py\n\n```\n\n# -*- coding: utf-8\nimport socket\nimport threading\nimport time\nimport os\nimport shutil\nimport sys\nimport getpass\n\ndef connTCP():\n    global tcp_client_socket\n    # 创建socket\n    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # IP 和端口\n    server_ip = 'bemfa.com'\n    server_port = 8344\n    try:\n        # 连接服务器\n        tcp_client_socket.connect((server_ip, server_port))\n        #发送订阅指令\n        substr = 'cmd=1&uid=巴法云私钥&topic=pc006\\r\\n'\n        tcp_client_socket.send(substr.encode(\"utf-8\"))\n    except:\n        time.sleep(2)\n        connTCP()\n\n#心跳\ndef Ping():\n    # 发送心跳\n    try:\n        keeplive = 'ping\\r\\n'\n        tcp_client_socket.send(keeplive.encode(\"utf-8\"))\n    except:\n        time.sleep(2)\n        connTCP()\n    #开启定时，30秒发送一次心跳\n    t = threading.Timer(30,Ping)\n    t.start()\n\n\nconnTCP()\nPing()\n\nwhile True:\n    # 接收服务器发送过来的数据\n    recvData = tcp_client_socket.recv(1024)\n    if len(recvData) != 0:\n        data = recvData.decode('utf-8')\n        print('recv:', data)\n        if \"on\" in data:\n            print(\"do nothing!\")\n        elif \"off\" in data:\n            print(\"starting poweroff after 3s ...\")\n            # 3s后 系统自动关机\n            print(os.system('shutdown -s -t 3'))\n    else:\n        print(\"conn err\")\n        connTCP()\n\n```\n\n设置main.exe开机启动\n\nhttps://www.cnblogs.com/muxiaomu/p/16649990.html","source":"back_posts/小爱同学控制电脑开关.md","raw":"---\ntitle: 小爱同学控制电脑开关\ncategories:\n  - test\ntags:\n  - test\n  - wol \ndate: 2024-07-02 20:50:22\n---\n\n\n\n# 一、环境准备\n\nwin11、小爱音箱、esp32(通过wol唤醒电脑)、巴法云平台注册\n\n这里使用的是esp32-cam\n\n![image-20240702211605888](../imgs/image-20240702211605888.png)\n\n# 二、开关机原理\n\n开机利用WOL技术，Wake-On-LAN简称WOL，是一种电源管理功能；如果存在网络活动，则允许设备将操作系统从待机或休眠模式中唤醒。许多主板厂商支持IBM提出的网络唤醒标准。该标准允许网络管理员远程打开PC机电源,以便进行文件升级、资源跟踪和设备清点等工作。WOL在还未广泛的采用,但在网络时代却具有广阔的发展前景。Wake-On-LAN的实现，主要是向目标主机发送特殊格式的数据包，是AMD公司制作的MagicPacket这套软件以生成网络唤醒所需要的特殊数据包，俗称魔术包（Magic Packet）。MagicPacket格式虽然只是AMD公司开发推广的技术，并非世界公认的标准，但是仍然受到很多网卡制造商的支持，因此许多具有网络唤醒功能的网卡都能与之兼容。wol基本实现原理实现是向需要被唤醒的终端网卡发送`FFFFFFFFFFFFFF+目标主机MAC地址(重复16次)`所组成的一个数据包，网卡收到数据后终端。（需要主板支持WOL，在BIOS中设置打开）\n\nwol参考：https://blog.csdn.net/a18359388932/article/details/126949062\n\n关机则通过获取巴法云获取关机指令，再通过python执行关机命令实现。\n\n## 数据传输框架\n\n小爱其实是不直接操作内网被控的电脑，而是通过小爱给一个第三方物联网平台巴法云发送一个消息，而你内网要部署一个用来接收巴法云下发的消息的程序，一旦接收到状态有发生变化，就执行一些执行，比如发送魔术包开机，再比如通过脚本ssh登录你的主机Windows主机执行关机命令.\n\n![xiaoaiui.png](../imgs/xiaoaiui.png)\n\n# 三、环境搭建\n\n## 1.巴法云平台设置\n\n打开巴法科技&巴法云-巴法设备云-巴法物联网云平台 (bemfa.com)，点击注册\n\nTCP创客云-》新建主题 pc006 -》设置昵称为电脑\n\n注意：\n\n新建主题的名称`pc`可以任意修改，但末尾必须是006，表示开关设备\n\n修改设备昵称，这个昵称`电脑`就是后面在米家中控制的名称\n\n记住私钥、主题（`pc006`）后续会用到\n\n![image-20240702214224123](../imgs/image-20240702214224123.png)\n\n## 2.米家设置\n\n打开手机app`米家`-我的-添加其他平台-添加-选择巴法-登录巴法账号-同步设备；\n\n同步成功后会显示出电脑图标，后面就可以通过小爱同学语音控制\"打开电脑\"\n\n## 3.windows网络唤醒设置\n\n进入BIOS设置wol（自行百度设置）\n\n1.打开设备管理器，点击网络适配器，右键属性，将电源管理的两个勾勾打上；\n\n![电源管理](../imgs/cce3ff865e6348cb9da8625fe5b92fe0.png)\n\n在高级设置里面将关机网络唤醒和魔术封包唤醒开启\n\n![网络唤醒](../imgs/82c684268ac443d191e73eb73b60aec4.png)\n\n## 4.搭建esp32开发环境并部署\n\n参考：\n\nhttps://blog.csdn.net/weixin_43935402/article/details/125590294\n\n环境搭建完毕后：\n\n本项目使用 Arduino 框架。\n\n- WakeOnLan : https://github.com/a7md0/WakeOnLan\n- AsyncTCP : https://github.com/me-no-dev/AsyncTCP\n\n参考：\n\nhttps://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main\n\n## （1）新建项目\n\n![image-20240702220340059](../imgs/image-20240702220340059.png)\n\n## （2）导入esp32库\n\n![image-20240702220502413](../imgs/image-20240702220502413.png)\n\n## （3） 添加库\n\n![image-20240702220705763](../imgs/image-20240702220705763.png)\n\n添加库WakeOnLan \n\n![image-20240702220828261](../imgs/image-20240702220828261.png)\n\n添加库AsyncTCP \n\n![image-20240702220932130](../imgs/image-20240702220932130.png)\n\n## （4）导入库\n\n![image-20240702221037900](../imgs/image-20240702221037900.png)\n\n添加文件bemfa_client.hpp、wifi_helper.hpp：\n\n![image-20240702221620487](../imgs/image-20240702221620487.png)\n\n将main.cpp拷贝到.ino文件中\n\n![image-20240702222853017](../imgs/image-20240702222853017.png)\n\n\n\n```\n#include \"bemfa_client.hpp\"\n#include \"WakeOnLan.h\"\n#include \"wifi_helper.hpp\"\n\nBemfaClient* bemfaClient;\nWifiHelper* wifiHelper;\n\nWiFiUDP UDP;\nWakeOnLan WOL(UDP);\n\nconst int LED_Pin = 2;\n\nconst char *SSID = \"xxx\";  // wifi名称\nconst char *PSW = \"xxx\";  // wifi密码\n\nconst char *UID = \"xxx\";  // 巴法云的UID\nconst char *TOPIC = \"pc006\";  // 巴法云中创建的TOPIC(不是昵称)\n\nconst char *TARGET_MAC_ADDR = \"xxx\";  // 要启动的电脑的MAC地址\n\nvoid blinkTwice() {\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n    delay(200);\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"Beginning...\");\n    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);\n    bemfaClient = new BemfaClient(UID, TOPIC);\n    bemfaClient->addCommand(\"on\", []{\n        Serial.println(\"Send magic packet\");\n        WOL.setRepeat(3, 100);\n        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());\n        WOL.sendMagicPacket(TARGET_MAC_ADDR);\n        blinkTwice();\n    });\n}\n\nvoid loop() {\n    wifiHelper->tick();\n    bemfaClient->tick();\n}\n```\n\n编译烧录即可，然后通过小爱同学“打开电脑”即可控制电脑开机\n\n## 5.关机python脚本配置\n\n安装python\n\n参考：https://docs.python.org/zh-cn/3/using/index.html\n\n```\n#安装相关依赖\npip install requests\npip install schedule\npip install pyinstaller\n```\n\npython打包\nhttps://www.cnblogs.com/weilaiqinkong/p/17240065.html\n\n如：pyinstaller -F -w main.py\n\n巴法云平台tcp连接参考：https://bbs.bemfa.com/81\n\n### main.py\n\n```\n\n# -*- coding: utf-8\nimport socket\nimport threading\nimport time\nimport os\nimport shutil\nimport sys\nimport getpass\n\ndef connTCP():\n    global tcp_client_socket\n    # 创建socket\n    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # IP 和端口\n    server_ip = 'bemfa.com'\n    server_port = 8344\n    try:\n        # 连接服务器\n        tcp_client_socket.connect((server_ip, server_port))\n        #发送订阅指令\n        substr = 'cmd=1&uid=巴法云私钥&topic=pc006\\r\\n'\n        tcp_client_socket.send(substr.encode(\"utf-8\"))\n    except:\n        time.sleep(2)\n        connTCP()\n\n#心跳\ndef Ping():\n    # 发送心跳\n    try:\n        keeplive = 'ping\\r\\n'\n        tcp_client_socket.send(keeplive.encode(\"utf-8\"))\n    except:\n        time.sleep(2)\n        connTCP()\n    #开启定时，30秒发送一次心跳\n    t = threading.Timer(30,Ping)\n    t.start()\n\n\nconnTCP()\nPing()\n\nwhile True:\n    # 接收服务器发送过来的数据\n    recvData = tcp_client_socket.recv(1024)\n    if len(recvData) != 0:\n        data = recvData.decode('utf-8')\n        print('recv:', data)\n        if \"on\" in data:\n            print(\"do nothing!\")\n        elif \"off\" in data:\n            print(\"starting poweroff after 3s ...\")\n            # 3s后 系统自动关机\n            print(os.system('shutdown -s -t 3'))\n    else:\n        print(\"conn err\")\n        connTCP()\n\n```\n\n设置main.exe开机启动\n\nhttps://www.cnblogs.com/muxiaomu/p/16649990.html","updated":"2024-07-02T14:41:27.852Z","path":"back_posts/小爱同学控制电脑开关.html","comments":1,"layout":"page","_id":"cly4iru9y0001uhjuawmt8r8r","content":"<h1 id=\"一、环境准备\"><a href=\"#一、环境准备\" class=\"headerlink\" title=\"一、环境准备\"></a>一、环境准备</h1><p>win11、小爱音箱、esp32(通过wol唤醒电脑)、巴法云平台注册</p>\n<p>这里使用的是esp32-cam</p>\n<p><img src=\"/../imgs/image-20240702211605888.png\" alt=\"image-20240702211605888\"></p>\n<h1 id=\"二、开关机原理\"><a href=\"#二、开关机原理\" class=\"headerlink\" title=\"二、开关机原理\"></a>二、开关机原理</h1><p>开机利用WOL技术，Wake-On-LAN简称WOL，是一种电源管理功能；如果存在网络活动，则允许设备将操作系统从待机或休眠模式中唤醒。许多主板厂商支持IBM提出的网络唤醒标准。该标准允许网络管理员远程打开PC机电源,以便进行文件升级、资源跟踪和设备清点等工作。WOL在还未广泛的采用,但在网络时代却具有广阔的发展前景。Wake-On-LAN的实现，主要是向目标主机发送特殊格式的数据包，是AMD公司制作的MagicPacket这套软件以生成网络唤醒所需要的特殊数据包，俗称魔术包（Magic Packet）。MagicPacket格式虽然只是AMD公司开发推广的技术，并非世界公认的标准，但是仍然受到很多网卡制造商的支持，因此许多具有网络唤醒功能的网卡都能与之兼容。wol基本实现原理实现是向需要被唤醒的终端网卡发送<code>FFFFFFFFFFFFFF+目标主机MAC地址(重复16次)</code>所组成的一个数据包，网卡收到数据后终端。（需要主板支持WOL，在BIOS中设置打开）</p>\n<p>wol参考：<a href=\"https://blog.csdn.net/a18359388932/article/details/126949062\">https://blog.csdn.net/a18359388932/article/details/126949062</a></p>\n<p>关机则通过获取巴法云获取关机指令，再通过python执行关机命令实现。</p>\n<h2 id=\"数据传输框架\"><a href=\"#数据传输框架\" class=\"headerlink\" title=\"数据传输框架\"></a>数据传输框架</h2><p>小爱其实是不直接操作内网被控的电脑，而是通过小爱给一个第三方物联网平台巴法云发送一个消息，而你内网要部署一个用来接收巴法云下发的消息的程序，一旦接收到状态有发生变化，就执行一些执行，比如发送魔术包开机，再比如通过脚本ssh登录你的主机Windows主机执行关机命令.</p>\n<p><img src=\"/../imgs/xiaoaiui.png\" alt=\"xiaoaiui.png\"></p>\n<h1 id=\"三、环境搭建\"><a href=\"#三、环境搭建\" class=\"headerlink\" title=\"三、环境搭建\"></a>三、环境搭建</h1><h2 id=\"1-巴法云平台设置\"><a href=\"#1-巴法云平台设置\" class=\"headerlink\" title=\"1.巴法云平台设置\"></a>1.巴法云平台设置</h2><p>打开巴法科技&amp;巴法云-巴法设备云-巴法物联网云平台 (bemfa.com)，点击注册</p>\n<p>TCP创客云-》新建主题 pc006 -》设置昵称为电脑</p>\n<p>注意：</p>\n<p>新建主题的名称<code>pc</code>可以任意修改，但末尾必须是006，表示开关设备</p>\n<p>修改设备昵称，这个昵称<code>电脑</code>就是后面在米家中控制的名称</p>\n<p>记住私钥、主题（<code>pc006</code>）后续会用到</p>\n<p><img src=\"/../imgs/image-20240702214224123.png\" alt=\"image-20240702214224123\"></p>\n<h2 id=\"2-米家设置\"><a href=\"#2-米家设置\" class=\"headerlink\" title=\"2.米家设置\"></a>2.米家设置</h2><p>打开手机app<code>米家</code>-我的-添加其他平台-添加-选择巴法-登录巴法账号-同步设备；</p>\n<p>同步成功后会显示出电脑图标，后面就可以通过小爱同学语音控制”打开电脑”</p>\n<h2 id=\"3-windows网络唤醒设置\"><a href=\"#3-windows网络唤醒设置\" class=\"headerlink\" title=\"3.windows网络唤醒设置\"></a>3.windows网络唤醒设置</h2><p>进入BIOS设置wol（自行百度设置）</p>\n<p>1.打开设备管理器，点击网络适配器，右键属性，将电源管理的两个勾勾打上；</p>\n<p><img src=\"/../imgs/cce3ff865e6348cb9da8625fe5b92fe0.png\" alt=\"电源管理\"></p>\n<p>在高级设置里面将关机网络唤醒和魔术封包唤醒开启</p>\n<p><img src=\"/../imgs/82c684268ac443d191e73eb73b60aec4.png\" alt=\"网络唤醒\"></p>\n<h2 id=\"4-搭建esp32开发环境并部署\"><a href=\"#4-搭建esp32开发环境并部署\" class=\"headerlink\" title=\"4.搭建esp32开发环境并部署\"></a>4.搭建esp32开发环境并部署</h2><p>参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_43935402/article/details/125590294\">https://blog.csdn.net/weixin_43935402/article/details/125590294</a></p>\n<p>环境搭建完毕后：</p>\n<p>本项目使用 Arduino 框架。</p>\n<ul>\n<li>WakeOnLan : <a href=\"https://github.com/a7md0/WakeOnLan\">https://github.com/a7md0/WakeOnLan</a></li>\n<li>AsyncTCP : <a href=\"https://github.com/me-no-dev/AsyncTCP\">https://github.com/me-no-dev/AsyncTCP</a></li>\n</ul>\n<p>参考：</p>\n<p><a href=\"https://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main\">https://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main</a></p>\n<h2 id=\"（1）新建项目\"><a href=\"#（1）新建项目\" class=\"headerlink\" title=\"（1）新建项目\"></a>（1）新建项目</h2><p><img src=\"/../imgs/image-20240702220340059.png\" alt=\"image-20240702220340059\"></p>\n<h2 id=\"（2）导入esp32库\"><a href=\"#（2）导入esp32库\" class=\"headerlink\" title=\"（2）导入esp32库\"></a>（2）导入esp32库</h2><p><img src=\"/../imgs/image-20240702220502413.png\" alt=\"image-20240702220502413\"></p>\n<h2 id=\"（3）-添加库\"><a href=\"#（3）-添加库\" class=\"headerlink\" title=\"（3） 添加库\"></a>（3） 添加库</h2><p><img src=\"/../imgs/image-20240702220705763.png\" alt=\"image-20240702220705763\"></p>\n<p>添加库WakeOnLan </p>\n<p><img src=\"/../imgs/image-20240702220828261.png\" alt=\"image-20240702220828261\"></p>\n<p>添加库AsyncTCP </p>\n<p><img src=\"/../imgs/image-20240702220932130.png\" alt=\"image-20240702220932130\"></p>\n<h2 id=\"（4）导入库\"><a href=\"#（4）导入库\" class=\"headerlink\" title=\"（4）导入库\"></a>（4）导入库</h2><p><img src=\"/../imgs/image-20240702221037900.png\" alt=\"image-20240702221037900\"></p>\n<p>添加文件bemfa_client.hpp、wifi_helper.hpp：</p>\n<p><img src=\"/../imgs/image-20240702221620487.png\" alt=\"image-20240702221620487\"></p>\n<p>将main.cpp拷贝到.ino文件中</p>\n<p><img src=\"/../imgs/image-20240702222853017.png\" alt=\"image-20240702222853017\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;bemfa_client.hpp&quot;</span><br><span class=\"line\">#include &quot;WakeOnLan.h&quot;</span><br><span class=\"line\">#include &quot;wifi_helper.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">BemfaClient* bemfaClient;</span><br><span class=\"line\">WifiHelper* wifiHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">WiFiUDP UDP;</span><br><span class=\"line\">WakeOnLan WOL(UDP);</span><br><span class=\"line\"></span><br><span class=\"line\">const int LED_Pin = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">const char *SSID = &quot;xxx&quot;;  // wifi名称</span><br><span class=\"line\">const char *PSW = &quot;xxx&quot;;  // wifi密码</span><br><span class=\"line\"></span><br><span class=\"line\">const char *UID = &quot;xxx&quot;;  // 巴法云的UID</span><br><span class=\"line\">const char *TOPIC = &quot;pc006&quot;;  // 巴法云中创建的TOPIC(不是昵称)</span><br><span class=\"line\"></span><br><span class=\"line\">const char *TARGET_MAC_ADDR = &quot;xxx&quot;;  // 要启动的电脑的MAC地址</span><br><span class=\"line\"></span><br><span class=\"line\">void blinkTwice() &#123;</span><br><span class=\"line\">    digitalWrite(LED_Pin, HIGH);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, LOW);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, HIGH);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, LOW);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void setup() &#123;</span><br><span class=\"line\">    Serial.begin(115200);</span><br><span class=\"line\">    Serial.println(&quot;Beginning...&quot;);</span><br><span class=\"line\">    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);</span><br><span class=\"line\">    bemfaClient = new BemfaClient(UID, TOPIC);</span><br><span class=\"line\">    bemfaClient-&gt;addCommand(&quot;on&quot;, []&#123;</span><br><span class=\"line\">        Serial.println(&quot;Send magic packet&quot;);</span><br><span class=\"line\">        WOL.setRepeat(3, 100);</span><br><span class=\"line\">        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());</span><br><span class=\"line\">        WOL.sendMagicPacket(TARGET_MAC_ADDR);</span><br><span class=\"line\">        blinkTwice();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void loop() &#123;</span><br><span class=\"line\">    wifiHelper-&gt;tick();</span><br><span class=\"line\">    bemfaClient-&gt;tick();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译烧录即可，然后通过小爱同学“打开电脑”即可控制电脑开机</p>\n<h2 id=\"5-关机python脚本配置\"><a href=\"#5-关机python脚本配置\" class=\"headerlink\" title=\"5.关机python脚本配置\"></a>5.关机python脚本配置</h2><p>安装python</p>\n<p>参考：<a href=\"https://docs.python.org/zh-cn/3/using/index.html\">https://docs.python.org/zh-cn/3/using/index.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#安装相关依赖</span><br><span class=\"line\">pip install requests</span><br><span class=\"line\">pip install schedule</span><br><span class=\"line\">pip install pyinstaller</span><br></pre></td></tr></table></figure>\n\n<p>python打包<br><a href=\"https://www.cnblogs.com/weilaiqinkong/p/17240065.html\">https://www.cnblogs.com/weilaiqinkong/p/17240065.html</a></p>\n<p>如：pyinstaller -F -w main.py</p>\n<p>巴法云平台tcp连接参考：<a href=\"https://bbs.bemfa.com/81\">https://bbs.bemfa.com/81</a></p>\n<h3 id=\"main-py\"><a href=\"#main-py\" class=\"headerlink\" title=\"main.py\"></a>main.py</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># -*- coding: utf-8</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\">import os</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">import sys</span><br><span class=\"line\">import getpass</span><br><span class=\"line\"></span><br><span class=\"line\">def connTCP():</span><br><span class=\"line\">    global tcp_client_socket</span><br><span class=\"line\">    # 创建socket</span><br><span class=\"line\">    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">    # IP 和端口</span><br><span class=\"line\">    server_ip = &#x27;bemfa.com&#x27;</span><br><span class=\"line\">    server_port = 8344</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        # 连接服务器</span><br><span class=\"line\">        tcp_client_socket.connect((server_ip, server_port))</span><br><span class=\"line\">        #发送订阅指令</span><br><span class=\"line\">        substr = &#x27;cmd=1&amp;uid=巴法云私钥&amp;topic=pc006\\r\\n&#x27;</span><br><span class=\"line\">        tcp_client_socket.send(substr.encode(&quot;utf-8&quot;))</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\"></span><br><span class=\"line\">#心跳</span><br><span class=\"line\">def Ping():</span><br><span class=\"line\">    # 发送心跳</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        keeplive = &#x27;ping\\r\\n&#x27;</span><br><span class=\"line\">        tcp_client_socket.send(keeplive.encode(&quot;utf-8&quot;))</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\">    #开启定时，30秒发送一次心跳</span><br><span class=\"line\">    t = threading.Timer(30,Ping)</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">connTCP()</span><br><span class=\"line\">Ping()</span><br><span class=\"line\"></span><br><span class=\"line\">while True:</span><br><span class=\"line\">    # 接收服务器发送过来的数据</span><br><span class=\"line\">    recvData = tcp_client_socket.recv(1024)</span><br><span class=\"line\">    if len(recvData) != 0:</span><br><span class=\"line\">        data = recvData.decode(&#x27;utf-8&#x27;)</span><br><span class=\"line\">        print(&#x27;recv:&#x27;, data)</span><br><span class=\"line\">        if &quot;on&quot; in data:</span><br><span class=\"line\">            print(&quot;do nothing!&quot;)</span><br><span class=\"line\">        elif &quot;off&quot; in data:</span><br><span class=\"line\">            print(&quot;starting poweroff after 3s ...&quot;)</span><br><span class=\"line\">            # 3s后 系统自动关机</span><br><span class=\"line\">            print(os.system(&#x27;shutdown -s -t 3&#x27;))</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;conn err&quot;)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>设置main.exe开机启动</p>\n<p><a href=\"https://www.cnblogs.com/muxiaomu/p/16649990.html\">https://www.cnblogs.com/muxiaomu/p/16649990.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、环境准备\"><a href=\"#一、环境准备\" class=\"headerlink\" title=\"一、环境准备\"></a>一、环境准备</h1><p>win11、小爱音箱、esp32(通过wol唤醒电脑)、巴法云平台注册</p>\n<p>这里使用的是esp32-cam</p>\n<p><img src=\"/../imgs/image-20240702211605888.png\" alt=\"image-20240702211605888\"></p>\n<h1 id=\"二、开关机原理\"><a href=\"#二、开关机原理\" class=\"headerlink\" title=\"二、开关机原理\"></a>二、开关机原理</h1><p>开机利用WOL技术，Wake-On-LAN简称WOL，是一种电源管理功能；如果存在网络活动，则允许设备将操作系统从待机或休眠模式中唤醒。许多主板厂商支持IBM提出的网络唤醒标准。该标准允许网络管理员远程打开PC机电源,以便进行文件升级、资源跟踪和设备清点等工作。WOL在还未广泛的采用,但在网络时代却具有广阔的发展前景。Wake-On-LAN的实现，主要是向目标主机发送特殊格式的数据包，是AMD公司制作的MagicPacket这套软件以生成网络唤醒所需要的特殊数据包，俗称魔术包（Magic Packet）。MagicPacket格式虽然只是AMD公司开发推广的技术，并非世界公认的标准，但是仍然受到很多网卡制造商的支持，因此许多具有网络唤醒功能的网卡都能与之兼容。wol基本实现原理实现是向需要被唤醒的终端网卡发送<code>FFFFFFFFFFFFFF+目标主机MAC地址(重复16次)</code>所组成的一个数据包，网卡收到数据后终端。（需要主板支持WOL，在BIOS中设置打开）</p>\n<p>wol参考：<a href=\"https://blog.csdn.net/a18359388932/article/details/126949062\">https://blog.csdn.net/a18359388932/article/details/126949062</a></p>\n<p>关机则通过获取巴法云获取关机指令，再通过python执行关机命令实现。</p>\n<h2 id=\"数据传输框架\"><a href=\"#数据传输框架\" class=\"headerlink\" title=\"数据传输框架\"></a>数据传输框架</h2><p>小爱其实是不直接操作内网被控的电脑，而是通过小爱给一个第三方物联网平台巴法云发送一个消息，而你内网要部署一个用来接收巴法云下发的消息的程序，一旦接收到状态有发生变化，就执行一些执行，比如发送魔术包开机，再比如通过脚本ssh登录你的主机Windows主机执行关机命令.</p>\n<p><img src=\"/../imgs/xiaoaiui.png\" alt=\"xiaoaiui.png\"></p>\n<h1 id=\"三、环境搭建\"><a href=\"#三、环境搭建\" class=\"headerlink\" title=\"三、环境搭建\"></a>三、环境搭建</h1><h2 id=\"1-巴法云平台设置\"><a href=\"#1-巴法云平台设置\" class=\"headerlink\" title=\"1.巴法云平台设置\"></a>1.巴法云平台设置</h2><p>打开巴法科技&amp;巴法云-巴法设备云-巴法物联网云平台 (bemfa.com)，点击注册</p>\n<p>TCP创客云-》新建主题 pc006 -》设置昵称为电脑</p>\n<p>注意：</p>\n<p>新建主题的名称<code>pc</code>可以任意修改，但末尾必须是006，表示开关设备</p>\n<p>修改设备昵称，这个昵称<code>电脑</code>就是后面在米家中控制的名称</p>\n<p>记住私钥、主题（<code>pc006</code>）后续会用到</p>\n<p><img src=\"/../imgs/image-20240702214224123.png\" alt=\"image-20240702214224123\"></p>\n<h2 id=\"2-米家设置\"><a href=\"#2-米家设置\" class=\"headerlink\" title=\"2.米家设置\"></a>2.米家设置</h2><p>打开手机app<code>米家</code>-我的-添加其他平台-添加-选择巴法-登录巴法账号-同步设备；</p>\n<p>同步成功后会显示出电脑图标，后面就可以通过小爱同学语音控制”打开电脑”</p>\n<h2 id=\"3-windows网络唤醒设置\"><a href=\"#3-windows网络唤醒设置\" class=\"headerlink\" title=\"3.windows网络唤醒设置\"></a>3.windows网络唤醒设置</h2><p>进入BIOS设置wol（自行百度设置）</p>\n<p>1.打开设备管理器，点击网络适配器，右键属性，将电源管理的两个勾勾打上；</p>\n<p><img src=\"/../imgs/cce3ff865e6348cb9da8625fe5b92fe0.png\" alt=\"电源管理\"></p>\n<p>在高级设置里面将关机网络唤醒和魔术封包唤醒开启</p>\n<p><img src=\"/../imgs/82c684268ac443d191e73eb73b60aec4.png\" alt=\"网络唤醒\"></p>\n<h2 id=\"4-搭建esp32开发环境并部署\"><a href=\"#4-搭建esp32开发环境并部署\" class=\"headerlink\" title=\"4.搭建esp32开发环境并部署\"></a>4.搭建esp32开发环境并部署</h2><p>参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_43935402/article/details/125590294\">https://blog.csdn.net/weixin_43935402/article/details/125590294</a></p>\n<p>环境搭建完毕后：</p>\n<p>本项目使用 Arduino 框架。</p>\n<ul>\n<li>WakeOnLan : <a href=\"https://github.com/a7md0/WakeOnLan\">https://github.com/a7md0/WakeOnLan</a></li>\n<li>AsyncTCP : <a href=\"https://github.com/me-no-dev/AsyncTCP\">https://github.com/me-no-dev/AsyncTCP</a></li>\n</ul>\n<p>参考：</p>\n<p><a href=\"https://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main\">https://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main</a></p>\n<h2 id=\"（1）新建项目\"><a href=\"#（1）新建项目\" class=\"headerlink\" title=\"（1）新建项目\"></a>（1）新建项目</h2><p><img src=\"/../imgs/image-20240702220340059.png\" alt=\"image-20240702220340059\"></p>\n<h2 id=\"（2）导入esp32库\"><a href=\"#（2）导入esp32库\" class=\"headerlink\" title=\"（2）导入esp32库\"></a>（2）导入esp32库</h2><p><img src=\"/../imgs/image-20240702220502413.png\" alt=\"image-20240702220502413\"></p>\n<h2 id=\"（3）-添加库\"><a href=\"#（3）-添加库\" class=\"headerlink\" title=\"（3） 添加库\"></a>（3） 添加库</h2><p><img src=\"/../imgs/image-20240702220705763.png\" alt=\"image-20240702220705763\"></p>\n<p>添加库WakeOnLan </p>\n<p><img src=\"/../imgs/image-20240702220828261.png\" alt=\"image-20240702220828261\"></p>\n<p>添加库AsyncTCP </p>\n<p><img src=\"/../imgs/image-20240702220932130.png\" alt=\"image-20240702220932130\"></p>\n<h2 id=\"（4）导入库\"><a href=\"#（4）导入库\" class=\"headerlink\" title=\"（4）导入库\"></a>（4）导入库</h2><p><img src=\"/../imgs/image-20240702221037900.png\" alt=\"image-20240702221037900\"></p>\n<p>添加文件bemfa_client.hpp、wifi_helper.hpp：</p>\n<p><img src=\"/../imgs/image-20240702221620487.png\" alt=\"image-20240702221620487\"></p>\n<p>将main.cpp拷贝到.ino文件中</p>\n<p><img src=\"/../imgs/image-20240702222853017.png\" alt=\"image-20240702222853017\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;bemfa_client.hpp&quot;</span><br><span class=\"line\">#include &quot;WakeOnLan.h&quot;</span><br><span class=\"line\">#include &quot;wifi_helper.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">BemfaClient* bemfaClient;</span><br><span class=\"line\">WifiHelper* wifiHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">WiFiUDP UDP;</span><br><span class=\"line\">WakeOnLan WOL(UDP);</span><br><span class=\"line\"></span><br><span class=\"line\">const int LED_Pin = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">const char *SSID = &quot;xxx&quot;;  // wifi名称</span><br><span class=\"line\">const char *PSW = &quot;xxx&quot;;  // wifi密码</span><br><span class=\"line\"></span><br><span class=\"line\">const char *UID = &quot;xxx&quot;;  // 巴法云的UID</span><br><span class=\"line\">const char *TOPIC = &quot;pc006&quot;;  // 巴法云中创建的TOPIC(不是昵称)</span><br><span class=\"line\"></span><br><span class=\"line\">const char *TARGET_MAC_ADDR = &quot;xxx&quot;;  // 要启动的电脑的MAC地址</span><br><span class=\"line\"></span><br><span class=\"line\">void blinkTwice() &#123;</span><br><span class=\"line\">    digitalWrite(LED_Pin, HIGH);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, LOW);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, HIGH);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, LOW);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void setup() &#123;</span><br><span class=\"line\">    Serial.begin(115200);</span><br><span class=\"line\">    Serial.println(&quot;Beginning...&quot;);</span><br><span class=\"line\">    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);</span><br><span class=\"line\">    bemfaClient = new BemfaClient(UID, TOPIC);</span><br><span class=\"line\">    bemfaClient-&gt;addCommand(&quot;on&quot;, []&#123;</span><br><span class=\"line\">        Serial.println(&quot;Send magic packet&quot;);</span><br><span class=\"line\">        WOL.setRepeat(3, 100);</span><br><span class=\"line\">        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());</span><br><span class=\"line\">        WOL.sendMagicPacket(TARGET_MAC_ADDR);</span><br><span class=\"line\">        blinkTwice();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void loop() &#123;</span><br><span class=\"line\">    wifiHelper-&gt;tick();</span><br><span class=\"line\">    bemfaClient-&gt;tick();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译烧录即可，然后通过小爱同学“打开电脑”即可控制电脑开机</p>\n<h2 id=\"5-关机python脚本配置\"><a href=\"#5-关机python脚本配置\" class=\"headerlink\" title=\"5.关机python脚本配置\"></a>5.关机python脚本配置</h2><p>安装python</p>\n<p>参考：<a href=\"https://docs.python.org/zh-cn/3/using/index.html\">https://docs.python.org/zh-cn/3/using/index.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#安装相关依赖</span><br><span class=\"line\">pip install requests</span><br><span class=\"line\">pip install schedule</span><br><span class=\"line\">pip install pyinstaller</span><br></pre></td></tr></table></figure>\n\n<p>python打包<br><a href=\"https://www.cnblogs.com/weilaiqinkong/p/17240065.html\">https://www.cnblogs.com/weilaiqinkong/p/17240065.html</a></p>\n<p>如：pyinstaller -F -w main.py</p>\n<p>巴法云平台tcp连接参考：<a href=\"https://bbs.bemfa.com/81\">https://bbs.bemfa.com/81</a></p>\n<h3 id=\"main-py\"><a href=\"#main-py\" class=\"headerlink\" title=\"main.py\"></a>main.py</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># -*- coding: utf-8</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\">import os</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">import sys</span><br><span class=\"line\">import getpass</span><br><span class=\"line\"></span><br><span class=\"line\">def connTCP():</span><br><span class=\"line\">    global tcp_client_socket</span><br><span class=\"line\">    # 创建socket</span><br><span class=\"line\">    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">    # IP 和端口</span><br><span class=\"line\">    server_ip = &#x27;bemfa.com&#x27;</span><br><span class=\"line\">    server_port = 8344</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        # 连接服务器</span><br><span class=\"line\">        tcp_client_socket.connect((server_ip, server_port))</span><br><span class=\"line\">        #发送订阅指令</span><br><span class=\"line\">        substr = &#x27;cmd=1&amp;uid=巴法云私钥&amp;topic=pc006\\r\\n&#x27;</span><br><span class=\"line\">        tcp_client_socket.send(substr.encode(&quot;utf-8&quot;))</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\"></span><br><span class=\"line\">#心跳</span><br><span class=\"line\">def Ping():</span><br><span class=\"line\">    # 发送心跳</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        keeplive = &#x27;ping\\r\\n&#x27;</span><br><span class=\"line\">        tcp_client_socket.send(keeplive.encode(&quot;utf-8&quot;))</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\">    #开启定时，30秒发送一次心跳</span><br><span class=\"line\">    t = threading.Timer(30,Ping)</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">connTCP()</span><br><span class=\"line\">Ping()</span><br><span class=\"line\"></span><br><span class=\"line\">while True:</span><br><span class=\"line\">    # 接收服务器发送过来的数据</span><br><span class=\"line\">    recvData = tcp_client_socket.recv(1024)</span><br><span class=\"line\">    if len(recvData) != 0:</span><br><span class=\"line\">        data = recvData.decode(&#x27;utf-8&#x27;)</span><br><span class=\"line\">        print(&#x27;recv:&#x27;, data)</span><br><span class=\"line\">        if &quot;on&quot; in data:</span><br><span class=\"line\">            print(&quot;do nothing!&quot;)</span><br><span class=\"line\">        elif &quot;off&quot; in data:</span><br><span class=\"line\">            print(&quot;starting poweroff after 3s ...&quot;)</span><br><span class=\"line\">            # 3s后 系统自动关机</span><br><span class=\"line\">            print(os.system(&#x27;shutdown -s -t 3&#x27;))</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;conn err&quot;)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>设置main.exe开机启动</p>\n<p><a href=\"https://www.cnblogs.com/muxiaomu/p/16649990.html\">https://www.cnblogs.com/muxiaomu/p/16649990.html</a></p>\n"}],"Post":[{"title":"00-rust学习网站","date":"2023-08-26T08:08:57.000Z","_content":"\n\n\n# 相关网站\n\n[GitHub-rust](https://github.com/sunface/rust-course)\n\n[关于本书 - Rust语言圣经(Rust Course)](https://course.rs/about-book.html)\n","source":"_posts/00-rust学习网站.md","raw":"---\ntitle: 00-rust学习网站\ndate: 2023-08-26 16:08:57\ncategories:\n- rust\ntags:\n- 学习网站\n- rust\n---\n\n\n\n# 相关网站\n\n[GitHub-rust](https://github.com/sunface/rust-course)\n\n[关于本书 - Rust语言圣经(Rust Course)](https://course.rs/about-book.html)\n","slug":"00-rust学习网站","published":1,"updated":"2024-05-15T06:26:36.420Z","_id":"clvjcoaak0000r9w096yq3vus","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"相关网站\"><a href=\"#相关网站\" class=\"headerlink\" title=\"相关网站\"></a>相关网站</h1><p><a href=\"https://github.com/sunface/rust-course\">GitHub-rust</a></p>\n<p><a href=\"https://course.rs/about-book.html\">关于本书 - Rust语言圣经(Rust Course)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"相关网站\"><a href=\"#相关网站\" class=\"headerlink\" title=\"相关网站\"></a>相关网站</h1><p><a href=\"https://github.com/sunface/rust-course\">GitHub-rust</a></p>\n<p><a href=\"https://course.rs/about-book.html\">关于本书 - Rust语言圣经(Rust Course)</a></p>\n"},{"title":"01-rust环境搭建","date":"2023-08-26T09:03:59.000Z","_content":"\n\n\n\n\n\n\n\n\n\n\n当前环境：win11+wsl+vscode\n\n## 1.安装rustup\n\n```\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\nsudo apt install build-essential\nrustc -V \ncargo -V\n```\n\n## 2.安装vsocode插件\n\n```\nrust-analyzer ，Rust 语言插件\nEven Better TOML，支持 .toml 文件完整特性\nError Lens, 更好的获得错误展示\nOne Dark Pro, 非常好看的 VSCode 主题\nCodeLLDB, Debugger 程序\n```\n\n## 3.运行hello world!\n\n```\ncargo new world_hello\ncd world_hello\ncargo run\n#编译\ncargo build\n#运行\n./target/debug/world_hello\nHello, world!\n#快速的检查一下代码能否编译通过\ncargo check\n```\n\n## 4.修改 Rust 的下载镜像为国内的镜像地址\n\n```\n#在 $HOME/.cargo/config.toml 添加以下内容：\n\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n","source":"_posts/01-rust环境搭建.md","raw":"---\ntitle: 01-rust环境搭建\ndate: 2023-08-26 17:03:59\ncategories:\n- rust\ntags:\n- rust环境搭建\n- rust\n---\n\n\n\n\n\n\n\n\n\n\n\n当前环境：win11+wsl+vscode\n\n## 1.安装rustup\n\n```\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\nsudo apt install build-essential\nrustc -V \ncargo -V\n```\n\n## 2.安装vsocode插件\n\n```\nrust-analyzer ，Rust 语言插件\nEven Better TOML，支持 .toml 文件完整特性\nError Lens, 更好的获得错误展示\nOne Dark Pro, 非常好看的 VSCode 主题\nCodeLLDB, Debugger 程序\n```\n\n## 3.运行hello world!\n\n```\ncargo new world_hello\ncd world_hello\ncargo run\n#编译\ncargo build\n#运行\n./target/debug/world_hello\nHello, world!\n#快速的检查一下代码能否编译通过\ncargo check\n```\n\n## 4.修改 Rust 的下载镜像为国内的镜像地址\n\n```\n#在 $HOME/.cargo/config.toml 添加以下内容：\n\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n","slug":"01-rust环境搭建","published":1,"updated":"2024-04-28T07:13:38.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clvjcoaao0001r9w0de539y4w","content":"<p>当前环境：win11+wsl+vscode</p>\n<h2 id=\"1-安装rustup\"><a href=\"#1-安装rustup\" class=\"headerlink\" title=\"1.安装rustup\"></a>1.安装rustup</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br><span class=\"line\">sudo apt install build-essential</span><br><span class=\"line\">rustc -V </span><br><span class=\"line\">cargo -V</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装vsocode插件\"><a href=\"#2-安装vsocode插件\" class=\"headerlink\" title=\"2.安装vsocode插件\"></a>2.安装vsocode插件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rust-analyzer ，Rust 语言插件</span><br><span class=\"line\">Even Better TOML，支持 .toml 文件完整特性</span><br><span class=\"line\">Error Lens, 更好的获得错误展示</span><br><span class=\"line\">One Dark Pro, 非常好看的 VSCode 主题</span><br><span class=\"line\">CodeLLDB, Debugger 程序</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-运行hello-world\"><a href=\"#3-运行hello-world\" class=\"headerlink\" title=\"3.运行hello world!\"></a>3.运行hello world!</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo new world_hello</span><br><span class=\"line\">cd world_hello</span><br><span class=\"line\">cargo run</span><br><span class=\"line\">#编译</span><br><span class=\"line\">cargo build</span><br><span class=\"line\">#运行</span><br><span class=\"line\">./target/debug/world_hello</span><br><span class=\"line\">Hello, world!</span><br><span class=\"line\">#快速的检查一下代码能否编译通过</span><br><span class=\"line\">cargo check</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-修改-Rust-的下载镜像为国内的镜像地址\"><a href=\"#4-修改-Rust-的下载镜像为国内的镜像地址\" class=\"headerlink\" title=\"4.修改 Rust 的下载镜像为国内的镜像地址\"></a>4.修改 Rust 的下载镜像为国内的镜像地址</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在 $HOME/.cargo/config.toml 添加以下内容：</span><br><span class=\"line\"></span><br><span class=\"line\">[source.crates-io]</span><br><span class=\"line\">replace-with = &#x27;ustc&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">[source.ustc]</span><br><span class=\"line\">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>当前环境：win11+wsl+vscode</p>\n<h2 id=\"1-安装rustup\"><a href=\"#1-安装rustup\" class=\"headerlink\" title=\"1.安装rustup\"></a>1.安装rustup</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br><span class=\"line\">sudo apt install build-essential</span><br><span class=\"line\">rustc -V </span><br><span class=\"line\">cargo -V</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装vsocode插件\"><a href=\"#2-安装vsocode插件\" class=\"headerlink\" title=\"2.安装vsocode插件\"></a>2.安装vsocode插件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rust-analyzer ，Rust 语言插件</span><br><span class=\"line\">Even Better TOML，支持 .toml 文件完整特性</span><br><span class=\"line\">Error Lens, 更好的获得错误展示</span><br><span class=\"line\">One Dark Pro, 非常好看的 VSCode 主题</span><br><span class=\"line\">CodeLLDB, Debugger 程序</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-运行hello-world\"><a href=\"#3-运行hello-world\" class=\"headerlink\" title=\"3.运行hello world!\"></a>3.运行hello world!</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo new world_hello</span><br><span class=\"line\">cd world_hello</span><br><span class=\"line\">cargo run</span><br><span class=\"line\">#编译</span><br><span class=\"line\">cargo build</span><br><span class=\"line\">#运行</span><br><span class=\"line\">./target/debug/world_hello</span><br><span class=\"line\">Hello, world!</span><br><span class=\"line\">#快速的检查一下代码能否编译通过</span><br><span class=\"line\">cargo check</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-修改-Rust-的下载镜像为国内的镜像地址\"><a href=\"#4-修改-Rust-的下载镜像为国内的镜像地址\" class=\"headerlink\" title=\"4.修改 Rust 的下载镜像为国内的镜像地址\"></a>4.修改 Rust 的下载镜像为国内的镜像地址</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在 $HOME/.cargo/config.toml 添加以下内容：</span><br><span class=\"line\"></span><br><span class=\"line\">[source.crates-io]</span><br><span class=\"line\">replace-with = &#x27;ustc&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">[source.ustc]</span><br><span class=\"line\">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"github+hexo 博客搭建","date":"2023-08-25T11:32:35.000Z","_content":"\n\n@[toc]\n环境：win11+wsl\n## 1.安装Node.js、Git和Hexo\n打开终端安装以下软件\n```\nsudo apt update\nsudo apt-get install git\n\nsudo apt install nodejs\nsudo apt install npm        #Node.js 的包管理器\nsudo npm install -g hexo-cli        #安装hexo\n```\n## 2.创建 GitHub 仓库并配置ssh\n登录你的 GitHub 帐号，并创建一个新的仓库，仓库名是 `<username>.github.io`，其中 `<username>` 是你的 GitHub 用户名。将该仓库设置为公开仓库。\n设置ssh\n```\nssh-keygen -t rsa -C 'xxx@xxx.com'  #自己的邮箱\ncat ~/.ssh/id_rsa.pub  #将里面的内容复制到 github ->settings ->SSH and GPC keys ->SSH keys ->New SSH key中\nssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）\n#接着在本地绑定与Github的用户名和邮箱（git）\ngit config --global user.name \"<username>\"    #自己的用户名\ngit config --global user.email 'xxx@xxx.com'  #自己的邮箱\n```\n## 3.初始化Hexo\n创建一个新的文件夹，用于存储你的博客项目。\n在终端中，进入该文件夹，并运行以下命令来初始化 Hexo\n```\nmkdir myblog\nhexo init    \n#或者直接一步到位 \nhexo init myblog\n```\n## 4.配置Hexo\n- 进入你的 Hexo 项目文件夹，找到 _config.yml 文件，使用文本编辑器打开它。\n- 在 _config.yml 文件中，配置你的博客设置，例如标题、描述、作者等。\n- 根据需要，你还可以配置主题、插件和其他 Hexo 选项。\n编辑_config.yml文件，添加如下内容 \n```\ndeploy:\n        type: git\n        repo: git@github.com: <username>/ <username>.github.io.git  #<username>为自己的用户名\n        branch: main\n```\n```\nnpm install hexo-deployer-git    #安装 hexo-deployer-git 插件 将部署过程自动化\n```\n## 5.创建博客内容\n在终端中，运行以下命令来创建新的博客文章：\n```\nhexo new \"My First Post\"\n```\n这将在 Hexo 项目的 source/_posts 目录下创建一个新的 Markdown 文件，用于编写你的第一篇博客文章。\n## 6.部署\n```\nhexo s    # 预览\n#Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n#用浏览器打开 http://localhost:4000/\nhexo g #生成静态网站文件\nhexo d #将生成的静态网站文件部署到github\n```\n## 7.查看\n浏览器打开`<username>.github.io`即可查看\n\n\n## 8.参考：\nhttps://blog.csdn.net/qq_62928039/article/details/130248518\n\n## 9.选择主题：\nhttps://hexo.io/themes/\nhttps://github.com/yelog/hexo-theme-3-hexo\n```\n#在hexo根目录下\ngit clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo\n#修改hexo根目录的_config.yml，如下\ntheme: 3-hexo\n#博客配置\nhttp://yelog.org/2017/03/23/3-hexo-instruction/\n```\n最终效果：\nhttps://yyheroi.github.io\n","source":"_posts/github+hexo博客搭建.md","raw":"---\ntitle: github+hexo 博客搭建\ndate: 2023-08-25 19:32:35\ncategories:\n- test\ntags:\n- test\n---\n\n\n@[toc]\n环境：win11+wsl\n## 1.安装Node.js、Git和Hexo\n打开终端安装以下软件\n```\nsudo apt update\nsudo apt-get install git\n\nsudo apt install nodejs\nsudo apt install npm        #Node.js 的包管理器\nsudo npm install -g hexo-cli        #安装hexo\n```\n## 2.创建 GitHub 仓库并配置ssh\n登录你的 GitHub 帐号，并创建一个新的仓库，仓库名是 `<username>.github.io`，其中 `<username>` 是你的 GitHub 用户名。将该仓库设置为公开仓库。\n设置ssh\n```\nssh-keygen -t rsa -C 'xxx@xxx.com'  #自己的邮箱\ncat ~/.ssh/id_rsa.pub  #将里面的内容复制到 github ->settings ->SSH and GPC keys ->SSH keys ->New SSH key中\nssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）\n#接着在本地绑定与Github的用户名和邮箱（git）\ngit config --global user.name \"<username>\"    #自己的用户名\ngit config --global user.email 'xxx@xxx.com'  #自己的邮箱\n```\n## 3.初始化Hexo\n创建一个新的文件夹，用于存储你的博客项目。\n在终端中，进入该文件夹，并运行以下命令来初始化 Hexo\n```\nmkdir myblog\nhexo init    \n#或者直接一步到位 \nhexo init myblog\n```\n## 4.配置Hexo\n- 进入你的 Hexo 项目文件夹，找到 _config.yml 文件，使用文本编辑器打开它。\n- 在 _config.yml 文件中，配置你的博客设置，例如标题、描述、作者等。\n- 根据需要，你还可以配置主题、插件和其他 Hexo 选项。\n编辑_config.yml文件，添加如下内容 \n```\ndeploy:\n        type: git\n        repo: git@github.com: <username>/ <username>.github.io.git  #<username>为自己的用户名\n        branch: main\n```\n```\nnpm install hexo-deployer-git    #安装 hexo-deployer-git 插件 将部署过程自动化\n```\n## 5.创建博客内容\n在终端中，运行以下命令来创建新的博客文章：\n```\nhexo new \"My First Post\"\n```\n这将在 Hexo 项目的 source/_posts 目录下创建一个新的 Markdown 文件，用于编写你的第一篇博客文章。\n## 6.部署\n```\nhexo s    # 预览\n#Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n#用浏览器打开 http://localhost:4000/\nhexo g #生成静态网站文件\nhexo d #将生成的静态网站文件部署到github\n```\n## 7.查看\n浏览器打开`<username>.github.io`即可查看\n\n\n## 8.参考：\nhttps://blog.csdn.net/qq_62928039/article/details/130248518\n\n## 9.选择主题：\nhttps://hexo.io/themes/\nhttps://github.com/yelog/hexo-theme-3-hexo\n```\n#在hexo根目录下\ngit clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo\n#修改hexo根目录的_config.yml，如下\ntheme: 3-hexo\n#博客配置\nhttp://yelog.org/2017/03/23/3-hexo-instruction/\n```\n最终效果：\nhttps://yyheroi.github.io\n","slug":"github+hexo博客搭建","published":1,"updated":"2024-04-28T07:13:38.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clvjcoaar0004r9w0en6ne5w9","content":"<p>@[toc]<br>环境：win11+wsl</p>\n<h2 id=\"1-安装Node-js、Git和Hexo\"><a href=\"#1-安装Node-js、Git和Hexo\" class=\"headerlink\" title=\"1.安装Node.js、Git和Hexo\"></a>1.安装Node.js、Git和Hexo</h2><p>打开终端安装以下软件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install git</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm        #Node.js 的包管理器</span><br><span class=\"line\">sudo npm install -g hexo-cli        #安装hexo</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-创建-GitHub-仓库并配置ssh\"><a href=\"#2-创建-GitHub-仓库并配置ssh\" class=\"headerlink\" title=\"2.创建 GitHub 仓库并配置ssh\"></a>2.创建 GitHub 仓库并配置ssh</h2><p>登录你的 GitHub 帐号，并创建一个新的仓库，仓库名是 <code>&lt;username&gt;.github.io</code>，其中 <code>&lt;username&gt;</code> 是你的 GitHub 用户名。将该仓库设置为公开仓库。<br>设置ssh</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br><span class=\"line\">cat ~/.ssh/id_rsa.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class=\"line\">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class=\"line\">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class=\"line\">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class=\"line\">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-初始化Hexo\"><a href=\"#3-初始化Hexo\" class=\"headerlink\" title=\"3.初始化Hexo\"></a>3.初始化Hexo</h2><p>创建一个新的文件夹，用于存储你的博客项目。<br>在终端中，进入该文件夹，并运行以下命令来初始化 Hexo</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir myblog</span><br><span class=\"line\">hexo init    </span><br><span class=\"line\">#或者直接一步到位 </span><br><span class=\"line\">hexo init myblog</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-配置Hexo\"><a href=\"#4-配置Hexo\" class=\"headerlink\" title=\"4.配置Hexo\"></a>4.配置Hexo</h2><ul>\n<li>进入你的 Hexo 项目文件夹，找到 _config.yml 文件，使用文本编辑器打开它。</li>\n<li>在 _config.yml 文件中，配置你的博客设置，例如标题、描述、作者等。</li>\n<li>根据需要，你还可以配置主题、插件和其他 Hexo 选项。<br>编辑_config.yml文件，添加如下内容 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">        type: git</span><br><span class=\"line\">        repo: git@github.com: &lt;username&gt;/ &lt;username&gt;.github.io.git  #&lt;username&gt;为自己的用户名</span><br><span class=\"line\">        branch: main</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git    #安装 hexo-deployer-git 插件 将部署过程自动化</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"5-创建博客内容\"><a href=\"#5-创建博客内容\" class=\"headerlink\" title=\"5.创建博客内容\"></a>5.创建博客内容</h2><p>在终端中，运行以下命令来创建新的博客文章：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;My First Post&quot;</span><br></pre></td></tr></table></figure>\n<p>这将在 Hexo 项目的 source&#x2F;_posts 目录下创建一个新的 Markdown 文件，用于编写你的第一篇博客文章。</p>\n<h2 id=\"6-部署\"><a href=\"#6-部署\" class=\"headerlink\" title=\"6.部署\"></a>6.部署</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s    # 预览</span><br><span class=\"line\">#Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class=\"line\">#用浏览器打开 http://localhost:4000/</span><br><span class=\"line\">hexo g #生成静态网站文件</span><br><span class=\"line\">hexo d #将生成的静态网站文件部署到github</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-查看\"><a href=\"#7-查看\" class=\"headerlink\" title=\"7.查看\"></a>7.查看</h2><p>浏览器打开<code>&lt;username&gt;.github.io</code>即可查看</p>\n<h2 id=\"8-参考：\"><a href=\"#8-参考：\" class=\"headerlink\" title=\"8.参考：\"></a>8.参考：</h2><p><a href=\"https://blog.csdn.net/qq_62928039/article/details/130248518\">https://blog.csdn.net/qq_62928039/article/details/130248518</a></p>\n<h2 id=\"9-选择主题：\"><a href=\"#9-选择主题：\" class=\"headerlink\" title=\"9.选择主题：\"></a>9.选择主题：</h2><p><a href=\"https://hexo.io/themes/\">https://hexo.io/themes/</a><br><a href=\"https://github.com/yelog/hexo-theme-3-hexo\">https://github.com/yelog/hexo-theme-3-hexo</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在hexo根目录下</span><br><span class=\"line\">git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</span><br><span class=\"line\">#修改hexo根目录的_config.yml，如下</span><br><span class=\"line\">theme: 3-hexo</span><br><span class=\"line\">#博客配置</span><br><span class=\"line\">http://yelog.org/2017/03/23/3-hexo-instruction/</span><br></pre></td></tr></table></figure>\n<p>最终效果：<br><a href=\"https://yyheroi.github.io/\">https://yyheroi.github.io</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>@[toc]<br>环境：win11+wsl</p>\n<h2 id=\"1-安装Node-js、Git和Hexo\"><a href=\"#1-安装Node-js、Git和Hexo\" class=\"headerlink\" title=\"1.安装Node.js、Git和Hexo\"></a>1.安装Node.js、Git和Hexo</h2><p>打开终端安装以下软件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install git</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm        #Node.js 的包管理器</span><br><span class=\"line\">sudo npm install -g hexo-cli        #安装hexo</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-创建-GitHub-仓库并配置ssh\"><a href=\"#2-创建-GitHub-仓库并配置ssh\" class=\"headerlink\" title=\"2.创建 GitHub 仓库并配置ssh\"></a>2.创建 GitHub 仓库并配置ssh</h2><p>登录你的 GitHub 帐号，并创建一个新的仓库，仓库名是 <code>&lt;username&gt;.github.io</code>，其中 <code>&lt;username&gt;</code> 是你的 GitHub 用户名。将该仓库设置为公开仓库。<br>设置ssh</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br><span class=\"line\">cat ~/.ssh/id_rsa.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class=\"line\">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class=\"line\">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class=\"line\">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class=\"line\">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-初始化Hexo\"><a href=\"#3-初始化Hexo\" class=\"headerlink\" title=\"3.初始化Hexo\"></a>3.初始化Hexo</h2><p>创建一个新的文件夹，用于存储你的博客项目。<br>在终端中，进入该文件夹，并运行以下命令来初始化 Hexo</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir myblog</span><br><span class=\"line\">hexo init    </span><br><span class=\"line\">#或者直接一步到位 </span><br><span class=\"line\">hexo init myblog</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-配置Hexo\"><a href=\"#4-配置Hexo\" class=\"headerlink\" title=\"4.配置Hexo\"></a>4.配置Hexo</h2><ul>\n<li>进入你的 Hexo 项目文件夹，找到 _config.yml 文件，使用文本编辑器打开它。</li>\n<li>在 _config.yml 文件中，配置你的博客设置，例如标题、描述、作者等。</li>\n<li>根据需要，你还可以配置主题、插件和其他 Hexo 选项。<br>编辑_config.yml文件，添加如下内容 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">        type: git</span><br><span class=\"line\">        repo: git@github.com: &lt;username&gt;/ &lt;username&gt;.github.io.git  #&lt;username&gt;为自己的用户名</span><br><span class=\"line\">        branch: main</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git    #安装 hexo-deployer-git 插件 将部署过程自动化</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"5-创建博客内容\"><a href=\"#5-创建博客内容\" class=\"headerlink\" title=\"5.创建博客内容\"></a>5.创建博客内容</h2><p>在终端中，运行以下命令来创建新的博客文章：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;My First Post&quot;</span><br></pre></td></tr></table></figure>\n<p>这将在 Hexo 项目的 source&#x2F;_posts 目录下创建一个新的 Markdown 文件，用于编写你的第一篇博客文章。</p>\n<h2 id=\"6-部署\"><a href=\"#6-部署\" class=\"headerlink\" title=\"6.部署\"></a>6.部署</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s    # 预览</span><br><span class=\"line\">#Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class=\"line\">#用浏览器打开 http://localhost:4000/</span><br><span class=\"line\">hexo g #生成静态网站文件</span><br><span class=\"line\">hexo d #将生成的静态网站文件部署到github</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-查看\"><a href=\"#7-查看\" class=\"headerlink\" title=\"7.查看\"></a>7.查看</h2><p>浏览器打开<code>&lt;username&gt;.github.io</code>即可查看</p>\n<h2 id=\"8-参考：\"><a href=\"#8-参考：\" class=\"headerlink\" title=\"8.参考：\"></a>8.参考：</h2><p><a href=\"https://blog.csdn.net/qq_62928039/article/details/130248518\">https://blog.csdn.net/qq_62928039/article/details/130248518</a></p>\n<h2 id=\"9-选择主题：\"><a href=\"#9-选择主题：\" class=\"headerlink\" title=\"9.选择主题：\"></a>9.选择主题：</h2><p><a href=\"https://hexo.io/themes/\">https://hexo.io/themes/</a><br><a href=\"https://github.com/yelog/hexo-theme-3-hexo\">https://github.com/yelog/hexo-theme-3-hexo</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在hexo根目录下</span><br><span class=\"line\">git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</span><br><span class=\"line\">#修改hexo根目录的_config.yml，如下</span><br><span class=\"line\">theme: 3-hexo</span><br><span class=\"line\">#博客配置</span><br><span class=\"line\">http://yelog.org/2017/03/23/3-hexo-instruction/</span><br></pre></td></tr></table></figure>\n<p>最终效果：<br><a href=\"https://yyheroi.github.io/\">https://yyheroi.github.io</a></p>\n"},{"title":"cpufreq","date":"2024-04-28T09:04:13.000Z","_content":"\n[toc]\n\n# cpufreq\n\n\n\nCPUFreq框架是内核的CPU调频框架，整个调频框架由以下几个部分组成：\n\n- cpufreq driver\n- cpufreq framework (core)\n- cpufreq governor\n\n一些基本概念：\n\nP-state: voltage and frequency point\n\n总体上，CPU Freq主要在sysfs向userspace提供了调频操作和策略设置节点。当使用一些自动调频的governor时，允许governor从系统获取信息，自动触发调频动作。\n\n另外，还向其他模块提供了qos频率投票，以及调频事件的notifier机制。\n\n下面分开来看每个部分。\n\n## Driver\n\n\n\nCpufreq Driver主要负责底层调频的操作，核心是实现 `cpufreq_dirver` 对象，并通过 `cpufreq_register_driver` 将驱动注册到系统，供core部分使用。\n\n其中，最核心的几个回调包括：\n\n- online: hotplug callback\n- offline: hotplug callback\n- target_index: set freq\n- set_boost: enter into boost mode\n\n以 `mediatek-cpufreq-hw.c` 为例，其freq table保存在硬件寄存器中，driver初始化时，从硬件中读出freq table，并实现相关调频回调，最终注册到core。\n\ndb845c使用的 `qcom-cpufreq-hw.c` 为例，其freq table保存在dts中，driver使用OPP框架来读取这些配置，并实现cpufreq回调。\n\n\\* OPP（Operating Performance Point，提供dts的freq-valt-table配置，及获取接口。\n\n## Core\n\n\n\nCore部分核心文件是 `/drivers/cpufreq/cpufreq.c`\n\n这个文件主要实现了BOOST，DRIVER，SYSFS，FREQ，NOTIFIER，GOVERNOR，POLICY相关功能的操作接口。\n\n`cpufreq_register_driver` (cpufreq_driver* cpufreq_driver)\n\n`cpufreq_register_governor` (cpufreq_governor_list)\n\n`cpufreq_register_notifier` (cpufreq_transition_notifier_list)\n\n`cpufreq_policy_alloc` (cpufreq_policy* PERCPU:cpufreq_cpu_data)\n\n`cpufreq_policy` 是一个调频实体，对应一个调频域（freq domain），一般为一个cluster，这个结构保存了每个调频实体（通常是一个cluster）调频相关的所有私有信息。同时，他作为调频操作的句柄，cpufreq顶层操作接口使用policy来对一个调频实体进行操作。\n\n每个CPU有一个percpu的指针指向其所属的policy，cluster中的多个CPU共享一个policy。（`cpufreq_cpu_data`）\n\nMainflow：\n\n1、cpufreq driver注册\n\n2、governor注册（每个policy初始化自己的governor）\n\n3、cpu hotplug state: \"cpufreq:online\"，`cpuhp_cpufreq_online`、`cpuhp_cpufreq_offline`，创建出percpu policy，绑定driver、governor\n\n4、向sysfs创建节点，提供功能\n\n5、governor开始工作，通过 `__cpufreq_driver_target` 进行调频。\n\n- Qos是调频投票机制，用来实现max_freq、min_freq limitation。(`cpufreq_notifier_min` `cpufreq_notifier_max`)，在其他module有需求投票后，freq constrants会被更新。\n\n## Sysfs\n\n\n\n```\n/sys/devices/system/cpu/cpu0/cpufreq/policyX\nscaling_driver\t\t\tr\t# cpufreq driver name\naffected_cpus\t\t\tr\t# cpu\nrelated_cpus\t\t\tr\t# <?>\nscaling_cur_freq\t\trw\t# cur freq\nscaling_min_freq\t\trw\t# min freq limit\nscaling_max_freq\t\trw\t# max freq limit\nscaling_governor\t\trw\t# selected governor\nscaling_available_governors\tr\t# available governors\nscaling_setspeed\t\tr\t# <not supported>\ncpuinfo_min_freq\t\tr\t# hardware min freq\ncpuinfo_max_freq\t\tr\t# hardware max freq\ncpuinfo_transition_latency\tr\t# hardware latency\n```\n\n\n\n## Governors\n\n\n\nGovernor负责从系统收集信息，并触发调频动作。\n\n**powersave**\n\nalways lowest frequency\n\n**performance**\n\nalways highest frequency\n\n**schedutil**\n\nuses CPU utilization data from scheduler to determine target frequence\n\n待完成\n\n**userspace**\n\nallow user space set the frequency\n\n**ondemand**\n\nuses CPU load as a CPU frequency selection metric\n\nit reaches the target by CPU load, 0->min, 100->max\n\n**conservative**\n\nuses CPU load as a CPU frequency selection metric\n\nit reaches the target step by step, up_threshold->up, down_threshold->down\n\n## Files\n\n\n\n```\n- /drivers/cpufreq/cpufreq.c\n- /drivers/cpufreq/cpufreq-dt.c\n- /drivers/cpufreq/cpufreq_stats.c\n- /drivers/cpufreq/cpufreq_conservative.c\n- /drivers/cpufreq/cpufreq_governor.c\n- /drivers/cpufreq/cpufreq_ondemand.c\n- /drivers/cpufreq/cpufreq_powersave.c\n- /drivers/cpufreq/cpufreq_performance.c\n- /drivers/cpufreq/cpufreq_userspace.c\n- /kernel/sched/cpufreq_schedutil.c\n- /kernel/power/qos.c\n```\n\n## rk3588-cpufreq-sys\n\n>查看cpufreq节点\n>RK3588的cpu是4个A55+4个A76，分为3组单独管理，节点分别是：\n>/sys/devices/system/cpu/cpufreq/policy0:（对应4个A55：CPU0-3）\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed\n>\n>/sys/devices/system/cpu/cpufreq/policy4:(对应2个A76：CPU4-5)\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed\n>\n>/sys/devices/system/cpu/cpufreq/policy6:(对应2个A76：CPU6-7)\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_drive\n>                        \n>\n>CPU性能模式\n>echo performance > /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>获取cpu运行的模式\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_available_governors\n>获取当前CPU支持的频点\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_available_frequencies\n>\n>cat /sys/devices/system/cpu/cpufreq/policy6/cpuinfo_cur_freq       \n>\n>\n>2.0设置cpufrq为performance模式\n>echo performance > /sys/devices/system/cpu/cpufreq/policy0/scaling_governor\n>echo performance > /sys/devices/system/cpu/cpufreq/policy4/scaling_governor\n>echo performance > /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>\n>查看模式\n>cat /sys/devices/system/cpu/cpufreq/policy*/scaling_governor\n>查看频率\n>cat /sys/devices/system/cpu/cpufreq/policy*/cpuinfo_cur_freq       \n\n## rk3588-cpufreq-code\n\n![cpufreq framework](../imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif)\n\n相关文件\n\nkernel/drivers/cpufreq/cpufreq.c\n\nkernel/drivers/cpufreq/rockchip-cpufreq.c\n\nkernel/drivers/cpufreq/cpufreq-dt-platdev.c\n\nkernel/drivers/cpufreq/cpufreq-dt.c\n\n```\nCONFIG_CPU_FREQ=y\nCONFIG_CPU_FREQ_STAT=y\nCONFIG_CPU_FREQ_TIMES=y\nCONFIG_CPU_FREQ_GOV_POWERSAVE=y\nCONFIG_CPU_FREQ_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_CPU_FREQ_GOV_CONSERVATIVE=y\nCONFIG_CPU_FREQ_GOV_INTERACTIVE=y\nCONFIG_CPU_FREQ_GOV_PERFORMANCE=y\nCONFIG_CPU_FREQ_GOV_COMMON=y\nCONFIG_CPU_FREQ_GOV_ATTR_SET=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y\nCONFIG_CPUFREQ_DT=y\n```\n\n\n\n### 1. CPUFreq核心和接口\n\ncpufreq代码为CPUFreq架构的驱 动程序（那些执行硬件频率切换的代码）以及 “通知器” 提供了一个标准化的接口。 包括设备驱动程序；需要了解策略变化（如 ACPI 热量管理），或所有频率变化（如计时代码）， 甚至需要强制限制为指定频率（如 ARM 架构上的 LCD 驱动程序）的其它内核组件。 此外，内核 “常数” loops_per_jiffy 会根据频率变化而更新。\n\ncpufreq策略的引用计数由 cpufreq_cpu_get 和 cpufreq_cpu_put 来完成，以确保 cpufreq 驱 动程序被正确地注册到核心中，并且驱动程序在 cpufreq_put_cpu 被调用之前不会被卸载。这也保证 了每个CPU核的cpufreq 策略在使用期间不会被释放。\n\n### 2. CPUFreq 通知器\n\nCPUFreq通知器遵循标准的内核通知器接口。 关于通知器的细节请参阅 linux/include/linux/notifier.h。\n\n这里有两个不同的CPUfreq通知器 - 策略通知器和转换通知器。\n\n#### 2.1 CPUFreq策略通知器\n\n当创建或移除策略时，这些都会被通知。\n\n阶段是在通知器的第二个参数中指定的。当第一次创建策略时，阶段是CPUFREQ_CREATE_POLICY，当 策略被移除时，阶段是CPUFREQ_REMOVE_POLICY。\n\n第三个参数 `void *pointer` 指向一个结构体cpufreq_policy，其包括min，max(新策略的下限和 上限（单位为kHz）)这几个值。\n\n#### 2.2 CPUFreq转换通知器\n\n当CPUfreq驱动切换CPU核心频率时，策略中的每个在线CPU都会收到两次通知，这些变化没有任何外部干 预。\n\n第二个参数指定阶段 - CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.\n\n第三个参数是一个包含如下值的结构体cpufreq_freqs：\n\n| policy | 指向struct cpufreq_policy的指针 |\n| ------ | ------------------------------- |\n| old    | 旧频率                          |\n| new    | 新频率                          |\n| flags  | cpufreq驱动的标志               |\n\n\n\n\n\n```\ncore_initcall(cpufreq_core_init);\n\tcpufreq_default_governor\t\t//获取默认的cpufreq策略 如schedutil powersave performace等\n\tkobject_create_and_add\t\t\t//创建sys/devices/system/cpu/cpufreq接口\n\t\n```\n\n\n\n```\nmodule_init(rockchip_cpufreq_driver_init)\n\tfor_each_possible_cpu\n\trockchip_cluster_info_lookup\n\trockchip_cpufreq_cluster_init\n\tcpufreq_register_notifier\t\t//注册通知CPUFREQ_POLICY_NOTYFIER  CPUFREQ_TRANSITION_NOTIFIER \n\t\trockchip_cpufreq_notifier\n\t\t\trockchip_cpufreq_add_monitor\n\t\t\t\trockchip_system_monitor_register\n```\n\n\n\n```\n#define for_each_cpu(cpu, mask)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\\\n\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n\t\t\n#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)\n\n\n/* Valid inputs for n are -1 and 0. */\nstatic inline unsigned int cpumask_next(int n, const struct cpumask *srcp)\n{\n\treturn n+1;\n}\n\n#if NR_CPUS == 1\n#define nr_cpu_ids\t\t1U\n#else\nextern unsigned int nr_cpu_ids;\n#endif\n```\n\n\n\n```\ndt_cpufreq_probe\n\tcpufreq_register_driver\n\t\tsubsys_interface_register \n\t\t\tcpufreq_interface\n\t\t\tcpufreq_add_dev\n\t\t\t\tcpufreq_online\n\t\t\t\t\tcpufreq_add_policy_cpu\n\t\t\t\t\t\tcpufreq_start_governor\n```\n\n\n\n\n\n## Reference\n\nhttps://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html\n\nhttps://docs.kernel.org/scheduler/schedutil.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_overview.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_driver.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_core.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_governor.html\n\n module_init()加载顺序 \n\nhttps://blog.csdn.net/shafa00419/article/details/85234867)","source":"_posts/cpufreq.md","raw":"---\ntitle: cpufreq\ndate: 2024-04-28 17:04:13\ncategories:\n- kernel\ntags:\n- power\n- cpufreq\n---\n\n[toc]\n\n# cpufreq\n\n\n\nCPUFreq框架是内核的CPU调频框架，整个调频框架由以下几个部分组成：\n\n- cpufreq driver\n- cpufreq framework (core)\n- cpufreq governor\n\n一些基本概念：\n\nP-state: voltage and frequency point\n\n总体上，CPU Freq主要在sysfs向userspace提供了调频操作和策略设置节点。当使用一些自动调频的governor时，允许governor从系统获取信息，自动触发调频动作。\n\n另外，还向其他模块提供了qos频率投票，以及调频事件的notifier机制。\n\n下面分开来看每个部分。\n\n## Driver\n\n\n\nCpufreq Driver主要负责底层调频的操作，核心是实现 `cpufreq_dirver` 对象，并通过 `cpufreq_register_driver` 将驱动注册到系统，供core部分使用。\n\n其中，最核心的几个回调包括：\n\n- online: hotplug callback\n- offline: hotplug callback\n- target_index: set freq\n- set_boost: enter into boost mode\n\n以 `mediatek-cpufreq-hw.c` 为例，其freq table保存在硬件寄存器中，driver初始化时，从硬件中读出freq table，并实现相关调频回调，最终注册到core。\n\ndb845c使用的 `qcom-cpufreq-hw.c` 为例，其freq table保存在dts中，driver使用OPP框架来读取这些配置，并实现cpufreq回调。\n\n\\* OPP（Operating Performance Point，提供dts的freq-valt-table配置，及获取接口。\n\n## Core\n\n\n\nCore部分核心文件是 `/drivers/cpufreq/cpufreq.c`\n\n这个文件主要实现了BOOST，DRIVER，SYSFS，FREQ，NOTIFIER，GOVERNOR，POLICY相关功能的操作接口。\n\n`cpufreq_register_driver` (cpufreq_driver* cpufreq_driver)\n\n`cpufreq_register_governor` (cpufreq_governor_list)\n\n`cpufreq_register_notifier` (cpufreq_transition_notifier_list)\n\n`cpufreq_policy_alloc` (cpufreq_policy* PERCPU:cpufreq_cpu_data)\n\n`cpufreq_policy` 是一个调频实体，对应一个调频域（freq domain），一般为一个cluster，这个结构保存了每个调频实体（通常是一个cluster）调频相关的所有私有信息。同时，他作为调频操作的句柄，cpufreq顶层操作接口使用policy来对一个调频实体进行操作。\n\n每个CPU有一个percpu的指针指向其所属的policy，cluster中的多个CPU共享一个policy。（`cpufreq_cpu_data`）\n\nMainflow：\n\n1、cpufreq driver注册\n\n2、governor注册（每个policy初始化自己的governor）\n\n3、cpu hotplug state: \"cpufreq:online\"，`cpuhp_cpufreq_online`、`cpuhp_cpufreq_offline`，创建出percpu policy，绑定driver、governor\n\n4、向sysfs创建节点，提供功能\n\n5、governor开始工作，通过 `__cpufreq_driver_target` 进行调频。\n\n- Qos是调频投票机制，用来实现max_freq、min_freq limitation。(`cpufreq_notifier_min` `cpufreq_notifier_max`)，在其他module有需求投票后，freq constrants会被更新。\n\n## Sysfs\n\n\n\n```\n/sys/devices/system/cpu/cpu0/cpufreq/policyX\nscaling_driver\t\t\tr\t# cpufreq driver name\naffected_cpus\t\t\tr\t# cpu\nrelated_cpus\t\t\tr\t# <?>\nscaling_cur_freq\t\trw\t# cur freq\nscaling_min_freq\t\trw\t# min freq limit\nscaling_max_freq\t\trw\t# max freq limit\nscaling_governor\t\trw\t# selected governor\nscaling_available_governors\tr\t# available governors\nscaling_setspeed\t\tr\t# <not supported>\ncpuinfo_min_freq\t\tr\t# hardware min freq\ncpuinfo_max_freq\t\tr\t# hardware max freq\ncpuinfo_transition_latency\tr\t# hardware latency\n```\n\n\n\n## Governors\n\n\n\nGovernor负责从系统收集信息，并触发调频动作。\n\n**powersave**\n\nalways lowest frequency\n\n**performance**\n\nalways highest frequency\n\n**schedutil**\n\nuses CPU utilization data from scheduler to determine target frequence\n\n待完成\n\n**userspace**\n\nallow user space set the frequency\n\n**ondemand**\n\nuses CPU load as a CPU frequency selection metric\n\nit reaches the target by CPU load, 0->min, 100->max\n\n**conservative**\n\nuses CPU load as a CPU frequency selection metric\n\nit reaches the target step by step, up_threshold->up, down_threshold->down\n\n## Files\n\n\n\n```\n- /drivers/cpufreq/cpufreq.c\n- /drivers/cpufreq/cpufreq-dt.c\n- /drivers/cpufreq/cpufreq_stats.c\n- /drivers/cpufreq/cpufreq_conservative.c\n- /drivers/cpufreq/cpufreq_governor.c\n- /drivers/cpufreq/cpufreq_ondemand.c\n- /drivers/cpufreq/cpufreq_powersave.c\n- /drivers/cpufreq/cpufreq_performance.c\n- /drivers/cpufreq/cpufreq_userspace.c\n- /kernel/sched/cpufreq_schedutil.c\n- /kernel/power/qos.c\n```\n\n## rk3588-cpufreq-sys\n\n>查看cpufreq节点\n>RK3588的cpu是4个A55+4个A76，分为3组单独管理，节点分别是：\n>/sys/devices/system/cpu/cpufreq/policy0:（对应4个A55：CPU0-3）\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed\n>\n>/sys/devices/system/cpu/cpufreq/policy4:(对应2个A76：CPU4-5)\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed\n>\n>/sys/devices/system/cpu/cpufreq/policy6:(对应2个A76：CPU6-7)\n>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats\n>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_drive\n>                        \n>\n>CPU性能模式\n>echo performance > /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>获取cpu运行的模式\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_available_governors\n>获取当前CPU支持的频点\n>cat /sys/devices/system/cpu/cpufreq/policy6/scaling_available_frequencies\n>\n>cat /sys/devices/system/cpu/cpufreq/policy6/cpuinfo_cur_freq       \n>\n>\n>2.0设置cpufrq为performance模式\n>echo performance > /sys/devices/system/cpu/cpufreq/policy0/scaling_governor\n>echo performance > /sys/devices/system/cpu/cpufreq/policy4/scaling_governor\n>echo performance > /sys/devices/system/cpu/cpufreq/policy6/scaling_governor\n>\n>查看模式\n>cat /sys/devices/system/cpu/cpufreq/policy*/scaling_governor\n>查看频率\n>cat /sys/devices/system/cpu/cpufreq/policy*/cpuinfo_cur_freq       \n\n## rk3588-cpufreq-code\n\n![cpufreq framework](../imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif)\n\n相关文件\n\nkernel/drivers/cpufreq/cpufreq.c\n\nkernel/drivers/cpufreq/rockchip-cpufreq.c\n\nkernel/drivers/cpufreq/cpufreq-dt-platdev.c\n\nkernel/drivers/cpufreq/cpufreq-dt.c\n\n```\nCONFIG_CPU_FREQ=y\nCONFIG_CPU_FREQ_STAT=y\nCONFIG_CPU_FREQ_TIMES=y\nCONFIG_CPU_FREQ_GOV_POWERSAVE=y\nCONFIG_CPU_FREQ_GOV_USERSPACE=y\nCONFIG_CPU_FREQ_GOV_ONDEMAND=y\nCONFIG_CPU_FREQ_GOV_CONSERVATIVE=y\nCONFIG_CPU_FREQ_GOV_INTERACTIVE=y\nCONFIG_CPU_FREQ_GOV_PERFORMANCE=y\nCONFIG_CPU_FREQ_GOV_COMMON=y\nCONFIG_CPU_FREQ_GOV_ATTR_SET=y\nCONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y\nCONFIG_CPUFREQ_DT=y\n```\n\n\n\n### 1. CPUFreq核心和接口\n\ncpufreq代码为CPUFreq架构的驱 动程序（那些执行硬件频率切换的代码）以及 “通知器” 提供了一个标准化的接口。 包括设备驱动程序；需要了解策略变化（如 ACPI 热量管理），或所有频率变化（如计时代码）， 甚至需要强制限制为指定频率（如 ARM 架构上的 LCD 驱动程序）的其它内核组件。 此外，内核 “常数” loops_per_jiffy 会根据频率变化而更新。\n\ncpufreq策略的引用计数由 cpufreq_cpu_get 和 cpufreq_cpu_put 来完成，以确保 cpufreq 驱 动程序被正确地注册到核心中，并且驱动程序在 cpufreq_put_cpu 被调用之前不会被卸载。这也保证 了每个CPU核的cpufreq 策略在使用期间不会被释放。\n\n### 2. CPUFreq 通知器\n\nCPUFreq通知器遵循标准的内核通知器接口。 关于通知器的细节请参阅 linux/include/linux/notifier.h。\n\n这里有两个不同的CPUfreq通知器 - 策略通知器和转换通知器。\n\n#### 2.1 CPUFreq策略通知器\n\n当创建或移除策略时，这些都会被通知。\n\n阶段是在通知器的第二个参数中指定的。当第一次创建策略时，阶段是CPUFREQ_CREATE_POLICY，当 策略被移除时，阶段是CPUFREQ_REMOVE_POLICY。\n\n第三个参数 `void *pointer` 指向一个结构体cpufreq_policy，其包括min，max(新策略的下限和 上限（单位为kHz）)这几个值。\n\n#### 2.2 CPUFreq转换通知器\n\n当CPUfreq驱动切换CPU核心频率时，策略中的每个在线CPU都会收到两次通知，这些变化没有任何外部干 预。\n\n第二个参数指定阶段 - CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.\n\n第三个参数是一个包含如下值的结构体cpufreq_freqs：\n\n| policy | 指向struct cpufreq_policy的指针 |\n| ------ | ------------------------------- |\n| old    | 旧频率                          |\n| new    | 新频率                          |\n| flags  | cpufreq驱动的标志               |\n\n\n\n\n\n```\ncore_initcall(cpufreq_core_init);\n\tcpufreq_default_governor\t\t//获取默认的cpufreq策略 如schedutil powersave performace等\n\tkobject_create_and_add\t\t\t//创建sys/devices/system/cpu/cpufreq接口\n\t\n```\n\n\n\n```\nmodule_init(rockchip_cpufreq_driver_init)\n\tfor_each_possible_cpu\n\trockchip_cluster_info_lookup\n\trockchip_cpufreq_cluster_init\n\tcpufreq_register_notifier\t\t//注册通知CPUFREQ_POLICY_NOTYFIER  CPUFREQ_TRANSITION_NOTIFIER \n\t\trockchip_cpufreq_notifier\n\t\t\trockchip_cpufreq_add_monitor\n\t\t\t\trockchip_system_monitor_register\n```\n\n\n\n```\n#define for_each_cpu(cpu, mask)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\\\n\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n\t\t\n#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)\n\n\n/* Valid inputs for n are -1 and 0. */\nstatic inline unsigned int cpumask_next(int n, const struct cpumask *srcp)\n{\n\treturn n+1;\n}\n\n#if NR_CPUS == 1\n#define nr_cpu_ids\t\t1U\n#else\nextern unsigned int nr_cpu_ids;\n#endif\n```\n\n\n\n```\ndt_cpufreq_probe\n\tcpufreq_register_driver\n\t\tsubsys_interface_register \n\t\t\tcpufreq_interface\n\t\t\tcpufreq_add_dev\n\t\t\t\tcpufreq_online\n\t\t\t\t\tcpufreq_add_policy_cpu\n\t\t\t\t\t\tcpufreq_start_governor\n```\n\n\n\n\n\n## Reference\n\nhttps://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html\n\nhttps://docs.kernel.org/scheduler/schedutil.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_overview.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_driver.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_core.html\n\nhttp://www.wowotech.net/pm_subsystem/cpufreq_governor.html\n\n module_init()加载顺序 \n\nhttps://blog.csdn.net/shafa00419/article/details/85234867)","slug":"cpufreq","published":1,"updated":"2024-06-06T11:39:43.154Z","_id":"clvjcoaas0005r9w0fujveufw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>[toc]</p>\n<h1 id=\"cpufreq\"><a href=\"#cpufreq\" class=\"headerlink\" title=\"cpufreq\"></a>cpufreq</h1><p>CPUFreq框架是内核的CPU调频框架，整个调频框架由以下几个部分组成：</p>\n<ul>\n<li>cpufreq driver</li>\n<li>cpufreq framework (core)</li>\n<li>cpufreq governor</li>\n</ul>\n<p>一些基本概念：</p>\n<p>P-state: voltage and frequency point</p>\n<p>总体上，CPU Freq主要在sysfs向userspace提供了调频操作和策略设置节点。当使用一些自动调频的governor时，允许governor从系统获取信息，自动触发调频动作。</p>\n<p>另外，还向其他模块提供了qos频率投票，以及调频事件的notifier机制。</p>\n<p>下面分开来看每个部分。</p>\n<h2 id=\"Driver\"><a href=\"#Driver\" class=\"headerlink\" title=\"Driver\"></a>Driver</h2><p>Cpufreq Driver主要负责底层调频的操作，核心是实现 <code>cpufreq_dirver</code> 对象，并通过 <code>cpufreq_register_driver</code> 将驱动注册到系统，供core部分使用。</p>\n<p>其中，最核心的几个回调包括：</p>\n<ul>\n<li>online: hotplug callback</li>\n<li>offline: hotplug callback</li>\n<li>target_index: set freq</li>\n<li>set_boost: enter into boost mode</li>\n</ul>\n<p>以 <code>mediatek-cpufreq-hw.c</code> 为例，其freq table保存在硬件寄存器中，driver初始化时，从硬件中读出freq table，并实现相关调频回调，最终注册到core。</p>\n<p>db845c使用的 <code>qcom-cpufreq-hw.c</code> 为例，其freq table保存在dts中，driver使用OPP框架来读取这些配置，并实现cpufreq回调。</p>\n<p>* OPP（Operating Performance Point，提供dts的freq-valt-table配置，及获取接口。</p>\n<h2 id=\"Core\"><a href=\"#Core\" class=\"headerlink\" title=\"Core\"></a>Core</h2><p>Core部分核心文件是 <code>/drivers/cpufreq/cpufreq.c</code></p>\n<p>这个文件主要实现了BOOST，DRIVER，SYSFS，FREQ，NOTIFIER，GOVERNOR，POLICY相关功能的操作接口。</p>\n<p><code>cpufreq_register_driver</code> (cpufreq_driver* cpufreq_driver)</p>\n<p><code>cpufreq_register_governor</code> (cpufreq_governor_list)</p>\n<p><code>cpufreq_register_notifier</code> (cpufreq_transition_notifier_list)</p>\n<p><code>cpufreq_policy_alloc</code> (cpufreq_policy* PERCPU:cpufreq_cpu_data)</p>\n<p><code>cpufreq_policy</code> 是一个调频实体，对应一个调频域（freq domain），一般为一个cluster，这个结构保存了每个调频实体（通常是一个cluster）调频相关的所有私有信息。同时，他作为调频操作的句柄，cpufreq顶层操作接口使用policy来对一个调频实体进行操作。</p>\n<p>每个CPU有一个percpu的指针指向其所属的policy，cluster中的多个CPU共享一个policy。（<code>cpufreq_cpu_data</code>）</p>\n<p>Mainflow：</p>\n<p>1、cpufreq driver注册</p>\n<p>2、governor注册（每个policy初始化自己的governor）</p>\n<p>3、cpu hotplug state: “cpufreq:online”，<code>cpuhp_cpufreq_online</code>、<code>cpuhp_cpufreq_offline</code>，创建出percpu policy，绑定driver、governor</p>\n<p>4、向sysfs创建节点，提供功能</p>\n<p>5、governor开始工作，通过 <code>__cpufreq_driver_target</code> 进行调频。</p>\n<ul>\n<li>Qos是调频投票机制，用来实现max_freq、min_freq limitation。(<code>cpufreq_notifier_min</code> <code>cpufreq_notifier_max</code>)，在其他module有需求投票后，freq constrants会被更新。</li>\n</ul>\n<h2 id=\"Sysfs\"><a href=\"#Sysfs\" class=\"headerlink\" title=\"Sysfs\"></a>Sysfs</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sys/devices/system/cpu/cpu0/cpufreq/policyX</span><br><span class=\"line\">scaling_driver\t\t\tr\t# cpufreq driver name</span><br><span class=\"line\">affected_cpus\t\t\tr\t# cpu</span><br><span class=\"line\">related_cpus\t\t\tr\t# &lt;?&gt;</span><br><span class=\"line\">scaling_cur_freq\t\trw\t# cur freq</span><br><span class=\"line\">scaling_min_freq\t\trw\t# min freq limit</span><br><span class=\"line\">scaling_max_freq\t\trw\t# max freq limit</span><br><span class=\"line\">scaling_governor\t\trw\t# selected governor</span><br><span class=\"line\">scaling_available_governors\tr\t# available governors</span><br><span class=\"line\">scaling_setspeed\t\tr\t# &lt;not supported&gt;</span><br><span class=\"line\">cpuinfo_min_freq\t\tr\t# hardware min freq</span><br><span class=\"line\">cpuinfo_max_freq\t\tr\t# hardware max freq</span><br><span class=\"line\">cpuinfo_transition_latency\tr\t# hardware latency</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Governors\"><a href=\"#Governors\" class=\"headerlink\" title=\"Governors\"></a>Governors</h2><p>Governor负责从系统收集信息，并触发调频动作。</p>\n<p><strong>powersave</strong></p>\n<p>always lowest frequency</p>\n<p><strong>performance</strong></p>\n<p>always highest frequency</p>\n<p><strong>schedutil</strong></p>\n<p>uses CPU utilization data from scheduler to determine target frequence</p>\n<p>待完成</p>\n<p><strong>userspace</strong></p>\n<p>allow user space set the frequency</p>\n<p><strong>ondemand</strong></p>\n<p>uses CPU load as a CPU frequency selection metric</p>\n<p>it reaches the target by CPU load, 0-&gt;min, 100-&gt;max</p>\n<p><strong>conservative</strong></p>\n<p>uses CPU load as a CPU frequency selection metric</p>\n<p>it reaches the target step by step, up_threshold-&gt;up, down_threshold-&gt;down</p>\n<h2 id=\"Files\"><a href=\"#Files\" class=\"headerlink\" title=\"Files\"></a>Files</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- /drivers/cpufreq/cpufreq.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq-dt.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_stats.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_conservative.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_governor.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_ondemand.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_powersave.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_performance.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_userspace.c</span><br><span class=\"line\">- /kernel/sched/cpufreq_schedutil.c</span><br><span class=\"line\">- /kernel/power/qos.c</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rk3588-cpufreq-sys\"><a href=\"#rk3588-cpufreq-sys\" class=\"headerlink\" title=\"rk3588-cpufreq-sys\"></a>rk3588-cpufreq-sys</h2><blockquote>\n<p>查看cpufreq节点<br>RK3588的cpu是4个A55+4个A76，分为3组单独管理，节点分别是：<br>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy0:（对应4个A55：CPU0-3）<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed</p>\n<p>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy4:(对应2个A76：CPU4-5)<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed</p>\n<p>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6:(对应2个A76：CPU6-7)<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_drive</p>\n<p>CPU性能模式<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor<br>获取cpu运行的模式<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_available_governors<br>获取当前CPU支持的频点<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_available_frequencies</p>\n<p>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;cpuinfo_cur_freq       </p>\n<p>2.0设置cpufrq为performance模式<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy0&#x2F;scaling_governor<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy4&#x2F;scaling_governor<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor</p>\n<p>查看模式<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy*&#x2F;scaling_governor<br>查看频率<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy*&#x2F;cpuinfo_cur_freq       </p>\n</blockquote>\n<h2 id=\"rk3588-cpufreq-code\"><a href=\"#rk3588-cpufreq-code\" class=\"headerlink\" title=\"rk3588-cpufreq-code\"></a>rk3588-cpufreq-code</h2><p><img src=\"/../imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif\" alt=\"cpufreq framework\"></p>\n<p>相关文件</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;rockchip-cpufreq.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq-dt-platdev.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq-dt.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_CPU_FREQ=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_STAT=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_TIMES=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_POWERSAVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_USERSPACE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_ONDEMAND=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_INTERACTIVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_PERFORMANCE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_COMMON=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_ATTR_SET=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y</span><br><span class=\"line\">CONFIG_CPUFREQ_DT=y</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"1-CPUFreq核心和接口\"><a href=\"#1-CPUFreq核心和接口\" class=\"headerlink\" title=\"1. CPUFreq核心和接口\"></a>1. CPUFreq核心和接口</h3><p>cpufreq代码为CPUFreq架构的驱 动程序（那些执行硬件频率切换的代码）以及 “通知器” 提供了一个标准化的接口。 包括设备驱动程序；需要了解策略变化（如 ACPI 热量管理），或所有频率变化（如计时代码）， 甚至需要强制限制为指定频率（如 ARM 架构上的 LCD 驱动程序）的其它内核组件。 此外，内核 “常数” loops_per_jiffy 会根据频率变化而更新。</p>\n<p>cpufreq策略的引用计数由 cpufreq_cpu_get 和 cpufreq_cpu_put 来完成，以确保 cpufreq 驱 动程序被正确地注册到核心中，并且驱动程序在 cpufreq_put_cpu 被调用之前不会被卸载。这也保证 了每个CPU核的cpufreq 策略在使用期间不会被释放。</p>\n<h3 id=\"2-CPUFreq-通知器\"><a href=\"#2-CPUFreq-通知器\" class=\"headerlink\" title=\"2. CPUFreq 通知器\"></a>2. CPUFreq 通知器</h3><p>CPUFreq通知器遵循标准的内核通知器接口。 关于通知器的细节请参阅 linux&#x2F;include&#x2F;linux&#x2F;notifier.h。</p>\n<p>这里有两个不同的CPUfreq通知器 - 策略通知器和转换通知器。</p>\n<h4 id=\"2-1-CPUFreq策略通知器\"><a href=\"#2-1-CPUFreq策略通知器\" class=\"headerlink\" title=\"2.1 CPUFreq策略通知器\"></a>2.1 CPUFreq策略通知器</h4><p>当创建或移除策略时，这些都会被通知。</p>\n<p>阶段是在通知器的第二个参数中指定的。当第一次创建策略时，阶段是CPUFREQ_CREATE_POLICY，当 策略被移除时，阶段是CPUFREQ_REMOVE_POLICY。</p>\n<p>第三个参数 <code>void *pointer</code> 指向一个结构体cpufreq_policy，其包括min，max(新策略的下限和 上限（单位为kHz）)这几个值。</p>\n<h4 id=\"2-2-CPUFreq转换通知器\"><a href=\"#2-2-CPUFreq转换通知器\" class=\"headerlink\" title=\"2.2 CPUFreq转换通知器\"></a>2.2 CPUFreq转换通知器</h4><p>当CPUfreq驱动切换CPU核心频率时，策略中的每个在线CPU都会收到两次通知，这些变化没有任何外部干 预。</p>\n<p>第二个参数指定阶段 - CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.</p>\n<p>第三个参数是一个包含如下值的结构体cpufreq_freqs：</p>\n<table>\n<thead>\n<tr>\n<th>policy</th>\n<th>指向struct cpufreq_policy的指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>old</td>\n<td>旧频率</td>\n</tr>\n<tr>\n<td>new</td>\n<td>新频率</td>\n</tr>\n<tr>\n<td>flags</td>\n<td>cpufreq驱动的标志</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">core_initcall(cpufreq_core_init);</span><br><span class=\"line\">\tcpufreq_default_governor\t\t//获取默认的cpufreq策略 如schedutil powersave performace等</span><br><span class=\"line\">\tkobject_create_and_add\t\t\t//创建sys/devices/system/cpu/cpufreq接口</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module_init(rockchip_cpufreq_driver_init)</span><br><span class=\"line\">\tfor_each_possible_cpu</span><br><span class=\"line\">\trockchip_cluster_info_lookup</span><br><span class=\"line\">\trockchip_cpufreq_cluster_init</span><br><span class=\"line\">\tcpufreq_register_notifier\t\t//注册通知CPUFREQ_POLICY_NOTYFIER  CPUFREQ_TRANSITION_NOTIFIER </span><br><span class=\"line\">\t\trockchip_cpufreq_notifier</span><br><span class=\"line\">\t\t\trockchip_cpufreq_add_monitor</span><br><span class=\"line\">\t\t\t\trockchip_system_monitor_register</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define for_each_cpu(cpu, mask)\t\t\t\t\\</span><br><span class=\"line\">\tfor ((cpu) = -1;\t\t\t\t\\</span><br><span class=\"line\">\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\</span><br><span class=\"line\">\t\t(cpu) &lt; nr_cpu_ids;)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/* Valid inputs for n are -1 and 0. */</span><br><span class=\"line\">static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn n+1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#if NR_CPUS == 1</span><br><span class=\"line\">#define nr_cpu_ids\t\t1U</span><br><span class=\"line\">#else</span><br><span class=\"line\">extern unsigned int nr_cpu_ids;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dt_cpufreq_probe</span><br><span class=\"line\">\tcpufreq_register_driver</span><br><span class=\"line\">\t\tsubsys_interface_register </span><br><span class=\"line\">\t\t\tcpufreq_interface</span><br><span class=\"line\">\t\t\tcpufreq_add_dev</span><br><span class=\"line\">\t\t\t\tcpufreq_online</span><br><span class=\"line\">\t\t\t\t\tcpufreq_add_policy_cpu</span><br><span class=\"line\">\t\t\t\t\t\tcpufreq_start_governor</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html\">https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html</a></p>\n<p><a href=\"https://docs.kernel.org/scheduler/schedutil.html\">https://docs.kernel.org/scheduler/schedutil.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_overview.html\">http://www.wowotech.net/pm_subsystem/cpufreq_overview.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_driver.html\">http://www.wowotech.net/pm_subsystem/cpufreq_driver.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_core.html\">http://www.wowotech.net/pm_subsystem/cpufreq_core.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_governor.html\">http://www.wowotech.net/pm_subsystem/cpufreq_governor.html</a></p>\n<p> module_init()加载顺序 </p>\n<p><a href=\"https://blog.csdn.net/shafa00419/article/details/85234867\">https://blog.csdn.net/shafa00419/article/details/85234867</a>)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"cpufreq\"><a href=\"#cpufreq\" class=\"headerlink\" title=\"cpufreq\"></a>cpufreq</h1><p>CPUFreq框架是内核的CPU调频框架，整个调频框架由以下几个部分组成：</p>\n<ul>\n<li>cpufreq driver</li>\n<li>cpufreq framework (core)</li>\n<li>cpufreq governor</li>\n</ul>\n<p>一些基本概念：</p>\n<p>P-state: voltage and frequency point</p>\n<p>总体上，CPU Freq主要在sysfs向userspace提供了调频操作和策略设置节点。当使用一些自动调频的governor时，允许governor从系统获取信息，自动触发调频动作。</p>\n<p>另外，还向其他模块提供了qos频率投票，以及调频事件的notifier机制。</p>\n<p>下面分开来看每个部分。</p>\n<h2 id=\"Driver\"><a href=\"#Driver\" class=\"headerlink\" title=\"Driver\"></a>Driver</h2><p>Cpufreq Driver主要负责底层调频的操作，核心是实现 <code>cpufreq_dirver</code> 对象，并通过 <code>cpufreq_register_driver</code> 将驱动注册到系统，供core部分使用。</p>\n<p>其中，最核心的几个回调包括：</p>\n<ul>\n<li>online: hotplug callback</li>\n<li>offline: hotplug callback</li>\n<li>target_index: set freq</li>\n<li>set_boost: enter into boost mode</li>\n</ul>\n<p>以 <code>mediatek-cpufreq-hw.c</code> 为例，其freq table保存在硬件寄存器中，driver初始化时，从硬件中读出freq table，并实现相关调频回调，最终注册到core。</p>\n<p>db845c使用的 <code>qcom-cpufreq-hw.c</code> 为例，其freq table保存在dts中，driver使用OPP框架来读取这些配置，并实现cpufreq回调。</p>\n<p>* OPP（Operating Performance Point，提供dts的freq-valt-table配置，及获取接口。</p>\n<h2 id=\"Core\"><a href=\"#Core\" class=\"headerlink\" title=\"Core\"></a>Core</h2><p>Core部分核心文件是 <code>/drivers/cpufreq/cpufreq.c</code></p>\n<p>这个文件主要实现了BOOST，DRIVER，SYSFS，FREQ，NOTIFIER，GOVERNOR，POLICY相关功能的操作接口。</p>\n<p><code>cpufreq_register_driver</code> (cpufreq_driver* cpufreq_driver)</p>\n<p><code>cpufreq_register_governor</code> (cpufreq_governor_list)</p>\n<p><code>cpufreq_register_notifier</code> (cpufreq_transition_notifier_list)</p>\n<p><code>cpufreq_policy_alloc</code> (cpufreq_policy* PERCPU:cpufreq_cpu_data)</p>\n<p><code>cpufreq_policy</code> 是一个调频实体，对应一个调频域（freq domain），一般为一个cluster，这个结构保存了每个调频实体（通常是一个cluster）调频相关的所有私有信息。同时，他作为调频操作的句柄，cpufreq顶层操作接口使用policy来对一个调频实体进行操作。</p>\n<p>每个CPU有一个percpu的指针指向其所属的policy，cluster中的多个CPU共享一个policy。（<code>cpufreq_cpu_data</code>）</p>\n<p>Mainflow：</p>\n<p>1、cpufreq driver注册</p>\n<p>2、governor注册（每个policy初始化自己的governor）</p>\n<p>3、cpu hotplug state: “cpufreq:online”，<code>cpuhp_cpufreq_online</code>、<code>cpuhp_cpufreq_offline</code>，创建出percpu policy，绑定driver、governor</p>\n<p>4、向sysfs创建节点，提供功能</p>\n<p>5、governor开始工作，通过 <code>__cpufreq_driver_target</code> 进行调频。</p>\n<ul>\n<li>Qos是调频投票机制，用来实现max_freq、min_freq limitation。(<code>cpufreq_notifier_min</code> <code>cpufreq_notifier_max</code>)，在其他module有需求投票后，freq constrants会被更新。</li>\n</ul>\n<h2 id=\"Sysfs\"><a href=\"#Sysfs\" class=\"headerlink\" title=\"Sysfs\"></a>Sysfs</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sys/devices/system/cpu/cpu0/cpufreq/policyX</span><br><span class=\"line\">scaling_driver\t\t\tr\t# cpufreq driver name</span><br><span class=\"line\">affected_cpus\t\t\tr\t# cpu</span><br><span class=\"line\">related_cpus\t\t\tr\t# &lt;?&gt;</span><br><span class=\"line\">scaling_cur_freq\t\trw\t# cur freq</span><br><span class=\"line\">scaling_min_freq\t\trw\t# min freq limit</span><br><span class=\"line\">scaling_max_freq\t\trw\t# max freq limit</span><br><span class=\"line\">scaling_governor\t\trw\t# selected governor</span><br><span class=\"line\">scaling_available_governors\tr\t# available governors</span><br><span class=\"line\">scaling_setspeed\t\tr\t# &lt;not supported&gt;</span><br><span class=\"line\">cpuinfo_min_freq\t\tr\t# hardware min freq</span><br><span class=\"line\">cpuinfo_max_freq\t\tr\t# hardware max freq</span><br><span class=\"line\">cpuinfo_transition_latency\tr\t# hardware latency</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Governors\"><a href=\"#Governors\" class=\"headerlink\" title=\"Governors\"></a>Governors</h2><p>Governor负责从系统收集信息，并触发调频动作。</p>\n<p><strong>powersave</strong></p>\n<p>always lowest frequency</p>\n<p><strong>performance</strong></p>\n<p>always highest frequency</p>\n<p><strong>schedutil</strong></p>\n<p>uses CPU utilization data from scheduler to determine target frequence</p>\n<p>待完成</p>\n<p><strong>userspace</strong></p>\n<p>allow user space set the frequency</p>\n<p><strong>ondemand</strong></p>\n<p>uses CPU load as a CPU frequency selection metric</p>\n<p>it reaches the target by CPU load, 0-&gt;min, 100-&gt;max</p>\n<p><strong>conservative</strong></p>\n<p>uses CPU load as a CPU frequency selection metric</p>\n<p>it reaches the target step by step, up_threshold-&gt;up, down_threshold-&gt;down</p>\n<h2 id=\"Files\"><a href=\"#Files\" class=\"headerlink\" title=\"Files\"></a>Files</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- /drivers/cpufreq/cpufreq.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq-dt.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_stats.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_conservative.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_governor.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_ondemand.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_powersave.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_performance.c</span><br><span class=\"line\">- /drivers/cpufreq/cpufreq_userspace.c</span><br><span class=\"line\">- /kernel/sched/cpufreq_schedutil.c</span><br><span class=\"line\">- /kernel/power/qos.c</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rk3588-cpufreq-sys\"><a href=\"#rk3588-cpufreq-sys\" class=\"headerlink\" title=\"rk3588-cpufreq-sys\"></a>rk3588-cpufreq-sys</h2><blockquote>\n<p>查看cpufreq节点<br>RK3588的cpu是4个A55+4个A76，分为3组单独管理，节点分别是：<br>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy0:（对应4个A55：CPU0-3）<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed</p>\n<p>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy4:(对应2个A76：CPU4-5)<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_driver    scaling_max_freq  scaling_setspeed</p>\n<p>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6:(对应2个A76：CPU6-7)<br>affected_cpus     cpuinfo_max_freq  cpuinfo_transition_latency  scaling_available_frequencies  scaling_cur_freq  scaling_governor  scaling_min_freq  stats<br>cpuinfo_cur_freq  cpuinfo_min_freq  related_cpus                scaling_available_governors    scaling_drive</p>\n<p>CPU性能模式<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor<br>获取cpu运行的模式<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_available_governors<br>获取当前CPU支持的频点<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_available_frequencies</p>\n<p>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;cpuinfo_cur_freq       </p>\n<p>2.0设置cpufrq为performance模式<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy0&#x2F;scaling_governor<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy4&#x2F;scaling_governor<br>echo performance &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy6&#x2F;scaling_governor</p>\n<p>查看模式<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy*&#x2F;scaling_governor<br>查看频率<br>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;policy*&#x2F;cpuinfo_cur_freq       </p>\n</blockquote>\n<h2 id=\"rk3588-cpufreq-code\"><a href=\"#rk3588-cpufreq-code\" class=\"headerlink\" title=\"rk3588-cpufreq-code\"></a>rk3588-cpufreq-code</h2><p><img src=\"/../imgs/f613cfd922113b82148afb75eb6edc0f20150613141951.gif\" alt=\"cpufreq framework\"></p>\n<p>相关文件</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;rockchip-cpufreq.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq-dt-platdev.c</p>\n<p>kernel&#x2F;drivers&#x2F;cpufreq&#x2F;cpufreq-dt.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONFIG_CPU_FREQ=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_STAT=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_TIMES=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_POWERSAVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_USERSPACE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_ONDEMAND=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_INTERACTIVE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_PERFORMANCE=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_COMMON=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_GOV_ATTR_SET=y</span><br><span class=\"line\">CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y</span><br><span class=\"line\">CONFIG_CPUFREQ_DT=y</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"1-CPUFreq核心和接口\"><a href=\"#1-CPUFreq核心和接口\" class=\"headerlink\" title=\"1. CPUFreq核心和接口\"></a>1. CPUFreq核心和接口</h3><p>cpufreq代码为CPUFreq架构的驱 动程序（那些执行硬件频率切换的代码）以及 “通知器” 提供了一个标准化的接口。 包括设备驱动程序；需要了解策略变化（如 ACPI 热量管理），或所有频率变化（如计时代码）， 甚至需要强制限制为指定频率（如 ARM 架构上的 LCD 驱动程序）的其它内核组件。 此外，内核 “常数” loops_per_jiffy 会根据频率变化而更新。</p>\n<p>cpufreq策略的引用计数由 cpufreq_cpu_get 和 cpufreq_cpu_put 来完成，以确保 cpufreq 驱 动程序被正确地注册到核心中，并且驱动程序在 cpufreq_put_cpu 被调用之前不会被卸载。这也保证 了每个CPU核的cpufreq 策略在使用期间不会被释放。</p>\n<h3 id=\"2-CPUFreq-通知器\"><a href=\"#2-CPUFreq-通知器\" class=\"headerlink\" title=\"2. CPUFreq 通知器\"></a>2. CPUFreq 通知器</h3><p>CPUFreq通知器遵循标准的内核通知器接口。 关于通知器的细节请参阅 linux&#x2F;include&#x2F;linux&#x2F;notifier.h。</p>\n<p>这里有两个不同的CPUfreq通知器 - 策略通知器和转换通知器。</p>\n<h4 id=\"2-1-CPUFreq策略通知器\"><a href=\"#2-1-CPUFreq策略通知器\" class=\"headerlink\" title=\"2.1 CPUFreq策略通知器\"></a>2.1 CPUFreq策略通知器</h4><p>当创建或移除策略时，这些都会被通知。</p>\n<p>阶段是在通知器的第二个参数中指定的。当第一次创建策略时，阶段是CPUFREQ_CREATE_POLICY，当 策略被移除时，阶段是CPUFREQ_REMOVE_POLICY。</p>\n<p>第三个参数 <code>void *pointer</code> 指向一个结构体cpufreq_policy，其包括min，max(新策略的下限和 上限（单位为kHz）)这几个值。</p>\n<h4 id=\"2-2-CPUFreq转换通知器\"><a href=\"#2-2-CPUFreq转换通知器\" class=\"headerlink\" title=\"2.2 CPUFreq转换通知器\"></a>2.2 CPUFreq转换通知器</h4><p>当CPUfreq驱动切换CPU核心频率时，策略中的每个在线CPU都会收到两次通知，这些变化没有任何外部干 预。</p>\n<p>第二个参数指定阶段 - CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.</p>\n<p>第三个参数是一个包含如下值的结构体cpufreq_freqs：</p>\n<table>\n<thead>\n<tr>\n<th>policy</th>\n<th>指向struct cpufreq_policy的指针</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>old</td>\n<td>旧频率</td>\n</tr>\n<tr>\n<td>new</td>\n<td>新频率</td>\n</tr>\n<tr>\n<td>flags</td>\n<td>cpufreq驱动的标志</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">core_initcall(cpufreq_core_init);</span><br><span class=\"line\">\tcpufreq_default_governor\t\t//获取默认的cpufreq策略 如schedutil powersave performace等</span><br><span class=\"line\">\tkobject_create_and_add\t\t\t//创建sys/devices/system/cpu/cpufreq接口</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module_init(rockchip_cpufreq_driver_init)</span><br><span class=\"line\">\tfor_each_possible_cpu</span><br><span class=\"line\">\trockchip_cluster_info_lookup</span><br><span class=\"line\">\trockchip_cpufreq_cluster_init</span><br><span class=\"line\">\tcpufreq_register_notifier\t\t//注册通知CPUFREQ_POLICY_NOTYFIER  CPUFREQ_TRANSITION_NOTIFIER </span><br><span class=\"line\">\t\trockchip_cpufreq_notifier</span><br><span class=\"line\">\t\t\trockchip_cpufreq_add_monitor</span><br><span class=\"line\">\t\t\t\trockchip_system_monitor_register</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define for_each_cpu(cpu, mask)\t\t\t\t\\</span><br><span class=\"line\">\tfor ((cpu) = -1;\t\t\t\t\\</span><br><span class=\"line\">\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\</span><br><span class=\"line\">\t\t(cpu) &lt; nr_cpu_ids;)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/* Valid inputs for n are -1 and 0. */</span><br><span class=\"line\">static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn n+1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#if NR_CPUS == 1</span><br><span class=\"line\">#define nr_cpu_ids\t\t1U</span><br><span class=\"line\">#else</span><br><span class=\"line\">extern unsigned int nr_cpu_ids;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dt_cpufreq_probe</span><br><span class=\"line\">\tcpufreq_register_driver</span><br><span class=\"line\">\t\tsubsys_interface_register </span><br><span class=\"line\">\t\t\tcpufreq_interface</span><br><span class=\"line\">\t\t\tcpufreq_add_dev</span><br><span class=\"line\">\t\t\t\tcpufreq_online</span><br><span class=\"line\">\t\t\t\t\tcpufreq_add_policy_cpu</span><br><span class=\"line\">\t\t\t\t\t\tcpufreq_start_governor</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html\">https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html</a></p>\n<p><a href=\"https://docs.kernel.org/scheduler/schedutil.html\">https://docs.kernel.org/scheduler/schedutil.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_overview.html\">http://www.wowotech.net/pm_subsystem/cpufreq_overview.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_driver.html\">http://www.wowotech.net/pm_subsystem/cpufreq_driver.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_core.html\">http://www.wowotech.net/pm_subsystem/cpufreq_core.html</a></p>\n<p><a href=\"http://www.wowotech.net/pm_subsystem/cpufreq_governor.html\">http://www.wowotech.net/pm_subsystem/cpufreq_governor.html</a></p>\n<p> module_init()加载顺序 </p>\n<p><a href=\"https://blog.csdn.net/shafa00419/article/details/85234867\">https://blog.csdn.net/shafa00419/article/details/85234867</a>)</p>\n"},{"title":"Hello World","date":"2023-08-24T16:00:00.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2023-08-25 00:00:00\ncategories:\n- test\ntags:\n- test\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2024-04-28T07:13:38.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clvjcoaas0006r9w0ciswdc7c","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Hexo在多台电脑上提交和更新","date":"2023-09-13T07:35:30.000Z","_content":"\n[toc]\n\n\n\n# 1.博客搭建\n\nhttps://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\n\n# 2.创建一个新文件夹new，用于上传hexo博客目录\n\n将以下目录（除了红色方框的目录）拷贝到新目录中\n\n![image-20230913154437526](../imgs/image-20230913154437526.png)\n\n参考：https://blog.csdn.net/K1052176873/article/details/122879462 \n\n# 3.github上创建hexo分支并设置为默认分支\n\n## 创建hexo分支\n\n![image-20230913154510439](../imgs/image-20230913154510439.png)\n\n## 将hexo分支设置为默认分支\n\n![image-20230913154524492](../imgs/image-20230913154524492.png)\n\n# 4.进入新建的文件夹中git clone，再上传相关文件至hexo分支\n\n基本原理：github仓库开两个分支，main分支存放的是hexo生成的静态页面，hexo分支存放基本的 Hexo 博客项目的结构和默认配置文件，如文章，主题\n当需要重新搭建环境时，直接拉取hexo分支中Hexo博客目录以及相关配置文件，当需要更新博客时直接\n\n```\ncd new\ngit clone git@github.com:<username>/<username>.github.io.git #<username> 用户名\ngit branch    #查看分支，显示 * hexo\n```\n\n\n\n## 1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\n\n```\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n```\n\n## 2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录\n\n![image-20230913154559571](../imgs/image-20230913154559571.png)\n\n## 3.送new目录中的相关文件到远程仓库 hexo分支\n\n```\ngit add .\ngit commit –m add_branch\ngit push        \n\n```\n\n\n\n# 5.！新环境中快速搭建博客环境！\n\n## 1.设置ssh\n\n参考：https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\n\n```\nssh-keygen -t ed25519 -C \"your_email@gmail.com\"\ncat ~/.ssh/id_ed25519.pub  #将里面的内容复制到 github ->settings ->SSH and GPC keys ->SSH keys ->New SSH key中\nssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）\n#接着在本地绑定与Github的用户名和邮箱（git）\ngit config --global user.name \"<username>\"    #自己的用户名\ngit config --global user.email 'xxx@xxx.com'  #自己的邮箱\n```\n\n## 2.安装nodejs和hexo\n\n```\nsudo apt update\nsudo apt-get install git\n\nsudo apt install nodejs\nsudo apt install npm  \n```\n\n## 3.拉取hexo博客目录\n\n```\ngit clone git@github.com:<username>/<username>.github.io.git #<username> 用户名\ngit branch    #查看分支，显示 * hexo\nnpm install hexo\nnpm install\nnpm install hexo-deployer-git        #不需要hexo init这条指令\nnpm i hexo-renderer-marked\n\n\n#更新博客 添加新文章 hello-world\nhexo new \"hello-world\"\ngit add .        #将文章备份至 hexo分支  或者git add source/_posts/hello-world \ngit commit –m \"hello-world\"\ngit push         #或者git push origin hexo\n\nhexo g        #生成静态页面\nhexo s        #启动本地服务器 预览\nhexo d        #将生成的博客文件部署到 github main分支，Hexo博客项目配置文件中_config.yml已设置好\n```\n\n# 6.遇到的问题\n\n## 问题1.nodejs版本过低\n\nnpm WARN notsup Unsupported engine for hexo@6.3.0: wanted: {\"node\":\">=12.13.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo@6.3.0\nnpm WARN notsup Unsupported engine for hexo-front-matter@3.0.0: wanted: {\"node\":\">=12.13.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-front-matter@3.0.0\nnpm WARN notsup Unsupported engine for hexo-cli@4.3.1: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-cli@4.3.1\nnpm WARN notsup Unsupported engine for hexo-log@3.2.0: wanted: {\"node\":\">=12.4.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-log@3.2.0\nnpm WARN notsup Unsupported engine for abbrev@2.0.0: wanted: {\"node\":\"^14.17.0 || ^16.13.0 || >=18.0.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: abbrev@2.0.0\nnpm WARN notsup Unsupported engine for hexo-fs@4.1.1: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-fs@4.1.1\nnpm WARN notsup Unsupported engine for hexo-log@4.1.0: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-log@4.1.0\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.3 (node_modules/fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\n\n## 升级nodejs\n\n```\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash         #安装 nvm\nsource ~/.bashrc            #加载 nvm\nnvm install node            #使用 nvm 安装最新版本的 Node.js\nnode -v                     #验证 Node.js 版本\n```\n\n\n\n\n\n## 问题2.hexo博客图片不显示\n\nhttps://blog.csdn.net/QRLYLETITBE/article/details/127737904 \n\n```\nnpm i hexo-renderer-marked\n\n```\n\n## 新建imgs文件夹\n\n![image-20230913161638961](../imgs/image-20230913161638961.png)\n\n```\nmarked:\n  prependRoot: true\n  postAsset: true\n\n```\n## 修改图片路径\n\n![image-20230913161842174](../imgs/image-20230913161842174.png)\n","source":"_posts/Hexo在多台电脑上提交和更新.md","raw":"---\ntitle: Hexo在多台电脑上提交和更新\ndate: 2023-09-13 15:35:30\ncategories:\n- test\ntags:\n- test\n---\n\n[toc]\n\n\n\n# 1.博客搭建\n\nhttps://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\n\n# 2.创建一个新文件夹new，用于上传hexo博客目录\n\n将以下目录（除了红色方框的目录）拷贝到新目录中\n\n![image-20230913154437526](../imgs/image-20230913154437526.png)\n\n参考：https://blog.csdn.net/K1052176873/article/details/122879462 \n\n# 3.github上创建hexo分支并设置为默认分支\n\n## 创建hexo分支\n\n![image-20230913154510439](../imgs/image-20230913154510439.png)\n\n## 将hexo分支设置为默认分支\n\n![image-20230913154524492](../imgs/image-20230913154524492.png)\n\n# 4.进入新建的文件夹中git clone，再上传相关文件至hexo分支\n\n基本原理：github仓库开两个分支，main分支存放的是hexo生成的静态页面，hexo分支存放基本的 Hexo 博客项目的结构和默认配置文件，如文章，主题\n当需要重新搭建环境时，直接拉取hexo分支中Hexo博客目录以及相关配置文件，当需要更新博客时直接\n\n```\ncd new\ngit clone git@github.com:<username>/<username>.github.io.git #<username> 用户名\ngit branch    #查看分支，显示 * hexo\n```\n\n\n\n## 1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\n\n```\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n```\n\n## 2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录\n\n![image-20230913154559571](../imgs/image-20230913154559571.png)\n\n## 3.送new目录中的相关文件到远程仓库 hexo分支\n\n```\ngit add .\ngit commit –m add_branch\ngit push        \n\n```\n\n\n\n# 5.！新环境中快速搭建博客环境！\n\n## 1.设置ssh\n\n参考：https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\n\n```\nssh-keygen -t ed25519 -C \"your_email@gmail.com\"\ncat ~/.ssh/id_ed25519.pub  #将里面的内容复制到 github ->settings ->SSH and GPC keys ->SSH keys ->New SSH key中\nssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）\n#接着在本地绑定与Github的用户名和邮箱（git）\ngit config --global user.name \"<username>\"    #自己的用户名\ngit config --global user.email 'xxx@xxx.com'  #自己的邮箱\n```\n\n## 2.安装nodejs和hexo\n\n```\nsudo apt update\nsudo apt-get install git\n\nsudo apt install nodejs\nsudo apt install npm  \n```\n\n## 3.拉取hexo博客目录\n\n```\ngit clone git@github.com:<username>/<username>.github.io.git #<username> 用户名\ngit branch    #查看分支，显示 * hexo\nnpm install hexo\nnpm install\nnpm install hexo-deployer-git        #不需要hexo init这条指令\nnpm i hexo-renderer-marked\n\n\n#更新博客 添加新文章 hello-world\nhexo new \"hello-world\"\ngit add .        #将文章备份至 hexo分支  或者git add source/_posts/hello-world \ngit commit –m \"hello-world\"\ngit push         #或者git push origin hexo\n\nhexo g        #生成静态页面\nhexo s        #启动本地服务器 预览\nhexo d        #将生成的博客文件部署到 github main分支，Hexo博客项目配置文件中_config.yml已设置好\n```\n\n# 6.遇到的问题\n\n## 问题1.nodejs版本过低\n\nnpm WARN notsup Unsupported engine for hexo@6.3.0: wanted: {\"node\":\">=12.13.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo@6.3.0\nnpm WARN notsup Unsupported engine for hexo-front-matter@3.0.0: wanted: {\"node\":\">=12.13.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-front-matter@3.0.0\nnpm WARN notsup Unsupported engine for hexo-cli@4.3.1: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-cli@4.3.1\nnpm WARN notsup Unsupported engine for hexo-log@3.2.0: wanted: {\"node\":\">=12.4.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-log@3.2.0\nnpm WARN notsup Unsupported engine for abbrev@2.0.0: wanted: {\"node\":\"^14.17.0 || ^16.13.0 || >=18.0.0\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: abbrev@2.0.0\nnpm WARN notsup Unsupported engine for hexo-fs@4.1.1: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-fs@4.1.1\nnpm WARN notsup Unsupported engine for hexo-log@4.1.0: wanted: {\"node\":\">=14\"} (current: {\"node\":\"10.19.0\",\"npm\":\"6.14.4\"})\nnpm WARN notsup Not compatible with your version of node/npm: hexo-log@4.1.0\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.3 (node_modules/fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.3: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"linux\",\"arch\":\"x64\"})\n\n## 升级nodejs\n\n```\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash         #安装 nvm\nsource ~/.bashrc            #加载 nvm\nnvm install node            #使用 nvm 安装最新版本的 Node.js\nnode -v                     #验证 Node.js 版本\n```\n\n\n\n\n\n## 问题2.hexo博客图片不显示\n\nhttps://blog.csdn.net/QRLYLETITBE/article/details/127737904 \n\n```\nnpm i hexo-renderer-marked\n\n```\n\n## 新建imgs文件夹\n\n![image-20230913161638961](../imgs/image-20230913161638961.png)\n\n```\nmarked:\n  prependRoot: true\n  postAsset: true\n\n```\n## 修改图片路径\n\n![image-20230913161842174](../imgs/image-20230913161842174.png)\n","slug":"Hexo在多台电脑上提交和更新","published":1,"updated":"2024-04-28T07:17:56.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clvjcoaau0009r9w09xzi7r99","content":"<p>[toc]</p>\n<h1 id=\"1-博客搭建\"><a href=\"#1-博客搭建\" class=\"headerlink\" title=\"1.博客搭建\"></a>1.博客搭建</h1><p><a href=\"https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\">https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</a></p>\n<h1 id=\"2-创建一个新文件夹new，用于上传hexo博客目录\"><a href=\"#2-创建一个新文件夹new，用于上传hexo博客目录\" class=\"headerlink\" title=\"2.创建一个新文件夹new，用于上传hexo博客目录\"></a>2.创建一个新文件夹new，用于上传hexo博客目录</h1><p>将以下目录（除了红色方框的目录）拷贝到新目录中</p>\n<p><img src=\"/../imgs/image-20230913154437526.png\" alt=\"image-20230913154437526\"></p>\n<p>参考：<a href=\"https://blog.csdn.net/K1052176873/article/details/122879462\">https://blog.csdn.net/K1052176873/article/details/122879462</a> </p>\n<h1 id=\"3-github上创建hexo分支并设置为默认分支\"><a href=\"#3-github上创建hexo分支并设置为默认分支\" class=\"headerlink\" title=\"3.github上创建hexo分支并设置为默认分支\"></a>3.github上创建hexo分支并设置为默认分支</h1><h2 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h2><p><img src=\"/../imgs/image-20230913154510439.png\" alt=\"image-20230913154510439\"></p>\n<h2 id=\"将hexo分支设置为默认分支\"><a href=\"#将hexo分支设置为默认分支\" class=\"headerlink\" title=\"将hexo分支设置为默认分支\"></a>将hexo分支设置为默认分支</h2><p><img src=\"/../imgs/image-20230913154524492.png\" alt=\"image-20230913154524492\"></p>\n<h1 id=\"4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支\"><a href=\"#4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支\" class=\"headerlink\" title=\"4.进入新建的文件夹中git clone，再上传相关文件至hexo分支\"></a>4.进入新建的文件夹中git clone，再上传相关文件至hexo分支</h1><p>基本原理：github仓库开两个分支，main分支存放的是hexo生成的静态页面，hexo分支存放基本的 Hexo 博客项目的结构和默认配置文件，如文章，主题<br>当需要重新搭建环境时，直接拉取hexo分支中Hexo博客目录以及相关配置文件，当需要更新博客时直接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd new</span><br><span class=\"line\">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class=\"line\">git branch    #查看分支，显示 * hexo</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\"><a href=\"#1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\" class=\"headerlink\" title=\"1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\"></a>1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json</span><br><span class=\"line\">*.log</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">public/</span><br><span class=\"line\">.deploy*/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录\"><a href=\"#2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录\" class=\"headerlink\" title=\"2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录\"></a>2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录</h2><p><img src=\"/../imgs/image-20230913154559571.png\" alt=\"image-20230913154559571\"></p>\n<h2 id=\"3-送new目录中的相关文件到远程仓库-hexo分支\"><a href=\"#3-送new目录中的相关文件到远程仓库-hexo分支\" class=\"headerlink\" title=\"3.送new目录中的相关文件到远程仓库 hexo分支\"></a>3.送new目录中的相关文件到远程仓库 hexo分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit –m add_branch</span><br><span class=\"line\">git push        </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"5-！新环境中快速搭建博客环境！\"><a href=\"#5-！新环境中快速搭建博客环境！\" class=\"headerlink\" title=\"5.！新环境中快速搭建博客环境！\"></a>5.！新环境中快速搭建博客环境！</h1><h2 id=\"1-设置ssh\"><a href=\"#1-设置ssh\" class=\"headerlink\" title=\"1.设置ssh\"></a>1.设置ssh</h2><p>参考：<a href=\"https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t ed25519 -C &quot;your_email@gmail.com&quot;</span><br><span class=\"line\">cat ~/.ssh/id_ed25519.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class=\"line\">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class=\"line\">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class=\"line\">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class=\"line\">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装nodejs和hexo\"><a href=\"#2-安装nodejs和hexo\" class=\"headerlink\" title=\"2.安装nodejs和hexo\"></a>2.安装nodejs和hexo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install git</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-拉取hexo博客目录\"><a href=\"#3-拉取hexo博客目录\" class=\"headerlink\" title=\"3.拉取hexo博客目录\"></a>3.拉取hexo博客目录</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class=\"line\">git branch    #查看分支，显示 * hexo</span><br><span class=\"line\">npm install hexo</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm install hexo-deployer-git        #不需要hexo init这条指令</span><br><span class=\"line\">npm i hexo-renderer-marked</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#更新博客 添加新文章 hello-world</span><br><span class=\"line\">hexo new &quot;hello-world&quot;</span><br><span class=\"line\">git add .        #将文章备份至 hexo分支  或者git add source/_posts/hello-world </span><br><span class=\"line\">git commit –m &quot;hello-world&quot;</span><br><span class=\"line\">git push         #或者git push origin hexo</span><br><span class=\"line\"></span><br><span class=\"line\">hexo g        #生成静态页面</span><br><span class=\"line\">hexo s        #启动本地服务器 预览</span><br><span class=\"line\">hexo d        #将生成的博客文件部署到 github main分支，Hexo博客项目配置文件中_config.yml已设置好</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-遇到的问题\"><a href=\"#6-遇到的问题\" class=\"headerlink\" title=\"6.遇到的问题\"></a>6.遇到的问题</h1><h2 id=\"问题1-nodejs版本过低\"><a href=\"#问题1-nodejs版本过低\" class=\"headerlink\" title=\"问题1.nodejs版本过低\"></a>问题1.nodejs版本过低</h2><p>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#101;&#120;&#x6f;&#x40;&#x36;&#x2e;&#51;&#x2e;&#48;\">&#104;&#101;&#120;&#x6f;&#x40;&#x36;&#x2e;&#51;&#x2e;&#48;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#101;&#120;&#x6f;&#64;&#x36;&#46;&#x33;&#46;&#48;\">&#104;&#101;&#120;&#x6f;&#64;&#x36;&#46;&#x33;&#46;&#48;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#x6f;&#110;&#116;&#45;&#109;&#x61;&#x74;&#116;&#x65;&#114;&#x40;&#x33;&#46;&#48;&#x2e;&#x30;\">&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#x6f;&#110;&#116;&#45;&#109;&#x61;&#x74;&#116;&#x65;&#114;&#x40;&#x33;&#46;&#48;&#x2e;&#x30;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#111;&#x6e;&#x74;&#x2d;&#x6d;&#97;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#48;&#46;&#48;\">&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#111;&#x6e;&#x74;&#x2d;&#x6d;&#97;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#48;&#46;&#48;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#120;&#111;&#x2d;&#x63;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#x2e;&#x31;\">&#x68;&#x65;&#120;&#111;&#x2d;&#x63;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#x2e;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#x65;&#120;&#111;&#45;&#99;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#46;&#49;\">&#x68;&#x65;&#120;&#111;&#45;&#99;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#46;&#49;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#x78;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#64;&#x33;&#x2e;&#x32;&#x2e;&#x30;\">&#x68;&#x65;&#x78;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#64;&#x33;&#x2e;&#x32;&#x2e;&#x30;</a>: wanted: {“node”:”&gt;&#x3D;12.4.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#101;&#x78;&#x6f;&#45;&#108;&#x6f;&#103;&#64;&#x33;&#x2e;&#50;&#x2e;&#48;\">&#x68;&#101;&#x78;&#x6f;&#45;&#108;&#x6f;&#103;&#64;&#x33;&#x2e;&#50;&#x2e;&#48;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#97;&#x62;&#x62;&#114;&#101;&#118;&#64;&#x32;&#x2e;&#48;&#46;&#48;\">&#97;&#x62;&#x62;&#114;&#101;&#118;&#64;&#x32;&#x2e;&#48;&#46;&#48;</a>: wanted: {“node”:”^14.17.0 || ^16.13.0 || &gt;&#x3D;18.0.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x61;&#x62;&#98;&#114;&#101;&#118;&#x40;&#x32;&#x2e;&#x30;&#x2e;&#x30;\">&#x61;&#x62;&#98;&#114;&#101;&#118;&#x40;&#x32;&#x2e;&#x30;&#x2e;&#x30;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#101;&#120;&#x6f;&#45;&#102;&#x73;&#64;&#52;&#x2e;&#49;&#46;&#x31;\">&#x68;&#101;&#120;&#x6f;&#45;&#102;&#x73;&#64;&#52;&#x2e;&#49;&#46;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#x65;&#120;&#111;&#45;&#102;&#x73;&#x40;&#x34;&#46;&#x31;&#x2e;&#x31;\">&#x68;&#x65;&#120;&#111;&#45;&#102;&#x73;&#x40;&#x34;&#46;&#x31;&#x2e;&#x31;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#101;&#120;&#111;&#x2d;&#x6c;&#111;&#x67;&#x40;&#52;&#x2e;&#x31;&#x2e;&#48;\">&#104;&#101;&#120;&#111;&#x2d;&#x6c;&#111;&#x67;&#x40;&#52;&#x2e;&#x31;&#x2e;&#48;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#x65;&#120;&#x6f;&#x2d;&#x6c;&#111;&#x67;&#64;&#52;&#46;&#49;&#46;&#48;\">&#104;&#x65;&#120;&#x6f;&#x2d;&#x6c;&#111;&#x67;&#64;&#52;&#46;&#49;&#46;&#48;</a><br>npm WARN optional SKIPPING OPTIONAL DEPENDENCY: <a href=\"mailto:&#x66;&#115;&#101;&#x76;&#101;&#110;&#116;&#115;&#64;&#50;&#x2e;&#51;&#x2e;&#x33;\">&#x66;&#115;&#101;&#x76;&#101;&#110;&#116;&#115;&#64;&#50;&#x2e;&#51;&#x2e;&#x33;</a> (node_modules&#x2F;fsevents):<br>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href=\"mailto:&#102;&#x73;&#x65;&#118;&#101;&#110;&#116;&#115;&#x40;&#x32;&#x2e;&#51;&#x2e;&#x33;\">&#102;&#x73;&#x65;&#118;&#101;&#110;&#116;&#115;&#x40;&#x32;&#x2e;&#51;&#x2e;&#x33;</a>: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”linux”,”arch”:”x64”})</p>\n<h2 id=\"升级nodejs\"><a href=\"#升级nodejs\" class=\"headerlink\" title=\"升级nodejs\"></a>升级nodejs</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash         #安装 nvm</span><br><span class=\"line\">source ~/.bashrc            #加载 nvm</span><br><span class=\"line\">nvm install node            #使用 nvm 安装最新版本的 Node.js</span><br><span class=\"line\">node -v                     #验证 Node.js 版本</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"问题2-hexo博客图片不显示\"><a href=\"#问题2-hexo博客图片不显示\" class=\"headerlink\" title=\"问题2.hexo博客图片不显示\"></a>问题2.hexo博客图片不显示</h2><p><a href=\"https://blog.csdn.net/QRLYLETITBE/article/details/127737904\">https://blog.csdn.net/QRLYLETITBE/article/details/127737904</a> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-marked</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"新建imgs文件夹\"><a href=\"#新建imgs文件夹\" class=\"headerlink\" title=\"新建imgs文件夹\"></a>新建imgs文件夹</h2><p><img src=\"/../imgs/image-20230913161638961.png\" alt=\"image-20230913161638961\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"修改图片路径\"><a href=\"#修改图片路径\" class=\"headerlink\" title=\"修改图片路径\"></a>修改图片路径</h2><p><img src=\"/../imgs/image-20230913161842174.png\" alt=\"image-20230913161842174\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"1-博客搭建\"><a href=\"#1-博客搭建\" class=\"headerlink\" title=\"1.博客搭建\"></a>1.博客搭建</h1><p><a href=\"https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/\">https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</a></p>\n<h1 id=\"2-创建一个新文件夹new，用于上传hexo博客目录\"><a href=\"#2-创建一个新文件夹new，用于上传hexo博客目录\" class=\"headerlink\" title=\"2.创建一个新文件夹new，用于上传hexo博客目录\"></a>2.创建一个新文件夹new，用于上传hexo博客目录</h1><p>将以下目录（除了红色方框的目录）拷贝到新目录中</p>\n<p><img src=\"/../imgs/image-20230913154437526.png\" alt=\"image-20230913154437526\"></p>\n<p>参考：<a href=\"https://blog.csdn.net/K1052176873/article/details/122879462\">https://blog.csdn.net/K1052176873/article/details/122879462</a> </p>\n<h1 id=\"3-github上创建hexo分支并设置为默认分支\"><a href=\"#3-github上创建hexo分支并设置为默认分支\" class=\"headerlink\" title=\"3.github上创建hexo分支并设置为默认分支\"></a>3.github上创建hexo分支并设置为默认分支</h1><h2 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h2><p><img src=\"/../imgs/image-20230913154510439.png\" alt=\"image-20230913154510439\"></p>\n<h2 id=\"将hexo分支设置为默认分支\"><a href=\"#将hexo分支设置为默认分支\" class=\"headerlink\" title=\"将hexo分支设置为默认分支\"></a>将hexo分支设置为默认分支</h2><p><img src=\"/../imgs/image-20230913154524492.png\" alt=\"image-20230913154524492\"></p>\n<h1 id=\"4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支\"><a href=\"#4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支\" class=\"headerlink\" title=\"4.进入新建的文件夹中git clone，再上传相关文件至hexo分支\"></a>4.进入新建的文件夹中git clone，再上传相关文件至hexo分支</h1><p>基本原理：github仓库开两个分支，main分支存放的是hexo生成的静态页面，hexo分支存放基本的 Hexo 博客项目的结构和默认配置文件，如文章，主题<br>当需要重新搭建环境时，直接拉取hexo分支中Hexo博客目录以及相关配置文件，当需要更新博客时直接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd new</span><br><span class=\"line\">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class=\"line\">git branch    #查看分支，显示 * hexo</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\"><a href=\"#1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\" class=\"headerlink\" title=\"1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：\"></a>1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">Thumbs.db</span><br><span class=\"line\">db.json</span><br><span class=\"line\">*.log</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">public/</span><br><span class=\"line\">.deploy*/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录\"><a href=\"#2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录\" class=\"headerlink\" title=\"2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录\"></a>2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录</h2><p><img src=\"/../imgs/image-20230913154559571.png\" alt=\"image-20230913154559571\"></p>\n<h2 id=\"3-送new目录中的相关文件到远程仓库-hexo分支\"><a href=\"#3-送new目录中的相关文件到远程仓库-hexo分支\" class=\"headerlink\" title=\"3.送new目录中的相关文件到远程仓库 hexo分支\"></a>3.送new目录中的相关文件到远程仓库 hexo分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit –m add_branch</span><br><span class=\"line\">git push        </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"5-！新环境中快速搭建博客环境！\"><a href=\"#5-！新环境中快速搭建博客环境！\" class=\"headerlink\" title=\"5.！新环境中快速搭建博客环境！\"></a>5.！新环境中快速搭建博客环境！</h1><h2 id=\"1-设置ssh\"><a href=\"#1-设置ssh\" class=\"headerlink\" title=\"1.设置ssh\"></a>1.设置ssh</h2><p>参考：<a href=\"https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t ed25519 -C &quot;your_email@gmail.com&quot;</span><br><span class=\"line\">cat ~/.ssh/id_ed25519.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class=\"line\">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class=\"line\">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class=\"line\">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class=\"line\">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装nodejs和hexo\"><a href=\"#2-安装nodejs和hexo\" class=\"headerlink\" title=\"2.安装nodejs和hexo\"></a>2.安装nodejs和hexo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install git</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install nodejs</span><br><span class=\"line\">sudo apt install npm  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-拉取hexo博客目录\"><a href=\"#3-拉取hexo博客目录\" class=\"headerlink\" title=\"3.拉取hexo博客目录\"></a>3.拉取hexo博客目录</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class=\"line\">git branch    #查看分支，显示 * hexo</span><br><span class=\"line\">npm install hexo</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm install hexo-deployer-git        #不需要hexo init这条指令</span><br><span class=\"line\">npm i hexo-renderer-marked</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#更新博客 添加新文章 hello-world</span><br><span class=\"line\">hexo new &quot;hello-world&quot;</span><br><span class=\"line\">git add .        #将文章备份至 hexo分支  或者git add source/_posts/hello-world </span><br><span class=\"line\">git commit –m &quot;hello-world&quot;</span><br><span class=\"line\">git push         #或者git push origin hexo</span><br><span class=\"line\"></span><br><span class=\"line\">hexo g        #生成静态页面</span><br><span class=\"line\">hexo s        #启动本地服务器 预览</span><br><span class=\"line\">hexo d        #将生成的博客文件部署到 github main分支，Hexo博客项目配置文件中_config.yml已设置好</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-遇到的问题\"><a href=\"#6-遇到的问题\" class=\"headerlink\" title=\"6.遇到的问题\"></a>6.遇到的问题</h1><h2 id=\"问题1-nodejs版本过低\"><a href=\"#问题1-nodejs版本过低\" class=\"headerlink\" title=\"问题1.nodejs版本过低\"></a>问题1.nodejs版本过低</h2><p>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#101;&#120;&#x6f;&#x40;&#x36;&#x2e;&#51;&#x2e;&#48;\">&#104;&#101;&#120;&#x6f;&#x40;&#x36;&#x2e;&#51;&#x2e;&#48;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#101;&#120;&#x6f;&#64;&#x36;&#46;&#x33;&#46;&#48;\">&#104;&#101;&#120;&#x6f;&#64;&#x36;&#46;&#x33;&#46;&#48;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#x6f;&#110;&#116;&#45;&#109;&#x61;&#x74;&#116;&#x65;&#114;&#x40;&#x33;&#46;&#48;&#x2e;&#x30;\">&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#x6f;&#110;&#116;&#45;&#109;&#x61;&#x74;&#116;&#x65;&#114;&#x40;&#x33;&#46;&#48;&#x2e;&#x30;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#111;&#x6e;&#x74;&#x2d;&#x6d;&#97;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#48;&#46;&#48;\">&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#111;&#x6e;&#x74;&#x2d;&#x6d;&#97;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#48;&#46;&#48;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#120;&#111;&#x2d;&#x63;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#x2e;&#x31;\">&#x68;&#x65;&#120;&#111;&#x2d;&#x63;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#x2e;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#x65;&#120;&#111;&#45;&#99;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#46;&#49;\">&#x68;&#x65;&#120;&#111;&#45;&#99;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#46;&#49;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#x65;&#x78;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#64;&#x33;&#x2e;&#x32;&#x2e;&#x30;\">&#x68;&#x65;&#x78;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#64;&#x33;&#x2e;&#x32;&#x2e;&#x30;</a>: wanted: {“node”:”&gt;&#x3D;12.4.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#101;&#x78;&#x6f;&#45;&#108;&#x6f;&#103;&#64;&#x33;&#x2e;&#50;&#x2e;&#48;\">&#x68;&#101;&#x78;&#x6f;&#45;&#108;&#x6f;&#103;&#64;&#x33;&#x2e;&#50;&#x2e;&#48;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#97;&#x62;&#x62;&#114;&#101;&#118;&#64;&#x32;&#x2e;&#48;&#46;&#48;\">&#97;&#x62;&#x62;&#114;&#101;&#118;&#64;&#x32;&#x2e;&#48;&#46;&#48;</a>: wanted: {“node”:”^14.17.0 || ^16.13.0 || &gt;&#x3D;18.0.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x61;&#x62;&#98;&#114;&#101;&#118;&#x40;&#x32;&#x2e;&#x30;&#x2e;&#x30;\">&#x61;&#x62;&#98;&#114;&#101;&#118;&#x40;&#x32;&#x2e;&#x30;&#x2e;&#x30;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#x68;&#101;&#120;&#x6f;&#45;&#102;&#x73;&#64;&#52;&#x2e;&#49;&#46;&#x31;\">&#x68;&#101;&#120;&#x6f;&#45;&#102;&#x73;&#64;&#52;&#x2e;&#49;&#46;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#x68;&#x65;&#120;&#111;&#45;&#102;&#x73;&#x40;&#x34;&#46;&#x31;&#x2e;&#x31;\">&#x68;&#x65;&#120;&#111;&#45;&#102;&#x73;&#x40;&#x34;&#46;&#x31;&#x2e;&#x31;</a><br>npm WARN notsup Unsupported engine for <a href=\"mailto:&#104;&#101;&#120;&#111;&#x2d;&#x6c;&#111;&#x67;&#x40;&#52;&#x2e;&#x31;&#x2e;&#48;\">&#104;&#101;&#120;&#111;&#x2d;&#x6c;&#111;&#x67;&#x40;&#52;&#x2e;&#x31;&#x2e;&#48;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href=\"mailto:&#104;&#x65;&#120;&#x6f;&#x2d;&#x6c;&#111;&#x67;&#64;&#52;&#46;&#49;&#46;&#48;\">&#104;&#x65;&#120;&#x6f;&#x2d;&#x6c;&#111;&#x67;&#64;&#52;&#46;&#49;&#46;&#48;</a><br>npm WARN optional SKIPPING OPTIONAL DEPENDENCY: <a href=\"mailto:&#x66;&#115;&#101;&#x76;&#101;&#110;&#116;&#115;&#64;&#50;&#x2e;&#51;&#x2e;&#x33;\">&#x66;&#115;&#101;&#x76;&#101;&#110;&#116;&#115;&#64;&#50;&#x2e;&#51;&#x2e;&#x33;</a> (node_modules&#x2F;fsevents):<br>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href=\"mailto:&#102;&#x73;&#x65;&#118;&#101;&#110;&#116;&#115;&#x40;&#x32;&#x2e;&#51;&#x2e;&#x33;\">&#102;&#x73;&#x65;&#118;&#101;&#110;&#116;&#115;&#x40;&#x32;&#x2e;&#51;&#x2e;&#x33;</a>: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”linux”,”arch”:”x64”})</p>\n<h2 id=\"升级nodejs\"><a href=\"#升级nodejs\" class=\"headerlink\" title=\"升级nodejs\"></a>升级nodejs</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash         #安装 nvm</span><br><span class=\"line\">source ~/.bashrc            #加载 nvm</span><br><span class=\"line\">nvm install node            #使用 nvm 安装最新版本的 Node.js</span><br><span class=\"line\">node -v                     #验证 Node.js 版本</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"问题2-hexo博客图片不显示\"><a href=\"#问题2-hexo博客图片不显示\" class=\"headerlink\" title=\"问题2.hexo博客图片不显示\"></a>问题2.hexo博客图片不显示</h2><p><a href=\"https://blog.csdn.net/QRLYLETITBE/article/details/127737904\">https://blog.csdn.net/QRLYLETITBE/article/details/127737904</a> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-marked</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"新建imgs文件夹\"><a href=\"#新建imgs文件夹\" class=\"headerlink\" title=\"新建imgs文件夹\"></a>新建imgs文件夹</h2><p><img src=\"/../imgs/image-20230913161638961.png\" alt=\"image-20230913161638961\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"修改图片路径\"><a href=\"#修改图片路径\" class=\"headerlink\" title=\"修改图片路径\"></a>修改图片路径</h2><p><img src=\"/../imgs/image-20230913161842174.png\" alt=\"image-20230913161842174\"></p>\n"},{"title":"02-rust基本类型","date":"2023-08-26T13:17:00.000Z","_content":"\n\n\n\n\n\n\n\n\n[toc]\n\n# Rust基本数据类型\n\nRust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：\n\n- 数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数\n- 字符串：字符串字面量和字符串切片 `&str`\n- 布尔类型： `true`和`false`\n- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节\n- 单元类型: 即 `()` ，其唯一的值也是 `()`\n\n## 1.数值类型\n\n| 长度       | 有符号类型 | 无符号类型 |\n| ---------- | ---------- | ---------- |\n| 8 位       | `i8`       | `u8`       |\n| 16 位      | `i16`      | `u16`      |\n| 32 位      | `i32`      | `u32`      |\n| 64 位      | `i64`      | `u64`      |\n| 128 位     | `i128`     | `u128`     |\n| 视架构而定 | `isize`    | `usize`    |\n\n整形字面量可以用下表的形式书写：\n\n| 数字字面量         | 示例          |\n| ------------------ | ------------- |\n| 十进制             | `98_222`      |\n| 十六进制           | `0xff`        |\n| 八进制             | `0o77`        |\n| 二进制             | `0b1111_0000` |\n| 字节 (仅限于 `u8`) | `b'A'`        |\n\n## 2.[浮点类型](https://course.rs/basic/base-type/numbers.html#浮点类型)\n\n**浮点类型数字** 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高。\n\n下面是一个演示浮点数的示例：\n\n```rust\nfn main() {\n    let x = 2.0; // f64\n\n    let y: f32 = 3.0; // f32\n}\n```\n\n## 3.[序列(Range)](https://course.rs/basic/base-type/numbers.html#序列range)\n\nRust 提供了一个非常简洁的方式，用来生成连续的数值，例如 **`1..5`，生成从 1 到 4 的连续数字，不包含 5** ；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：\n\n```rust\nfor i in 1..=5 {\n    println!(\"{}\",i);\n}\n```\n\n最终程序输出:\n\n```console\n1\n2\n3\n4\n5\n```\n\n**序列只允许用于数字或字符类型**，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：\n\n```rust\nfor i in 'a'..='z' {\n    println!(\"{}\",i);\n}\n```\n\n## 4.[有理数和复数](https://course.rs/basic/base-type/numbers.html#有理数和复数)\n\nRust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：\n\n- 有理数和复数\n- 任意大小的整数和任意精度的浮点数\n- 固定精度的十进制小数，常用于货币相关的场景\n\n好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。\n\n按照以下步骤来引入 `num` 库：\n\n1. 创建新工程 `cargo new complex-num && cd complex-num`\n2. 在 `Cargo.toml` 中的 `[dependencies]` 下添加一行 `num = \"0.4.0\"`\n3. 将 `src/main.rs` 文件中的 `main` 函数替换为下面的代码\n4. 运行 `cargo run`\n\n```rust\nuse num::complex::Complex;\n\n fn main() {\n   let a = Complex { re: 2.1, im: -1.2 };\n   let b = Complex::new(11.1, 22.2);\n   let result = a + b;\n\n   println!(\"{} + {}i\", result.re, result.im)\n }\n```\n\n#### [总结](https://course.rs/basic/base-type/numbers.html#总结)\n\n之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：\n\n- **Rust 拥有相当多的数值类型**. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数\n- **类型转换必须是显式的**. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数\n- **Rust 的数值上可以使用方法**. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14` 的具体类型\n\n## 5.[函数要点](https://course.rs/basic/base-type/function.html#函数要点)\n\n- 函数名和变量名使用[蛇形命名法(snake case)](https://course.rs/practice/naming.html)，例如 `fn add_two() -> {}`\n- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可\n- 每个函数参数都需要标注类型\n\n```\nfn add(i: i32, j: i32) -> i32 {\n   i + j\n }\n\n```\n\n![img](https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png)\n\n### 返回值：\n\n​\t[无返回值`()`](https://course.rs/basic/base-type/function.html#无返回值)\n\n- 函数没有返回值，那么返回一个 `()`\n- 通过 `;` 结尾的表达式返回一个 `()`\n\n​    [永不返回的发散函数 `!`](https://course.rs/basic/base-type/function.html#永不返回的发散函数-)\n\n​\t\t当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：\n\n## 6.练习\n\n[数值类型 - Rust By Practice( Rust 练习实践 )](https://zh.practice.rs/basic-types/numbers.html)\n\n```// 填空\nfn main() {\n    let v: u16 = 38_u8 as u16; //从8位无符号整数（u8）到16位无符号整数（u16）的类型转换\n}\n```\n\n```\n\n// 修改 `assert_eq!` 让代码工作\nfn main() {\n    let x = 5;\t\t//i32\n    assert_eq!(\"i32\".to_string(), type_of(&x)); //\n}\n\n// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  \"i8\", \"u8\", \"i32\", \"u32\"\nfn type_of<T>(_: &T) -> String {\n    format!(\"{}\", std::any::type_name::<T>())\n}\n\n```\n\n```\nfn main() {\n    assert_eq!(i8::MAX, 127); \n    assert_eq!(u8::MAX, 255); \n}\n\n```\n\n```\n\n// 解决代码中的错误和 `panic`\nfn main() {\n   let v1 = 251_u8.wrapping_add(8);\n   let v2 = match u8::checked_add(251, 8) {\n        Some(value) => value,\n        None => {\n            println!(\"Overflow occurred.\");\n            0\n        }\n    };\n   println!(\"{},{}\",v1,v2);\n}\n\n```\n\n```\nfn main() {\n    let x = 1_000.000_1; // f64\n    let y: f32 = 0.12; // f32\n    let z = 0.01_f64; // f64\n}\n```\n\n```c\n#使用两种方法来让下面代码工作\nfn main() {\n    assert!(0.1+0.2==0.3);\n}\n fn main() {\n     assert!(0.1_f32+0.2_f32==0.3_f32);\n }\n//降低精度\nfn main() {\n    let eps=0.001;\n    assert!((0.1_f64+ 0.2 - 0.3).abs() < eps);\n}\n//设置允许误差\n```\n\n### [序列Range](https://zh.practice.rs/basic-types/numbers.html#序列range)\n\n1. 🌟🌟 两个目标: 1. 修改 `assert!` 让它工作 2. 让 `println!` 输出: 97 - 122\n\n```\nfn main() {\n    let mut sum = 0;\n    for i in -3..2 {\n        sum += i\n    }\n\n    assert!(sum == -5);\n\n    for c in 'a'..='z' {\n        println!(\"{}\",c as u8);\n    }\n}\n\n```\n\n```\\// 填空\nuse std::ops::{Range, RangeInclusive};\nfn main() {\n    assert_eq!((1..5), Range{ start: 1, end: 5 });\n    assert_eq!((1..=5), RangeInclusive::new(1, 5));\n}\n///RangeInclusive::new(1, 5) 创建的是一个闭区间，表示从 1 到 5（包括 5）的范围。若 (1..5) 创建的是一个半开区间，表示从 1 到 5（不包括 5）的范围。\n```\n\n```\nuse std::mem::size_of_val;\nfn main() {\n    let unit: () = ();\n    assert!(size_of_val(&unit) == 0);\t\t//单元类型占用的内存大小 0\n\n    println!(\"Success!\")\n}\n```\n\n### [语句与表达式](https://zh.practice.rs/basic-types/statements-expressions.html#语句与表达式)\n\n```\nfn main() {\n   let v = {\n       let mut x = 1;\n       x += 2\t\t// 没有返回值  \n   };\n\n   assert_eq!(v, 3);\n}\n正确的做法\nfn main() {\n   let v = {\n       let mut x = 1;\n       x += 2;\n       x\n   };\n\n   assert_eq!(v, 3);\n}\n\nlet z = {\n\t// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`\n\t2 * x;\n};\nfn main() {\n   let v = { let x = 3; x};\n\n   assert!(v == 3);\n}\n```\n\n### [函数](https://zh.practice.rs/basic-types/functions.html#函数)\n\n\n\n## 7.总结：\n\n1.`let x = 2.0; // f64`\n\n2.比较浮点数`(0.1_f64 + 0.2 - 0.3).abs() < 0.00001`\n\n3.`编译器会进行自动推导，给予twenty i32的类型  let twenty = 20;`\n\n4.按照补码循环溢出规则处理`et b = 255_u8.wrapping_add(20);  // 19`  `在 u8 的情况下，256 变成 0，257 变成 1，`\n\n5.`(1..5)  表示从 1 到 5（不包括 5）半开区间的范围`\n\n6.`(1..=5)  表示从 1 到 5（包括 5）半闭区间的范围`\n\n6.**表达式不能包含分号**。`表达式总要返回值`\n\n7.返回值为！的表达式\n\n```\nloop {}  \npanic!(\"Never return\");  \ntodo!();  \nunimplemented!();  //未实现的占位符函数\n \n```\n","source":"_posts/02-rust基本类型.md","raw":"---\ntitle: 02-rust基本类型\ndate: 2023-08-26 21:17:00\ncategories:\n- rust\ntags:\n- rust基本类型\n- rust\n\n---\n\n\n\n\n\n\n\n\n\n[toc]\n\n# Rust基本数据类型\n\nRust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：\n\n- 数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数\n- 字符串：字符串字面量和字符串切片 `&str`\n- 布尔类型： `true`和`false`\n- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节\n- 单元类型: 即 `()` ，其唯一的值也是 `()`\n\n## 1.数值类型\n\n| 长度       | 有符号类型 | 无符号类型 |\n| ---------- | ---------- | ---------- |\n| 8 位       | `i8`       | `u8`       |\n| 16 位      | `i16`      | `u16`      |\n| 32 位      | `i32`      | `u32`      |\n| 64 位      | `i64`      | `u64`      |\n| 128 位     | `i128`     | `u128`     |\n| 视架构而定 | `isize`    | `usize`    |\n\n整形字面量可以用下表的形式书写：\n\n| 数字字面量         | 示例          |\n| ------------------ | ------------- |\n| 十进制             | `98_222`      |\n| 十六进制           | `0xff`        |\n| 八进制             | `0o77`        |\n| 二进制             | `0b1111_0000` |\n| 字节 (仅限于 `u8`) | `b'A'`        |\n\n## 2.[浮点类型](https://course.rs/basic/base-type/numbers.html#浮点类型)\n\n**浮点类型数字** 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高。\n\n下面是一个演示浮点数的示例：\n\n```rust\nfn main() {\n    let x = 2.0; // f64\n\n    let y: f32 = 3.0; // f32\n}\n```\n\n## 3.[序列(Range)](https://course.rs/basic/base-type/numbers.html#序列range)\n\nRust 提供了一个非常简洁的方式，用来生成连续的数值，例如 **`1..5`，生成从 1 到 4 的连续数字，不包含 5** ；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：\n\n```rust\nfor i in 1..=5 {\n    println!(\"{}\",i);\n}\n```\n\n最终程序输出:\n\n```console\n1\n2\n3\n4\n5\n```\n\n**序列只允许用于数字或字符类型**，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：\n\n```rust\nfor i in 'a'..='z' {\n    println!(\"{}\",i);\n}\n```\n\n## 4.[有理数和复数](https://course.rs/basic/base-type/numbers.html#有理数和复数)\n\nRust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：\n\n- 有理数和复数\n- 任意大小的整数和任意精度的浮点数\n- 固定精度的十进制小数，常用于货币相关的场景\n\n好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。\n\n按照以下步骤来引入 `num` 库：\n\n1. 创建新工程 `cargo new complex-num && cd complex-num`\n2. 在 `Cargo.toml` 中的 `[dependencies]` 下添加一行 `num = \"0.4.0\"`\n3. 将 `src/main.rs` 文件中的 `main` 函数替换为下面的代码\n4. 运行 `cargo run`\n\n```rust\nuse num::complex::Complex;\n\n fn main() {\n   let a = Complex { re: 2.1, im: -1.2 };\n   let b = Complex::new(11.1, 22.2);\n   let result = a + b;\n\n   println!(\"{} + {}i\", result.re, result.im)\n }\n```\n\n#### [总结](https://course.rs/basic/base-type/numbers.html#总结)\n\n之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：\n\n- **Rust 拥有相当多的数值类型**. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数\n- **类型转换必须是显式的**. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数\n- **Rust 的数值上可以使用方法**. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14` 的具体类型\n\n## 5.[函数要点](https://course.rs/basic/base-type/function.html#函数要点)\n\n- 函数名和变量名使用[蛇形命名法(snake case)](https://course.rs/practice/naming.html)，例如 `fn add_two() -> {}`\n- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可\n- 每个函数参数都需要标注类型\n\n```\nfn add(i: i32, j: i32) -> i32 {\n   i + j\n }\n\n```\n\n![img](https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png)\n\n### 返回值：\n\n​\t[无返回值`()`](https://course.rs/basic/base-type/function.html#无返回值)\n\n- 函数没有返回值，那么返回一个 `()`\n- 通过 `;` 结尾的表达式返回一个 `()`\n\n​    [永不返回的发散函数 `!`](https://course.rs/basic/base-type/function.html#永不返回的发散函数-)\n\n​\t\t当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：\n\n## 6.练习\n\n[数值类型 - Rust By Practice( Rust 练习实践 )](https://zh.practice.rs/basic-types/numbers.html)\n\n```// 填空\nfn main() {\n    let v: u16 = 38_u8 as u16; //从8位无符号整数（u8）到16位无符号整数（u16）的类型转换\n}\n```\n\n```\n\n// 修改 `assert_eq!` 让代码工作\nfn main() {\n    let x = 5;\t\t//i32\n    assert_eq!(\"i32\".to_string(), type_of(&x)); //\n}\n\n// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  \"i8\", \"u8\", \"i32\", \"u32\"\nfn type_of<T>(_: &T) -> String {\n    format!(\"{}\", std::any::type_name::<T>())\n}\n\n```\n\n```\nfn main() {\n    assert_eq!(i8::MAX, 127); \n    assert_eq!(u8::MAX, 255); \n}\n\n```\n\n```\n\n// 解决代码中的错误和 `panic`\nfn main() {\n   let v1 = 251_u8.wrapping_add(8);\n   let v2 = match u8::checked_add(251, 8) {\n        Some(value) => value,\n        None => {\n            println!(\"Overflow occurred.\");\n            0\n        }\n    };\n   println!(\"{},{}\",v1,v2);\n}\n\n```\n\n```\nfn main() {\n    let x = 1_000.000_1; // f64\n    let y: f32 = 0.12; // f32\n    let z = 0.01_f64; // f64\n}\n```\n\n```c\n#使用两种方法来让下面代码工作\nfn main() {\n    assert!(0.1+0.2==0.3);\n}\n fn main() {\n     assert!(0.1_f32+0.2_f32==0.3_f32);\n }\n//降低精度\nfn main() {\n    let eps=0.001;\n    assert!((0.1_f64+ 0.2 - 0.3).abs() < eps);\n}\n//设置允许误差\n```\n\n### [序列Range](https://zh.practice.rs/basic-types/numbers.html#序列range)\n\n1. 🌟🌟 两个目标: 1. 修改 `assert!` 让它工作 2. 让 `println!` 输出: 97 - 122\n\n```\nfn main() {\n    let mut sum = 0;\n    for i in -3..2 {\n        sum += i\n    }\n\n    assert!(sum == -5);\n\n    for c in 'a'..='z' {\n        println!(\"{}\",c as u8);\n    }\n}\n\n```\n\n```\\// 填空\nuse std::ops::{Range, RangeInclusive};\nfn main() {\n    assert_eq!((1..5), Range{ start: 1, end: 5 });\n    assert_eq!((1..=5), RangeInclusive::new(1, 5));\n}\n///RangeInclusive::new(1, 5) 创建的是一个闭区间，表示从 1 到 5（包括 5）的范围。若 (1..5) 创建的是一个半开区间，表示从 1 到 5（不包括 5）的范围。\n```\n\n```\nuse std::mem::size_of_val;\nfn main() {\n    let unit: () = ();\n    assert!(size_of_val(&unit) == 0);\t\t//单元类型占用的内存大小 0\n\n    println!(\"Success!\")\n}\n```\n\n### [语句与表达式](https://zh.practice.rs/basic-types/statements-expressions.html#语句与表达式)\n\n```\nfn main() {\n   let v = {\n       let mut x = 1;\n       x += 2\t\t// 没有返回值  \n   };\n\n   assert_eq!(v, 3);\n}\n正确的做法\nfn main() {\n   let v = {\n       let mut x = 1;\n       x += 2;\n       x\n   };\n\n   assert_eq!(v, 3);\n}\n\nlet z = {\n\t// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`\n\t2 * x;\n};\nfn main() {\n   let v = { let x = 3; x};\n\n   assert!(v == 3);\n}\n```\n\n### [函数](https://zh.practice.rs/basic-types/functions.html#函数)\n\n\n\n## 7.总结：\n\n1.`let x = 2.0; // f64`\n\n2.比较浮点数`(0.1_f64 + 0.2 - 0.3).abs() < 0.00001`\n\n3.`编译器会进行自动推导，给予twenty i32的类型  let twenty = 20;`\n\n4.按照补码循环溢出规则处理`et b = 255_u8.wrapping_add(20);  // 19`  `在 u8 的情况下，256 变成 0，257 变成 1，`\n\n5.`(1..5)  表示从 1 到 5（不包括 5）半开区间的范围`\n\n6.`(1..=5)  表示从 1 到 5（包括 5）半闭区间的范围`\n\n6.**表达式不能包含分号**。`表达式总要返回值`\n\n7.返回值为！的表达式\n\n```\nloop {}  \npanic!(\"Never return\");  \ntodo!();  \nunimplemented!();  //未实现的占位符函数\n \n```\n","slug":"02-rust基本类型","published":1,"updated":"2024-04-28T07:13:38.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clvjcoaav000ar9w07gr4ho88","content":"<p>[toc]</p>\n<h1 id=\"Rust基本数据类型\"><a href=\"#Rust基本数据类型\" class=\"headerlink\" title=\"Rust基本数据类型\"></a>Rust基本数据类型</h1><p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：</p>\n<ul>\n<li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</li>\n<li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li>\n<li>布尔类型： <code>true</code>和<code>false</code></li>\n<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>\n<li>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></li>\n</ul>\n<h2 id=\"1-数值类型\"><a href=\"#1-数值类型\" class=\"headerlink\" title=\"1.数值类型\"></a>1.数值类型</h2><table>\n<thead>\n<tr>\n<th>长度</th>\n<th>有符号类型</th>\n<th>无符号类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8 位</td>\n<td><code>i8</code></td>\n<td><code>u8</code></td>\n</tr>\n<tr>\n<td>16 位</td>\n<td><code>i16</code></td>\n<td><code>u16</code></td>\n</tr>\n<tr>\n<td>32 位</td>\n<td><code>i32</code></td>\n<td><code>u32</code></td>\n</tr>\n<tr>\n<td>64 位</td>\n<td><code>i64</code></td>\n<td><code>u64</code></td>\n</tr>\n<tr>\n<td>128 位</td>\n<td><code>i128</code></td>\n<td><code>u128</code></td>\n</tr>\n<tr>\n<td>视架构而定</td>\n<td><code>isize</code></td>\n<td><code>usize</code></td>\n</tr>\n</tbody></table>\n<p>整形字面量可以用下表的形式书写：</p>\n<table>\n<thead>\n<tr>\n<th>数字字面量</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>十进制</td>\n<td><code>98_222</code></td>\n</tr>\n<tr>\n<td>十六进制</td>\n<td><code>0xff</code></td>\n</tr>\n<tr>\n<td>八进制</td>\n<td><code>0o77</code></td>\n</tr>\n<tr>\n<td>二进制</td>\n<td><code>0b1111_0000</code></td>\n</tr>\n<tr>\n<td>字节 (仅限于 <code>u8</code>)</td>\n<td><code>b&#39;A&#39;</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"2-浮点类型\"><a href=\"#2-浮点类型\" class=\"headerlink\" title=\"2.浮点类型\"></a>2.<a href=\"https://course.rs/basic/base-type/numbers.html#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B\">浮点类型</a></h2><p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p>\n<p>下面是一个演示浮点数的示例：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">2.0</span>; <span class=\"comment\">// f64</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span>: <span class=\"type\">f32</span> = <span class=\"number\">3.0</span>; <span class=\"comment\">// f32</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-序列-Range\"><a href=\"#3-序列-Range\" class=\"headerlink\" title=\"3.序列(Range)\"></a>3.<a href=\"https://course.rs/basic/base-type/numbers.html#%E5%BA%8F%E5%88%97range\">序列(Range)</a></h2><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <strong><code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5</strong> ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>..=<span class=\"number\">5</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终程序输出:</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><strong>序列只允许用于数字或字符类型</strong>，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"string\">&#x27;a&#x27;</span>..=<span class=\"string\">&#x27;z&#x27;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-有理数和复数\"><a href=\"#4-有理数和复数\" class=\"headerlink\" title=\"4.有理数和复数\"></a>4.<a href=\"https://course.rs/basic/base-type/numbers.html#%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E5%A4%8D%E6%95%B0\">有理数和复数</a></h2><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p>\n<ul>\n<li>有理数和复数</li>\n<li>任意大小的整数和任意精度的浮点数</li>\n<li>固定精度的十进制小数，常用于货币相关的场景</li>\n</ul>\n<p>好在社区已经开发出高质量的 Rust 数值库：<a href=\"https://crates.io/crates/num\">num</a>。</p>\n<p>按照以下步骤来引入 <code>num</code> 库：</p>\n<ol>\n<li>创建新工程 <code>cargo new complex-num &amp;&amp; cd complex-num</code></li>\n<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = &quot;0.4.0&quot;</code></li>\n<li>将 <code>src/main.rs</code> 文件中的 <code>main</code> 函数替换为下面的代码</li>\n<li>运行 <code>cargo run</code></li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> num::complex::Complex;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Complex &#123; re: <span class=\"number\">2.1</span>, im: -<span class=\"number\">1.2</span> &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = Complex::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">11.1</span>, <span class=\"number\">22.2</span>);</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; + &#123;&#125;i&quot;</span>, result.re, result.im)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><a href=\"https://course.rs/basic/base-type/numbers.html#%E6%80%BB%E7%BB%93\">总结</a></h4><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p>\n<ul>\n<li><strong>Rust 拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li>\n<li><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</li>\n<li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整：<code>13.14_f32.round()</code>，在这里我们使用了类型后缀，因为编译器需要知道 <code>13.14</code> 的具体类型</li>\n</ul>\n<h2 id=\"5-函数要点\"><a href=\"#5-函数要点\" class=\"headerlink\" title=\"5.函数要点\"></a>5.<a href=\"https://course.rs/basic/base-type/function.html#%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9\">函数要点</a></h2><ul>\n<li>函数名和变量名使用<a href=\"https://course.rs/practice/naming.html\">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; &#123;&#125;</code></li>\n<li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li>\n<li>每个函数参数都需要标注类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn add(i: i32, j: i32) -&gt; i32 &#123;</span><br><span class=\"line\">   i + j</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png\" alt=\"img\"></p>\n<h3 id=\"返回值：\"><a href=\"#返回值：\" class=\"headerlink\" title=\"返回值：\"></a>返回值：</h3><p>​\t<a href=\"https://course.rs/basic/base-type/function.html#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC\">无返回值<code>()</code></a></p>\n<ul>\n<li>函数没有返回值，那么返回一个 <code>()</code></li>\n<li>通过 <code>;</code> 结尾的表达式返回一个 <code>()</code></li>\n</ul>\n<p>​    <a href=\"https://course.rs/basic/base-type/function.html#%E6%B0%B8%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0-\">永不返回的发散函数 <code>!</code></a></p>\n<p>​\t\t当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p>\n<h2 id=\"6-练习\"><a href=\"#6-练习\" class=\"headerlink\" title=\"6.练习\"></a>6.练习</h2><p><a href=\"https://zh.practice.rs/basic-types/numbers.html\">数值类型 - Rust By Practice( Rust 练习实践 )</a></p>\n<figure class=\"highlight plaintext\"><figcaption><span>填空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let v: u16 = 38_u8 as u16; //从8位无符号整数（u8）到16位无符号整数（u16）的类型转换</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 修改 `assert_eq!` 让代码工作</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let x = 5;\t\t//i32</span><br><span class=\"line\">    assert_eq!(&quot;i32&quot;.to_string(), type_of(&amp;x)); //</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;</span><br><span class=\"line\">fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123;</span><br><span class=\"line\">    format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    assert_eq!(i8::MAX, 127); </span><br><span class=\"line\">    assert_eq!(u8::MAX, 255); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 解决代码中的错误和 `panic`</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v1 = 251_u8.wrapping_add(8);</span><br><span class=\"line\">   let v2 = match u8::checked_add(251, 8) &#123;</span><br><span class=\"line\">        Some(value) =&gt; value,</span><br><span class=\"line\">        None =&gt; &#123;</span><br><span class=\"line\">            println!(&quot;Overflow occurred.&quot;);</span><br><span class=\"line\">            0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let x = 1_000.000_1; // f64</span><br><span class=\"line\">    let y: f32 = 0.12; // f32</span><br><span class=\"line\">    let z = 0.01_f64; // f64</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#使用两种方法来让下面代码工作</span><br><span class=\"line\">fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    assert!(<span class=\"number\">0.1</span>+<span class=\"number\">0.2</span>==<span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     assert!(<span class=\"number\">0.1</span>_f32+<span class=\"number\">0.2</span>_f32==<span class=\"number\">0.3</span>_f32);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//降低精度</span></span><br><span class=\"line\">fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    let eps=<span class=\"number\">0.001</span>;</span><br><span class=\"line\">    assert!((<span class=\"number\">0.1</span>_f64+ <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span>).<span class=\"built_in\">abs</span>() &lt; eps);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置允许误差</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"序列Range\"><a href=\"#序列Range\" class=\"headerlink\" title=\"序列Range\"></a><a href=\"https://zh.practice.rs/basic-types/numbers.html#%E5%BA%8F%E5%88%97range\">序列Range</a></h3><ol>\n<li>🌟🌟 两个目标: 1. 修改 <code>assert!</code> 让它工作 2. 让 <code>println!</code> 输出: 97 - 122</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let mut sum = 0;</span><br><span class=\"line\">    for i in -3..2 &#123;</span><br><span class=\"line\">        sum += i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert!(sum == -5);</span><br><span class=\"line\"></span><br><span class=\"line\">    for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123;</span><br><span class=\"line\">        println!(&quot;&#123;&#125;&quot;,c as u8);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>填空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use std::ops::&#123;Range, RangeInclusive&#125;;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;);</span><br><span class=\"line\">    assert_eq!((1..=5), RangeInclusive::new(1, 5));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">///RangeInclusive::new(1, 5) 创建的是一个闭区间，表示从 1 到 5（包括 5）的范围。若 (1..5) 创建的是一个半开区间，表示从 1 到 5（不包括 5）的范围。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use std::mem::size_of_val;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let unit: () = ();</span><br><span class=\"line\">    assert!(size_of_val(&amp;unit) == 0);\t\t//单元类型占用的内存大小 0</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语句与表达式\"><a href=\"#语句与表达式\" class=\"headerlink\" title=\"语句与表达式\"></a><a href=\"https://zh.practice.rs/basic-types/statements-expressions.html#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F\">语句与表达式</a></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123;</span><br><span class=\"line\">       let mut x = 1;</span><br><span class=\"line\">       x += 2\t\t// 没有返回值  </span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert_eq!(v, 3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">正确的做法</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123;</span><br><span class=\"line\">       let mut x = 1;</span><br><span class=\"line\">       x += 2;</span><br><span class=\"line\">       x</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert_eq!(v, 3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let z = &#123;</span><br><span class=\"line\">\t// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`</span><br><span class=\"line\">\t2 * x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123; let x = 3; x&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert!(v == 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a><a href=\"https://zh.practice.rs/basic-types/functions.html#%E5%87%BD%E6%95%B0\">函数</a></h3><h2 id=\"7-总结：\"><a href=\"#7-总结：\" class=\"headerlink\" title=\"7.总结：\"></a>7.总结：</h2><p>1.<code>let x = 2.0; // f64</code></p>\n<p>2.比较浮点数<code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code></p>\n<p>3.<code>编译器会进行自动推导，给予twenty i32的类型  let twenty = 20;</code></p>\n<p>4.按照补码循环溢出规则处理<code>et b = 255_u8.wrapping_add(20);  // 19</code>  <code>在 u8 的情况下，256 变成 0，257 变成 1，</code></p>\n<p>5.<code>(1..5)  表示从 1 到 5（不包括 5）半开区间的范围</code></p>\n<p>6.<code>(1..=5)  表示从 1 到 5（包括 5）半闭区间的范围</code></p>\n<p>6.<strong>表达式不能包含分号</strong>。<code>表达式总要返回值</code></p>\n<p>7.返回值为！的表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop &#123;&#125;  </span><br><span class=\"line\">panic!(&quot;Never return&quot;);  </span><br><span class=\"line\">todo!();  </span><br><span class=\"line\">unimplemented!();  //未实现的占位符函数</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"Rust基本数据类型\"><a href=\"#Rust基本数据类型\" class=\"headerlink\" title=\"Rust基本数据类型\"></a>Rust基本数据类型</h1><p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：</p>\n<ul>\n<li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</li>\n<li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li>\n<li>布尔类型： <code>true</code>和<code>false</code></li>\n<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>\n<li>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></li>\n</ul>\n<h2 id=\"1-数值类型\"><a href=\"#1-数值类型\" class=\"headerlink\" title=\"1.数值类型\"></a>1.数值类型</h2><table>\n<thead>\n<tr>\n<th>长度</th>\n<th>有符号类型</th>\n<th>无符号类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8 位</td>\n<td><code>i8</code></td>\n<td><code>u8</code></td>\n</tr>\n<tr>\n<td>16 位</td>\n<td><code>i16</code></td>\n<td><code>u16</code></td>\n</tr>\n<tr>\n<td>32 位</td>\n<td><code>i32</code></td>\n<td><code>u32</code></td>\n</tr>\n<tr>\n<td>64 位</td>\n<td><code>i64</code></td>\n<td><code>u64</code></td>\n</tr>\n<tr>\n<td>128 位</td>\n<td><code>i128</code></td>\n<td><code>u128</code></td>\n</tr>\n<tr>\n<td>视架构而定</td>\n<td><code>isize</code></td>\n<td><code>usize</code></td>\n</tr>\n</tbody></table>\n<p>整形字面量可以用下表的形式书写：</p>\n<table>\n<thead>\n<tr>\n<th>数字字面量</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>十进制</td>\n<td><code>98_222</code></td>\n</tr>\n<tr>\n<td>十六进制</td>\n<td><code>0xff</code></td>\n</tr>\n<tr>\n<td>八进制</td>\n<td><code>0o77</code></td>\n</tr>\n<tr>\n<td>二进制</td>\n<td><code>0b1111_0000</code></td>\n</tr>\n<tr>\n<td>字节 (仅限于 <code>u8</code>)</td>\n<td><code>b&#39;A&#39;</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"2-浮点类型\"><a href=\"#2-浮点类型\" class=\"headerlink\" title=\"2.浮点类型\"></a>2.<a href=\"https://course.rs/basic/base-type/numbers.html#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B\">浮点类型</a></h2><p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p>\n<p>下面是一个演示浮点数的示例：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">2.0</span>; <span class=\"comment\">// f64</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span>: <span class=\"type\">f32</span> = <span class=\"number\">3.0</span>; <span class=\"comment\">// f32</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-序列-Range\"><a href=\"#3-序列-Range\" class=\"headerlink\" title=\"3.序列(Range)\"></a>3.<a href=\"https://course.rs/basic/base-type/numbers.html#%E5%BA%8F%E5%88%97range\">序列(Range)</a></h2><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <strong><code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5</strong> ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>..=<span class=\"number\">5</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终程序输出:</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><strong>序列只允许用于数字或字符类型</strong>，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"string\">&#x27;a&#x27;</span>..=<span class=\"string\">&#x27;z&#x27;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-有理数和复数\"><a href=\"#4-有理数和复数\" class=\"headerlink\" title=\"4.有理数和复数\"></a>4.<a href=\"https://course.rs/basic/base-type/numbers.html#%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E5%A4%8D%E6%95%B0\">有理数和复数</a></h2><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p>\n<ul>\n<li>有理数和复数</li>\n<li>任意大小的整数和任意精度的浮点数</li>\n<li>固定精度的十进制小数，常用于货币相关的场景</li>\n</ul>\n<p>好在社区已经开发出高质量的 Rust 数值库：<a href=\"https://crates.io/crates/num\">num</a>。</p>\n<p>按照以下步骤来引入 <code>num</code> 库：</p>\n<ol>\n<li>创建新工程 <code>cargo new complex-num &amp;&amp; cd complex-num</code></li>\n<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = &quot;0.4.0&quot;</code></li>\n<li>将 <code>src/main.rs</code> 文件中的 <code>main</code> 函数替换为下面的代码</li>\n<li>运行 <code>cargo run</code></li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> num::complex::Complex;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Complex &#123; re: <span class=\"number\">2.1</span>, im: -<span class=\"number\">1.2</span> &#125;;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = Complex::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">11.1</span>, <span class=\"number\">22.2</span>);</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; + &#123;&#125;i&quot;</span>, result.re, result.im)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><a href=\"https://course.rs/basic/base-type/numbers.html#%E6%80%BB%E7%BB%93\">总结</a></h4><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p>\n<ul>\n<li><strong>Rust 拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li>\n<li><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</li>\n<li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整：<code>13.14_f32.round()</code>，在这里我们使用了类型后缀，因为编译器需要知道 <code>13.14</code> 的具体类型</li>\n</ul>\n<h2 id=\"5-函数要点\"><a href=\"#5-函数要点\" class=\"headerlink\" title=\"5.函数要点\"></a>5.<a href=\"https://course.rs/basic/base-type/function.html#%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9\">函数要点</a></h2><ul>\n<li>函数名和变量名使用<a href=\"https://course.rs/practice/naming.html\">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; &#123;&#125;</code></li>\n<li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li>\n<li>每个函数参数都需要标注类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn add(i: i32, j: i32) -&gt; i32 &#123;</span><br><span class=\"line\">   i + j</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png\" alt=\"img\"></p>\n<h3 id=\"返回值：\"><a href=\"#返回值：\" class=\"headerlink\" title=\"返回值：\"></a>返回值：</h3><p>​\t<a href=\"https://course.rs/basic/base-type/function.html#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC\">无返回值<code>()</code></a></p>\n<ul>\n<li>函数没有返回值，那么返回一个 <code>()</code></li>\n<li>通过 <code>;</code> 结尾的表达式返回一个 <code>()</code></li>\n</ul>\n<p>​    <a href=\"https://course.rs/basic/base-type/function.html#%E6%B0%B8%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0-\">永不返回的发散函数 <code>!</code></a></p>\n<p>​\t\t当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p>\n<h2 id=\"6-练习\"><a href=\"#6-练习\" class=\"headerlink\" title=\"6.练习\"></a>6.练习</h2><p><a href=\"https://zh.practice.rs/basic-types/numbers.html\">数值类型 - Rust By Practice( Rust 练习实践 )</a></p>\n<figure class=\"highlight plaintext\"><figcaption><span>填空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let v: u16 = 38_u8 as u16; //从8位无符号整数（u8）到16位无符号整数（u16）的类型转换</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 修改 `assert_eq!` 让代码工作</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let x = 5;\t\t//i32</span><br><span class=\"line\">    assert_eq!(&quot;i32&quot;.to_string(), type_of(&amp;x)); //</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;</span><br><span class=\"line\">fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123;</span><br><span class=\"line\">    format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    assert_eq!(i8::MAX, 127); </span><br><span class=\"line\">    assert_eq!(u8::MAX, 255); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 解决代码中的错误和 `panic`</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v1 = 251_u8.wrapping_add(8);</span><br><span class=\"line\">   let v2 = match u8::checked_add(251, 8) &#123;</span><br><span class=\"line\">        Some(value) =&gt; value,</span><br><span class=\"line\">        None =&gt; &#123;</span><br><span class=\"line\">            println!(&quot;Overflow occurred.&quot;);</span><br><span class=\"line\">            0</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">   println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let x = 1_000.000_1; // f64</span><br><span class=\"line\">    let y: f32 = 0.12; // f32</span><br><span class=\"line\">    let z = 0.01_f64; // f64</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#使用两种方法来让下面代码工作</span><br><span class=\"line\">fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    assert!(<span class=\"number\">0.1</span>+<span class=\"number\">0.2</span>==<span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     assert!(<span class=\"number\">0.1</span>_f32+<span class=\"number\">0.2</span>_f32==<span class=\"number\">0.3</span>_f32);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"comment\">//降低精度</span></span><br><span class=\"line\">fn <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    let eps=<span class=\"number\">0.001</span>;</span><br><span class=\"line\">    assert!((<span class=\"number\">0.1</span>_f64+ <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span>).<span class=\"built_in\">abs</span>() &lt; eps);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置允许误差</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"序列Range\"><a href=\"#序列Range\" class=\"headerlink\" title=\"序列Range\"></a><a href=\"https://zh.practice.rs/basic-types/numbers.html#%E5%BA%8F%E5%88%97range\">序列Range</a></h3><ol>\n<li>🌟🌟 两个目标: 1. 修改 <code>assert!</code> 让它工作 2. 让 <code>println!</code> 输出: 97 - 122</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let mut sum = 0;</span><br><span class=\"line\">    for i in -3..2 &#123;</span><br><span class=\"line\">        sum += i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert!(sum == -5);</span><br><span class=\"line\"></span><br><span class=\"line\">    for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123;</span><br><span class=\"line\">        println!(&quot;&#123;&#125;&quot;,c as u8);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>填空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use std::ops::&#123;Range, RangeInclusive&#125;;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;);</span><br><span class=\"line\">    assert_eq!((1..=5), RangeInclusive::new(1, 5));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">///RangeInclusive::new(1, 5) 创建的是一个闭区间，表示从 1 到 5（包括 5）的范围。若 (1..5) 创建的是一个半开区间，表示从 1 到 5（不包括 5）的范围。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use std::mem::size_of_val;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let unit: () = ();</span><br><span class=\"line\">    assert!(size_of_val(&amp;unit) == 0);\t\t//单元类型占用的内存大小 0</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语句与表达式\"><a href=\"#语句与表达式\" class=\"headerlink\" title=\"语句与表达式\"></a><a href=\"https://zh.practice.rs/basic-types/statements-expressions.html#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F\">语句与表达式</a></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123;</span><br><span class=\"line\">       let mut x = 1;</span><br><span class=\"line\">       x += 2\t\t// 没有返回值  </span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert_eq!(v, 3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">正确的做法</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123;</span><br><span class=\"line\">       let mut x = 1;</span><br><span class=\"line\">       x += 2;</span><br><span class=\"line\">       x</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert_eq!(v, 3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let z = &#123;</span><br><span class=\"line\">\t// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`</span><br><span class=\"line\">\t2 * x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">   let v = &#123; let x = 3; x&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   assert!(v == 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a><a href=\"https://zh.practice.rs/basic-types/functions.html#%E5%87%BD%E6%95%B0\">函数</a></h3><h2 id=\"7-总结：\"><a href=\"#7-总结：\" class=\"headerlink\" title=\"7.总结：\"></a>7.总结：</h2><p>1.<code>let x = 2.0; // f64</code></p>\n<p>2.比较浮点数<code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code></p>\n<p>3.<code>编译器会进行自动推导，给予twenty i32的类型  let twenty = 20;</code></p>\n<p>4.按照补码循环溢出规则处理<code>et b = 255_u8.wrapping_add(20);  // 19</code>  <code>在 u8 的情况下，256 变成 0，257 变成 1，</code></p>\n<p>5.<code>(1..5)  表示从 1 到 5（不包括 5）半开区间的范围</code></p>\n<p>6.<code>(1..=5)  表示从 1 到 5（包括 5）半闭区间的范围</code></p>\n<p>6.<strong>表达式不能包含分号</strong>。<code>表达式总要返回值</code></p>\n<p>7.返回值为！的表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop &#123;&#125;  </span><br><span class=\"line\">panic!(&quot;Never return&quot;);  </span><br><span class=\"line\">todo!();  </span><br><span class=\"line\">unimplemented!();  //未实现的占位符函数</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n"},{"title":"03-rust复合类型","date":"2023-08-28T13:58:27.000Z","_content":"\n\n\n\n\n# 1.字符串和切片\n\n## [什么是字符串?](https://course.rs/basic/compound-type/string-slice.html#什么是字符串)\n\n**Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)**\n\n`str` 类型是硬编码进可执行文件，也无法被修改，但是 `String` 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，**当 Rust 用户提到字符串时，往往指的就是 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码**。\n\n```\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\nassert_eq!(slice, &[2, 3]);\n\n```\n\n\n\n## [String 与 &str 的转换](https://course.rs/basic/compound-type/string-slice.html#string-与-str-的转换)\n\n```\nfn main() {\n    let s = String::from(\"hello,world!\");\n    say_hello(&s);\n    say_hello(&s[..]);\n    say_hello(s.as_str());\n}\n\nfn say_hello(s: &str) {\n    println!(\"{}\",s);\n}\n```\n\n## [字符串索引](https://course.rs/basic/compound-type/string-slice.html#字符串索引)\n\n## [字符串切片](https://course.rs/basic/compound-type/string-slice.html#字符串切片)\n\n通过索引区间来访问字符串时，**需要格外的小心**，一不注意，就会导致你程序的崩溃！\n\n## [操作字符串](https://course.rs/basic/compound-type/string-slice.html#操作字符串)\n\n#### [追加 (Push)](https://course.rs/basic/compound-type/string-slice.html#追加-push)\n\n\n\n#### [插入 (Insert)](https://course.rs/basic/compound-type/string-slice.html#插入-insert)\n\n#### [替换 (Replace)](https://course.rs/basic/compound-type/string-slice.html#替换-replace)\n\n#### [删除 (Delete)](https://course.rs/basic/compound-type/string-slice.html#删除-delete)\n\n#### [连接 (Concatenate)](https://course.rs/basic/compound-type/string-slice.html#连接-concatenate)\n\n## [字符串转义](https://course.rs/basic/compound-type/string-slice.html#字符串转义)\n\n```\nfn main() {\n    println!(\"{}\", \"hello \\\\x52\\\\x75\\\\x73\\\\x74\");\n    let raw_str = r\"Escapes don't work here: \\x3F \\u{211D}\";\n    println!(\"{}\", raw_str);\n\n    // 如果字符串包含双引号，可以在开头和结尾加 #\n    let quotes = r#\"And then I said: \"There is no escape!\"\"#;\n    println!(\"{}\", quotes);\n\n    // 如果还是有歧义，可以继续增加，没有限制\n    let longer_delimiter = r###\"A string with \"# in it. And even \"##!\"###;\n    println!(\"{}\", longer_delimiter);\n}\n```\n\n## [操作 UTF-8 字符串](https://course.rs/basic/compound-type/string-slice.html#操作-utf-8-字符串)\n\n[字符串与切片 - Rust语言圣经(Rust Course)](https://course.rs/basic/compound-type/string-slice.html#课后练习)\n\n```\nfor c in \"中国人\".chars() {\n    println!(\"{}\", c);\n}\n```\n\n## [课后练习](https://course.rs/basic/compound-type/string-slice.html#课后练习)\n\n> Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。\n>\n> - [字符串](https://zh.practice.rs/compound-types/string.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md)\n> - [切片](https://zh.practice.rs/compound-types/slice.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md)\n> - [String](https://zh.practice.rs/collections/String.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md)\n\n```\n\n// 填空并修复错误\nfn main() {\n    let s = String::from(\"hello, 世界\");\n    let slice1 = &s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节\n    assert_eq!(slice1, \"h\");\n\n    let slice2 = &s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节\n    assert_eq!(slice2, \"世\");\n    \n    // 迭代 s 中的所有字符\n    for (i, c) in s.chars().enumerate() {\n        if i == 7 {\n            assert_eq!(c, '世')\n        }\n    }\n\n    println!(\"Success!\")\n}\n\n\n\n// 填空\nfn main() {\n    let mut s = String::new();\n     s.push_str(\"hello\");\n\n    let v = vec![104, 101, 108, 108, 111];\n\n    // 将字节数组转换成 String\n    let s1 = String::from_utf8(v).unwrap();\n    \n    \n    assert_eq!(s, s1);\n\n    println!(\"Success!\")\n}\n\n\n\n// 填空\nuse std::mem;\n\nfn main() {\n    let story = String::from(\"Rust By Practice\");\n\n    // 阻止 String 的数据被自动 drop\n    let mut story = mem::ManuallyDrop::new(story);\n\n    let ptr = story.as_mut_ptr();\n    let len = story.len();\n    let capacity = story.capacity();\n\n    assert_eq!(16, len);\n\n    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. \n    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的\n    let s = unsafe { String::from_raw_parts(ptr, len, capacity) };\n\n    assert_eq!(*story, s);\n\n    println!(\"Success!\")\n}\n\n```\n\n\n\n# 2.[元组](https://course.rs/basic/compound-type/tuple.html#元组)\n\n# 3. 元组\n# 4. test\n\n待续。。。\n","source":"_posts/03-rust复合类型.md","raw":"---\ntitle: 03-rust复合类型\ndate: 2023-08-28 21:58:27\ncategories:\n- rust\ntags:\n- rust复合类型\n- rust\n---\n\n\n\n\n\n# 1.字符串和切片\n\n## [什么是字符串?](https://course.rs/basic/compound-type/string-slice.html#什么是字符串)\n\n**Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)**\n\n`str` 类型是硬编码进可执行文件，也无法被修改，但是 `String` 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，**当 Rust 用户提到字符串时，往往指的就是 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码**。\n\n```\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\nassert_eq!(slice, &[2, 3]);\n\n```\n\n\n\n## [String 与 &str 的转换](https://course.rs/basic/compound-type/string-slice.html#string-与-str-的转换)\n\n```\nfn main() {\n    let s = String::from(\"hello,world!\");\n    say_hello(&s);\n    say_hello(&s[..]);\n    say_hello(s.as_str());\n}\n\nfn say_hello(s: &str) {\n    println!(\"{}\",s);\n}\n```\n\n## [字符串索引](https://course.rs/basic/compound-type/string-slice.html#字符串索引)\n\n## [字符串切片](https://course.rs/basic/compound-type/string-slice.html#字符串切片)\n\n通过索引区间来访问字符串时，**需要格外的小心**，一不注意，就会导致你程序的崩溃！\n\n## [操作字符串](https://course.rs/basic/compound-type/string-slice.html#操作字符串)\n\n#### [追加 (Push)](https://course.rs/basic/compound-type/string-slice.html#追加-push)\n\n\n\n#### [插入 (Insert)](https://course.rs/basic/compound-type/string-slice.html#插入-insert)\n\n#### [替换 (Replace)](https://course.rs/basic/compound-type/string-slice.html#替换-replace)\n\n#### [删除 (Delete)](https://course.rs/basic/compound-type/string-slice.html#删除-delete)\n\n#### [连接 (Concatenate)](https://course.rs/basic/compound-type/string-slice.html#连接-concatenate)\n\n## [字符串转义](https://course.rs/basic/compound-type/string-slice.html#字符串转义)\n\n```\nfn main() {\n    println!(\"{}\", \"hello \\\\x52\\\\x75\\\\x73\\\\x74\");\n    let raw_str = r\"Escapes don't work here: \\x3F \\u{211D}\";\n    println!(\"{}\", raw_str);\n\n    // 如果字符串包含双引号，可以在开头和结尾加 #\n    let quotes = r#\"And then I said: \"There is no escape!\"\"#;\n    println!(\"{}\", quotes);\n\n    // 如果还是有歧义，可以继续增加，没有限制\n    let longer_delimiter = r###\"A string with \"# in it. And even \"##!\"###;\n    println!(\"{}\", longer_delimiter);\n}\n```\n\n## [操作 UTF-8 字符串](https://course.rs/basic/compound-type/string-slice.html#操作-utf-8-字符串)\n\n[字符串与切片 - Rust语言圣经(Rust Course)](https://course.rs/basic/compound-type/string-slice.html#课后练习)\n\n```\nfor c in \"中国人\".chars() {\n    println!(\"{}\", c);\n}\n```\n\n## [课后练习](https://course.rs/basic/compound-type/string-slice.html#课后练习)\n\n> Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。\n>\n> - [字符串](https://zh.practice.rs/compound-types/string.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md)\n> - [切片](https://zh.practice.rs/compound-types/slice.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md)\n> - [String](https://zh.practice.rs/collections/String.html)\n>   - [习题解答](https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md)\n\n```\n\n// 填空并修复错误\nfn main() {\n    let s = String::from(\"hello, 世界\");\n    let slice1 = &s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节\n    assert_eq!(slice1, \"h\");\n\n    let slice2 = &s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节\n    assert_eq!(slice2, \"世\");\n    \n    // 迭代 s 中的所有字符\n    for (i, c) in s.chars().enumerate() {\n        if i == 7 {\n            assert_eq!(c, '世')\n        }\n    }\n\n    println!(\"Success!\")\n}\n\n\n\n// 填空\nfn main() {\n    let mut s = String::new();\n     s.push_str(\"hello\");\n\n    let v = vec![104, 101, 108, 108, 111];\n\n    // 将字节数组转换成 String\n    let s1 = String::from_utf8(v).unwrap();\n    \n    \n    assert_eq!(s, s1);\n\n    println!(\"Success!\")\n}\n\n\n\n// 填空\nuse std::mem;\n\nfn main() {\n    let story = String::from(\"Rust By Practice\");\n\n    // 阻止 String 的数据被自动 drop\n    let mut story = mem::ManuallyDrop::new(story);\n\n    let ptr = story.as_mut_ptr();\n    let len = story.len();\n    let capacity = story.capacity();\n\n    assert_eq!(16, len);\n\n    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. \n    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的\n    let s = unsafe { String::from_raw_parts(ptr, len, capacity) };\n\n    assert_eq!(*story, s);\n\n    println!(\"Success!\")\n}\n\n```\n\n\n\n# 2.[元组](https://course.rs/basic/compound-type/tuple.html#元组)\n\n# 3. 元组\n# 4. test\n\n待续。。。\n","slug":"03-rust复合类型","published":1,"updated":"2024-04-28T07:13:38.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clvjcoaaw000er9w08cjhb54a","content":"<h1 id=\"1-字符串和切片\"><a href=\"#1-字符串和切片\" class=\"headerlink\" title=\"1.字符串和切片\"></a>1.字符串和切片</h1><h2 id=\"什么是字符串\"><a href=\"#什么是字符串\" class=\"headerlink\" title=\"什么是字符串?\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2\">什么是字符串?</a></h2><p><strong>Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)</strong></p>\n<p><code>str</code> 类型是硬编码进可执行文件，也无法被修改，但是 <code>String</code> 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，<strong>当 Rust 用户提到字符串时，往往指的就是 <code>String</code> 类型和 <code>&amp;str</code> 字符串切片类型，这两个类型都是 UTF-8 编码</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1, 2, 3, 4, 5];</span><br><span class=\"line\"></span><br><span class=\"line\">let slice = &amp;a[1..3];</span><br><span class=\"line\"></span><br><span class=\"line\">assert_eq!(slice, &amp;[2, 3]);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"String-与-str-的转换\"><a href=\"#String-与-str-的转换\" class=\"headerlink\" title=\"String 与 &amp;str 的转换\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#string-%E4%B8%8E-str-%E7%9A%84%E8%BD%AC%E6%8D%A2\">String 与 &amp;str 的转换</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let s = String::from(&quot;hello,world!&quot;);</span><br><span class=\"line\">    say_hello(&amp;s);</span><br><span class=\"line\">    say_hello(&amp;s[..]);</span><br><span class=\"line\">    say_hello(s.as_str());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn say_hello(s: &amp;str) &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;,s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串索引\"><a href=\"#字符串索引\" class=\"headerlink\" title=\"字符串索引\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95\">字符串索引</a></h2><h2 id=\"字符串切片\"><a href=\"#字符串切片\" class=\"headerlink\" title=\"字符串切片\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87\">字符串切片</a></h2><p>通过索引区间来访问字符串时，<strong>需要格外的小心</strong>，一不注意，就会导致你程序的崩溃！</p>\n<h2 id=\"操作字符串\"><a href=\"#操作字符串\" class=\"headerlink\" title=\"操作字符串\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2\">操作字符串</a></h2><h4 id=\"追加-Push\"><a href=\"#追加-Push\" class=\"headerlink\" title=\"追加 (Push)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%BF%BD%E5%8A%A0-push\">追加 (Push)</a></h4><h4 id=\"插入-Insert\"><a href=\"#插入-Insert\" class=\"headerlink\" title=\"插入 (Insert)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%8F%92%E5%85%A5-insert\">插入 (Insert)</a></h4><h4 id=\"替换-Replace\"><a href=\"#替换-Replace\" class=\"headerlink\" title=\"替换 (Replace)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%9B%BF%E6%8D%A2-replace\">替换 (Replace)</a></h4><h4 id=\"删除-Delete\"><a href=\"#删除-Delete\" class=\"headerlink\" title=\"删除 (Delete)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%88%A0%E9%99%A4-delete\">删除 (Delete)</a></h4><h4 id=\"连接-Concatenate\"><a href=\"#连接-Concatenate\" class=\"headerlink\" title=\"连接 (Concatenate)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%BF%9E%E6%8E%A5-concatenate\">连接 (Concatenate)</a></h4><h2 id=\"字符串转义\"><a href=\"#字符串转义\" class=\"headerlink\" title=\"字符串转义\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89\">字符串转义</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, &quot;hello \\\\x52\\\\x75\\\\x73\\\\x74&quot;);</span><br><span class=\"line\">    let raw_str = r&quot;Escapes don&#x27;t work here: \\x3F \\u&#123;211D&#125;&quot;;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, raw_str);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果字符串包含双引号，可以在开头和结尾加 #</span><br><span class=\"line\">    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, quotes);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果还是有歧义，可以继续增加，没有限制</span><br><span class=\"line\">    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, longer_delimiter);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作-UTF-8-字符串\"><a href=\"#操作-UTF-8-字符串\" class=\"headerlink\" title=\"操作 UTF-8 字符串\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2\">操作 UTF-8 字符串</a></h2><p><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0\">字符串与切片 - Rust语言圣经(Rust Course)</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for c in &quot;中国人&quot;.chars() &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"课后练习\"><a href=\"#课后练习\" class=\"headerlink\" title=\"课后练习\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0\">课后练习</a></h2><blockquote>\n<p>Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。</p>\n<ul>\n<li><a href=\"https://zh.practice.rs/compound-types/string.html\">字符串</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md\">习题解答</a></li>\n</ul>\n</li>\n<li><a href=\"https://zh.practice.rs/compound-types/slice.html\">切片</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md\">习题解答</a></li>\n</ul>\n</li>\n<li><a href=\"https://zh.practice.rs/collections/String.html\">String</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md\">习题解答</a></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 填空并修复错误</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let s = String::from(&quot;hello, 世界&quot;);</span><br><span class=\"line\">    let slice1 = &amp;s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节</span><br><span class=\"line\">    assert_eq!(slice1, &quot;h&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let slice2 = &amp;s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节</span><br><span class=\"line\">    assert_eq!(slice2, &quot;世&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 迭代 s 中的所有字符</span><br><span class=\"line\">    for (i, c) in s.chars().enumerate() &#123;</span><br><span class=\"line\">        if i == 7 &#123;</span><br><span class=\"line\">            assert_eq!(c, &#x27;世&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 填空</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let mut s = String::new();</span><br><span class=\"line\">     s.push_str(&quot;hello&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let v = vec![104, 101, 108, 108, 111];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将字节数组转换成 String</span><br><span class=\"line\">    let s1 = String::from_utf8(v).unwrap();</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    assert_eq!(s, s1);</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 填空</span><br><span class=\"line\">use std::mem;</span><br><span class=\"line\"></span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let story = String::from(&quot;Rust By Practice&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 阻止 String 的数据被自动 drop</span><br><span class=\"line\">    let mut story = mem::ManuallyDrop::new(story);</span><br><span class=\"line\"></span><br><span class=\"line\">    let ptr = story.as_mut_ptr();</span><br><span class=\"line\">    let len = story.len();</span><br><span class=\"line\">    let capacity = story.capacity();</span><br><span class=\"line\"></span><br><span class=\"line\">    assert_eq!(16, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. </span><br><span class=\"line\">    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的</span><br><span class=\"line\">    let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert_eq!(*story, s);</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"2-元组\"><a href=\"#2-元组\" class=\"headerlink\" title=\"2.元组\"></a>2.<a href=\"https://course.rs/basic/compound-type/tuple.html#%E5%85%83%E7%BB%84\">元组</a></h1><h1 id=\"3-元组\"><a href=\"#3-元组\" class=\"headerlink\" title=\"3. 元组\"></a>3. 元组</h1><h1 id=\"4-test\"><a href=\"#4-test\" class=\"headerlink\" title=\"4. test\"></a>4. test</h1><p>待续。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-字符串和切片\"><a href=\"#1-字符串和切片\" class=\"headerlink\" title=\"1.字符串和切片\"></a>1.字符串和切片</h1><h2 id=\"什么是字符串\"><a href=\"#什么是字符串\" class=\"headerlink\" title=\"什么是字符串?\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2\">什么是字符串?</a></h2><p><strong>Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)</strong></p>\n<p><code>str</code> 类型是硬编码进可执行文件，也无法被修改，但是 <code>String</code> 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，<strong>当 Rust 用户提到字符串时，往往指的就是 <code>String</code> 类型和 <code>&amp;str</code> 字符串切片类型，这两个类型都是 UTF-8 编码</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1, 2, 3, 4, 5];</span><br><span class=\"line\"></span><br><span class=\"line\">let slice = &amp;a[1..3];</span><br><span class=\"line\"></span><br><span class=\"line\">assert_eq!(slice, &amp;[2, 3]);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"String-与-str-的转换\"><a href=\"#String-与-str-的转换\" class=\"headerlink\" title=\"String 与 &amp;str 的转换\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#string-%E4%B8%8E-str-%E7%9A%84%E8%BD%AC%E6%8D%A2\">String 与 &amp;str 的转换</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let s = String::from(&quot;hello,world!&quot;);</span><br><span class=\"line\">    say_hello(&amp;s);</span><br><span class=\"line\">    say_hello(&amp;s[..]);</span><br><span class=\"line\">    say_hello(s.as_str());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn say_hello(s: &amp;str) &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;,s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串索引\"><a href=\"#字符串索引\" class=\"headerlink\" title=\"字符串索引\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95\">字符串索引</a></h2><h2 id=\"字符串切片\"><a href=\"#字符串切片\" class=\"headerlink\" title=\"字符串切片\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87\">字符串切片</a></h2><p>通过索引区间来访问字符串时，<strong>需要格外的小心</strong>，一不注意，就会导致你程序的崩溃！</p>\n<h2 id=\"操作字符串\"><a href=\"#操作字符串\" class=\"headerlink\" title=\"操作字符串\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2\">操作字符串</a></h2><h4 id=\"追加-Push\"><a href=\"#追加-Push\" class=\"headerlink\" title=\"追加 (Push)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%BF%BD%E5%8A%A0-push\">追加 (Push)</a></h4><h4 id=\"插入-Insert\"><a href=\"#插入-Insert\" class=\"headerlink\" title=\"插入 (Insert)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%8F%92%E5%85%A5-insert\">插入 (Insert)</a></h4><h4 id=\"替换-Replace\"><a href=\"#替换-Replace\" class=\"headerlink\" title=\"替换 (Replace)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%9B%BF%E6%8D%A2-replace\">替换 (Replace)</a></h4><h4 id=\"删除-Delete\"><a href=\"#删除-Delete\" class=\"headerlink\" title=\"删除 (Delete)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%88%A0%E9%99%A4-delete\">删除 (Delete)</a></h4><h4 id=\"连接-Concatenate\"><a href=\"#连接-Concatenate\" class=\"headerlink\" title=\"连接 (Concatenate)\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%BF%9E%E6%8E%A5-concatenate\">连接 (Concatenate)</a></h4><h2 id=\"字符串转义\"><a href=\"#字符串转义\" class=\"headerlink\" title=\"字符串转义\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89\">字符串转义</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, &quot;hello \\\\x52\\\\x75\\\\x73\\\\x74&quot;);</span><br><span class=\"line\">    let raw_str = r&quot;Escapes don&#x27;t work here: \\x3F \\u&#123;211D&#125;&quot;;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, raw_str);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果字符串包含双引号，可以在开头和结尾加 #</span><br><span class=\"line\">    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, quotes);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果还是有歧义，可以继续增加，没有限制</span><br><span class=\"line\">    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, longer_delimiter);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作-UTF-8-字符串\"><a href=\"#操作-UTF-8-字符串\" class=\"headerlink\" title=\"操作 UTF-8 字符串\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2\">操作 UTF-8 字符串</a></h2><p><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0\">字符串与切片 - Rust语言圣经(Rust Course)</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for c in &quot;中国人&quot;.chars() &#123;</span><br><span class=\"line\">    println!(&quot;&#123;&#125;&quot;, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"课后练习\"><a href=\"#课后练习\" class=\"headerlink\" title=\"课后练习\"></a><a href=\"https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0\">课后练习</a></h2><blockquote>\n<p>Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。</p>\n<ul>\n<li><a href=\"https://zh.practice.rs/compound-types/string.html\">字符串</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md\">习题解答</a></li>\n</ul>\n</li>\n<li><a href=\"https://zh.practice.rs/compound-types/slice.html\">切片</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md\">习题解答</a></li>\n</ul>\n</li>\n<li><a href=\"https://zh.practice.rs/collections/String.html\">String</a><ul>\n<li><a href=\"https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md\">习题解答</a></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 填空并修复错误</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let s = String::from(&quot;hello, 世界&quot;);</span><br><span class=\"line\">    let slice1 = &amp;s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节</span><br><span class=\"line\">    assert_eq!(slice1, &quot;h&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let slice2 = &amp;s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节</span><br><span class=\"line\">    assert_eq!(slice2, &quot;世&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 迭代 s 中的所有字符</span><br><span class=\"line\">    for (i, c) in s.chars().enumerate() &#123;</span><br><span class=\"line\">        if i == 7 &#123;</span><br><span class=\"line\">            assert_eq!(c, &#x27;世&#x27;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 填空</span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let mut s = String::new();</span><br><span class=\"line\">     s.push_str(&quot;hello&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let v = vec![104, 101, 108, 108, 111];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将字节数组转换成 String</span><br><span class=\"line\">    let s1 = String::from_utf8(v).unwrap();</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    assert_eq!(s, s1);</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 填空</span><br><span class=\"line\">use std::mem;</span><br><span class=\"line\"></span><br><span class=\"line\">fn main() &#123;</span><br><span class=\"line\">    let story = String::from(&quot;Rust By Practice&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 阻止 String 的数据被自动 drop</span><br><span class=\"line\">    let mut story = mem::ManuallyDrop::new(story);</span><br><span class=\"line\"></span><br><span class=\"line\">    let ptr = story.as_mut_ptr();</span><br><span class=\"line\">    let len = story.len();</span><br><span class=\"line\">    let capacity = story.capacity();</span><br><span class=\"line\"></span><br><span class=\"line\">    assert_eq!(16, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. </span><br><span class=\"line\">    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的</span><br><span class=\"line\">    let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert_eq!(*story, s);</span><br><span class=\"line\"></span><br><span class=\"line\">    println!(&quot;Success!&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"2-元组\"><a href=\"#2-元组\" class=\"headerlink\" title=\"2.元组\"></a>2.<a href=\"https://course.rs/basic/compound-type/tuple.html#%E5%85%83%E7%BB%84\">元组</a></h1><h1 id=\"3-元组\"><a href=\"#3-元组\" class=\"headerlink\" title=\"3. 元组\"></a>3. 元组</h1><h1 id=\"4-test\"><a href=\"#4-test\" class=\"headerlink\" title=\"4. test\"></a>4. test</h1><p>待续。。。</p>\n"},{"title":"OSTEP-40-VSFS","date":"2024-05-15T06:40:25.000Z","_content":"\nhttps://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\n\n磁盘上的哪些结构存储文件系统的数据和元数据？\n\n当一个进程打开一个文件时会发生什么？\n\n在读取或写入期间访问哪些磁盘结构？\n","source":"_posts/OSTEP-40-VSFS.md","raw":"---\ntitle: OSTEP-40-VSFS\ndate: 2024-05-15 14:40:25\ncategories:\n- OSTEP\ntags:\n- vsfs\n---\n\nhttps://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\n\n磁盘上的哪些结构存储文件系统的数据和元数据？\n\n当一个进程打开一个文件时会发生什么？\n\n在读取或写入期间访问哪些磁盘结构？\n","slug":"OSTEP-40-VSFS","published":1,"updated":"2024-05-15T06:52:52.721Z","_id":"clw7gjvto00004zw06cc94zms","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf</a></p>\n<p>磁盘上的哪些结构存储文件系统的数据和元数据？</p>\n<p>当一个进程打开一个文件时会发生什么？</p>\n<p>在读取或写入期间访问哪些磁盘结构？</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf</a></p>\n<p>磁盘上的哪些结构存储文件系统的数据和元数据？</p>\n<p>当一个进程打开一个文件时会发生什么？</p>\n<p>在读取或写入期间访问哪些磁盘结构？</p>\n"},{"title":"linux-block","date":"2024-05-15T06:36:36.000Z","_content":"\n# 块设备驱动\n\n\n\n块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。\n","source":"_posts/linux-block.md","raw":"---\ntitle: linux-block\ndate: 2024-05-15 14:36:36\ncategories:\n- driver\ntags:\n- block\n\n---\n\n# 块设备驱动\n\n\n\n块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。\n","slug":"linux-block","published":1,"updated":"2024-05-15T06:51:56.921Z","_id":"clw7gjvtr00014zw0fnm7f1ci","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"块设备驱动\"><a href=\"#块设备驱动\" class=\"headerlink\" title=\"块设备驱动\"></a>块设备驱动</h1><p>块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"块设备驱动\"><a href=\"#块设备驱动\" class=\"headerlink\" title=\"块设备驱动\"></a>块设备驱动</h1><p>块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。</p>\n"},{"title":"U-Boot-fdt-GPT","date":"2024-05-15T06:37:05.000Z","_content":"\nU-Boot官网:https://docs.u-boot.org/en/latest/\n\nu-boot启动流程\n\n- 板子上电以后，首先执行的是ROM中的一段启动代码。启动代码**根据寄存器/外部管脚配置**，确定是进入下载模式，还是从某介质(Flash/EMMC/SD卡等存储设备)启动u-boot\n\n> ROM中的代码是固化的，无法修改\n\n# 一、介绍\n\n> FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。\n>\n> uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  \n\n> U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc/README.fdt-control\n\n### dtb在U-boot中的位置\n\n- dtb能够以两种形式编译到U-boot的镜像中\n\n1. dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)\n\n> 通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址\n\n1. dtb集成到u-boot的bin文件内部\n\n> 通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb\n\n1. 获取dts文件的地址gd->fdt_blob\n\n```\n// 宏用来表示是否把dtb文件放在uboot.bin的文件中\nCONFIG_OF_EMBED\n\n// 单独编译dtb文件\nCONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址\n\ngd->fdt_blob = (ulong *)&_end;\n\n// 可以通过fdtcontroladdr环境变量来指定fdt的地址\ngd->fdt_blob = (void *)getenv_ulong(\"fdtcontroladdr\", 16,\n\t\t\t\t\t\t(uintptr_t)gd->fdt_blob); \n```\n\n###  dtb解析接口\n\n- 定义在lib/fdtdec.c文件中，节点变量node中存放的是偏移地址\n\n```\n// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点\nint fdt_path_offset(const void *fdt, const char *path)\neg：node = fdt_path_offset(gd->fdt_blob, “/aliases”);\n\n// 获得节点node的某个字符串属性值\nconst void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)\neg： mac = fdt_getprop(gd->fdt_blob, node, “mac-address”, &len);\n\n// 获得节点node的某个整形数组属性值\nint fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)\neg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));\n\n// 获得节点node的地址属性值\nfdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)\neg：fdtdec_get_addr(blob, node, “reg”);\n\n// 获得config节点下的整形属性、bool属性、字符串等等\nfdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string\n\n// 获得chosen下的name节点的偏移\nint fdtdec_get_chosen_node(const void *blob, const char *name)\n\n// 获得chosen下name属性的值\nconst char *fdtdec_get_chosen_prop(const void *blob, const char *name)\n```\n\n- 定义在lib/fdtdec_common.c文件中\n\n```\n// 获得节点node的某个整形属性值\nint fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)\neg： bus->udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);\n\n// 获得节点node的某个无符号整形属性值\nfdtdec_get_uint\n```\n\n## fdt 命令\n\n对于u-boot提供了fdt的相关命令\n\n```\nfdt - flattened device tree utility commands\n\nUsage:\nfdt addr [-c]  <addr> [<length>]   - Set the [control] fdt location to <addr>\nfdt apply <addr>                    - Apply overlay to the DT\nfdt move   <fdt> <newaddr> <length> - Copy the fdt to <addr> and make it active\nfdt resize [<extrasize>]            - Resize fdt to size + padding to 4k addr + some optional <extrasize> if needed\nfdt print  <path> [<prop>]          - Recursive print starting at <path>\nfdt list   <path> [<prop>]          - Print one level starting at <path>\nfdt get value <var> <path> <prop>   - Get <property> and store in <var>\nfdt get name <var> <path> <index>   - Get name of node <index> and store in <var>\nfdt get addr <var> <path> <prop>    - Get start address of <property> and store in <var>\nfdt get size <var> <path> [<prop>]  - Get size of [<property>] or num nodes and store in <var>\nfdt set    <path> <prop> [<val>]    - Set <property> [to <val>]\nfdt mknode <path> <node>            - Create a new node after <path>\nfdt rm     <path> [<prop>]          - Delete the node or <property>\nfdt header                          - Display header info\nfdt bootcpu <id>                    - Set boot cpuid\nfdt memory <addr> <size>            - Add/Update memory node\nfdt rsvmem print                    - Show current mem reserves\nfdt rsvmem add <addr> <size>        - Add a mem reserve\nfdt rsvmem delete <index>           - Delete a mem reserves\nfdt chosen [<start> <end>]          - Add/update the /chosen branch in the tree\n                                        <start>/<end> - initrd start/end addr\nNOTE: Dereference aliases by omitting the leading '/', e.g. fdt print ethernet0.\n```\n\nfdt print加path参数，则打path内容，如下(其中/memory是path)：\n\n```c\nU-Boot> fdt print /memory\nmemory {\ndevice_type = \"memory\";\nreg = <0x70000000 0x4000000>;\n};\n\nU-Boot> fdt print #不加参数时，打印出整颗树\n```\n\n\n\n# 二、u-boot 获取GPT分区表\n\n在uboot中通过命令打印分区表\n\n```\npart list mmc 0\n```\n\n## 3588-android-uboot\n\n```c\n#include <common.h>\n#include <command.h>\n#include <android_image.h>\n#include <mmc.h>\n#include <stdlib.h>\n#include <memalign.h>\n#include <fdtdec.h>\n\n#define PART_MAX_COUNT  128\n#define\tLAB_SIZE\t\t512\n#define\tHEADER_OFFSET\tLAB_SIZE\n#define\tENTRY_OFFSET\t(2 * LAB_SIZE)\n#define\tVAL1_OFFSET\t\tsizeof(u64)\n#define\tVAL2_OFFSET\t\t(2 * sizeof(u64))\n\nstatic u64 get_gpt_blk_cnt_and_print(struct blk_desc *dev_desc,\n\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte) {\n\tchar efi_str[PARTNAME_SZ + 1];\n\tu64 gpt_part_size, gpt_blk_cnt = 0;\n\tgpt_entry *gpt_e;\n\tint i;\n\n\tgpt_e = *gpt_pte;\n\tfor (i = 0; i < gpt_head->num_partition_entries; i++) {\n\n\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,\n\t\t\t\t\t     PARTNAME_SZ + 1);\n\n\t\tprintf(\"%s: part: %2d name - GPT: %16s \",\n\t\t      __func__, i, efi_str);\n\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -\n\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + 1;\n\t\tgpt_blk_cnt += gpt_part_size;\n\t\t\n\t\tif(gpt_part_size == 1) \n\t\t\tbreak;\n\t\t\n\t\tprintf(\"size(LBA) - GPT: %8llu \",\n\t\t      (unsigned long long)gpt_part_size);\n\n\t\tprintf(\"start LBA - GPT: %8llu \\n\",\n\t\t      le64_to_cpu(gpt_e[i].starting_lba));\n\t}\n\n\treturn gpt_blk_cnt + gpt_e[0].starting_lba - 1;\n}\n\nstatic int get_gpt_meta_data(u64 *data_size, void **data)\n{\n    gpt_header *pgpt_head;\n\tgpt_entry *entries;\n\tvoid *meta_data;\n\tu64 meta_data_size, gpt_entries_size;\n\tstruct blk_desc *dev_desc = NULL;\n\tstruct mmc *mmc = NULL;\n\tu64 blk_size = 0;\n\tu64 blk_cnt = 0;\n\tu64 tag = 0x55AA;\n\tlbaint_t lba;\n    \n\tif (!data_size || !data) {\n\t\tprintf(\"%s *** ERROR: Invalid Argument(s) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    mmc = do_returnmmc();\n\tif (!mmc)\n\t\treturn CMD_RET_FAILURE;\n    \n    dev_desc = mmc_get_blk_desc(mmc);\n\tif (!dev_desc) {\n\t\tprintf(\"%s *** ERROR: mmc_get_blk_desc err ***\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tgpt_entries_size = sizeof(gpt_entry) * PART_MAX_COUNT;\n\tmeta_data_size = LAB_SIZE + sizeof(gpt_header) + gpt_entries_size;\n\tmeta_data = malloc(meta_data_size);\n\tif(!meta_data) {\n\t\tprintf(\"%s *** ERROR: malloc memory (gpt meta data) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    memset(meta_data, 0, meta_data_size);\n\tpgpt_head = (gpt_header *)((char *)meta_data + HEADER_OFFSET);\n\tentries = (gpt_entry *)((char *)meta_data + ENTRY_OFFSET);\n\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc->blksz);\n\n\t/* Read MBR Header from device */\n\tlba = 0; /* MBR is always at 0 */\n\tblk_cnt = 1; /* MBR (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != 1) {\n\t\tprintf(\"*** ERROR: Can't read MBR header ***\\n\");\n\t\tgoto ERROR_OUT;\n\t}\n\n\t/* Read GPT Header from device */\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tblk_cnt = 1; /* GPT Header (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != 1) {\n    \tprintf(\"%s *** ERROR: Can't read GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tif (validate_gpt_header(pgpt_head, lba, dev_desc->lba)) {\n\t\tprintf(\"%s *** ERROR: validate_gpt_header GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tif (dev_desc->sig_type == SIG_TYPE_NONE) {\n\t\tefi_guid_t empty = {};\n\t\tif (memcmp(&pgpt_head->disk_guid, &empty, sizeof(empty))) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_GUID;\n\t\t\tmemcpy(&dev_desc->guid_sig, &pgpt_head->disk_guid,\n\t\t\t      sizeof(empty));\n\t\t} else if (mbr->unique_mbr_signature != 0) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_MBR;\n\t\t\tdev_desc->mbr_sig = mbr->unique_mbr_signature;\n\t\t}\n\t}\n\n\t/* Read GPT Entries from device */\n\tlba = le64_to_cpu(pgpt_head->partition_entry_lba);\n\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head->num_partition_entries) *\n\t\t\t\t   \tle32_to_cpu(pgpt_head->sizeof_partition_entry)),\n\t\t\t\t  \tdev_desc);\n\tif (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) {\n\t\tprintf(\"%s *** ERROR:read entries (lba=%llu) ***\\n\",\n\t\t\t\t__func__, pgpt_head->partition_entry_lba);\n\t\tgoto ERROR_OUT;\n\t}\n\t\n\tblk_size = dev_desc->blksz;\n\tvalidate_gpt_entries(pgpt_head, entries);\n\t\n\tdebug(\"%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n\",\n\t\t\t\t__func__, (unsigned long long)(ulong)lba, blk_cnt, blk_size);\n\t\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n    \n    /* \n\t * build info, layout of meta_data:\n\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries\n\t */\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n\t/*this value makes we known the reserved memory is available*/\n\tmemcpy(meta_data, (void *)&tag, sizeof(u64));\n\tmemcpy(meta_data + VAL1_OFFSET, (void *)&blk_size, sizeof(u64));\n\tmemcpy(meta_data + VAL2_OFFSET, (void *)&blk_cnt, sizeof(u64));\n\n\t*data_size = meta_data_size;\n\t*data = meta_data;\n\n\treturn 0;\n\nERROR_OUT:\n\tfree(meta_data);\n\tmeta_data = NULL;\n\treturn -1;\n}\n```\n\n\n\n参考：\n\n[Device Tree（四）：文件结构解析 (wowotech.net)](http://www.wowotech.net/device_model/dt-code-file-struct-parse.html)\n\n[Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376295326)\n\n[Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376296222)\n\nhttps://www.cnblogs.com/solo666/p/16518154.html\n","source":"_posts/U-Boot-fdt-GPT.md","raw":"---\ntitle: U-Boot-fdt-GPT\ndate: 2024-05-15 14:37:05\ncategories:\n- uboot\ntags:\n- fdt\n- GPT\n- rk3588\n---\n\nU-Boot官网:https://docs.u-boot.org/en/latest/\n\nu-boot启动流程\n\n- 板子上电以后，首先执行的是ROM中的一段启动代码。启动代码**根据寄存器/外部管脚配置**，确定是进入下载模式，还是从某介质(Flash/EMMC/SD卡等存储设备)启动u-boot\n\n> ROM中的代码是固化的，无法修改\n\n# 一、介绍\n\n> FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。\n>\n> uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  \n\n> U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc/README.fdt-control\n\n### dtb在U-boot中的位置\n\n- dtb能够以两种形式编译到U-boot的镜像中\n\n1. dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)\n\n> 通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址\n\n1. dtb集成到u-boot的bin文件内部\n\n> 通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb\n\n1. 获取dts文件的地址gd->fdt_blob\n\n```\n// 宏用来表示是否把dtb文件放在uboot.bin的文件中\nCONFIG_OF_EMBED\n\n// 单独编译dtb文件\nCONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址\n\ngd->fdt_blob = (ulong *)&_end;\n\n// 可以通过fdtcontroladdr环境变量来指定fdt的地址\ngd->fdt_blob = (void *)getenv_ulong(\"fdtcontroladdr\", 16,\n\t\t\t\t\t\t(uintptr_t)gd->fdt_blob); \n```\n\n###  dtb解析接口\n\n- 定义在lib/fdtdec.c文件中，节点变量node中存放的是偏移地址\n\n```\n// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点\nint fdt_path_offset(const void *fdt, const char *path)\neg：node = fdt_path_offset(gd->fdt_blob, “/aliases”);\n\n// 获得节点node的某个字符串属性值\nconst void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)\neg： mac = fdt_getprop(gd->fdt_blob, node, “mac-address”, &len);\n\n// 获得节点node的某个整形数组属性值\nint fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)\neg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));\n\n// 获得节点node的地址属性值\nfdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)\neg：fdtdec_get_addr(blob, node, “reg”);\n\n// 获得config节点下的整形属性、bool属性、字符串等等\nfdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string\n\n// 获得chosen下的name节点的偏移\nint fdtdec_get_chosen_node(const void *blob, const char *name)\n\n// 获得chosen下name属性的值\nconst char *fdtdec_get_chosen_prop(const void *blob, const char *name)\n```\n\n- 定义在lib/fdtdec_common.c文件中\n\n```\n// 获得节点node的某个整形属性值\nint fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)\neg： bus->udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);\n\n// 获得节点node的某个无符号整形属性值\nfdtdec_get_uint\n```\n\n## fdt 命令\n\n对于u-boot提供了fdt的相关命令\n\n```\nfdt - flattened device tree utility commands\n\nUsage:\nfdt addr [-c]  <addr> [<length>]   - Set the [control] fdt location to <addr>\nfdt apply <addr>                    - Apply overlay to the DT\nfdt move   <fdt> <newaddr> <length> - Copy the fdt to <addr> and make it active\nfdt resize [<extrasize>]            - Resize fdt to size + padding to 4k addr + some optional <extrasize> if needed\nfdt print  <path> [<prop>]          - Recursive print starting at <path>\nfdt list   <path> [<prop>]          - Print one level starting at <path>\nfdt get value <var> <path> <prop>   - Get <property> and store in <var>\nfdt get name <var> <path> <index>   - Get name of node <index> and store in <var>\nfdt get addr <var> <path> <prop>    - Get start address of <property> and store in <var>\nfdt get size <var> <path> [<prop>]  - Get size of [<property>] or num nodes and store in <var>\nfdt set    <path> <prop> [<val>]    - Set <property> [to <val>]\nfdt mknode <path> <node>            - Create a new node after <path>\nfdt rm     <path> [<prop>]          - Delete the node or <property>\nfdt header                          - Display header info\nfdt bootcpu <id>                    - Set boot cpuid\nfdt memory <addr> <size>            - Add/Update memory node\nfdt rsvmem print                    - Show current mem reserves\nfdt rsvmem add <addr> <size>        - Add a mem reserve\nfdt rsvmem delete <index>           - Delete a mem reserves\nfdt chosen [<start> <end>]          - Add/update the /chosen branch in the tree\n                                        <start>/<end> - initrd start/end addr\nNOTE: Dereference aliases by omitting the leading '/', e.g. fdt print ethernet0.\n```\n\nfdt print加path参数，则打path内容，如下(其中/memory是path)：\n\n```c\nU-Boot> fdt print /memory\nmemory {\ndevice_type = \"memory\";\nreg = <0x70000000 0x4000000>;\n};\n\nU-Boot> fdt print #不加参数时，打印出整颗树\n```\n\n\n\n# 二、u-boot 获取GPT分区表\n\n在uboot中通过命令打印分区表\n\n```\npart list mmc 0\n```\n\n## 3588-android-uboot\n\n```c\n#include <common.h>\n#include <command.h>\n#include <android_image.h>\n#include <mmc.h>\n#include <stdlib.h>\n#include <memalign.h>\n#include <fdtdec.h>\n\n#define PART_MAX_COUNT  128\n#define\tLAB_SIZE\t\t512\n#define\tHEADER_OFFSET\tLAB_SIZE\n#define\tENTRY_OFFSET\t(2 * LAB_SIZE)\n#define\tVAL1_OFFSET\t\tsizeof(u64)\n#define\tVAL2_OFFSET\t\t(2 * sizeof(u64))\n\nstatic u64 get_gpt_blk_cnt_and_print(struct blk_desc *dev_desc,\n\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte) {\n\tchar efi_str[PARTNAME_SZ + 1];\n\tu64 gpt_part_size, gpt_blk_cnt = 0;\n\tgpt_entry *gpt_e;\n\tint i;\n\n\tgpt_e = *gpt_pte;\n\tfor (i = 0; i < gpt_head->num_partition_entries; i++) {\n\n\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,\n\t\t\t\t\t     PARTNAME_SZ + 1);\n\n\t\tprintf(\"%s: part: %2d name - GPT: %16s \",\n\t\t      __func__, i, efi_str);\n\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -\n\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + 1;\n\t\tgpt_blk_cnt += gpt_part_size;\n\t\t\n\t\tif(gpt_part_size == 1) \n\t\t\tbreak;\n\t\t\n\t\tprintf(\"size(LBA) - GPT: %8llu \",\n\t\t      (unsigned long long)gpt_part_size);\n\n\t\tprintf(\"start LBA - GPT: %8llu \\n\",\n\t\t      le64_to_cpu(gpt_e[i].starting_lba));\n\t}\n\n\treturn gpt_blk_cnt + gpt_e[0].starting_lba - 1;\n}\n\nstatic int get_gpt_meta_data(u64 *data_size, void **data)\n{\n    gpt_header *pgpt_head;\n\tgpt_entry *entries;\n\tvoid *meta_data;\n\tu64 meta_data_size, gpt_entries_size;\n\tstruct blk_desc *dev_desc = NULL;\n\tstruct mmc *mmc = NULL;\n\tu64 blk_size = 0;\n\tu64 blk_cnt = 0;\n\tu64 tag = 0x55AA;\n\tlbaint_t lba;\n    \n\tif (!data_size || !data) {\n\t\tprintf(\"%s *** ERROR: Invalid Argument(s) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    mmc = do_returnmmc();\n\tif (!mmc)\n\t\treturn CMD_RET_FAILURE;\n    \n    dev_desc = mmc_get_blk_desc(mmc);\n\tif (!dev_desc) {\n\t\tprintf(\"%s *** ERROR: mmc_get_blk_desc err ***\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tgpt_entries_size = sizeof(gpt_entry) * PART_MAX_COUNT;\n\tmeta_data_size = LAB_SIZE + sizeof(gpt_header) + gpt_entries_size;\n\tmeta_data = malloc(meta_data_size);\n\tif(!meta_data) {\n\t\tprintf(\"%s *** ERROR: malloc memory (gpt meta data) ***\\n\", __func__);\n\t\treturn -1;\n\t}\n    \n    memset(meta_data, 0, meta_data_size);\n\tpgpt_head = (gpt_header *)((char *)meta_data + HEADER_OFFSET);\n\tentries = (gpt_entry *)((char *)meta_data + ENTRY_OFFSET);\n\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc->blksz);\n\n\t/* Read MBR Header from device */\n\tlba = 0; /* MBR is always at 0 */\n\tblk_cnt = 1; /* MBR (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != 1) {\n\t\tprintf(\"*** ERROR: Can't read MBR header ***\\n\");\n\t\tgoto ERROR_OUT;\n\t}\n\n\t/* Read GPT Header from device */\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tblk_cnt = 1; /* GPT Header (1 block) */\n\tif (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != 1) {\n    \tprintf(\"%s *** ERROR: Can't read GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;\n\tif (validate_gpt_header(pgpt_head, lba, dev_desc->lba)) {\n\t\tprintf(\"%s *** ERROR: validate_gpt_header GPT header ***\\n\", __func__);\n\t\tgoto ERROR_OUT;\n\t}\n\n\tif (dev_desc->sig_type == SIG_TYPE_NONE) {\n\t\tefi_guid_t empty = {};\n\t\tif (memcmp(&pgpt_head->disk_guid, &empty, sizeof(empty))) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_GUID;\n\t\t\tmemcpy(&dev_desc->guid_sig, &pgpt_head->disk_guid,\n\t\t\t      sizeof(empty));\n\t\t} else if (mbr->unique_mbr_signature != 0) {\n\t\t\tdev_desc->sig_type = SIG_TYPE_MBR;\n\t\t\tdev_desc->mbr_sig = mbr->unique_mbr_signature;\n\t\t}\n\t}\n\n\t/* Read GPT Entries from device */\n\tlba = le64_to_cpu(pgpt_head->partition_entry_lba);\n\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head->num_partition_entries) *\n\t\t\t\t   \tle32_to_cpu(pgpt_head->sizeof_partition_entry)),\n\t\t\t\t  \tdev_desc);\n\tif (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) {\n\t\tprintf(\"%s *** ERROR:read entries (lba=%llu) ***\\n\",\n\t\t\t\t__func__, pgpt_head->partition_entry_lba);\n\t\tgoto ERROR_OUT;\n\t}\n\t\n\tblk_size = dev_desc->blksz;\n\tvalidate_gpt_entries(pgpt_head, entries);\n\t\n\tdebug(\"%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n\",\n\t\t\t\t__func__, (unsigned long long)(ulong)lba, blk_cnt, blk_size);\n\t\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n    \n    /* \n\t * build info, layout of meta_data:\n\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries\n\t */\n\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &entries);\n\t/*this value makes we known the reserved memory is available*/\n\tmemcpy(meta_data, (void *)&tag, sizeof(u64));\n\tmemcpy(meta_data + VAL1_OFFSET, (void *)&blk_size, sizeof(u64));\n\tmemcpy(meta_data + VAL2_OFFSET, (void *)&blk_cnt, sizeof(u64));\n\n\t*data_size = meta_data_size;\n\t*data = meta_data;\n\n\treturn 0;\n\nERROR_OUT:\n\tfree(meta_data);\n\tmeta_data = NULL;\n\treturn -1;\n}\n```\n\n\n\n参考：\n\n[Device Tree（四）：文件结构解析 (wowotech.net)](http://www.wowotech.net/device_model/dt-code-file-struct-parse.html)\n\n[Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376295326)\n\n[Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376296222)\n\nhttps://www.cnblogs.com/solo666/p/16518154.html\n","slug":"U-Boot-fdt-GPT","published":1,"updated":"2024-05-15T06:50:22.548Z","_id":"clw7gjvtv00044zw001hi1y1n","comments":1,"layout":"post","photos":[],"link":"","content":"<p>U-Boot官网:<a href=\"https://docs.u-boot.org/en/latest/\">https://docs.u-boot.org/en/latest/</a></p>\n<p>u-boot启动流程</p>\n<ul>\n<li>板子上电以后，首先执行的是ROM中的一段启动代码。启动代码<strong>根据寄存器&#x2F;外部管脚配置</strong>，确定是进入下载模式，还是从某介质(Flash&#x2F;EMMC&#x2F;SD卡等存储设备)启动u-boot</li>\n</ul>\n<blockquote>\n<p>ROM中的代码是固化的，无法修改</p>\n</blockquote>\n<h1 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h1><blockquote>\n<p>FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。</p>\n<p>uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  </p>\n</blockquote>\n<blockquote>\n<p>U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc&#x2F;README.fdt-control</p>\n</blockquote>\n<h3 id=\"dtb在U-boot中的位置\"><a href=\"#dtb在U-boot中的位置\" class=\"headerlink\" title=\"dtb在U-boot中的位置\"></a>dtb在U-boot中的位置</h3><ul>\n<li>dtb能够以两种形式编译到U-boot的镜像中</li>\n</ul>\n<ol>\n<li>dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址</p>\n</blockquote>\n<ol>\n<li>dtb集成到u-boot的bin文件内部</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb</p>\n</blockquote>\n<ol>\n<li>获取dts文件的地址gd-&gt;fdt_blob</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 宏用来表示是否把dtb文件放在uboot.bin的文件中</span><br><span class=\"line\">CONFIG_OF_EMBED</span><br><span class=\"line\"></span><br><span class=\"line\">// 单独编译dtb文件</span><br><span class=\"line\">CONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址</span><br><span class=\"line\"></span><br><span class=\"line\">gd-&gt;fdt_blob = (ulong *)&amp;_end;</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以通过fdtcontroladdr环境变量来指定fdt的地址</span><br><span class=\"line\">gd-&gt;fdt_blob = (void *)getenv_ulong(&quot;fdtcontroladdr&quot;, 16,</span><br><span class=\"line\">\t\t\t\t\t\t(uintptr_t)gd-&gt;fdt_blob); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dtb解析接口\"><a href=\"#dtb解析接口\" class=\"headerlink\" title=\"dtb解析接口\"></a>dtb解析接口</h3><ul>\n<li>定义在lib&#x2F;fdtdec.c文件中，节点变量node中存放的是偏移地址</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点</span><br><span class=\"line\">int fdt_path_offset(const void *fdt, const char *path)</span><br><span class=\"line\">eg：node = fdt_path_offset(gd-&gt;fdt_blob, “/aliases”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个字符串属性值</span><br><span class=\"line\">const void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)</span><br><span class=\"line\">eg： mac = fdt_getprop(gd-&gt;fdt_blob, node, “mac-address”, &amp;len);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个整形数组属性值</span><br><span class=\"line\">int fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)</span><br><span class=\"line\">eg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的地址属性值</span><br><span class=\"line\">fdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)</span><br><span class=\"line\">eg：fdtdec_get_addr(blob, node, “reg”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得config节点下的整形属性、bool属性、字符串等等</span><br><span class=\"line\">fdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下的name节点的偏移</span><br><span class=\"line\">int fdtdec_get_chosen_node(const void *blob, const char *name)</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下name属性的值</span><br><span class=\"line\">const char *fdtdec_get_chosen_prop(const void *blob, const char *name)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义在lib&#x2F;fdtdec_common.c文件中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得节点node的某个整形属性值</span><br><span class=\"line\">int fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)</span><br><span class=\"line\">eg： bus-&gt;udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个无符号整形属性值</span><br><span class=\"line\">fdtdec_get_uint</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fdt-命令\"><a href=\"#fdt-命令\" class=\"headerlink\" title=\"fdt 命令\"></a>fdt 命令</h2><p>对于u-boot提供了fdt的相关命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdt - flattened device tree utility commands</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">fdt addr [-c]  &lt;addr&gt; [&lt;length&gt;]   - Set the [control] fdt location to &lt;addr&gt;</span><br><span class=\"line\">fdt apply &lt;addr&gt;                    - Apply overlay to the DT</span><br><span class=\"line\">fdt move   &lt;fdt&gt; &lt;newaddr&gt; &lt;length&gt; - Copy the fdt to &lt;addr&gt; and make it active</span><br><span class=\"line\">fdt resize [&lt;extrasize&gt;]            - Resize fdt to size + padding to 4k addr + some optional &lt;extrasize&gt; if needed</span><br><span class=\"line\">fdt print  &lt;path&gt; [&lt;prop&gt;]          - Recursive print starting at &lt;path&gt;</span><br><span class=\"line\">fdt list   &lt;path&gt; [&lt;prop&gt;]          - Print one level starting at &lt;path&gt;</span><br><span class=\"line\">fdt get value &lt;var&gt; &lt;path&gt; &lt;prop&gt;   - Get &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get name &lt;var&gt; &lt;path&gt; &lt;index&gt;   - Get name of node &lt;index&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get addr &lt;var&gt; &lt;path&gt; &lt;prop&gt;    - Get start address of &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get size &lt;var&gt; &lt;path&gt; [&lt;prop&gt;]  - Get size of [&lt;property&gt;] or num nodes and store in &lt;var&gt;</span><br><span class=\"line\">fdt set    &lt;path&gt; &lt;prop&gt; [&lt;val&gt;]    - Set &lt;property&gt; [to &lt;val&gt;]</span><br><span class=\"line\">fdt mknode &lt;path&gt; &lt;node&gt;            - Create a new node after &lt;path&gt;</span><br><span class=\"line\">fdt rm     &lt;path&gt; [&lt;prop&gt;]          - Delete the node or &lt;property&gt;</span><br><span class=\"line\">fdt header                          - Display header info</span><br><span class=\"line\">fdt bootcpu &lt;id&gt;                    - Set boot cpuid</span><br><span class=\"line\">fdt memory &lt;addr&gt; &lt;size&gt;            - Add/Update memory node</span><br><span class=\"line\">fdt rsvmem print                    - Show current mem reserves</span><br><span class=\"line\">fdt rsvmem add &lt;addr&gt; &lt;size&gt;        - Add a mem reserve</span><br><span class=\"line\">fdt rsvmem delete &lt;index&gt;           - Delete a mem reserves</span><br><span class=\"line\">fdt chosen [&lt;start&gt; &lt;end&gt;]          - Add/update the /chosen branch in the tree</span><br><span class=\"line\">                                        &lt;start&gt;/&lt;end&gt; - initrd start/end addr</span><br><span class=\"line\">NOTE: Dereference aliases by omitting the leading &#x27;/&#x27;, e.g. fdt print ethernet0.</span><br></pre></td></tr></table></figure>\n\n<p>fdt print加path参数，则打path内容，如下(其中&#x2F;memory是path)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">U-Boot&gt; fdt print /memory</span><br><span class=\"line\">memory &#123;</span><br><span class=\"line\">device_type = <span class=\"string\">&quot;memory&quot;</span>;</span><br><span class=\"line\">reg = &lt;<span class=\"number\">0x70000000</span> <span class=\"number\">0x4000000</span>&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot&gt; fdt print #不加参数时，打印出整颗树</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"二、u-boot-获取GPT分区表\"><a href=\"#二、u-boot-获取GPT分区表\" class=\"headerlink\" title=\"二、u-boot 获取GPT分区表\"></a>二、u-boot 获取GPT分区表</h1><p>在uboot中通过命令打印分区表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">part list mmc 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3588-android-uboot\"><a href=\"#3588-android-uboot\" class=\"headerlink\" title=\"3588-android-uboot\"></a>3588-android-uboot</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;common.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;command.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;android_image.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mmc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memalign.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fdtdec.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PART_MAX_COUNT  128</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tLAB_SIZE\t\t512</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tHEADER_OFFSET\tLAB_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tENTRY_OFFSET\t(2 * LAB_SIZE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL1_OFFSET\t\tsizeof(u64)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL2_OFFSET\t\t(2 * sizeof(u64))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">get_gpt_blk_cnt_and_print</span><span class=\"params\">(<span class=\"keyword\">struct</span> blk_desc *dev_desc,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> efi_str[PARTNAME_SZ + <span class=\"number\">1</span>];</span><br><span class=\"line\">\tu64 gpt_part_size, gpt_blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tgpt_entry *gpt_e;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_e = *gpt_pte;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; gpt_head-&gt;num_partition_entries; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,</span><br><span class=\"line\">\t\t\t\t\t     PARTNAME_SZ + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s: part: %2d name - GPT: %16s &quot;</span>,</span><br><span class=\"line\">\t\t      __func__, i, efi_str);</span><br><span class=\"line\">\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -</span><br><span class=\"line\">\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tgpt_blk_cnt += gpt_part_size;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(gpt_part_size == <span class=\"number\">1</span>) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size(LBA) - GPT: %8llu &quot;</span>,</span><br><span class=\"line\">\t\t      (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)gpt_part_size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start LBA - GPT: %8llu \\n&quot;</span>,</span><br><span class=\"line\">\t\t      le64_to_cpu(gpt_e[i].starting_lba));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gpt_blk_cnt + gpt_e[<span class=\"number\">0</span>].starting_lba - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">get_gpt_meta_data</span><span class=\"params\">(u64 *data_size, <span class=\"type\">void</span> **data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gpt_header *pgpt_head;</span><br><span class=\"line\">\tgpt_entry *entries;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *meta_data;</span><br><span class=\"line\">\tu64 meta_data_size, gpt_entries_size;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_desc</span> *<span class=\"title\">dev_desc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mmc</span> *<span class=\"title\">mmc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tu64 blk_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 tag = <span class=\"number\">0x55AA</span>;</span><br><span class=\"line\">\t<span class=\"type\">lbaint_t</span> lba;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!data_size || !data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Invalid Argument(s) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mmc = do_returnmmc();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!mmc)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> CMD_RET_FAILURE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    dev_desc = mmc_get_blk_desc(mmc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!dev_desc) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: mmc_get_blk_desc err ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_entries_size = <span class=\"keyword\">sizeof</span>(gpt_entry) * PART_MAX_COUNT;</span><br><span class=\"line\">\tmeta_data_size = LAB_SIZE + <span class=\"keyword\">sizeof</span>(gpt_header) + gpt_entries_size;</span><br><span class=\"line\">\tmeta_data = <span class=\"built_in\">malloc</span>(meta_data_size);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!meta_data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: malloc memory (gpt meta data) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(meta_data, <span class=\"number\">0</span>, meta_data_size);</span><br><span class=\"line\">\tpgpt_head = (gpt_header *)((<span class=\"type\">char</span> *)meta_data + HEADER_OFFSET);</span><br><span class=\"line\">\tentries = (gpt_entry *)((<span class=\"type\">char</span> *)meta_data + ENTRY_OFFSET);</span><br><span class=\"line\">\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc-&gt;blksz);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read MBR Header from device */</span></span><br><span class=\"line\">\tlba = <span class=\"number\">0</span>; <span class=\"comment\">/* MBR is always at 0 */</span></span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* MBR (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*** ERROR: Can&#x27;t read MBR header ***\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Header from device */</span></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* GPT Header (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Can&#x27;t read GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (validate_gpt_header(pgpt_head, lba, dev_desc-&gt;lba)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: validate_gpt_header GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dev_desc-&gt;sig_type == SIG_TYPE_NONE) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">efi_guid_t</span> empty = &#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">memcmp</span>(&amp;pgpt_head-&gt;disk_guid, &amp;empty, <span class=\"keyword\">sizeof</span>(empty))) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_GUID;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(&amp;dev_desc-&gt;guid_sig, &amp;pgpt_head-&gt;disk_guid,</span><br><span class=\"line\">\t\t\t      <span class=\"keyword\">sizeof</span>(empty));</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mbr-&gt;unique_mbr_signature != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_MBR;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;mbr_sig = mbr-&gt;unique_mbr_signature;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Entries from device */</span></span><br><span class=\"line\">\tlba = le64_to_cpu(pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head-&gt;num_partition_entries) *</span><br><span class=\"line\">\t\t\t\t   \tle32_to_cpu(pgpt_head-&gt;sizeof_partition_entry)),</span><br><span class=\"line\">\t\t\t\t  \tdev_desc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR:read entries (lba=%llu) ***\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_size = dev_desc-&gt;blksz;</span><br><span class=\"line\">\tvalidate_gpt_entries(pgpt_head, entries);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdebug(<span class=\"string\">&quot;%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)(ulong)lba, blk_cnt, blk_size);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">\t * build info, layout of meta_data:</span></span><br><span class=\"line\"><span class=\"comment\">\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">\t<span class=\"comment\">/*this value makes we known the reserved memory is available*/</span></span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data, (<span class=\"type\">void</span> *)&amp;tag, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL1_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_size, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL2_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_cnt, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data_size = meta_data_size;</span><br><span class=\"line\">\t*data = meta_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR_OUT:</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(meta_data);</span><br><span class=\"line\">\tmeta_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参考：</p>\n<p><a href=\"http://www.wowotech.net/device_model/dt-code-file-struct-parse.html\">Device Tree（四）：文件结构解析 (wowotech.net)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376295326\">Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376296222\">Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/solo666/p/16518154.html\">https://www.cnblogs.com/solo666/p/16518154.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>U-Boot官网:<a href=\"https://docs.u-boot.org/en/latest/\">https://docs.u-boot.org/en/latest/</a></p>\n<p>u-boot启动流程</p>\n<ul>\n<li>板子上电以后，首先执行的是ROM中的一段启动代码。启动代码<strong>根据寄存器&#x2F;外部管脚配置</strong>，确定是进入下载模式，还是从某介质(Flash&#x2F;EMMC&#x2F;SD卡等存储设备)启动u-boot</li>\n</ul>\n<blockquote>\n<p>ROM中的代码是固化的，无法修改</p>\n</blockquote>\n<h1 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h1><blockquote>\n<p>FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。</p>\n<p>uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  </p>\n</blockquote>\n<blockquote>\n<p>U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc&#x2F;README.fdt-control</p>\n</blockquote>\n<h3 id=\"dtb在U-boot中的位置\"><a href=\"#dtb在U-boot中的位置\" class=\"headerlink\" title=\"dtb在U-boot中的位置\"></a>dtb在U-boot中的位置</h3><ul>\n<li>dtb能够以两种形式编译到U-boot的镜像中</li>\n</ul>\n<ol>\n<li>dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址</p>\n</blockquote>\n<ol>\n<li>dtb集成到u-boot的bin文件内部</li>\n</ol>\n<blockquote>\n<p>通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb</p>\n</blockquote>\n<ol>\n<li>获取dts文件的地址gd-&gt;fdt_blob</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 宏用来表示是否把dtb文件放在uboot.bin的文件中</span><br><span class=\"line\">CONFIG_OF_EMBED</span><br><span class=\"line\"></span><br><span class=\"line\">// 单独编译dtb文件</span><br><span class=\"line\">CONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址</span><br><span class=\"line\"></span><br><span class=\"line\">gd-&gt;fdt_blob = (ulong *)&amp;_end;</span><br><span class=\"line\"></span><br><span class=\"line\">// 可以通过fdtcontroladdr环境变量来指定fdt的地址</span><br><span class=\"line\">gd-&gt;fdt_blob = (void *)getenv_ulong(&quot;fdtcontroladdr&quot;, 16,</span><br><span class=\"line\">\t\t\t\t\t\t(uintptr_t)gd-&gt;fdt_blob); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dtb解析接口\"><a href=\"#dtb解析接口\" class=\"headerlink\" title=\"dtb解析接口\"></a>dtb解析接口</h3><ul>\n<li>定义在lib&#x2F;fdtdec.c文件中，节点变量node中存放的是偏移地址</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点</span><br><span class=\"line\">int fdt_path_offset(const void *fdt, const char *path)</span><br><span class=\"line\">eg：node = fdt_path_offset(gd-&gt;fdt_blob, “/aliases”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个字符串属性值</span><br><span class=\"line\">const void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)</span><br><span class=\"line\">eg： mac = fdt_getprop(gd-&gt;fdt_blob, node, “mac-address”, &amp;len);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个整形数组属性值</span><br><span class=\"line\">int fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)</span><br><span class=\"line\">eg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的地址属性值</span><br><span class=\"line\">fdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)</span><br><span class=\"line\">eg：fdtdec_get_addr(blob, node, “reg”);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得config节点下的整形属性、bool属性、字符串等等</span><br><span class=\"line\">fdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下的name节点的偏移</span><br><span class=\"line\">int fdtdec_get_chosen_node(const void *blob, const char *name)</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得chosen下name属性的值</span><br><span class=\"line\">const char *fdtdec_get_chosen_prop(const void *blob, const char *name)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义在lib&#x2F;fdtdec_common.c文件中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得节点node的某个整形属性值</span><br><span class=\"line\">int fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)</span><br><span class=\"line\">eg： bus-&gt;udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);</span><br><span class=\"line\"></span><br><span class=\"line\">// 获得节点node的某个无符号整形属性值</span><br><span class=\"line\">fdtdec_get_uint</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"fdt-命令\"><a href=\"#fdt-命令\" class=\"headerlink\" title=\"fdt 命令\"></a>fdt 命令</h2><p>对于u-boot提供了fdt的相关命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdt - flattened device tree utility commands</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">fdt addr [-c]  &lt;addr&gt; [&lt;length&gt;]   - Set the [control] fdt location to &lt;addr&gt;</span><br><span class=\"line\">fdt apply &lt;addr&gt;                    - Apply overlay to the DT</span><br><span class=\"line\">fdt move   &lt;fdt&gt; &lt;newaddr&gt; &lt;length&gt; - Copy the fdt to &lt;addr&gt; and make it active</span><br><span class=\"line\">fdt resize [&lt;extrasize&gt;]            - Resize fdt to size + padding to 4k addr + some optional &lt;extrasize&gt; if needed</span><br><span class=\"line\">fdt print  &lt;path&gt; [&lt;prop&gt;]          - Recursive print starting at &lt;path&gt;</span><br><span class=\"line\">fdt list   &lt;path&gt; [&lt;prop&gt;]          - Print one level starting at &lt;path&gt;</span><br><span class=\"line\">fdt get value &lt;var&gt; &lt;path&gt; &lt;prop&gt;   - Get &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get name &lt;var&gt; &lt;path&gt; &lt;index&gt;   - Get name of node &lt;index&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get addr &lt;var&gt; &lt;path&gt; &lt;prop&gt;    - Get start address of &lt;property&gt; and store in &lt;var&gt;</span><br><span class=\"line\">fdt get size &lt;var&gt; &lt;path&gt; [&lt;prop&gt;]  - Get size of [&lt;property&gt;] or num nodes and store in &lt;var&gt;</span><br><span class=\"line\">fdt set    &lt;path&gt; &lt;prop&gt; [&lt;val&gt;]    - Set &lt;property&gt; [to &lt;val&gt;]</span><br><span class=\"line\">fdt mknode &lt;path&gt; &lt;node&gt;            - Create a new node after &lt;path&gt;</span><br><span class=\"line\">fdt rm     &lt;path&gt; [&lt;prop&gt;]          - Delete the node or &lt;property&gt;</span><br><span class=\"line\">fdt header                          - Display header info</span><br><span class=\"line\">fdt bootcpu &lt;id&gt;                    - Set boot cpuid</span><br><span class=\"line\">fdt memory &lt;addr&gt; &lt;size&gt;            - Add/Update memory node</span><br><span class=\"line\">fdt rsvmem print                    - Show current mem reserves</span><br><span class=\"line\">fdt rsvmem add &lt;addr&gt; &lt;size&gt;        - Add a mem reserve</span><br><span class=\"line\">fdt rsvmem delete &lt;index&gt;           - Delete a mem reserves</span><br><span class=\"line\">fdt chosen [&lt;start&gt; &lt;end&gt;]          - Add/update the /chosen branch in the tree</span><br><span class=\"line\">                                        &lt;start&gt;/&lt;end&gt; - initrd start/end addr</span><br><span class=\"line\">NOTE: Dereference aliases by omitting the leading &#x27;/&#x27;, e.g. fdt print ethernet0.</span><br></pre></td></tr></table></figure>\n\n<p>fdt print加path参数，则打path内容，如下(其中&#x2F;memory是path)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">U-Boot&gt; fdt print /memory</span><br><span class=\"line\">memory &#123;</span><br><span class=\"line\">device_type = <span class=\"string\">&quot;memory&quot;</span>;</span><br><span class=\"line\">reg = &lt;<span class=\"number\">0x70000000</span> <span class=\"number\">0x4000000</span>&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">U-Boot&gt; fdt print #不加参数时，打印出整颗树</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"二、u-boot-获取GPT分区表\"><a href=\"#二、u-boot-获取GPT分区表\" class=\"headerlink\" title=\"二、u-boot 获取GPT分区表\"></a>二、u-boot 获取GPT分区表</h1><p>在uboot中通过命令打印分区表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">part list mmc 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3588-android-uboot\"><a href=\"#3588-android-uboot\" class=\"headerlink\" title=\"3588-android-uboot\"></a>3588-android-uboot</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;common.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;command.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;android_image.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mmc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memalign.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fdtdec.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PART_MAX_COUNT  128</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tLAB_SIZE\t\t512</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tHEADER_OFFSET\tLAB_SIZE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tENTRY_OFFSET\t(2 * LAB_SIZE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL1_OFFSET\t\tsizeof(u64)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>\tVAL2_OFFSET\t\t(2 * sizeof(u64))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">get_gpt_blk_cnt_and_print</span><span class=\"params\">(<span class=\"keyword\">struct</span> blk_desc *dev_desc,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t  gpt_header *gpt_head, gpt_entry **gpt_pte)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">char</span> efi_str[PARTNAME_SZ + <span class=\"number\">1</span>];</span><br><span class=\"line\">\tu64 gpt_part_size, gpt_blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tgpt_entry *gpt_e;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_e = *gpt_pte;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; gpt_head-&gt;num_partition_entries; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\traite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,</span><br><span class=\"line\">\t\t\t\t\t     PARTNAME_SZ + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s: part: %2d name - GPT: %16s &quot;</span>,</span><br><span class=\"line\">\t\t      __func__, i, efi_str);</span><br><span class=\"line\">\t\tgpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -</span><br><span class=\"line\">\t\t\tle64_to_cpu(gpt_e[i].starting_lba) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tgpt_blk_cnt += gpt_part_size;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(gpt_part_size == <span class=\"number\">1</span>) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size(LBA) - GPT: %8llu &quot;</span>,</span><br><span class=\"line\">\t\t      (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)gpt_part_size);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start LBA - GPT: %8llu \\n&quot;</span>,</span><br><span class=\"line\">\t\t      le64_to_cpu(gpt_e[i].starting_lba));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> gpt_blk_cnt + gpt_e[<span class=\"number\">0</span>].starting_lba - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">get_gpt_meta_data</span><span class=\"params\">(u64 *data_size, <span class=\"type\">void</span> **data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    gpt_header *pgpt_head;</span><br><span class=\"line\">\tgpt_entry *entries;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *meta_data;</span><br><span class=\"line\">\tu64 meta_data_size, gpt_entries_size;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">blk_desc</span> *<span class=\"title\">dev_desc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mmc</span> *<span class=\"title\">mmc</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tu64 blk_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 blk_cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tu64 tag = <span class=\"number\">0x55AA</span>;</span><br><span class=\"line\">\t<span class=\"type\">lbaint_t</span> lba;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!data_size || !data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Invalid Argument(s) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mmc = do_returnmmc();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!mmc)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> CMD_RET_FAILURE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    dev_desc = mmc_get_blk_desc(mmc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!dev_desc) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: mmc_get_blk_desc err ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgpt_entries_size = <span class=\"keyword\">sizeof</span>(gpt_entry) * PART_MAX_COUNT;</span><br><span class=\"line\">\tmeta_data_size = LAB_SIZE + <span class=\"keyword\">sizeof</span>(gpt_header) + gpt_entries_size;</span><br><span class=\"line\">\tmeta_data = <span class=\"built_in\">malloc</span>(meta_data_size);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!meta_data) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: malloc memory (gpt meta data) ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(meta_data, <span class=\"number\">0</span>, meta_data_size);</span><br><span class=\"line\">\tpgpt_head = (gpt_header *)((<span class=\"type\">char</span> *)meta_data + HEADER_OFFSET);</span><br><span class=\"line\">\tentries = (gpt_entry *)((<span class=\"type\">char</span> *)meta_data + ENTRY_OFFSET);</span><br><span class=\"line\">\tALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc-&gt;blksz);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read MBR Header from device */</span></span><br><span class=\"line\">\tlba = <span class=\"number\">0</span>; <span class=\"comment\">/* MBR is always at 0 */</span></span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* MBR (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*** ERROR: Can&#x27;t read MBR header ***\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Header from device */</span></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\tblk_cnt = <span class=\"number\">1</span>; <span class=\"comment\">/* GPT Header (1 block) */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: Can&#x27;t read GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (validate_gpt_header(pgpt_head, lba, dev_desc-&gt;lba)) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR: validate_gpt_header GPT header ***\\n&quot;</span>, __func__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dev_desc-&gt;sig_type == SIG_TYPE_NONE) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">efi_guid_t</span> empty = &#123;&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">memcmp</span>(&amp;pgpt_head-&gt;disk_guid, &amp;empty, <span class=\"keyword\">sizeof</span>(empty))) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_GUID;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(&amp;dev_desc-&gt;guid_sig, &amp;pgpt_head-&gt;disk_guid,</span><br><span class=\"line\">\t\t\t      <span class=\"keyword\">sizeof</span>(empty));</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mbr-&gt;unique_mbr_signature != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;sig_type = SIG_TYPE_MBR;</span><br><span class=\"line\">\t\t\tdev_desc-&gt;mbr_sig = mbr-&gt;unique_mbr_signature;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Read GPT Entries from device */</span></span><br><span class=\"line\">\tlba = le64_to_cpu(pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\tblk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head-&gt;num_partition_entries) *</span><br><span class=\"line\">\t\t\t\t   \tle32_to_cpu(pgpt_head-&gt;sizeof_partition_entry)),</span><br><span class=\"line\">\t\t\t\t  \tdev_desc);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s *** ERROR:read entries (lba=%llu) ***\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, pgpt_head-&gt;partition_entry_lba);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> ERROR_OUT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_size = dev_desc-&gt;blksz;</span><br><span class=\"line\">\tvalidate_gpt_entries(pgpt_head, entries);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdebug(<span class=\"string\">&quot;%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t__func__, (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)(ulong)lba, blk_cnt, blk_size);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">\t * build info, layout of meta_data:</span></span><br><span class=\"line\"><span class=\"comment\">\t * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tblk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class=\"line\">\t<span class=\"comment\">/*this value makes we known the reserved memory is available*/</span></span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data, (<span class=\"type\">void</span> *)&amp;tag, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL1_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_size, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(meta_data + VAL2_OFFSET, (<span class=\"type\">void</span> *)&amp;blk_cnt, <span class=\"keyword\">sizeof</span>(u64));</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data_size = meta_data_size;</span><br><span class=\"line\">\t*data = meta_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR_OUT:</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(meta_data);</span><br><span class=\"line\">\tmeta_data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参考：</p>\n<p><a href=\"http://www.wowotech.net/device_model/dt-code-file-struct-parse.html\">Device Tree（四）：文件结构解析 (wowotech.net)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376295326\">Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/376296222\">Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.cnblogs.com/solo666/p/16518154.html\">https://www.cnblogs.com/solo666/p/16518154.html</a></p>\n"},{"title":"uboot-01-概念","date":"2024-05-15T13:59:01.000Z","_content":"\nuboot(Universal Boot Loader)\n\nuboot 官网为 http://www.denx.de/wiki/U-Boot/\n\nLinux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段\nbootloader 程序。这段 bootloader 程序会先初始化DDR 等外设，然后将 Linux 内核从 flash(NAND，\nNOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核\n\nuboot主要目的是为系统启动做准备\n\nuboot是一种通用的bootloader，支持多种架构\n\n\n\n\n\n\n\n# uboot常见命令\n\n\n\n\n\n","source":"_posts/uboot-01-概念.md","raw":"---\ntitle: uboot-01-概念\ncategories:\n  - uboot\ntags:\n  - uboot概念\ndate: 2024-05-15 21:59:01\n\n---\n\nuboot(Universal Boot Loader)\n\nuboot 官网为 http://www.denx.de/wiki/U-Boot/\n\nLinux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段\nbootloader 程序。这段 bootloader 程序会先初始化DDR 等外设，然后将 Linux 内核从 flash(NAND，\nNOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核\n\nuboot主要目的是为系统启动做准备\n\nuboot是一种通用的bootloader，支持多种架构\n\n\n\n\n\n\n\n# uboot常见命令\n\n\n\n\n\n","slug":"uboot-01-概念","published":1,"updated":"2024-05-16T05:31:36.959Z","_id":"clw7y3oy60000zfapahvk834m","comments":1,"layout":"post","photos":[],"link":"","content":"<p>uboot(Universal Boot Loader)</p>\n<p>uboot 官网为 <a href=\"http://www.denx.de/wiki/U-Boot/\">http://www.denx.de/wiki/U-Boot/</a></p>\n<p>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段<br>bootloader 程序。这段 bootloader 程序会先初始化DDR 等外设，然后将 Linux 内核从 flash(NAND，<br>NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核</p>\n<p>uboot主要目的是为系统启动做准备</p>\n<p>uboot是一种通用的bootloader，支持多种架构</p>\n<h1 id=\"uboot常见命令\"><a href=\"#uboot常见命令\" class=\"headerlink\" title=\"uboot常见命令\"></a>uboot常见命令</h1>","site":{"data":{}},"excerpt":"","more":"<p>uboot(Universal Boot Loader)</p>\n<p>uboot 官网为 <a href=\"http://www.denx.de/wiki/U-Boot/\">http://www.denx.de/wiki/U-Boot/</a></p>\n<p>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段<br>bootloader 程序。这段 bootloader 程序会先初始化DDR 等外设，然后将 Linux 内核从 flash(NAND，<br>NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核</p>\n<p>uboot主要目的是为系统启动做准备</p>\n<p>uboot是一种通用的bootloader，支持多种架构</p>\n<h1 id=\"uboot常见命令\"><a href=\"#uboot常见命令\" class=\"headerlink\" title=\"uboot常见命令\"></a>uboot常见命令</h1>"},{"title":"cgroup","date":"2024-05-16T07:30:33.000Z","_content":"\n[toc]\n\ncgroup是linux内核实现、用于控制linux系统资源的组件。因此要了解cgroup，首先从引入这个组件的kernel文档中寻找。\n\n去到举世闻名的www.kernel.org\n\n找到介绍文档：Documentation/cgroup-v1/cgroups.txt\n\n## 1 什么是cgroup?\n\n>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup绑定一个进程集合到一个或多个子系统上。\n>\n>subsystem，子系统，一个通过cgroup提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。\n>\n>hierarchy，层级树，多个cgroup的集合，这些集合构成的树叫hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy上的层次关系通过cgroupfs虚拟文件系统显示。系统允许多个hierarchy同时存在，每个hierachy包含系统中的部分或者全部进程集合。\n>\n>cgroupfs是用户管理操纵cgroup的主要接口：通过在cgroupfs文件系统中创建目录，实现cgroup的创建；通过向目录下的属性文件写入内容，设置cgroup对资源的控制；向task属性文件写入进程ID，可以将进程绑定到某个cgroup，以此达到控制进程资源使用的目的；也可以列出cgroup包含的进程pid。这些操作影响的是sysfs关联的hierarchy，对其它hierarchy没有影响。\n>\n>对于cgroup，其本身的作用只是任务跟踪。但其它系统（比如cpusets，cpuacct），可以利用cgroup的这个功能实现一些新的属性，比如统计或者控制一个cgroup中进程可以访问的资源。举个例子，cpusets子系统可以将进程绑定到特定的cpu和内存节点上。\n\n2 为什么需要cgroup?\n\n>\n>\n>这个问题相当于问cgroup重要吗？有哪些地方用到了。回答是重要，又不重要。如果你用到了，那就重要，如果没有用到，那就不重要。呵呵呵~~~~其实挺重要的。cgroup的主要运用是资源跟踪。我接触的场景就是用cgroup控制虚拟机进程或者docker进程可以使用的资源。当你想在linux对应用进程做资源访问控制的时候，cgroup就派上用场了。\n\n## 3 cgroup怎么实现的？\n\n>——    系统中的每个进程（task_struct，后面用task代指）都持有一个指向css_set结构的指针。\n>\n>——    一个css_set结构体包含了一组指向cgroup_subsys_state对象的指针（所以一个task可以附加到多个cgroup上），每个cgroup_subsys_state在系统中都有注册。task结构体没有直接指向hierarchy中一个节点（cgroup）的指针。但可以通过其包含的cgroup_subsys_state间接确定。这样设计的原因是cpu对subsystem state的访问很频繁，但涉及到将task绑定到cgroup的操作却不多。task中还有个双向链表cg_list，这个链表维护所有同属于一个css_set的tasks。\n>\n>——    用户可以通过cgroupfs文件系统来浏览cgroup hierarchy。\n>\n>——    用户可以列出任意一个cgroup上附着的task PID\n>\n>cgroup在kernel中除了本身功能的实现外，在kernel中还有两处修改：\n>\n>——    在kernel启动时对root cgroup的初始化和css_set结构体的初始化。这个在init/main.c文件中实现。\n>\n>——    在task的创建（fork）和退出（exit）阶段，对应地将task与css_set进行绑定和解绑。\n>\n>另外，cgroup为了向用户提供操作接口，特别开发了一个虚拟文件系统类型（cgroupfs），这个文件系统与sysfs，proc类似。cgroupfs是向用户展示cgroup的hierarchy，通知kernel用户对cgroup改动的窗口。挂载cgroupfs时通过选项（-otype）指定要挂载的子系统类型，如果不指定，默认挂载所有的注册的子系统。\n>\n>如果新挂载的cgroup关联的hierachy与系统中存在的hierarchy完全一样，那么cgroupfs会拒绝挂载。如果没有匹配到相同的hierarchy，但新挂载hierachy声明的资源正在被已经存在的hierarchy使用，挂载会报-EBUSY错误。\n>\n>当前cgroup还没有实现向已经存在的cgroup hierarchy绑定新子系统的操作，将子系统从cgroup hierachy解绑也不允许。这些操作在未来也许会支持，但也可能会进一步产生错误恢复的一系列问题。\n>\n>卸载cgroupfs时，如果它的子cgroupfs还在活动，那么子cgroupfs还是会持续生效。直到所有的子cgroupfs不再活动，卸载cgroupfs才会真正生效。\n>\n>cgroupfs下不能再挂载其它类型的文件系统。所有对cgroup的查询修改都只通过cgroupfs文件系统来完成。\n>\n>系统中的所有task，在/proc/pid目录下都有一个名为cgroup的文件，这个文件展示了该task相对cgroupfs 根的路径。通过查看这个文件，可以了解一个进程在cgroup hierarchy的位置。以此得到task可以使用的资源信息。\n>\n>cgroupfs中目录表示cgroup，每个目录在创建时默认生成如下的属性文件，这些文件描述了cgroup的信息：\n>\n>——    tasks: 所有附属于这个cgroup的进程ID列表。tasks文件中增加进程ID，表示将进程加入这个cgroup，进程能够使用的资源受cgroup限制。\n>\n>——    cgroup.procs: 所有附属于这个cgroup线程组ID，将TGID写入这个文件后，TGID所在进程包含的所有线程都加入这个cgroup，这些线程受cgroup限制。\n\n> PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。\n> TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。\n> PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。\n> SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。\n> ——    notify_on_release flag: 标记退出时是否运行release agent\n>\n> ——    release_agent: 制定要运行的release agent的路径，这个属性文件只在cgroup的顶层目录中存在。\n>\n> 以上文件是每个cgroup基本的属性文件，对于不同的子系统，对应的cgroup可能会有其它附加的属性文件，存在于其对应的cgroup目录之下。\n>\n> 通过mkdir命令创建cgroup，通过向目录下的文件写入适当的数值设置修改cgroup的属性。\n>\n> 嵌套的cgroups，指定了层级结构，以此将系统资源划分成嵌套的，动态可变的更小的资源块。\n>\n> 一个进程可以附加到多个不同的cgroup中，只要这些cgroup不在同一个层级树上即可。因为cgroupfs会保证新挂载的cgroup关联的层级树全局唯一。子进程在被创建后默认附加到父进程所在的cgroup，后面用户可以根据需要将其移动到别的cgroup。\n>\n> 当进程从一个cgroup被移动到另一个cgroup。进程的task_struct会获取一个新的css_set指针：如果这个cgroup所在的css_set已经存在就重用这个css_set，否则就新分配一个css_set。kernel会在全局的hash表中查找确认cgroup所属的css_set是否存在。\n\n## 4 notify_on_release 是做什么的？\n\n>如果cgroup中使能notify_on_release，cgroup中的最后一个进程被移除，最后一个子cgroup也被删除时，cgroup会主动通知kernel。接收到消息的kernel会执行release_agent文件中指定的程序。notify_on_release默认是关闭的，release_agent的内容默认为空，子cgroup在创建时会继承父cgroup中notify_on_relase和release_agent的属性。所以这两个文件只存在于cgroupfs的顶层目录中。\n\n\n\n## 5 clone_children有什么用？\n\n> clone_chilren仅针对cpu绑定（cpuset），如果clone_children使能，新的cpuset cgroup在初始化时会继承父cgroup的属性。\n\n## 6 cgroup怎么用？\n\n>\n>\n>假设现在要将一个新的任务加入到cgroup，功能是将该任务的进程在指定的cpu上运行，因此我们使用\"cpuset\"cgroup 子系统，操作的大致步骤如下：\n>\n>1）mount -t tmpfs cgroup_root /sys/fs/cgroup \n>\n>挂载cgroup根文件系统，类型为tmpfs\n>\n>2）mkdir /sys/fs/cgroup/cpuset\n>\n>在cgroupfs根目录下创建子cgroup，名为cpuset\n>\n>3）mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset\n>\n>将名为cpuset的cgroup关联到cpuset子系统\n>\n>4）在cpuset目录下创建目录，生成一个子cgroup，属性文件中写入相应内容，设置属性。\n>\n>5）启动需要限制的进程，查找其对应的进程ID，将其写入对应的task文件中\n>\n>以下操作步骤是创建一个名为\"Charlie\"的cgroup，这个cgroup的资源包含cpu2，cpu3和内存节点1，将shell进程附加到这个cgroup。\n>\n>mount -t tmpfs cgroup_root /sys/fs/cgroup\n>\n>mkdir /sys/fs/cgroup/cpuset\n>\n>mount -t cgroup cpuset -o cpuset /sys/fs/cgroup/cpuset\n>\n>cd /sys/fs/cgroup/cpuset\n>\n>mkdir Charlie\n>\n>cd Charlie\n>\n>echo 2-3 > cpuset.cpus\n>\n>echo 1 > cpuset.mems\n>\n>echo $$ > tasks\n>\n>sh\n>\n>cat /proc/self/cgroup\n\n转：\n\n https://blog.csdn.net/huang987246510/article/details/80765628\n","source":"_posts/cgroup.md","raw":"---\ntitle: cgroup\ncategories:\n  - kernel\ntags:\n  - cgroup\ndate: 2024-05-16 15:30:33\n---\n\n[toc]\n\ncgroup是linux内核实现、用于控制linux系统资源的组件。因此要了解cgroup，首先从引入这个组件的kernel文档中寻找。\n\n去到举世闻名的www.kernel.org\n\n找到介绍文档：Documentation/cgroup-v1/cgroups.txt\n\n## 1 什么是cgroup?\n\n>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup绑定一个进程集合到一个或多个子系统上。\n>\n>subsystem，子系统，一个通过cgroup提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。\n>\n>hierarchy，层级树，多个cgroup的集合，这些集合构成的树叫hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy上的层次关系通过cgroupfs虚拟文件系统显示。系统允许多个hierarchy同时存在，每个hierachy包含系统中的部分或者全部进程集合。\n>\n>cgroupfs是用户管理操纵cgroup的主要接口：通过在cgroupfs文件系统中创建目录，实现cgroup的创建；通过向目录下的属性文件写入内容，设置cgroup对资源的控制；向task属性文件写入进程ID，可以将进程绑定到某个cgroup，以此达到控制进程资源使用的目的；也可以列出cgroup包含的进程pid。这些操作影响的是sysfs关联的hierarchy，对其它hierarchy没有影响。\n>\n>对于cgroup，其本身的作用只是任务跟踪。但其它系统（比如cpusets，cpuacct），可以利用cgroup的这个功能实现一些新的属性，比如统计或者控制一个cgroup中进程可以访问的资源。举个例子，cpusets子系统可以将进程绑定到特定的cpu和内存节点上。\n\n2 为什么需要cgroup?\n\n>\n>\n>这个问题相当于问cgroup重要吗？有哪些地方用到了。回答是重要，又不重要。如果你用到了，那就重要，如果没有用到，那就不重要。呵呵呵~~~~其实挺重要的。cgroup的主要运用是资源跟踪。我接触的场景就是用cgroup控制虚拟机进程或者docker进程可以使用的资源。当你想在linux对应用进程做资源访问控制的时候，cgroup就派上用场了。\n\n## 3 cgroup怎么实现的？\n\n>——    系统中的每个进程（task_struct，后面用task代指）都持有一个指向css_set结构的指针。\n>\n>——    一个css_set结构体包含了一组指向cgroup_subsys_state对象的指针（所以一个task可以附加到多个cgroup上），每个cgroup_subsys_state在系统中都有注册。task结构体没有直接指向hierarchy中一个节点（cgroup）的指针。但可以通过其包含的cgroup_subsys_state间接确定。这样设计的原因是cpu对subsystem state的访问很频繁，但涉及到将task绑定到cgroup的操作却不多。task中还有个双向链表cg_list，这个链表维护所有同属于一个css_set的tasks。\n>\n>——    用户可以通过cgroupfs文件系统来浏览cgroup hierarchy。\n>\n>——    用户可以列出任意一个cgroup上附着的task PID\n>\n>cgroup在kernel中除了本身功能的实现外，在kernel中还有两处修改：\n>\n>——    在kernel启动时对root cgroup的初始化和css_set结构体的初始化。这个在init/main.c文件中实现。\n>\n>——    在task的创建（fork）和退出（exit）阶段，对应地将task与css_set进行绑定和解绑。\n>\n>另外，cgroup为了向用户提供操作接口，特别开发了一个虚拟文件系统类型（cgroupfs），这个文件系统与sysfs，proc类似。cgroupfs是向用户展示cgroup的hierarchy，通知kernel用户对cgroup改动的窗口。挂载cgroupfs时通过选项（-otype）指定要挂载的子系统类型，如果不指定，默认挂载所有的注册的子系统。\n>\n>如果新挂载的cgroup关联的hierachy与系统中存在的hierarchy完全一样，那么cgroupfs会拒绝挂载。如果没有匹配到相同的hierarchy，但新挂载hierachy声明的资源正在被已经存在的hierarchy使用，挂载会报-EBUSY错误。\n>\n>当前cgroup还没有实现向已经存在的cgroup hierarchy绑定新子系统的操作，将子系统从cgroup hierachy解绑也不允许。这些操作在未来也许会支持，但也可能会进一步产生错误恢复的一系列问题。\n>\n>卸载cgroupfs时，如果它的子cgroupfs还在活动，那么子cgroupfs还是会持续生效。直到所有的子cgroupfs不再活动，卸载cgroupfs才会真正生效。\n>\n>cgroupfs下不能再挂载其它类型的文件系统。所有对cgroup的查询修改都只通过cgroupfs文件系统来完成。\n>\n>系统中的所有task，在/proc/pid目录下都有一个名为cgroup的文件，这个文件展示了该task相对cgroupfs 根的路径。通过查看这个文件，可以了解一个进程在cgroup hierarchy的位置。以此得到task可以使用的资源信息。\n>\n>cgroupfs中目录表示cgroup，每个目录在创建时默认生成如下的属性文件，这些文件描述了cgroup的信息：\n>\n>——    tasks: 所有附属于这个cgroup的进程ID列表。tasks文件中增加进程ID，表示将进程加入这个cgroup，进程能够使用的资源受cgroup限制。\n>\n>——    cgroup.procs: 所有附属于这个cgroup线程组ID，将TGID写入这个文件后，TGID所在进程包含的所有线程都加入这个cgroup，这些线程受cgroup限制。\n\n> PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。\n> TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。\n> PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。\n> SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。\n> ——    notify_on_release flag: 标记退出时是否运行release agent\n>\n> ——    release_agent: 制定要运行的release agent的路径，这个属性文件只在cgroup的顶层目录中存在。\n>\n> 以上文件是每个cgroup基本的属性文件，对于不同的子系统，对应的cgroup可能会有其它附加的属性文件，存在于其对应的cgroup目录之下。\n>\n> 通过mkdir命令创建cgroup，通过向目录下的文件写入适当的数值设置修改cgroup的属性。\n>\n> 嵌套的cgroups，指定了层级结构，以此将系统资源划分成嵌套的，动态可变的更小的资源块。\n>\n> 一个进程可以附加到多个不同的cgroup中，只要这些cgroup不在同一个层级树上即可。因为cgroupfs会保证新挂载的cgroup关联的层级树全局唯一。子进程在被创建后默认附加到父进程所在的cgroup，后面用户可以根据需要将其移动到别的cgroup。\n>\n> 当进程从一个cgroup被移动到另一个cgroup。进程的task_struct会获取一个新的css_set指针：如果这个cgroup所在的css_set已经存在就重用这个css_set，否则就新分配一个css_set。kernel会在全局的hash表中查找确认cgroup所属的css_set是否存在。\n\n## 4 notify_on_release 是做什么的？\n\n>如果cgroup中使能notify_on_release，cgroup中的最后一个进程被移除，最后一个子cgroup也被删除时，cgroup会主动通知kernel。接收到消息的kernel会执行release_agent文件中指定的程序。notify_on_release默认是关闭的，release_agent的内容默认为空，子cgroup在创建时会继承父cgroup中notify_on_relase和release_agent的属性。所以这两个文件只存在于cgroupfs的顶层目录中。\n\n\n\n## 5 clone_children有什么用？\n\n> clone_chilren仅针对cpu绑定（cpuset），如果clone_children使能，新的cpuset cgroup在初始化时会继承父cgroup的属性。\n\n## 6 cgroup怎么用？\n\n>\n>\n>假设现在要将一个新的任务加入到cgroup，功能是将该任务的进程在指定的cpu上运行，因此我们使用\"cpuset\"cgroup 子系统，操作的大致步骤如下：\n>\n>1）mount -t tmpfs cgroup_root /sys/fs/cgroup \n>\n>挂载cgroup根文件系统，类型为tmpfs\n>\n>2）mkdir /sys/fs/cgroup/cpuset\n>\n>在cgroupfs根目录下创建子cgroup，名为cpuset\n>\n>3）mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset\n>\n>将名为cpuset的cgroup关联到cpuset子系统\n>\n>4）在cpuset目录下创建目录，生成一个子cgroup，属性文件中写入相应内容，设置属性。\n>\n>5）启动需要限制的进程，查找其对应的进程ID，将其写入对应的task文件中\n>\n>以下操作步骤是创建一个名为\"Charlie\"的cgroup，这个cgroup的资源包含cpu2，cpu3和内存节点1，将shell进程附加到这个cgroup。\n>\n>mount -t tmpfs cgroup_root /sys/fs/cgroup\n>\n>mkdir /sys/fs/cgroup/cpuset\n>\n>mount -t cgroup cpuset -o cpuset /sys/fs/cgroup/cpuset\n>\n>cd /sys/fs/cgroup/cpuset\n>\n>mkdir Charlie\n>\n>cd Charlie\n>\n>echo 2-3 > cpuset.cpus\n>\n>echo 1 > cpuset.mems\n>\n>echo $$ > tasks\n>\n>sh\n>\n>cat /proc/self/cgroup\n\n转：\n\n https://blog.csdn.net/huang987246510/article/details/80765628\n","slug":"cgroup","published":1,"updated":"2024-05-16T10:00:13.008Z","_id":"clw8xrfbp00009gw0cohxazat","comments":1,"layout":"post","photos":[],"link":"","content":"<p>[toc]</p>\n<p>cgroup是linux内核实现、用于控制linux系统资源的组件。因此要了解cgroup，首先从引入这个组件的kernel文档中寻找。</p>\n<p>去到举世闻名的<a href=\"http://www.kernel.org/\">www.kernel.org</a></p>\n<p>找到介绍文档：Documentation&#x2F;cgroup-v1&#x2F;cgroups.txt</p>\n<h2 id=\"1-什么是cgroup\"><a href=\"#1-什么是cgroup\" class=\"headerlink\" title=\"1 什么是cgroup?\"></a>1 什么是cgroup?</h2><blockquote>\n<p>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup绑定一个进程集合到一个或多个子系统上。</p>\n<p>subsystem，子系统，一个通过cgroup提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。</p>\n<p>hierarchy，层级树，多个cgroup的集合，这些集合构成的树叫hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy上的层次关系通过cgroupfs虚拟文件系统显示。系统允许多个hierarchy同时存在，每个hierachy包含系统中的部分或者全部进程集合。</p>\n<p>cgroupfs是用户管理操纵cgroup的主要接口：通过在cgroupfs文件系统中创建目录，实现cgroup的创建；通过向目录下的属性文件写入内容，设置cgroup对资源的控制；向task属性文件写入进程ID，可以将进程绑定到某个cgroup，以此达到控制进程资源使用的目的；也可以列出cgroup包含的进程pid。这些操作影响的是sysfs关联的hierarchy，对其它hierarchy没有影响。</p>\n<p>对于cgroup，其本身的作用只是任务跟踪。但其它系统（比如cpusets，cpuacct），可以利用cgroup的这个功能实现一些新的属性，比如统计或者控制一个cgroup中进程可以访问的资源。举个例子，cpusets子系统可以将进程绑定到特定的cpu和内存节点上。</p>\n</blockquote>\n<p>2 为什么需要cgroup?</p>\n<blockquote>\n<p>这个问题相当于问cgroup重要吗？有哪些地方用到了。回答是重要，又不重要。如果你用到了，那就重要，如果没有用到，那就不重要。呵呵呵~~~~其实挺重要的。cgroup的主要运用是资源跟踪。我接触的场景就是用cgroup控制虚拟机进程或者docker进程可以使用的资源。当你想在linux对应用进程做资源访问控制的时候，cgroup就派上用场了。</p>\n</blockquote>\n<h2 id=\"3-cgroup怎么实现的？\"><a href=\"#3-cgroup怎么实现的？\" class=\"headerlink\" title=\"3 cgroup怎么实现的？\"></a>3 cgroup怎么实现的？</h2><blockquote>\n<p>——    系统中的每个进程（task_struct，后面用task代指）都持有一个指向css_set结构的指针。</p>\n<p>——    一个css_set结构体包含了一组指向cgroup_subsys_state对象的指针（所以一个task可以附加到多个cgroup上），每个cgroup_subsys_state在系统中都有注册。task结构体没有直接指向hierarchy中一个节点（cgroup）的指针。但可以通过其包含的cgroup_subsys_state间接确定。这样设计的原因是cpu对subsystem state的访问很频繁，但涉及到将task绑定到cgroup的操作却不多。task中还有个双向链表cg_list，这个链表维护所有同属于一个css_set的tasks。</p>\n<p>——    用户可以通过cgroupfs文件系统来浏览cgroup hierarchy。</p>\n<p>——    用户可以列出任意一个cgroup上附着的task PID</p>\n<p>cgroup在kernel中除了本身功能的实现外，在kernel中还有两处修改：</p>\n<p>——    在kernel启动时对root cgroup的初始化和css_set结构体的初始化。这个在init&#x2F;main.c文件中实现。</p>\n<p>——    在task的创建（fork）和退出（exit）阶段，对应地将task与css_set进行绑定和解绑。</p>\n<p>另外，cgroup为了向用户提供操作接口，特别开发了一个虚拟文件系统类型（cgroupfs），这个文件系统与sysfs，proc类似。cgroupfs是向用户展示cgroup的hierarchy，通知kernel用户对cgroup改动的窗口。挂载cgroupfs时通过选项（-otype）指定要挂载的子系统类型，如果不指定，默认挂载所有的注册的子系统。</p>\n<p>如果新挂载的cgroup关联的hierachy与系统中存在的hierarchy完全一样，那么cgroupfs会拒绝挂载。如果没有匹配到相同的hierarchy，但新挂载hierachy声明的资源正在被已经存在的hierarchy使用，挂载会报-EBUSY错误。</p>\n<p>当前cgroup还没有实现向已经存在的cgroup hierarchy绑定新子系统的操作，将子系统从cgroup hierachy解绑也不允许。这些操作在未来也许会支持，但也可能会进一步产生错误恢复的一系列问题。</p>\n<p>卸载cgroupfs时，如果它的子cgroupfs还在活动，那么子cgroupfs还是会持续生效。直到所有的子cgroupfs不再活动，卸载cgroupfs才会真正生效。</p>\n<p>cgroupfs下不能再挂载其它类型的文件系统。所有对cgroup的查询修改都只通过cgroupfs文件系统来完成。</p>\n<p>系统中的所有task，在&#x2F;proc&#x2F;pid目录下都有一个名为cgroup的文件，这个文件展示了该task相对cgroupfs 根的路径。通过查看这个文件，可以了解一个进程在cgroup hierarchy的位置。以此得到task可以使用的资源信息。</p>\n<p>cgroupfs中目录表示cgroup，每个目录在创建时默认生成如下的属性文件，这些文件描述了cgroup的信息：</p>\n<p>——    tasks: 所有附属于这个cgroup的进程ID列表。tasks文件中增加进程ID，表示将进程加入这个cgroup，进程能够使用的资源受cgroup限制。</p>\n<p>——    cgroup.procs: 所有附属于这个cgroup线程组ID，将TGID写入这个文件后，TGID所在进程包含的所有线程都加入这个cgroup，这些线程受cgroup限制。</p>\n</blockquote>\n<blockquote>\n<p>PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。<br>TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。<br>PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。<br>SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。<br>——    notify_on_release flag: 标记退出时是否运行release agent</p>\n<p>——    release_agent: 制定要运行的release agent的路径，这个属性文件只在cgroup的顶层目录中存在。</p>\n<p>以上文件是每个cgroup基本的属性文件，对于不同的子系统，对应的cgroup可能会有其它附加的属性文件，存在于其对应的cgroup目录之下。</p>\n<p>通过mkdir命令创建cgroup，通过向目录下的文件写入适当的数值设置修改cgroup的属性。</p>\n<p>嵌套的cgroups，指定了层级结构，以此将系统资源划分成嵌套的，动态可变的更小的资源块。</p>\n<p>一个进程可以附加到多个不同的cgroup中，只要这些cgroup不在同一个层级树上即可。因为cgroupfs会保证新挂载的cgroup关联的层级树全局唯一。子进程在被创建后默认附加到父进程所在的cgroup，后面用户可以根据需要将其移动到别的cgroup。</p>\n<p>当进程从一个cgroup被移动到另一个cgroup。进程的task_struct会获取一个新的css_set指针：如果这个cgroup所在的css_set已经存在就重用这个css_set，否则就新分配一个css_set。kernel会在全局的hash表中查找确认cgroup所属的css_set是否存在。</p>\n</blockquote>\n<h2 id=\"4-notify-on-release-是做什么的？\"><a href=\"#4-notify-on-release-是做什么的？\" class=\"headerlink\" title=\"4 notify_on_release 是做什么的？\"></a>4 notify_on_release 是做什么的？</h2><blockquote>\n<p>如果cgroup中使能notify_on_release，cgroup中的最后一个进程被移除，最后一个子cgroup也被删除时，cgroup会主动通知kernel。接收到消息的kernel会执行release_agent文件中指定的程序。notify_on_release默认是关闭的，release_agent的内容默认为空，子cgroup在创建时会继承父cgroup中notify_on_relase和release_agent的属性。所以这两个文件只存在于cgroupfs的顶层目录中。</p>\n</blockquote>\n<h2 id=\"5-clone-children有什么用？\"><a href=\"#5-clone-children有什么用？\" class=\"headerlink\" title=\"5 clone_children有什么用？\"></a>5 clone_children有什么用？</h2><blockquote>\n<p>clone_chilren仅针对cpu绑定（cpuset），如果clone_children使能，新的cpuset cgroup在初始化时会继承父cgroup的属性。</p>\n</blockquote>\n<h2 id=\"6-cgroup怎么用？\"><a href=\"#6-cgroup怎么用？\" class=\"headerlink\" title=\"6 cgroup怎么用？\"></a>6 cgroup怎么用？</h2><blockquote>\n<p>假设现在要将一个新的任务加入到cgroup，功能是将该任务的进程在指定的cpu上运行，因此我们使用”cpuset”cgroup 子系统，操作的大致步骤如下：</p>\n<p>1）mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup </p>\n<p>挂载cgroup根文件系统，类型为tmpfs</p>\n<p>2）mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>在cgroupfs根目录下创建子cgroup，名为cpuset</p>\n<p>3）mount -t cgroup -o cpuset cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>将名为cpuset的cgroup关联到cpuset子系统</p>\n<p>4）在cpuset目录下创建目录，生成一个子cgroup，属性文件中写入相应内容，设置属性。</p>\n<p>5）启动需要限制的进程，查找其对应的进程ID，将其写入对应的task文件中</p>\n<p>以下操作步骤是创建一个名为”Charlie”的cgroup，这个cgroup的资源包含cpu2，cpu3和内存节点1，将shell进程附加到这个cgroup。</p>\n<p>mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup</p>\n<p>mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>mount -t cgroup cpuset -o cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>cd &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>mkdir Charlie</p>\n<p>cd Charlie</p>\n<p>echo 2-3 &gt; cpuset.cpus</p>\n<p>echo 1 &gt; cpuset.mems</p>\n<p>echo $$ &gt; tasks</p>\n<p>sh</p>\n<p>cat &#x2F;proc&#x2F;self&#x2F;cgroup</p>\n</blockquote>\n<p>转：</p>\n<p> <a href=\"https://blog.csdn.net/huang987246510/article/details/80765628\">https://blog.csdn.net/huang987246510/article/details/80765628</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<p>cgroup是linux内核实现、用于控制linux系统资源的组件。因此要了解cgroup，首先从引入这个组件的kernel文档中寻找。</p>\n<p>去到举世闻名的<a href=\"http://www.kernel.org/\">www.kernel.org</a></p>\n<p>找到介绍文档：Documentation&#x2F;cgroup-v1&#x2F;cgroups.txt</p>\n<h2 id=\"1-什么是cgroup\"><a href=\"#1-什么是cgroup\" class=\"headerlink\" title=\"1 什么是cgroup?\"></a>1 什么是cgroup?</h2><blockquote>\n<p>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup绑定一个进程集合到一个或多个子系统上。</p>\n<p>subsystem，子系统，一个通过cgroup提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。</p>\n<p>hierarchy，层级树，多个cgroup的集合，这些集合构成的树叫hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy上的层次关系通过cgroupfs虚拟文件系统显示。系统允许多个hierarchy同时存在，每个hierachy包含系统中的部分或者全部进程集合。</p>\n<p>cgroupfs是用户管理操纵cgroup的主要接口：通过在cgroupfs文件系统中创建目录，实现cgroup的创建；通过向目录下的属性文件写入内容，设置cgroup对资源的控制；向task属性文件写入进程ID，可以将进程绑定到某个cgroup，以此达到控制进程资源使用的目的；也可以列出cgroup包含的进程pid。这些操作影响的是sysfs关联的hierarchy，对其它hierarchy没有影响。</p>\n<p>对于cgroup，其本身的作用只是任务跟踪。但其它系统（比如cpusets，cpuacct），可以利用cgroup的这个功能实现一些新的属性，比如统计或者控制一个cgroup中进程可以访问的资源。举个例子，cpusets子系统可以将进程绑定到特定的cpu和内存节点上。</p>\n</blockquote>\n<p>2 为什么需要cgroup?</p>\n<blockquote>\n<p>这个问题相当于问cgroup重要吗？有哪些地方用到了。回答是重要，又不重要。如果你用到了，那就重要，如果没有用到，那就不重要。呵呵呵~~~~其实挺重要的。cgroup的主要运用是资源跟踪。我接触的场景就是用cgroup控制虚拟机进程或者docker进程可以使用的资源。当你想在linux对应用进程做资源访问控制的时候，cgroup就派上用场了。</p>\n</blockquote>\n<h2 id=\"3-cgroup怎么实现的？\"><a href=\"#3-cgroup怎么实现的？\" class=\"headerlink\" title=\"3 cgroup怎么实现的？\"></a>3 cgroup怎么实现的？</h2><blockquote>\n<p>——    系统中的每个进程（task_struct，后面用task代指）都持有一个指向css_set结构的指针。</p>\n<p>——    一个css_set结构体包含了一组指向cgroup_subsys_state对象的指针（所以一个task可以附加到多个cgroup上），每个cgroup_subsys_state在系统中都有注册。task结构体没有直接指向hierarchy中一个节点（cgroup）的指针。但可以通过其包含的cgroup_subsys_state间接确定。这样设计的原因是cpu对subsystem state的访问很频繁，但涉及到将task绑定到cgroup的操作却不多。task中还有个双向链表cg_list，这个链表维护所有同属于一个css_set的tasks。</p>\n<p>——    用户可以通过cgroupfs文件系统来浏览cgroup hierarchy。</p>\n<p>——    用户可以列出任意一个cgroup上附着的task PID</p>\n<p>cgroup在kernel中除了本身功能的实现外，在kernel中还有两处修改：</p>\n<p>——    在kernel启动时对root cgroup的初始化和css_set结构体的初始化。这个在init&#x2F;main.c文件中实现。</p>\n<p>——    在task的创建（fork）和退出（exit）阶段，对应地将task与css_set进行绑定和解绑。</p>\n<p>另外，cgroup为了向用户提供操作接口，特别开发了一个虚拟文件系统类型（cgroupfs），这个文件系统与sysfs，proc类似。cgroupfs是向用户展示cgroup的hierarchy，通知kernel用户对cgroup改动的窗口。挂载cgroupfs时通过选项（-otype）指定要挂载的子系统类型，如果不指定，默认挂载所有的注册的子系统。</p>\n<p>如果新挂载的cgroup关联的hierachy与系统中存在的hierarchy完全一样，那么cgroupfs会拒绝挂载。如果没有匹配到相同的hierarchy，但新挂载hierachy声明的资源正在被已经存在的hierarchy使用，挂载会报-EBUSY错误。</p>\n<p>当前cgroup还没有实现向已经存在的cgroup hierarchy绑定新子系统的操作，将子系统从cgroup hierachy解绑也不允许。这些操作在未来也许会支持，但也可能会进一步产生错误恢复的一系列问题。</p>\n<p>卸载cgroupfs时，如果它的子cgroupfs还在活动，那么子cgroupfs还是会持续生效。直到所有的子cgroupfs不再活动，卸载cgroupfs才会真正生效。</p>\n<p>cgroupfs下不能再挂载其它类型的文件系统。所有对cgroup的查询修改都只通过cgroupfs文件系统来完成。</p>\n<p>系统中的所有task，在&#x2F;proc&#x2F;pid目录下都有一个名为cgroup的文件，这个文件展示了该task相对cgroupfs 根的路径。通过查看这个文件，可以了解一个进程在cgroup hierarchy的位置。以此得到task可以使用的资源信息。</p>\n<p>cgroupfs中目录表示cgroup，每个目录在创建时默认生成如下的属性文件，这些文件描述了cgroup的信息：</p>\n<p>——    tasks: 所有附属于这个cgroup的进程ID列表。tasks文件中增加进程ID，表示将进程加入这个cgroup，进程能够使用的资源受cgroup限制。</p>\n<p>——    cgroup.procs: 所有附属于这个cgroup线程组ID，将TGID写入这个文件后，TGID所在进程包含的所有线程都加入这个cgroup，这些线程受cgroup限制。</p>\n</blockquote>\n<blockquote>\n<p>PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。<br>TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。<br>PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。<br>SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。<br>——    notify_on_release flag: 标记退出时是否运行release agent</p>\n<p>——    release_agent: 制定要运行的release agent的路径，这个属性文件只在cgroup的顶层目录中存在。</p>\n<p>以上文件是每个cgroup基本的属性文件，对于不同的子系统，对应的cgroup可能会有其它附加的属性文件，存在于其对应的cgroup目录之下。</p>\n<p>通过mkdir命令创建cgroup，通过向目录下的文件写入适当的数值设置修改cgroup的属性。</p>\n<p>嵌套的cgroups，指定了层级结构，以此将系统资源划分成嵌套的，动态可变的更小的资源块。</p>\n<p>一个进程可以附加到多个不同的cgroup中，只要这些cgroup不在同一个层级树上即可。因为cgroupfs会保证新挂载的cgroup关联的层级树全局唯一。子进程在被创建后默认附加到父进程所在的cgroup，后面用户可以根据需要将其移动到别的cgroup。</p>\n<p>当进程从一个cgroup被移动到另一个cgroup。进程的task_struct会获取一个新的css_set指针：如果这个cgroup所在的css_set已经存在就重用这个css_set，否则就新分配一个css_set。kernel会在全局的hash表中查找确认cgroup所属的css_set是否存在。</p>\n</blockquote>\n<h2 id=\"4-notify-on-release-是做什么的？\"><a href=\"#4-notify-on-release-是做什么的？\" class=\"headerlink\" title=\"4 notify_on_release 是做什么的？\"></a>4 notify_on_release 是做什么的？</h2><blockquote>\n<p>如果cgroup中使能notify_on_release，cgroup中的最后一个进程被移除，最后一个子cgroup也被删除时，cgroup会主动通知kernel。接收到消息的kernel会执行release_agent文件中指定的程序。notify_on_release默认是关闭的，release_agent的内容默认为空，子cgroup在创建时会继承父cgroup中notify_on_relase和release_agent的属性。所以这两个文件只存在于cgroupfs的顶层目录中。</p>\n</blockquote>\n<h2 id=\"5-clone-children有什么用？\"><a href=\"#5-clone-children有什么用？\" class=\"headerlink\" title=\"5 clone_children有什么用？\"></a>5 clone_children有什么用？</h2><blockquote>\n<p>clone_chilren仅针对cpu绑定（cpuset），如果clone_children使能，新的cpuset cgroup在初始化时会继承父cgroup的属性。</p>\n</blockquote>\n<h2 id=\"6-cgroup怎么用？\"><a href=\"#6-cgroup怎么用？\" class=\"headerlink\" title=\"6 cgroup怎么用？\"></a>6 cgroup怎么用？</h2><blockquote>\n<p>假设现在要将一个新的任务加入到cgroup，功能是将该任务的进程在指定的cpu上运行，因此我们使用”cpuset”cgroup 子系统，操作的大致步骤如下：</p>\n<p>1）mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup </p>\n<p>挂载cgroup根文件系统，类型为tmpfs</p>\n<p>2）mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>在cgroupfs根目录下创建子cgroup，名为cpuset</p>\n<p>3）mount -t cgroup -o cpuset cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>将名为cpuset的cgroup关联到cpuset子系统</p>\n<p>4）在cpuset目录下创建目录，生成一个子cgroup，属性文件中写入相应内容，设置属性。</p>\n<p>5）启动需要限制的进程，查找其对应的进程ID，将其写入对应的task文件中</p>\n<p>以下操作步骤是创建一个名为”Charlie”的cgroup，这个cgroup的资源包含cpu2，cpu3和内存节点1，将shell进程附加到这个cgroup。</p>\n<p>mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup</p>\n<p>mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>mount -t cgroup cpuset -o cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>cd &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>\n<p>mkdir Charlie</p>\n<p>cd Charlie</p>\n<p>echo 2-3 &gt; cpuset.cpus</p>\n<p>echo 1 &gt; cpuset.mems</p>\n<p>echo $$ &gt; tasks</p>\n<p>sh</p>\n<p>cat &#x2F;proc&#x2F;self&#x2F;cgroup</p>\n</blockquote>\n<p>转：</p>\n<p> <a href=\"https://blog.csdn.net/huang987246510/article/details/80765628\">https://blog.csdn.net/huang987246510/article/details/80765628</a></p>\n"},{"title":"pinctrl","date":"2024-05-16T05:33:03.000Z","_content":"\n\n\n查看具体设备树中的宏定义\n\ninclude/dt-bindings/gpio/gpio.h\n\ninclude/dt-bindings/pinctrl/rockchip.h\n\ndt-bindings/clock/rk3588-cru.h\n\n\n\n查看物理单系统中的pinctrl配置，获取物理外设真实的device name\n\n  cat /sys/kernel/debug/pinctrl/pinctrl-maps\n\n\n\n\n\npinctrl的三大作用,有助于理解相关结构体\n\n1.引脚枚举与命名 enumerating and naming\n\n2.引脚服用 Multiplexing：比如用作GPIO、I2C或其他功能\n\n3.引脚配置 Configuration：比如上拉、下拉、open drain、驱动强度等\n\n\n\n\n\nrk3588s.dtsi\nrk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例\n\n查看引脚的复用情况\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins\n\nRK3588频脚计算方式与一般的计算方式没有区别：\nGPIO pin脚计算公式：pin = bank * 32 + number\nGPIO 小组编号计算公式：number = group * 8 + X\n\n摘自官网：\n\n下面演示GPIO1_D0 pin脚计算方法：\n\nbank = 1;      //GPIO1_D0 => 1, bank ∈ [0,4]\n\ngroup = 3;      //GPIO1_D0 => 3, group ∈ {(A=0), (B=1), (C=2), (D=3)}\n\nX = 0;       //GPIO1_D0 => 0, X ∈ [0,7]\n\nnumber = group * 8 + X = 3 * 8 + 0 = 24\n\npin = bank*32 + number= 1 * 32 + 24 = 56;\n\nGPIO1_D0 对应的设备树属性描述为:<&gpio1 24 GPIO_ACTIVE_HIGH>,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的\n的宏定义可知，也可以将GPIO1_D0描述为<&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>。\n\n\n\n## client端相关结构体\n\nhttps://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&icon_type=3&file_type=20 \n\n![image-20240530170508734](../imgs/image-20240530170508734.png)\n\n\n\n\n\nrk3588-pinctrl-pin-config-debug\n\n```\ncd /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl \ncat pinmux-pins  \ncat ../pinctrl-handles\t#查看所有pinctrl client state\n```\n\n\n\n```\n\nrk3588s.dtsi\nrk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例\n\n查看引脚的复用情况\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins\n\nRK3588频脚计算方式与一般的计算方式没有区别：\nGPIO pin脚计算公式：pin = bank * 32 + number\nGPIO 小组编号计算公式：number = group * 8 + X\n\n摘自官网：\n\n下面演示GPIO1_D0 pin脚计算方法：\n\nbank = 1;      //GPIO1_D0 => 1, bank ∈ [0,4]\n\ngroup = 3;      //GPIO1_D0 => 3, group ∈ {(A=0), (B=1), (C=2), (D=3)}\n\nX = 0;       //GPIO1_D0 => 0, X ∈ [0,7]\n\nnumber = group * 8 + X = 3 * 8 + 0 = 24\n\npin = bank*32 + number= 1 * 32 + 24 = 56;\n\nGPIO1_D0 对应的设备树属性描述为:<&gpio1 24 GPIO_ACTIVE_HIGH>,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的\n的宏定义可知，也可以将GPIO1_D0描述为<&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>。\n\n\nrockchip_pinctrl_parse_dt\n\tinfo->groups = devm_kcalloc(dev, info->ngroups, sizeof(*info->groups), GFP_KERNEL);\n\trockchip_pinctrl_parse_functions\n\t\trockchip_pinctrl_parse_groups\n\t\t\tpinconf_generic_parse_dt_config\n\t\t\t\tparse_dt_cfg\n\t\t\t\t\tpinconf_to_config_packed\n\t\t\t\t\t\tPIN_CONF_PACKED\n\n#define PIN_CONF_PACKED(p, a) ((a << 8) | ((unsigned long) p & 0xffUL))\n5,1\n105\n\n\nof_property_read_u32(np, par->property, &val);\n\tof_property_read_u32_array(np, property, val, 1);\n\t\tof_property_read_variable_u32_array(np, property, val, 1, 0);\n\t\tof_find_property_value_of_size(np, property, 4, 0, &sz);\n\n\tpinctrl_show\n\t\tpinconf_show_setting\n\t\t\tpinconf_show_config\n\t\t\t\tsetting->data.configs.configs\n\nadd_setting\n\tpinconf_map_to_setting\n\n\t\tsetting->data.configs.configs = map->data.configs.configs;\n\nrockchip_dt_node_to_map\n\tpinctrl_name_to_group\n\t\trockchip_pin_group * grp = info->groups[i]\n\n\tnew_map[i].data.configs.configs = grp->data[i].configs;\n\n\nrockchip_pmx_set\n\tconst struct rockchip_pin_config *data = info->groups[group].data;\n\n\nrockchip_pin_group\n\n\nuart1 {\n\t\t/omit-if-no-ref/\n\t\tuart1m1_xfer: uart1m1-xfer {\n\t\t\trockchip,pins =\n\t\t\t\t/* uart1_rx_m1 */\n\t\t\t\t<1 RK_PB7 10 &pcfg_pull_up>,\n\t\t\t\t/* uart1_tx_m1 */\n\t\t\t\t<1 RK_PB6 10 &pcfg_pull_up>;\n\t\t};\n\n\npcfg_pull_up\n\tbias-pull-up;\n\t\tstatic const struct pinconf_generic_params dt_params[] = {\n\t\t\t{ \"bias-bus-hold\", PIN_CONFIG_BIAS_BUS_HOLD, 0 },\n\t\t\t{ \"bias-disable\", PIN_CONFIG_BIAS_DISABLE, 0 },\n\t\t\t{ \"bias-high-impedance\", PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 },\n\t\t\t{ \"bias-pull-up\", PIN_CONFIG_BIAS_PULL_UP, 1 },\n\n\t\tstatic const struct pin_config_item conf_items[] = {\n\t\t\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, \"input bias pull up\", \"ohms\", true),\n\n\t\tenum pin_config_param {\n\t\t\tPIN_CONFIG_BIAS_BUS_HOLD,\n\t\t\tPIN_CONFIG_BIAS_DISABLE,\n\t\t\tPIN_CONFIG_BIAS_HIGH_IMPEDANCE,\n\t\t\tPIN_CONFIG_BIAS_PULL_DOWN,\n\t\t\tPIN_CONFIG_BIAS_PULL_PIN_DEFAULT,\n\t\t\tPIN_CONFIG_BIAS_PULL_UP,\t//5\n```\n\n","source":"_posts/pinctrl.md","raw":"---\ntitle: pinctrl\ncategories:\n  - kernel\ntags:\n  - pinctrl\ndate: 2024-05-16 13:33:03\n---\n\n\n\n查看具体设备树中的宏定义\n\ninclude/dt-bindings/gpio/gpio.h\n\ninclude/dt-bindings/pinctrl/rockchip.h\n\ndt-bindings/clock/rk3588-cru.h\n\n\n\n查看物理单系统中的pinctrl配置，获取物理外设真实的device name\n\n  cat /sys/kernel/debug/pinctrl/pinctrl-maps\n\n\n\n\n\npinctrl的三大作用,有助于理解相关结构体\n\n1.引脚枚举与命名 enumerating and naming\n\n2.引脚服用 Multiplexing：比如用作GPIO、I2C或其他功能\n\n3.引脚配置 Configuration：比如上拉、下拉、open drain、驱动强度等\n\n\n\n\n\nrk3588s.dtsi\nrk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例\n\n查看引脚的复用情况\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins\n\nRK3588频脚计算方式与一般的计算方式没有区别：\nGPIO pin脚计算公式：pin = bank * 32 + number\nGPIO 小组编号计算公式：number = group * 8 + X\n\n摘自官网：\n\n下面演示GPIO1_D0 pin脚计算方法：\n\nbank = 1;      //GPIO1_D0 => 1, bank ∈ [0,4]\n\ngroup = 3;      //GPIO1_D0 => 3, group ∈ {(A=0), (B=1), (C=2), (D=3)}\n\nX = 0;       //GPIO1_D0 => 0, X ∈ [0,7]\n\nnumber = group * 8 + X = 3 * 8 + 0 = 24\n\npin = bank*32 + number= 1 * 32 + 24 = 56;\n\nGPIO1_D0 对应的设备树属性描述为:<&gpio1 24 GPIO_ACTIVE_HIGH>,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的\n的宏定义可知，也可以将GPIO1_D0描述为<&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>。\n\n\n\n## client端相关结构体\n\nhttps://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&icon_type=3&file_type=20 \n\n![image-20240530170508734](../imgs/image-20240530170508734.png)\n\n\n\n\n\nrk3588-pinctrl-pin-config-debug\n\n```\ncd /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl \ncat pinmux-pins  \ncat ../pinctrl-handles\t#查看所有pinctrl client state\n```\n\n\n\n```\n\nrk3588s.dtsi\nrk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例\n\n查看引脚的复用情况\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins\n\nRK3588频脚计算方式与一般的计算方式没有区别：\nGPIO pin脚计算公式：pin = bank * 32 + number\nGPIO 小组编号计算公式：number = group * 8 + X\n\n摘自官网：\n\n下面演示GPIO1_D0 pin脚计算方法：\n\nbank = 1;      //GPIO1_D0 => 1, bank ∈ [0,4]\n\ngroup = 3;      //GPIO1_D0 => 3, group ∈ {(A=0), (B=1), (C=2), (D=3)}\n\nX = 0;       //GPIO1_D0 => 0, X ∈ [0,7]\n\nnumber = group * 8 + X = 3 * 8 + 0 = 24\n\npin = bank*32 + number= 1 * 32 + 24 = 56;\n\nGPIO1_D0 对应的设备树属性描述为:<&gpio1 24 GPIO_ACTIVE_HIGH>,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的\n的宏定义可知，也可以将GPIO1_D0描述为<&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>。\n\n\nrockchip_pinctrl_parse_dt\n\tinfo->groups = devm_kcalloc(dev, info->ngroups, sizeof(*info->groups), GFP_KERNEL);\n\trockchip_pinctrl_parse_functions\n\t\trockchip_pinctrl_parse_groups\n\t\t\tpinconf_generic_parse_dt_config\n\t\t\t\tparse_dt_cfg\n\t\t\t\t\tpinconf_to_config_packed\n\t\t\t\t\t\tPIN_CONF_PACKED\n\n#define PIN_CONF_PACKED(p, a) ((a << 8) | ((unsigned long) p & 0xffUL))\n5,1\n105\n\n\nof_property_read_u32(np, par->property, &val);\n\tof_property_read_u32_array(np, property, val, 1);\n\t\tof_property_read_variable_u32_array(np, property, val, 1, 0);\n\t\tof_find_property_value_of_size(np, property, 4, 0, &sz);\n\n\tpinctrl_show\n\t\tpinconf_show_setting\n\t\t\tpinconf_show_config\n\t\t\t\tsetting->data.configs.configs\n\nadd_setting\n\tpinconf_map_to_setting\n\n\t\tsetting->data.configs.configs = map->data.configs.configs;\n\nrockchip_dt_node_to_map\n\tpinctrl_name_to_group\n\t\trockchip_pin_group * grp = info->groups[i]\n\n\tnew_map[i].data.configs.configs = grp->data[i].configs;\n\n\nrockchip_pmx_set\n\tconst struct rockchip_pin_config *data = info->groups[group].data;\n\n\nrockchip_pin_group\n\n\nuart1 {\n\t\t/omit-if-no-ref/\n\t\tuart1m1_xfer: uart1m1-xfer {\n\t\t\trockchip,pins =\n\t\t\t\t/* uart1_rx_m1 */\n\t\t\t\t<1 RK_PB7 10 &pcfg_pull_up>,\n\t\t\t\t/* uart1_tx_m1 */\n\t\t\t\t<1 RK_PB6 10 &pcfg_pull_up>;\n\t\t};\n\n\npcfg_pull_up\n\tbias-pull-up;\n\t\tstatic const struct pinconf_generic_params dt_params[] = {\n\t\t\t{ \"bias-bus-hold\", PIN_CONFIG_BIAS_BUS_HOLD, 0 },\n\t\t\t{ \"bias-disable\", PIN_CONFIG_BIAS_DISABLE, 0 },\n\t\t\t{ \"bias-high-impedance\", PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 },\n\t\t\t{ \"bias-pull-up\", PIN_CONFIG_BIAS_PULL_UP, 1 },\n\n\t\tstatic const struct pin_config_item conf_items[] = {\n\t\t\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, \"input bias pull up\", \"ohms\", true),\n\n\t\tenum pin_config_param {\n\t\t\tPIN_CONFIG_BIAS_BUS_HOLD,\n\t\t\tPIN_CONFIG_BIAS_DISABLE,\n\t\t\tPIN_CONFIG_BIAS_HIGH_IMPEDANCE,\n\t\t\tPIN_CONFIG_BIAS_PULL_DOWN,\n\t\t\tPIN_CONFIG_BIAS_PULL_PIN_DEFAULT,\n\t\t\tPIN_CONFIG_BIAS_PULL_UP,\t//5\n```\n\n","slug":"pinctrl","published":1,"updated":"2024-06-04T05:57:28.917Z","_id":"clw8xrfby00029gw0eobh98nt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>查看具体设备树中的宏定义</p>\n<p>include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h</p>\n<p>include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h</p>\n<p>dt-bindings&#x2F;clock&#x2F;rk3588-cru.h</p>\n<p>查看物理单系统中的pinctrl配置，获取物理外设真实的device name</p>\n<p>  cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;pinctrl&#x2F;pinctrl-maps</p>\n<p>pinctrl的三大作用,有助于理解相关结构体</p>\n<p>1.引脚枚举与命名 enumerating and naming</p>\n<p>2.引脚服用 Multiplexing：比如用作GPIO、I2C或其他功能</p>\n<p>3.引脚配置 Configuration：比如上拉、下拉、open drain、驱动强度等</p>\n<p>rk3588s.dtsi<br>rk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例</p>\n<p>查看引脚的复用情况<br>cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;pinctrl&#x2F;pinctrl-rockchip-pinctrl&#x2F;pinmux-pins</p>\n<p>RK3588频脚计算方式与一般的计算方式没有区别：<br>GPIO pin脚计算公式：pin &#x3D; bank * 32 + number<br>GPIO 小组编号计算公式：number &#x3D; group * 8 + X</p>\n<p>摘自官网：</p>\n<p>下面演示GPIO1_D0 pin脚计算方法：</p>\n<p>bank &#x3D; 1;      &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 1, bank ∈ [0,4]</p>\n<p>group &#x3D; 3;      &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 3, group ∈ {(A&#x3D;0), (B&#x3D;1), (C&#x3D;2), (D&#x3D;3)}</p>\n<p>X &#x3D; 0;       &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 0, X ∈ [0,7]</p>\n<p>number &#x3D; group * 8 + X &#x3D; 3 * 8 + 0 &#x3D; 24</p>\n<p>pin &#x3D; bank*32 + number&#x3D; 1 * 32 + 24 &#x3D; 56;</p>\n<p>GPIO1_D0 对应的设备树属性描述为:&lt;&amp;gpio1 24 GPIO_ACTIVE_HIGH&gt;,由kernel-5.10&#x2F;include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h的<br>的宏定义可知，也可以将GPIO1_D0描述为&lt;&amp;gpio1 RK_PD0 GPIO_ACTIVE_HIGH&gt;。</p>\n<h2 id=\"client端相关结构体\"><a href=\"#client端相关结构体\" class=\"headerlink\" title=\"client端相关结构体\"></a>client端相关结构体</h2><p><a href=\"https://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&icon_type=3&file_type=20\">https://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&amp;icon_type=3&amp;file_type=20</a> </p>\n<p><img src=\"/../imgs/image-20240530170508734.png\" alt=\"image-20240530170508734\"></p>\n<p>rk3588-pinctrl-pin-config-debug</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl </span><br><span class=\"line\">cat pinmux-pins  </span><br><span class=\"line\">cat ../pinctrl-handles\t#查看所有pinctrl client state</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">rk3588s.dtsi</span><br><span class=\"line\">rk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例</span><br><span class=\"line\"></span><br><span class=\"line\">查看引脚的复用情况</span><br><span class=\"line\">cat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins</span><br><span class=\"line\"></span><br><span class=\"line\">RK3588频脚计算方式与一般的计算方式没有区别：</span><br><span class=\"line\">GPIO pin脚计算公式：pin = bank * 32 + number</span><br><span class=\"line\">GPIO 小组编号计算公式：number = group * 8 + X</span><br><span class=\"line\"></span><br><span class=\"line\">摘自官网：</span><br><span class=\"line\"></span><br><span class=\"line\">下面演示GPIO1_D0 pin脚计算方法：</span><br><span class=\"line\"></span><br><span class=\"line\">bank = 1;      //GPIO1_D0 =&gt; 1, bank ∈ [0,4]</span><br><span class=\"line\"></span><br><span class=\"line\">group = 3;      //GPIO1_D0 =&gt; 3, group ∈ &#123;(A=0), (B=1), (C=2), (D=3)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">X = 0;       //GPIO1_D0 =&gt; 0, X ∈ [0,7]</span><br><span class=\"line\"></span><br><span class=\"line\">number = group * 8 + X = 3 * 8 + 0 = 24</span><br><span class=\"line\"></span><br><span class=\"line\">pin = bank*32 + number= 1 * 32 + 24 = 56;</span><br><span class=\"line\"></span><br><span class=\"line\">GPIO1_D0 对应的设备树属性描述为:&lt;&amp;gpio1 24 GPIO_ACTIVE_HIGH&gt;,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的</span><br><span class=\"line\">的宏定义可知，也可以将GPIO1_D0描述为&lt;&amp;gpio1 RK_PD0 GPIO_ACTIVE_HIGH&gt;。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pinctrl_parse_dt</span><br><span class=\"line\">\tinfo-&gt;groups = devm_kcalloc(dev, info-&gt;ngroups, sizeof(*info-&gt;groups), GFP_KERNEL);</span><br><span class=\"line\">\trockchip_pinctrl_parse_functions</span><br><span class=\"line\">\t\trockchip_pinctrl_parse_groups</span><br><span class=\"line\">\t\t\tpinconf_generic_parse_dt_config</span><br><span class=\"line\">\t\t\t\tparse_dt_cfg</span><br><span class=\"line\">\t\t\t\t\tpinconf_to_config_packed</span><br><span class=\"line\">\t\t\t\t\t\tPIN_CONF_PACKED</span><br><span class=\"line\"></span><br><span class=\"line\">#define PIN_CONF_PACKED(p, a) ((a &lt;&lt; 8) | ((unsigned long) p &amp; 0xffUL))</span><br><span class=\"line\">5,1</span><br><span class=\"line\">105</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">of_property_read_u32(np, par-&gt;property, &amp;val);</span><br><span class=\"line\">\tof_property_read_u32_array(np, property, val, 1);</span><br><span class=\"line\">\t\tof_property_read_variable_u32_array(np, property, val, 1, 0);</span><br><span class=\"line\">\t\tof_find_property_value_of_size(np, property, 4, 0, &amp;sz);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpinctrl_show</span><br><span class=\"line\">\t\tpinconf_show_setting</span><br><span class=\"line\">\t\t\tpinconf_show_config</span><br><span class=\"line\">\t\t\t\tsetting-&gt;data.configs.configs</span><br><span class=\"line\"></span><br><span class=\"line\">add_setting</span><br><span class=\"line\">\tpinconf_map_to_setting</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsetting-&gt;data.configs.configs = map-&gt;data.configs.configs;</span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_dt_node_to_map</span><br><span class=\"line\">\tpinctrl_name_to_group</span><br><span class=\"line\">\t\trockchip_pin_group * grp = info-&gt;groups[i]</span><br><span class=\"line\"></span><br><span class=\"line\">\tnew_map[i].data.configs.configs = grp-&gt;data[i].configs;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pmx_set</span><br><span class=\"line\">\tconst struct rockchip_pin_config *data = info-&gt;groups[group].data;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pin_group</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">uart1 &#123;</span><br><span class=\"line\">\t\t/omit-if-no-ref/</span><br><span class=\"line\">\t\tuart1m1_xfer: uart1m1-xfer &#123;</span><br><span class=\"line\">\t\t\trockchip,pins =</span><br><span class=\"line\">\t\t\t\t/* uart1_rx_m1 */</span><br><span class=\"line\">\t\t\t\t&lt;1 RK_PB7 10 &amp;pcfg_pull_up&gt;,</span><br><span class=\"line\">\t\t\t\t/* uart1_tx_m1 */</span><br><span class=\"line\">\t\t\t\t&lt;1 RK_PB6 10 &amp;pcfg_pull_up&gt;;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">pcfg_pull_up</span><br><span class=\"line\">\tbias-pull-up;</span><br><span class=\"line\">\t\tstatic const struct pinconf_generic_params dt_params[] = &#123;</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-bus-hold&quot;, PIN_CONFIG_BIAS_BUS_HOLD, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-disable&quot;, PIN_CONFIG_BIAS_DISABLE, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-high-impedance&quot;, PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-pull-up&quot;, PIN_CONFIG_BIAS_PULL_UP, 1 &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tstatic const struct pin_config_item conf_items[] = &#123;</span><br><span class=\"line\">\t\t\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, &quot;input bias pull up&quot;, &quot;ohms&quot;, true),</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tenum pin_config_param &#123;</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_BUS_HOLD,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_DISABLE,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_HIGH_IMPEDANCE,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_DOWN,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_PIN_DEFAULT,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_UP,\t//5</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>查看具体设备树中的宏定义</p>\n<p>include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h</p>\n<p>include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h</p>\n<p>dt-bindings&#x2F;clock&#x2F;rk3588-cru.h</p>\n<p>查看物理单系统中的pinctrl配置，获取物理外设真实的device name</p>\n<p>  cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;pinctrl&#x2F;pinctrl-maps</p>\n<p>pinctrl的三大作用,有助于理解相关结构体</p>\n<p>1.引脚枚举与命名 enumerating and naming</p>\n<p>2.引脚服用 Multiplexing：比如用作GPIO、I2C或其他功能</p>\n<p>3.引脚配置 Configuration：比如上拉、下拉、open drain、驱动强度等</p>\n<p>rk3588s.dtsi<br>rk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例</p>\n<p>查看引脚的复用情况<br>cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;pinctrl&#x2F;pinctrl-rockchip-pinctrl&#x2F;pinmux-pins</p>\n<p>RK3588频脚计算方式与一般的计算方式没有区别：<br>GPIO pin脚计算公式：pin &#x3D; bank * 32 + number<br>GPIO 小组编号计算公式：number &#x3D; group * 8 + X</p>\n<p>摘自官网：</p>\n<p>下面演示GPIO1_D0 pin脚计算方法：</p>\n<p>bank &#x3D; 1;      &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 1, bank ∈ [0,4]</p>\n<p>group &#x3D; 3;      &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 3, group ∈ {(A&#x3D;0), (B&#x3D;1), (C&#x3D;2), (D&#x3D;3)}</p>\n<p>X &#x3D; 0;       &#x2F;&#x2F;GPIO1_D0 &#x3D;&gt; 0, X ∈ [0,7]</p>\n<p>number &#x3D; group * 8 + X &#x3D; 3 * 8 + 0 &#x3D; 24</p>\n<p>pin &#x3D; bank*32 + number&#x3D; 1 * 32 + 24 &#x3D; 56;</p>\n<p>GPIO1_D0 对应的设备树属性描述为:&lt;&amp;gpio1 24 GPIO_ACTIVE_HIGH&gt;,由kernel-5.10&#x2F;include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h的<br>的宏定义可知，也可以将GPIO1_D0描述为&lt;&amp;gpio1 RK_PD0 GPIO_ACTIVE_HIGH&gt;。</p>\n<h2 id=\"client端相关结构体\"><a href=\"#client端相关结构体\" class=\"headerlink\" title=\"client端相关结构体\"></a>client端相关结构体</h2><p><a href=\"https://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&icon_type=3&file_type=20\">https://pixso.cn/app/board/2hWH9JSK6ESlVP76tmeENQ?showQuickFrame=true&amp;icon_type=3&amp;file_type=20</a> </p>\n<p><img src=\"/../imgs/image-20240530170508734.png\" alt=\"image-20240530170508734\"></p>\n<p>rk3588-pinctrl-pin-config-debug</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl </span><br><span class=\"line\">cat pinmux-pins  </span><br><span class=\"line\">cat ../pinctrl-handles\t#查看所有pinctrl client state</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">rk3588s.dtsi</span><br><span class=\"line\">rk3588s.-pinctrl.dtsi该文件枚举了3588所有的iomux实例</span><br><span class=\"line\"></span><br><span class=\"line\">查看引脚的复用情况</span><br><span class=\"line\">cat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins</span><br><span class=\"line\"></span><br><span class=\"line\">RK3588频脚计算方式与一般的计算方式没有区别：</span><br><span class=\"line\">GPIO pin脚计算公式：pin = bank * 32 + number</span><br><span class=\"line\">GPIO 小组编号计算公式：number = group * 8 + X</span><br><span class=\"line\"></span><br><span class=\"line\">摘自官网：</span><br><span class=\"line\"></span><br><span class=\"line\">下面演示GPIO1_D0 pin脚计算方法：</span><br><span class=\"line\"></span><br><span class=\"line\">bank = 1;      //GPIO1_D0 =&gt; 1, bank ∈ [0,4]</span><br><span class=\"line\"></span><br><span class=\"line\">group = 3;      //GPIO1_D0 =&gt; 3, group ∈ &#123;(A=0), (B=1), (C=2), (D=3)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">X = 0;       //GPIO1_D0 =&gt; 0, X ∈ [0,7]</span><br><span class=\"line\"></span><br><span class=\"line\">number = group * 8 + X = 3 * 8 + 0 = 24</span><br><span class=\"line\"></span><br><span class=\"line\">pin = bank*32 + number= 1 * 32 + 24 = 56;</span><br><span class=\"line\"></span><br><span class=\"line\">GPIO1_D0 对应的设备树属性描述为:&lt;&amp;gpio1 24 GPIO_ACTIVE_HIGH&gt;,由kernel-5.10/include/dt-bindings/pinctrl/rockchip.h的</span><br><span class=\"line\">的宏定义可知，也可以将GPIO1_D0描述为&lt;&amp;gpio1 RK_PD0 GPIO_ACTIVE_HIGH&gt;。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pinctrl_parse_dt</span><br><span class=\"line\">\tinfo-&gt;groups = devm_kcalloc(dev, info-&gt;ngroups, sizeof(*info-&gt;groups), GFP_KERNEL);</span><br><span class=\"line\">\trockchip_pinctrl_parse_functions</span><br><span class=\"line\">\t\trockchip_pinctrl_parse_groups</span><br><span class=\"line\">\t\t\tpinconf_generic_parse_dt_config</span><br><span class=\"line\">\t\t\t\tparse_dt_cfg</span><br><span class=\"line\">\t\t\t\t\tpinconf_to_config_packed</span><br><span class=\"line\">\t\t\t\t\t\tPIN_CONF_PACKED</span><br><span class=\"line\"></span><br><span class=\"line\">#define PIN_CONF_PACKED(p, a) ((a &lt;&lt; 8) | ((unsigned long) p &amp; 0xffUL))</span><br><span class=\"line\">5,1</span><br><span class=\"line\">105</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">of_property_read_u32(np, par-&gt;property, &amp;val);</span><br><span class=\"line\">\tof_property_read_u32_array(np, property, val, 1);</span><br><span class=\"line\">\t\tof_property_read_variable_u32_array(np, property, val, 1, 0);</span><br><span class=\"line\">\t\tof_find_property_value_of_size(np, property, 4, 0, &amp;sz);</span><br><span class=\"line\"></span><br><span class=\"line\">\tpinctrl_show</span><br><span class=\"line\">\t\tpinconf_show_setting</span><br><span class=\"line\">\t\t\tpinconf_show_config</span><br><span class=\"line\">\t\t\t\tsetting-&gt;data.configs.configs</span><br><span class=\"line\"></span><br><span class=\"line\">add_setting</span><br><span class=\"line\">\tpinconf_map_to_setting</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsetting-&gt;data.configs.configs = map-&gt;data.configs.configs;</span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_dt_node_to_map</span><br><span class=\"line\">\tpinctrl_name_to_group</span><br><span class=\"line\">\t\trockchip_pin_group * grp = info-&gt;groups[i]</span><br><span class=\"line\"></span><br><span class=\"line\">\tnew_map[i].data.configs.configs = grp-&gt;data[i].configs;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pmx_set</span><br><span class=\"line\">\tconst struct rockchip_pin_config *data = info-&gt;groups[group].data;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">rockchip_pin_group</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">uart1 &#123;</span><br><span class=\"line\">\t\t/omit-if-no-ref/</span><br><span class=\"line\">\t\tuart1m1_xfer: uart1m1-xfer &#123;</span><br><span class=\"line\">\t\t\trockchip,pins =</span><br><span class=\"line\">\t\t\t\t/* uart1_rx_m1 */</span><br><span class=\"line\">\t\t\t\t&lt;1 RK_PB7 10 &amp;pcfg_pull_up&gt;,</span><br><span class=\"line\">\t\t\t\t/* uart1_tx_m1 */</span><br><span class=\"line\">\t\t\t\t&lt;1 RK_PB6 10 &amp;pcfg_pull_up&gt;;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">pcfg_pull_up</span><br><span class=\"line\">\tbias-pull-up;</span><br><span class=\"line\">\t\tstatic const struct pinconf_generic_params dt_params[] = &#123;</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-bus-hold&quot;, PIN_CONFIG_BIAS_BUS_HOLD, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-disable&quot;, PIN_CONFIG_BIAS_DISABLE, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-high-impedance&quot;, PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 &#125;,</span><br><span class=\"line\">\t\t\t&#123; &quot;bias-pull-up&quot;, PIN_CONFIG_BIAS_PULL_UP, 1 &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tstatic const struct pin_config_item conf_items[] = &#123;</span><br><span class=\"line\">\t\t\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, &quot;input bias pull up&quot;, &quot;ohms&quot;, true),</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tenum pin_config_param &#123;</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_BUS_HOLD,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_DISABLE,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_HIGH_IMPEDANCE,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_DOWN,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_PIN_DEFAULT,</span><br><span class=\"line\">\t\t\tPIN_CONFIG_BIAS_PULL_UP,\t//5</span><br></pre></td></tr></table></figure>\n\n"},{"title":"PHY芯片","date":"2024-05-16T10:58:06.000Z","_content":"\n[toc]\n\n# PHY（physical Layer，PHY）\n\n## 什么是PHY？\n\n物理层芯片称为PHY、数据链路层芯片称为MAC\n\n可以看到PHY的数据是[RJ45](https://so.csdn.net/so/search?q=RJ45&spm=1001.2101.3001.7020)网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。\n\n那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）\n\n## 什么是RJ45接口？\n\nRJ45接口通常用于数据传输，最常见的应用为网卡接口。RJ-45端口是我们最常见的端口之一，是比较常见的[双绞线](https://www.zhihu.com/search?q=双绞线&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A3477234795})以太网端口，因为在快速以太网中也主要采用双绞线作为传输介质。\n\nRJ45型网线插头又称水晶头，共由八芯做成，广泛应用于局域网和ADSL宽带上网用户的网络设备间网线（称作五类线或双绞线）的连接。\n\nRJ45接头根据线的排序不同主要分两种，一种是橙白、橙、绿白、蓝、蓝白、绿、棕白、棕；另一种是绿白、绿、橙白、蓝、蓝白、橙、棕白、棕；因此使用RJ45接头的线也有两种即：直通线、交叉线。分别称作[T568A线序](https://www.zhihu.com/search?q=T568A线序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A3477234795})和T568B线序。\n\nRJ45插座连接器接口内部是金属，注意不能受潮或者接触到水，否则会造成短路现象。\n\n## 为什么要熟悉RJ45网口\n\n上面说到针对phy芯片我们只要进行模式选择（下文会介绍使用[mdio](https://so.csdn.net/so/search?q=mdio&spm=1001.2101.3001.7020)接口，通过寄存器控制）\n\n那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看\n\n![img](../imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png)\n\nRJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，**绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信**，**黄灯闪动频率快表示网速**好，这两个灯由 PHY 芯片控制。\n\n## 网络七层协议\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png)\n\n## 两个模块进行通信\n\n下图是两个主控直接的通信，比如我们的电脑 和 路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的\n\n如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西\n\n比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。\n\n（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）\n\n![img](../img/84b0b5e31bb246c0a970ace7c71a3f82.png)\n\n## 什么是MDIO协议\n\nmido协议即SMI协议\n\nSMI协议也是一种通信协议类似与I2C协议但是通信方式不一样\n\nSMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，\n\n如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png)\n\n\n\n## MDIO的作用 \n\n从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据\n\n那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率[休眠状态](https://baike.baidu.com/item/休眠状态?fromModule=lemma_inlink)、TX/RX模式选择、[自动协商](https://baike.baidu.com/item/自动协商/7765053?fromModule=lemma_inlink)控制、环回模式控制等。\n\n\n\n### MDIO没那么重要\n\nMDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！\n\n换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。\n\n但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。\n\n如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！\n\n\n## MDIO读写时序\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png)\n\nPreamble：32bits的前导码\n\nStart：2bit的开始位。\n\nOP Code：2bits的操作码，10表示读，01表示写。\n\nPHYAD：5bits的PHY地址。\n\nREGAD：5bits的寄存器地址，即要读或写的寄存器。\n\nTurn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。\n\nData：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。\n\nIdle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。\n为什么说读取的phy最多32个\n因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为\n\n## 为什么说reg地址最多32个\n\n同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个\n\n PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16`~`31 这 16 个寄存器由厂商自行实现。 也就是说不管你用的哪个厂家的 PHY 芯片，其中 0`~`15 这 16 个寄存器是一模一样的。 仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。\n\n \n\n\n\n转：\n\n[PHY芯片快速深度理解（持续更新中……）-CSDN博客](https://blog.csdn.net/qq_40715266/article/details/124095801)\n\n\n\n[PHY（Physical Layer，PHY） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/148538791)\n","source":"_posts/PHY芯片.md","raw":"---\ntitle: PHY芯片\ncategories:\n  - test\ntags:\n  - PHY芯片\ndate: 2024-05-16 18:58:06\n---\n\n[toc]\n\n# PHY（physical Layer，PHY）\n\n## 什么是PHY？\n\n物理层芯片称为PHY、数据链路层芯片称为MAC\n\n可以看到PHY的数据是[RJ45](https://so.csdn.net/so/search?q=RJ45&spm=1001.2101.3001.7020)网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。\n\n那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）\n\n## 什么是RJ45接口？\n\nRJ45接口通常用于数据传输，最常见的应用为网卡接口。RJ-45端口是我们最常见的端口之一，是比较常见的[双绞线](https://www.zhihu.com/search?q=双绞线&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A3477234795})以太网端口，因为在快速以太网中也主要采用双绞线作为传输介质。\n\nRJ45型网线插头又称水晶头，共由八芯做成，广泛应用于局域网和ADSL宽带上网用户的网络设备间网线（称作五类线或双绞线）的连接。\n\nRJ45接头根据线的排序不同主要分两种，一种是橙白、橙、绿白、蓝、蓝白、绿、棕白、棕；另一种是绿白、绿、橙白、蓝、蓝白、橙、棕白、棕；因此使用RJ45接头的线也有两种即：直通线、交叉线。分别称作[T568A线序](https://www.zhihu.com/search?q=T568A线序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A3477234795})和T568B线序。\n\nRJ45插座连接器接口内部是金属，注意不能受潮或者接触到水，否则会造成短路现象。\n\n## 为什么要熟悉RJ45网口\n\n上面说到针对phy芯片我们只要进行模式选择（下文会介绍使用[mdio](https://so.csdn.net/so/search?q=mdio&spm=1001.2101.3001.7020)接口，通过寄存器控制）\n\n那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看\n\n![img](../imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png)\n\nRJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，**绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信**，**黄灯闪动频率快表示网速**好，这两个灯由 PHY 芯片控制。\n\n## 网络七层协议\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png)\n\n## 两个模块进行通信\n\n下图是两个主控直接的通信，比如我们的电脑 和 路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的\n\n如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西\n\n比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。\n\n（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）\n\n![img](../img/84b0b5e31bb246c0a970ace7c71a3f82.png)\n\n## 什么是MDIO协议\n\nmido协议即SMI协议\n\nSMI协议也是一种通信协议类似与I2C协议但是通信方式不一样\n\nSMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，\n\n如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png)\n\n\n\n## MDIO的作用 \n\n从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据\n\n那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率[休眠状态](https://baike.baidu.com/item/休眠状态?fromModule=lemma_inlink)、TX/RX模式选择、[自动协商](https://baike.baidu.com/item/自动协商/7765053?fromModule=lemma_inlink)控制、环回模式控制等。\n\n\n\n### MDIO没那么重要\n\nMDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！\n\n换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。\n\n但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。\n\n如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！\n\n\n## MDIO读写时序\n\n![img](../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png)\n\nPreamble：32bits的前导码\n\nStart：2bit的开始位。\n\nOP Code：2bits的操作码，10表示读，01表示写。\n\nPHYAD：5bits的PHY地址。\n\nREGAD：5bits的寄存器地址，即要读或写的寄存器。\n\nTurn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。\n\nData：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。\n\nIdle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。\n为什么说读取的phy最多32个\n因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为\n\n## 为什么说reg地址最多32个\n\n同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个\n\n PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16`~`31 这 16 个寄存器由厂商自行实现。 也就是说不管你用的哪个厂家的 PHY 芯片，其中 0`~`15 这 16 个寄存器是一模一样的。 仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。\n\n \n\n\n\n转：\n\n[PHY芯片快速深度理解（持续更新中……）-CSDN博客](https://blog.csdn.net/qq_40715266/article/details/124095801)\n\n\n\n[PHY（Physical Layer，PHY） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/148538791)\n","slug":"PHY芯片","published":1,"updated":"2024-05-16T11:52:51.715Z","_id":"clw95434m0001auw046z4fp3s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>[toc]</p>\n<h1 id=\"PHY（physical-Layer，PHY）\"><a href=\"#PHY（physical-Layer，PHY）\" class=\"headerlink\" title=\"PHY（physical Layer，PHY）\"></a>PHY（physical Layer，PHY）</h1><h2 id=\"什么是PHY？\"><a href=\"#什么是PHY？\" class=\"headerlink\" title=\"什么是PHY？\"></a>什么是PHY？</h2><p>物理层芯片称为PHY、数据链路层芯片称为MAC</p>\n<p>可以看到PHY的数据是<a href=\"https://so.csdn.net/so/search?q=RJ45&spm=1001.2101.3001.7020\">RJ45</a>网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。</p>\n<p>那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）</p>\n<h2 id=\"什么是RJ45接口？\"><a href=\"#什么是RJ45接口？\" class=\"headerlink\" title=\"什么是RJ45接口？\"></a>什么是RJ45接口？</h2><p>RJ45接口通常用于数据传输，最常见的应用为网卡接口。RJ-45端口是我们最常见的端口之一，是比较常见的<a href=\"https://www.zhihu.com/search?q=%E5%8F%8C%E7%BB%9E%E7%BA%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D\">双绞线</a>以太网端口，因为在快速以太网中也主要采用双绞线作为传输介质。</p>\n<p>RJ45型网线插头又称水晶头，共由八芯做成，广泛应用于局域网和ADSL宽带上网用户的网络设备间网线（称作五类线或双绞线）的连接。</p>\n<p>RJ45接头根据线的排序不同主要分两种，一种是橙白、橙、绿白、蓝、蓝白、绿、棕白、棕；另一种是绿白、绿、橙白、蓝、蓝白、橙、棕白、棕；因此使用RJ45接头的线也有两种即：直通线、交叉线。分别称作<a href=\"https://www.zhihu.com/search?q=T568A%E7%BA%BF%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D\">T568A线序</a>和T568B线序。</p>\n<p>RJ45插座连接器接口内部是金属，注意不能受潮或者接触到水，否则会造成短路现象。</p>\n<h2 id=\"为什么要熟悉RJ45网口\"><a href=\"#为什么要熟悉RJ45网口\" class=\"headerlink\" title=\"为什么要熟悉RJ45网口\"></a>为什么要熟悉RJ45网口</h2><p>上面说到针对phy芯片我们只要进行模式选择（下文会介绍使用<a href=\"https://so.csdn.net/so/search?q=mdio&spm=1001.2101.3001.7020\">mdio</a>接口，通过寄存器控制）</p>\n<p>那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看</p>\n<p><img src=\"/../imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png\" alt=\"img\"></p>\n<p>RJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，<strong>绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信</strong>，<strong>黄灯闪动频率快表示网速</strong>好，这两个灯由 PHY 芯片控制。</p>\n<h2 id=\"网络七层协议\"><a href=\"#网络七层协议\" class=\"headerlink\" title=\"网络七层协议\"></a>网络七层协议</h2><p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<h2 id=\"两个模块进行通信\"><a href=\"#两个模块进行通信\" class=\"headerlink\" title=\"两个模块进行通信\"></a>两个模块进行通信</h2><p>下图是两个主控直接的通信，比如我们的电脑 和 路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的</p>\n<p>如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西</p>\n<p>比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。</p>\n<p>（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）</p>\n<p><img src=\"/../img/84b0b5e31bb246c0a970ace7c71a3f82.png\" alt=\"img\"></p>\n<h2 id=\"什么是MDIO协议\"><a href=\"#什么是MDIO协议\" class=\"headerlink\" title=\"什么是MDIO协议\"></a>什么是MDIO协议</h2><p>mido协议即SMI协议</p>\n<p>SMI协议也是一种通信协议类似与I2C协议但是通信方式不一样</p>\n<p>SMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，</p>\n<p>如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。</p>\n<p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<h2 id=\"MDIO的作用\"><a href=\"#MDIO的作用\" class=\"headerlink\" title=\"MDIO的作用\"></a>MDIO的作用</h2><p>从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据</p>\n<p>那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率<a href=\"https://baike.baidu.com/item/%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%80%81?fromModule=lemma_inlink\">休眠状态</a>、TX&#x2F;RX模式选择、<a href=\"https://baike.baidu.com/item/%E8%87%AA%E5%8A%A8%E5%8D%8F%E5%95%86/7765053?fromModule=lemma_inlink\">自动协商</a>控制、环回模式控制等。</p>\n<h3 id=\"MDIO没那么重要\"><a href=\"#MDIO没那么重要\" class=\"headerlink\" title=\"MDIO没那么重要\"></a>MDIO没那么重要</h3><p>MDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！</p>\n<p>换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。</p>\n<p>但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。</p>\n<p>如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！</p>\n<h2 id=\"MDIO读写时序\"><a href=\"#MDIO读写时序\" class=\"headerlink\" title=\"MDIO读写时序\"></a>MDIO读写时序</h2><p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<p>Preamble：32bits的前导码</p>\n<p>Start：2bit的开始位。</p>\n<p>OP Code：2bits的操作码，10表示读，01表示写。</p>\n<p>PHYAD：5bits的PHY地址。</p>\n<p>REGAD：5bits的寄存器地址，即要读或写的寄存器。</p>\n<p>Turn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。</p>\n<p>Data：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。</p>\n<p>Idle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。<br>为什么说读取的phy最多32个<br>因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为</p>\n<h2 id=\"为什么说reg地址最多32个\"><a href=\"#为什么说reg地址最多32个\" class=\"headerlink\" title=\"为什么说reg地址最多32个\"></a>为什么说reg地址最多32个</h2><p>同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个</p>\n<p> PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16<code>~</code>31 这 16 个寄存器由厂商自行实现。 也就是说不管你用的哪个厂家的 PHY 芯片，其中 0<code>~</code>15 这 16 个寄存器是一模一样的。 仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。</p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/qq_40715266/article/details/124095801\">PHY芯片快速深度理解（持续更新中……）-CSDN博客</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/148538791\">PHY（Physical Layer，PHY） - 知乎 (zhihu.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h1 id=\"PHY（physical-Layer，PHY）\"><a href=\"#PHY（physical-Layer，PHY）\" class=\"headerlink\" title=\"PHY（physical Layer，PHY）\"></a>PHY（physical Layer，PHY）</h1><h2 id=\"什么是PHY？\"><a href=\"#什么是PHY？\" class=\"headerlink\" title=\"什么是PHY？\"></a>什么是PHY？</h2><p>物理层芯片称为PHY、数据链路层芯片称为MAC</p>\n<p>可以看到PHY的数据是<a href=\"https://so.csdn.net/so/search?q=RJ45&spm=1001.2101.3001.7020\">RJ45</a>网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。</p>\n<p>那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）</p>\n<h2 id=\"什么是RJ45接口？\"><a href=\"#什么是RJ45接口？\" class=\"headerlink\" title=\"什么是RJ45接口？\"></a>什么是RJ45接口？</h2><p>RJ45接口通常用于数据传输，最常见的应用为网卡接口。RJ-45端口是我们最常见的端口之一，是比较常见的<a href=\"https://www.zhihu.com/search?q=%E5%8F%8C%E7%BB%9E%E7%BA%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D\">双绞线</a>以太网端口，因为在快速以太网中也主要采用双绞线作为传输介质。</p>\n<p>RJ45型网线插头又称水晶头，共由八芯做成，广泛应用于局域网和ADSL宽带上网用户的网络设备间网线（称作五类线或双绞线）的连接。</p>\n<p>RJ45接头根据线的排序不同主要分两种，一种是橙白、橙、绿白、蓝、蓝白、绿、棕白、棕；另一种是绿白、绿、橙白、蓝、蓝白、橙、棕白、棕；因此使用RJ45接头的线也有两种即：直通线、交叉线。分别称作<a href=\"https://www.zhihu.com/search?q=T568A%E7%BA%BF%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D\">T568A线序</a>和T568B线序。</p>\n<p>RJ45插座连接器接口内部是金属，注意不能受潮或者接触到水，否则会造成短路现象。</p>\n<h2 id=\"为什么要熟悉RJ45网口\"><a href=\"#为什么要熟悉RJ45网口\" class=\"headerlink\" title=\"为什么要熟悉RJ45网口\"></a>为什么要熟悉RJ45网口</h2><p>上面说到针对phy芯片我们只要进行模式选择（下文会介绍使用<a href=\"https://so.csdn.net/so/search?q=mdio&spm=1001.2101.3001.7020\">mdio</a>接口，通过寄存器控制）</p>\n<p>那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看</p>\n<p><img src=\"/../imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png\" alt=\"img\"></p>\n<p>RJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，<strong>绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信</strong>，<strong>黄灯闪动频率快表示网速</strong>好，这两个灯由 PHY 芯片控制。</p>\n<h2 id=\"网络七层协议\"><a href=\"#网络七层协议\" class=\"headerlink\" title=\"网络七层协议\"></a>网络七层协议</h2><p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<h2 id=\"两个模块进行通信\"><a href=\"#两个模块进行通信\" class=\"headerlink\" title=\"两个模块进行通信\"></a>两个模块进行通信</h2><p>下图是两个主控直接的通信，比如我们的电脑 和 路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的</p>\n<p>如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西</p>\n<p>比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。</p>\n<p>（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）</p>\n<p><img src=\"/../img/84b0b5e31bb246c0a970ace7c71a3f82.png\" alt=\"img\"></p>\n<h2 id=\"什么是MDIO协议\"><a href=\"#什么是MDIO协议\" class=\"headerlink\" title=\"什么是MDIO协议\"></a>什么是MDIO协议</h2><p>mido协议即SMI协议</p>\n<p>SMI协议也是一种通信协议类似与I2C协议但是通信方式不一样</p>\n<p>SMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，</p>\n<p>如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。</p>\n<p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<h2 id=\"MDIO的作用\"><a href=\"#MDIO的作用\" class=\"headerlink\" title=\"MDIO的作用\"></a>MDIO的作用</h2><p>从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据</p>\n<p>那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率<a href=\"https://baike.baidu.com/item/%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%80%81?fromModule=lemma_inlink\">休眠状态</a>、TX&#x2F;RX模式选择、<a href=\"https://baike.baidu.com/item/%E8%87%AA%E5%8A%A8%E5%8D%8F%E5%95%86/7765053?fromModule=lemma_inlink\">自动协商</a>控制、环回模式控制等。</p>\n<h3 id=\"MDIO没那么重要\"><a href=\"#MDIO没那么重要\" class=\"headerlink\" title=\"MDIO没那么重要\"></a>MDIO没那么重要</h3><p>MDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！</p>\n<p>换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。</p>\n<p>但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。</p>\n<p>如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！</p>\n<h2 id=\"MDIO读写时序\"><a href=\"#MDIO读写时序\" class=\"headerlink\" title=\"MDIO读写时序\"></a>MDIO读写时序</h2><p><img src=\"/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png\" alt=\"img\"></p>\n<p>Preamble：32bits的前导码</p>\n<p>Start：2bit的开始位。</p>\n<p>OP Code：2bits的操作码，10表示读，01表示写。</p>\n<p>PHYAD：5bits的PHY地址。</p>\n<p>REGAD：5bits的寄存器地址，即要读或写的寄存器。</p>\n<p>Turn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。</p>\n<p>Data：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。</p>\n<p>Idle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。<br>为什么说读取的phy最多32个<br>因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为</p>\n<h2 id=\"为什么说reg地址最多32个\"><a href=\"#为什么说reg地址最多32个\" class=\"headerlink\" title=\"为什么说reg地址最多32个\"></a>为什么说reg地址最多32个</h2><p>同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个</p>\n<p> PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16<code>~</code>31 这 16 个寄存器由厂商自行实现。 也就是说不管你用的哪个厂家的 PHY 芯片，其中 0<code>~</code>15 这 16 个寄存器是一模一样的。 仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。</p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/qq_40715266/article/details/124095801\">PHY芯片快速深度理解（持续更新中……）-CSDN博客</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/148538791\">PHY（Physical Layer，PHY） - 知乎 (zhihu.com)</a></p>\n"},{"title":"Clion202204-破解","date":"2024-05-17T02:10:50.000Z","_content":"\n\n\n## 下载与安装\n\n此教程为CLion 2022.2.4 破解教程，且此教程以及下面提供的破解补丁适用与2022.2以后的新版本。\n2022年11月10日亲测有效，mac与windows均测试完美破解\n\n### CLion 下载\n\nClion官网下载地址：https://www.jetbrains.com.cn/clion/download/other.html\n\n![image](../imgs/1894089-20230211102247487-1038132289.png)\n\n找到2022.2.4的，然后根据自己的电脑系统选择。Windows的下载Windows，Mac的下载Mac的。\n\n### 安装\n\n直接上面的地址下载安装即可，安装完后记得不要打开，打开后也要先关闭，这里步骤就忽略了，安装很简单。\n\n- **卸载老版本 CLion(未安装则不用管，跳过看下面步骤)**\n  注意，安装新版本之前，如果本机安装过老版本的, 需要先彻底卸载，以免两者冲突，导致破解失败。\n  **安装太简单了，步骤就忽略了。**\n\n## 破解\n\n### 破解补丁下载\n\n破解补丁下载地址：https://kohler.lanzouo.com/iS5E40n7ojba\n\n### Windows版破解\n\n下载破解补丁后，解压得到，如下图：\n\n![image](../imgs/1894089-20230211102659035-421863408.png)\n\n将上面图示的补丁的所属文件夹 `/jetbra` 复制电脑某个位置，我是放置到了 桌面目录下（不推荐，自己选个D盘目录或者其他位置），\n点击进入`/jetbra` 补丁目录，再点击进入`/scripts` 文件夹，双击执行 `install-all-user.vbs` 破解脚本：\n\n![image](../imgs/1894089-20230211102807063-1324567688.png)\n\n**注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。**\n\n![image](../imgs/1894089-20230211102825164-1230499662.png)\n\n会提示安装补丁需要等待数秒。点击**【确定】**按钮后，过程大概 10 - 30 秒，如看到弹框提示 Done 时，表示激活破解成功：\n\n![image](../imgs/1894089-20230211102841861-1500251037.png)\n\n### mac版破解\n\n**Mac / Linux** 系统与上面 Windows 系统一样，需将补丁所属文件`/jetbra` 复制到某个路径，且**路径不能包含空格与中文**。\n\n之后，打开终端，进入到`/jetbra/scripts` 文件夹， 执行 `install.sh`脚本, 命令如下：\n\n\n\n```shell\nsudo bash install.sh\n```\n\n看到提示 Done , 表示激活成功。\n\n![image](../imgs/1894089-20230211104108634-1740893276.png)\n\n**Mac / Linux** 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，**Mac / Linux 需重启系统**，以确保环境变量生效。\n\n### linux版破解\n\n和mac版一样，参考mac,这里就不做介绍了。\n\n### 重启 CLion\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n## 填入指定激活码完成激活\n\n打开文件夹里的激活码，粘贴到输入框内，点击 `Activate` 按钮，就激活成功了。\n\n![image](../imgs/1894089-20230211104238842-2069324840.png)\n\n![image](../imgs/1894089-20230211104310444-38131101.png)\n\n激活成功后，就可以开心的 coding 了 ~\n\n![image](../imgs/1894089-20230211104336300-896542684.png)\n\n转：\n\n[CLion 2022.2.4破解教程详细图解mac,windows,linux均适用 - 愚生浅末 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kohler21/p/17111018.html)\n\n参考：\n\n[使用Clion优雅的完全远程自动同步和远程调试c++-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1406250)\n","source":"_posts/Clion202204-破解.md","raw":"---\ntitle: Clion202204-破解\ncategories:\n  - test\ntags:\n  - Clion\ndate: 2024-05-17 10:10:50\n---\n\n\n\n## 下载与安装\n\n此教程为CLion 2022.2.4 破解教程，且此教程以及下面提供的破解补丁适用与2022.2以后的新版本。\n2022年11月10日亲测有效，mac与windows均测试完美破解\n\n### CLion 下载\n\nClion官网下载地址：https://www.jetbrains.com.cn/clion/download/other.html\n\n![image](../imgs/1894089-20230211102247487-1038132289.png)\n\n找到2022.2.4的，然后根据自己的电脑系统选择。Windows的下载Windows，Mac的下载Mac的。\n\n### 安装\n\n直接上面的地址下载安装即可，安装完后记得不要打开，打开后也要先关闭，这里步骤就忽略了，安装很简单。\n\n- **卸载老版本 CLion(未安装则不用管，跳过看下面步骤)**\n  注意，安装新版本之前，如果本机安装过老版本的, 需要先彻底卸载，以免两者冲突，导致破解失败。\n  **安装太简单了，步骤就忽略了。**\n\n## 破解\n\n### 破解补丁下载\n\n破解补丁下载地址：https://kohler.lanzouo.com/iS5E40n7ojba\n\n### Windows版破解\n\n下载破解补丁后，解压得到，如下图：\n\n![image](../imgs/1894089-20230211102659035-421863408.png)\n\n将上面图示的补丁的所属文件夹 `/jetbra` 复制电脑某个位置，我是放置到了 桌面目录下（不推荐，自己选个D盘目录或者其他位置），\n点击进入`/jetbra` 补丁目录，再点击进入`/scripts` 文件夹，双击执行 `install-all-user.vbs` 破解脚本：\n\n![image](../imgs/1894089-20230211102807063-1324567688.png)\n\n**注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。**\n\n![image](../imgs/1894089-20230211102825164-1230499662.png)\n\n会提示安装补丁需要等待数秒。点击**【确定】**按钮后，过程大概 10 - 30 秒，如看到弹框提示 Done 时，表示激活破解成功：\n\n![image](../imgs/1894089-20230211102841861-1500251037.png)\n\n### mac版破解\n\n**Mac / Linux** 系统与上面 Windows 系统一样，需将补丁所属文件`/jetbra` 复制到某个路径，且**路径不能包含空格与中文**。\n\n之后，打开终端，进入到`/jetbra/scripts` 文件夹， 执行 `install.sh`脚本, 命令如下：\n\n\n\n```shell\nsudo bash install.sh\n```\n\n看到提示 Done , 表示激活成功。\n\n![image](../imgs/1894089-20230211104108634-1740893276.png)\n\n**Mac / Linux** 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，**Mac / Linux 需重启系统**，以确保环境变量生效。\n\n### linux版破解\n\n和mac版一样，参考mac,这里就不做介绍了。\n\n### 重启 CLion\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n**脚本执行成功后，一定要重启 CLion**!!!\n\n## 填入指定激活码完成激活\n\n打开文件夹里的激活码，粘贴到输入框内，点击 `Activate` 按钮，就激活成功了。\n\n![image](../imgs/1894089-20230211104238842-2069324840.png)\n\n![image](../imgs/1894089-20230211104310444-38131101.png)\n\n激活成功后，就可以开心的 coding 了 ~\n\n![image](../imgs/1894089-20230211104336300-896542684.png)\n\n转：\n\n[CLion 2022.2.4破解教程详细图解mac,windows,linux均适用 - 愚生浅末 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kohler21/p/17111018.html)\n\n参考：\n\n[使用Clion优雅的完全远程自动同步和远程调试c++-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1406250)\n","slug":"Clion202204-破解","published":1,"updated":"2024-05-17T02:15:07.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwa1rz3i0000prw00euv7b5w","content":"<h2 id=\"下载与安装\"><a href=\"#下载与安装\" class=\"headerlink\" title=\"下载与安装\"></a>下载与安装</h2><p>此教程为CLion 2022.2.4 破解教程，且此教程以及下面提供的破解补丁适用与2022.2以后的新版本。<br>2022年11月10日亲测有效，mac与windows均测试完美破解</p>\n<h3 id=\"CLion-下载\"><a href=\"#CLion-下载\" class=\"headerlink\" title=\"CLion 下载\"></a>CLion 下载</h3><p>Clion官网下载地址：<a href=\"https://www.jetbrains.com.cn/clion/download/other.html\">https://www.jetbrains.com.cn/clion/download/other.html</a></p>\n<p><img src=\"/../imgs/1894089-20230211102247487-1038132289.png\" alt=\"image\"></p>\n<p>找到2022.2.4的，然后根据自己的电脑系统选择。Windows的下载Windows，Mac的下载Mac的。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>直接上面的地址下载安装即可，安装完后记得不要打开，打开后也要先关闭，这里步骤就忽略了，安装很简单。</p>\n<ul>\n<li><strong>卸载老版本 CLion(未安装则不用管，跳过看下面步骤)</strong><br>注意，安装新版本之前，如果本机安装过老版本的, 需要先彻底卸载，以免两者冲突，导致破解失败。<br><strong>安装太简单了，步骤就忽略了。</strong></li>\n</ul>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><h3 id=\"破解补丁下载\"><a href=\"#破解补丁下载\" class=\"headerlink\" title=\"破解补丁下载\"></a>破解补丁下载</h3><p>破解补丁下载地址：<a href=\"https://kohler.lanzouo.com/iS5E40n7ojba\">https://kohler.lanzouo.com/iS5E40n7ojba</a></p>\n<h3 id=\"Windows版破解\"><a href=\"#Windows版破解\" class=\"headerlink\" title=\"Windows版破解\"></a>Windows版破解</h3><p>下载破解补丁后，解压得到，如下图：</p>\n<p><img src=\"/../imgs/1894089-20230211102659035-421863408.png\" alt=\"image\"></p>\n<p>将上面图示的补丁的所属文件夹 <code>/jetbra</code> 复制电脑某个位置，我是放置到了 桌面目录下（不推荐，自己选个D盘目录或者其他位置），<br>点击进入<code>/jetbra</code> 补丁目录，再点击进入<code>/scripts</code> 文件夹，双击执行 <code>install-all-user.vbs</code> 破解脚本：</p>\n<p><img src=\"/../imgs/1894089-20230211102807063-1324567688.png\" alt=\"image\"></p>\n<p><strong>注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。</strong></p>\n<p><img src=\"/../imgs/1894089-20230211102825164-1230499662.png\" alt=\"image\"></p>\n<p>会提示安装补丁需要等待数秒。点击<strong>【确定】</strong>按钮后，过程大概 10 - 30 秒，如看到弹框提示 Done 时，表示激活破解成功：</p>\n<p><img src=\"/../imgs/1894089-20230211102841861-1500251037.png\" alt=\"image\"></p>\n<h3 id=\"mac版破解\"><a href=\"#mac版破解\" class=\"headerlink\" title=\"mac版破解\"></a>mac版破解</h3><p><strong>Mac &#x2F; Linux</strong> 系统与上面 Windows 系统一样，需将补丁所属文件<code>/jetbra</code> 复制到某个路径，且<strong>路径不能包含空格与中文</strong>。</p>\n<p>之后，打开终端，进入到<code>/jetbra/scripts</code> 文件夹， 执行 <code>install.sh</code>脚本, 命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo bash install.sh</span><br></pre></td></tr></table></figure>\n\n<p>看到提示 Done , 表示激活成功。</p>\n<p><img src=\"/../imgs/1894089-20230211104108634-1740893276.png\" alt=\"image\"></p>\n<p><strong>Mac &#x2F; Linux</strong> 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，<strong>Mac &#x2F; Linux 需重启系统</strong>，以确保环境变量生效。</p>\n<h3 id=\"linux版破解\"><a href=\"#linux版破解\" class=\"headerlink\" title=\"linux版破解\"></a>linux版破解</h3><p>和mac版一样，参考mac,这里就不做介绍了。</p>\n<h3 id=\"重启-CLion\"><a href=\"#重启-CLion\" class=\"headerlink\" title=\"重启 CLion\"></a>重启 CLion</h3><p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<h2 id=\"填入指定激活码完成激活\"><a href=\"#填入指定激活码完成激活\" class=\"headerlink\" title=\"填入指定激活码完成激活\"></a>填入指定激活码完成激活</h2><p>打开文件夹里的激活码，粘贴到输入框内，点击 <code>Activate</code> 按钮，就激活成功了。</p>\n<p><img src=\"/../imgs/1894089-20230211104238842-2069324840.png\" alt=\"image\"></p>\n<p><img src=\"/../imgs/1894089-20230211104310444-38131101.png\" alt=\"image\"></p>\n<p>激活成功后，就可以开心的 coding 了 ~</p>\n<p><img src=\"/../imgs/1894089-20230211104336300-896542684.png\" alt=\"image\"></p>\n<p>转：</p>\n<p><a href=\"https://www.cnblogs.com/kohler21/p/17111018.html\">CLion 2022.2.4破解教程详细图解mac,windows,linux均适用 - 愚生浅末 - 博客园 (cnblogs.com)</a></p>\n<p>参考：</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1406250\">使用Clion优雅的完全远程自动同步和远程调试c++-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"下载与安装\"><a href=\"#下载与安装\" class=\"headerlink\" title=\"下载与安装\"></a>下载与安装</h2><p>此教程为CLion 2022.2.4 破解教程，且此教程以及下面提供的破解补丁适用与2022.2以后的新版本。<br>2022年11月10日亲测有效，mac与windows均测试完美破解</p>\n<h3 id=\"CLion-下载\"><a href=\"#CLion-下载\" class=\"headerlink\" title=\"CLion 下载\"></a>CLion 下载</h3><p>Clion官网下载地址：<a href=\"https://www.jetbrains.com.cn/clion/download/other.html\">https://www.jetbrains.com.cn/clion/download/other.html</a></p>\n<p><img src=\"/../imgs/1894089-20230211102247487-1038132289.png\" alt=\"image\"></p>\n<p>找到2022.2.4的，然后根据自己的电脑系统选择。Windows的下载Windows，Mac的下载Mac的。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>直接上面的地址下载安装即可，安装完后记得不要打开，打开后也要先关闭，这里步骤就忽略了，安装很简单。</p>\n<ul>\n<li><strong>卸载老版本 CLion(未安装则不用管，跳过看下面步骤)</strong><br>注意，安装新版本之前，如果本机安装过老版本的, 需要先彻底卸载，以免两者冲突，导致破解失败。<br><strong>安装太简单了，步骤就忽略了。</strong></li>\n</ul>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><h3 id=\"破解补丁下载\"><a href=\"#破解补丁下载\" class=\"headerlink\" title=\"破解补丁下载\"></a>破解补丁下载</h3><p>破解补丁下载地址：<a href=\"https://kohler.lanzouo.com/iS5E40n7ojba\">https://kohler.lanzouo.com/iS5E40n7ojba</a></p>\n<h3 id=\"Windows版破解\"><a href=\"#Windows版破解\" class=\"headerlink\" title=\"Windows版破解\"></a>Windows版破解</h3><p>下载破解补丁后，解压得到，如下图：</p>\n<p><img src=\"/../imgs/1894089-20230211102659035-421863408.png\" alt=\"image\"></p>\n<p>将上面图示的补丁的所属文件夹 <code>/jetbra</code> 复制电脑某个位置，我是放置到了 桌面目录下（不推荐，自己选个D盘目录或者其他位置），<br>点击进入<code>/jetbra</code> 补丁目录，再点击进入<code>/scripts</code> 文件夹，双击执行 <code>install-all-user.vbs</code> 破解脚本：</p>\n<p><img src=\"/../imgs/1894089-20230211102807063-1324567688.png\" alt=\"image\"></p>\n<p><strong>注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。</strong></p>\n<p><img src=\"/../imgs/1894089-20230211102825164-1230499662.png\" alt=\"image\"></p>\n<p>会提示安装补丁需要等待数秒。点击<strong>【确定】</strong>按钮后，过程大概 10 - 30 秒，如看到弹框提示 Done 时，表示激活破解成功：</p>\n<p><img src=\"/../imgs/1894089-20230211102841861-1500251037.png\" alt=\"image\"></p>\n<h3 id=\"mac版破解\"><a href=\"#mac版破解\" class=\"headerlink\" title=\"mac版破解\"></a>mac版破解</h3><p><strong>Mac &#x2F; Linux</strong> 系统与上面 Windows 系统一样，需将补丁所属文件<code>/jetbra</code> 复制到某个路径，且<strong>路径不能包含空格与中文</strong>。</p>\n<p>之后，打开终端，进入到<code>/jetbra/scripts</code> 文件夹， 执行 <code>install.sh</code>脚本, 命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo bash install.sh</span><br></pre></td></tr></table></figure>\n\n<p>看到提示 Done , 表示激活成功。</p>\n<p><img src=\"/../imgs/1894089-20230211104108634-1740893276.png\" alt=\"image\"></p>\n<p><strong>Mac &#x2F; Linux</strong> 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，<strong>Mac &#x2F; Linux 需重启系统</strong>，以确保环境变量生效。</p>\n<h3 id=\"linux版破解\"><a href=\"#linux版破解\" class=\"headerlink\" title=\"linux版破解\"></a>linux版破解</h3><p>和mac版一样，参考mac,这里就不做介绍了。</p>\n<h3 id=\"重启-CLion\"><a href=\"#重启-CLion\" class=\"headerlink\" title=\"重启 CLion\"></a>重启 CLion</h3><p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p>\n<h2 id=\"填入指定激活码完成激活\"><a href=\"#填入指定激活码完成激活\" class=\"headerlink\" title=\"填入指定激活码完成激活\"></a>填入指定激活码完成激活</h2><p>打开文件夹里的激活码，粘贴到输入框内，点击 <code>Activate</code> 按钮，就激活成功了。</p>\n<p><img src=\"/../imgs/1894089-20230211104238842-2069324840.png\" alt=\"image\"></p>\n<p><img src=\"/../imgs/1894089-20230211104310444-38131101.png\" alt=\"image\"></p>\n<p>激活成功后，就可以开心的 coding 了 ~</p>\n<p><img src=\"/../imgs/1894089-20230211104336300-896542684.png\" alt=\"image\"></p>\n<p>转：</p>\n<p><a href=\"https://www.cnblogs.com/kohler21/p/17111018.html\">CLion 2022.2.4破解教程详细图解mac,windows,linux均适用 - 愚生浅末 - 博客园 (cnblogs.com)</a></p>\n<p>参考：</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1406250\">使用Clion优雅的完全远程自动同步和远程调试c++-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n"},{"title":"ARMv8架构-内存虚拟化","date":"2024-05-17T06:45:28.000Z","_content":"\nARM64为支持内存虚拟化，可以将地址类型分为如下三种：\n\n- **VA（虚拟地址）**\n\n   最大宽度为48bit，VA地址空间可分为底部VA和顶部VA两个子区域，每个VM子区域最大支持256T\n   底部VA：0x0000_0000_0000_0000 =>0x0000_FFFF_FFFF_FFFF\n   顶部VA：0xFFFF_0000_0000_0000 =>0xFFFF_FFFF_FFFF_FFFF\n\n- **IPA（中间物理地址）**\n\n   如果不支持Stage 2转换，那么IPA==PA。如果支持Stage 2，IPA作为Stage 1的OA(Output Adress)，IPA作为Stage 2的IA(Input Adress)。它最大支持48bit。\n\n- **PA（物理地址）**\n\n   物理内存单元映射中地址，可以看做是PE到内存系统的输出地址(OA)，其最大支持48bit。\n\n![图2 ARM64内存虚拟化](..\\imgs\\image2019-5-10_14-22-29.png)\n\n 上图是ARM64内存虚拟化的框图，虚拟机通过TTBRn_EL1完成Stage 1的地址转换，将虚拟机使用的VA转换成IPA。然后再通过VTTBR_EL2完成Stage 2的地址转换，将IPA转换成PA。\n\n![ 图2 Stage 1地址转换](../imgs/image2019-5-10_14-24-0.png)\n\n上图是Stage 1（一阶地址转换图）图解，其转换过程如下：\n\n| TTBR 寄存器提供Level 0查找的基地址，通过此基地址和IA[n:39] => 查找到Level 1基地址 |\n| ------------------------------------------------------------ |\n| Level 1基地址结合IA[38：30]=> 查找到Level2 的基地址          |\n| Level 2基地址结合IA[29：21]=> 查找到Level3 的基地址          |\n| Level 3基地址结合IA[20：12]=> 查找物理页框所在地址OA         |\n| 最后得到需要的物理地址PA[47：0] <= OA[47:12] + IA[11：0]     |\n\n![ 图3 Stage 2地址转换](../imgs/image2019-5-10_14-24-58.png)\n\n 上图是Stage 2（二阶地址转换图）图解，，其转换过程如下：\n\n| Stage 2有级联table的概念，可以减少level的级数                |\n| ------------------------------------------------------------ |\n| 所谓级联就是假如有IA[40:0]，而Level1解析地址段为IA[38:30]，超过了2个bit，而2^40 = 2^2*2^38，所以相当于要2^2个这样的translation table来实现级联解析。ARMv8规定，Stage 2最多支持4-bit级联，也就是最大级联2^4 == 16个translation table级联解析.以达到减少查找level的目的. |\n| VTTBR_EL2寄存器提供初始Level查找基地址，Stage 2只为EL2服务   |\n| 同Stage 1，Level 1支持1GB的内存block，Level 2支持2MB的内存block |\n","source":"_posts/ARMv8架构-内存虚拟化.md","raw":"---\ntitle: ARMv8架构-内存虚拟化\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-05-17 14:45:28\n---\n\nARM64为支持内存虚拟化，可以将地址类型分为如下三种：\n\n- **VA（虚拟地址）**\n\n   最大宽度为48bit，VA地址空间可分为底部VA和顶部VA两个子区域，每个VM子区域最大支持256T\n   底部VA：0x0000_0000_0000_0000 =>0x0000_FFFF_FFFF_FFFF\n   顶部VA：0xFFFF_0000_0000_0000 =>0xFFFF_FFFF_FFFF_FFFF\n\n- **IPA（中间物理地址）**\n\n   如果不支持Stage 2转换，那么IPA==PA。如果支持Stage 2，IPA作为Stage 1的OA(Output Adress)，IPA作为Stage 2的IA(Input Adress)。它最大支持48bit。\n\n- **PA（物理地址）**\n\n   物理内存单元映射中地址，可以看做是PE到内存系统的输出地址(OA)，其最大支持48bit。\n\n![图2 ARM64内存虚拟化](..\\imgs\\image2019-5-10_14-22-29.png)\n\n 上图是ARM64内存虚拟化的框图，虚拟机通过TTBRn_EL1完成Stage 1的地址转换，将虚拟机使用的VA转换成IPA。然后再通过VTTBR_EL2完成Stage 2的地址转换，将IPA转换成PA。\n\n![ 图2 Stage 1地址转换](../imgs/image2019-5-10_14-24-0.png)\n\n上图是Stage 1（一阶地址转换图）图解，其转换过程如下：\n\n| TTBR 寄存器提供Level 0查找的基地址，通过此基地址和IA[n:39] => 查找到Level 1基地址 |\n| ------------------------------------------------------------ |\n| Level 1基地址结合IA[38：30]=> 查找到Level2 的基地址          |\n| Level 2基地址结合IA[29：21]=> 查找到Level3 的基地址          |\n| Level 3基地址结合IA[20：12]=> 查找物理页框所在地址OA         |\n| 最后得到需要的物理地址PA[47：0] <= OA[47:12] + IA[11：0]     |\n\n![ 图3 Stage 2地址转换](../imgs/image2019-5-10_14-24-58.png)\n\n 上图是Stage 2（二阶地址转换图）图解，，其转换过程如下：\n\n| Stage 2有级联table的概念，可以减少level的级数                |\n| ------------------------------------------------------------ |\n| 所谓级联就是假如有IA[40:0]，而Level1解析地址段为IA[38:30]，超过了2个bit，而2^40 = 2^2*2^38，所以相当于要2^2个这样的translation table来实现级联解析。ARMv8规定，Stage 2最多支持4-bit级联，也就是最大级联2^4 == 16个translation table级联解析.以达到减少查找level的目的. |\n| VTTBR_EL2寄存器提供初始Level查找基地址，Stage 2只为EL2服务   |\n| 同Stage 1，Level 1支持1GB的内存block，Level 2支持2MB的内存block |\n","slug":"ARMv8架构-内存虚拟化","published":1,"updated":"2024-05-17T06:58:23.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwabwixx0001ygw07nwzhs9w","content":"<p>ARM64为支持内存虚拟化，可以将地址类型分为如下三种：</p>\n<ul>\n<li><p><strong>VA（虚拟地址）</strong></p>\n<p> 最大宽度为48bit，VA地址空间可分为底部VA和顶部VA两个子区域，每个VM子区域最大支持256T<br> 底部VA：0x0000_0000_0000_0000 &#x3D;&gt;0x0000_FFFF_FFFF_FFFF<br> 顶部VA：0xFFFF_0000_0000_0000 &#x3D;&gt;0xFFFF_FFFF_FFFF_FFFF</p>\n</li>\n<li><p><strong>IPA（中间物理地址）</strong></p>\n<p> 如果不支持Stage 2转换，那么IPA&#x3D;&#x3D;PA。如果支持Stage 2，IPA作为Stage 1的OA(Output Adress)，IPA作为Stage 2的IA(Input Adress)。它最大支持48bit。</p>\n</li>\n<li><p><strong>PA（物理地址）</strong></p>\n<p> 物理内存单元映射中地址，可以看做是PE到内存系统的输出地址(OA)，其最大支持48bit。</p>\n</li>\n</ul>\n<p><img src=\"/..%5Cimgs%5Cimage2019-5-10_14-22-29.png\" alt=\"图2 ARM64内存虚拟化\"></p>\n<p> 上图是ARM64内存虚拟化的框图，虚拟机通过TTBRn_EL1完成Stage 1的地址转换，将虚拟机使用的VA转换成IPA。然后再通过VTTBR_EL2完成Stage 2的地址转换，将IPA转换成PA。</p>\n<p><img src=\"/../imgs/image2019-5-10_14-24-0.png\" alt=\" 图2 Stage 1地址转换\"></p>\n<p>上图是Stage 1（一阶地址转换图）图解，其转换过程如下：</p>\n<table>\n<thead>\n<tr>\n<th>TTBR 寄存器提供Level 0查找的基地址，通过此基地址和IA[n:39] &#x3D;&gt; 查找到Level 1基地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Level 1基地址结合IA[38：30]&#x3D;&gt; 查找到Level2 的基地址</td>\n</tr>\n<tr>\n<td>Level 2基地址结合IA[29：21]&#x3D;&gt; 查找到Level3 的基地址</td>\n</tr>\n<tr>\n<td>Level 3基地址结合IA[20：12]&#x3D;&gt; 查找物理页框所在地址OA</td>\n</tr>\n<tr>\n<td>最后得到需要的物理地址PA[47：0] &lt;&#x3D; OA[47:12] + IA[11：0]</td>\n</tr>\n</tbody></table>\n<p><img src=\"/../imgs/image2019-5-10_14-24-58.png\" alt=\" 图3 Stage 2地址转换\"></p>\n<p> 上图是Stage 2（二阶地址转换图）图解，，其转换过程如下：</p>\n<table>\n<thead>\n<tr>\n<th>Stage 2有级联table的概念，可以减少level的级数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>所谓级联就是假如有IA[40:0]，而Level1解析地址段为IA[38:30]，超过了2个bit，而2^40 &#x3D; 2^2*2^38，所以相当于要2^2个这样的translation table来实现级联解析。ARMv8规定，Stage 2最多支持4-bit级联，也就是最大级联2^4 &#x3D;&#x3D; 16个translation table级联解析.以达到减少查找level的目的.</td>\n</tr>\n<tr>\n<td>VTTBR_EL2寄存器提供初始Level查找基地址，Stage 2只为EL2服务</td>\n</tr>\n<tr>\n<td>同Stage 1，Level 1支持1GB的内存block，Level 2支持2MB的内存block</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>ARM64为支持内存虚拟化，可以将地址类型分为如下三种：</p>\n<ul>\n<li><p><strong>VA（虚拟地址）</strong></p>\n<p> 最大宽度为48bit，VA地址空间可分为底部VA和顶部VA两个子区域，每个VM子区域最大支持256T<br> 底部VA：0x0000_0000_0000_0000 &#x3D;&gt;0x0000_FFFF_FFFF_FFFF<br> 顶部VA：0xFFFF_0000_0000_0000 &#x3D;&gt;0xFFFF_FFFF_FFFF_FFFF</p>\n</li>\n<li><p><strong>IPA（中间物理地址）</strong></p>\n<p> 如果不支持Stage 2转换，那么IPA&#x3D;&#x3D;PA。如果支持Stage 2，IPA作为Stage 1的OA(Output Adress)，IPA作为Stage 2的IA(Input Adress)。它最大支持48bit。</p>\n</li>\n<li><p><strong>PA（物理地址）</strong></p>\n<p> 物理内存单元映射中地址，可以看做是PE到内存系统的输出地址(OA)，其最大支持48bit。</p>\n</li>\n</ul>\n<p><img src=\"/..%5Cimgs%5Cimage2019-5-10_14-22-29.png\" alt=\"图2 ARM64内存虚拟化\"></p>\n<p> 上图是ARM64内存虚拟化的框图，虚拟机通过TTBRn_EL1完成Stage 1的地址转换，将虚拟机使用的VA转换成IPA。然后再通过VTTBR_EL2完成Stage 2的地址转换，将IPA转换成PA。</p>\n<p><img src=\"/../imgs/image2019-5-10_14-24-0.png\" alt=\" 图2 Stage 1地址转换\"></p>\n<p>上图是Stage 1（一阶地址转换图）图解，其转换过程如下：</p>\n<table>\n<thead>\n<tr>\n<th>TTBR 寄存器提供Level 0查找的基地址，通过此基地址和IA[n:39] &#x3D;&gt; 查找到Level 1基地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Level 1基地址结合IA[38：30]&#x3D;&gt; 查找到Level2 的基地址</td>\n</tr>\n<tr>\n<td>Level 2基地址结合IA[29：21]&#x3D;&gt; 查找到Level3 的基地址</td>\n</tr>\n<tr>\n<td>Level 3基地址结合IA[20：12]&#x3D;&gt; 查找物理页框所在地址OA</td>\n</tr>\n<tr>\n<td>最后得到需要的物理地址PA[47：0] &lt;&#x3D; OA[47:12] + IA[11：0]</td>\n</tr>\n</tbody></table>\n<p><img src=\"/../imgs/image2019-5-10_14-24-58.png\" alt=\" 图3 Stage 2地址转换\"></p>\n<p> 上图是Stage 2（二阶地址转换图）图解，，其转换过程如下：</p>\n<table>\n<thead>\n<tr>\n<th>Stage 2有级联table的概念，可以减少level的级数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>所谓级联就是假如有IA[40:0]，而Level1解析地址段为IA[38:30]，超过了2个bit，而2^40 &#x3D; 2^2*2^38，所以相当于要2^2个这样的translation table来实现级联解析。ARMv8规定，Stage 2最多支持4-bit级联，也就是最大级联2^4 &#x3D;&#x3D; 16个translation table级联解析.以达到减少查找level的目的.</td>\n</tr>\n<tr>\n<td>VTTBR_EL2寄存器提供初始Level查找基地址，Stage 2只为EL2服务</td>\n</tr>\n<tr>\n<td>同Stage 1，Level 1支持1GB的内存block，Level 2支持2MB的内存block</td>\n</tr>\n</tbody></table>\n"},{"title":"vscode-安装-卸载","date":"2024-05-17T07:17:18.000Z","_content":"\n\n\n\n\n\n\n1.安装vscode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 一、安装vscode\n\n1.安装vscode\n\n下载链接：https://code.visualstudio.com/Download#\n\n2.安装VScode插件\n\nhttps://marketplace.visualstudio.com\n\n[Search results - remote | Visual Studio Code , Visual Studio Marketplace](https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All categories&sortBy=Relevance)\n\n安装vscode时选择默认路径，安装完成后打开，安装扩展：\n1、 C/C++（就是有些教程里的cpptools）\n2、 C/C++ Clang Command Adapter：提供静态检测（Lint），很重要\n3、 Code Runner：右键即可编译运行单文件，很方便\n4、 Bracket Pair Colorizer：彩虹花括号\n5、 Include Autocomplete：提供头文件名字的补全\n6、 C/C++ Snippets：Snippets 即重用代码块，\n7、 One Dark Pro：大概是VS Code安装量最高的主题\n8、 python\n9、Clang-Format\n10、Chinese （Simplified）Language Pack for Visual Studio Code：汉化包\n\n# 二、卸载\n\n1、打开控制面板的程序，卸载安装的vscode\n\n或者\n\n找到安装目录点击unins000\n\n![image-20240517154457324](../imgs/image-20240517154457324-17159319055301.png)\n\n2.删除相关配置文件\n\n```\nC: \\ Users \\ .vscode\nC: \\ Users \\ AppData \\ Roaming \\ Code \n```\n\n或者\n\nwin+r输入以下内容\n\n```c\n%appdata%\t\t#删除 Code目录\n%userprofile%\t#删除 .vscode\n```\n\n\n\n[彻底卸载VScode并重置本地配置数据-CSDN博客](https://blog.csdn.net/2301_80868127/article/details/136386915)\n\n[vsCode离线安装remote-ssh插件搭建远程开发环境 (qq.com)](https://mp.weixin.qq.com/s/n7zyDFOeHd9K5oSKz7Zg9Q)\n","source":"_posts/vscode-安装-卸载.md","raw":"---\ntitle: vscode-安装-卸载\ncategories:\n  - test\ntags:\n  - vscode\ndate: 2024-05-17 15:17:18\n---\n\n\n\n\n\n\n\n1.安装vscode\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 一、安装vscode\n\n1.安装vscode\n\n下载链接：https://code.visualstudio.com/Download#\n\n2.安装VScode插件\n\nhttps://marketplace.visualstudio.com\n\n[Search results - remote | Visual Studio Code , Visual Studio Marketplace](https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All categories&sortBy=Relevance)\n\n安装vscode时选择默认路径，安装完成后打开，安装扩展：\n1、 C/C++（就是有些教程里的cpptools）\n2、 C/C++ Clang Command Adapter：提供静态检测（Lint），很重要\n3、 Code Runner：右键即可编译运行单文件，很方便\n4、 Bracket Pair Colorizer：彩虹花括号\n5、 Include Autocomplete：提供头文件名字的补全\n6、 C/C++ Snippets：Snippets 即重用代码块，\n7、 One Dark Pro：大概是VS Code安装量最高的主题\n8、 python\n9、Clang-Format\n10、Chinese （Simplified）Language Pack for Visual Studio Code：汉化包\n\n# 二、卸载\n\n1、打开控制面板的程序，卸载安装的vscode\n\n或者\n\n找到安装目录点击unins000\n\n![image-20240517154457324](../imgs/image-20240517154457324-17159319055301.png)\n\n2.删除相关配置文件\n\n```\nC: \\ Users \\ .vscode\nC: \\ Users \\ AppData \\ Roaming \\ Code \n```\n\n或者\n\nwin+r输入以下内容\n\n```c\n%appdata%\t\t#删除 Code目录\n%userprofile%\t#删除 .vscode\n```\n\n\n\n[彻底卸载VScode并重置本地配置数据-CSDN博客](https://blog.csdn.net/2301_80868127/article/details/136386915)\n\n[vsCode离线安装remote-ssh插件搭建远程开发环境 (qq.com)](https://mp.weixin.qq.com/s/n7zyDFOeHd9K5oSKz7Zg9Q)\n","slug":"vscode-安装-卸载","published":1,"updated":"2024-05-17T07:48:35.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwadqd7500017pw0hxu7428y","content":"<p>1.安装vscode</p>\n<h1 id=\"一、安装vscode\"><a href=\"#一、安装vscode\" class=\"headerlink\" title=\"一、安装vscode\"></a>一、安装vscode</h1><p>1.安装vscode</p>\n<p>下载链接：<a href=\"https://code.visualstudio.com/Download#\">https://code.visualstudio.com/Download#</a></p>\n<p>2.安装VScode插件</p>\n<p><a href=\"https://marketplace.visualstudio.com/\">https://marketplace.visualstudio.com</a></p>\n<p>[Search results - remote | Visual Studio Code , Visual Studio Marketplace](<a href=\"https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All\">https://marketplace.visualstudio.com/search?term=remote&amp;target=VSCode&amp;category=All</a> categories&amp;sortBy&#x3D;Relevance)</p>\n<p>安装vscode时选择默认路径，安装完成后打开，安装扩展：<br>1、 C&#x2F;C++（就是有些教程里的cpptools）<br>2、 C&#x2F;C++ Clang Command Adapter：提供静态检测（Lint），很重要<br>3、 Code Runner：右键即可编译运行单文件，很方便<br>4、 Bracket Pair Colorizer：彩虹花括号<br>5、 Include Autocomplete：提供头文件名字的补全<br>6、 C&#x2F;C++ Snippets：Snippets 即重用代码块，<br>7、 One Dark Pro：大概是VS Code安装量最高的主题<br>8、 python<br>9、Clang-Format<br>10、Chinese （Simplified）Language Pack for Visual Studio Code：汉化包</p>\n<h1 id=\"二、卸载\"><a href=\"#二、卸载\" class=\"headerlink\" title=\"二、卸载\"></a>二、卸载</h1><p>1、打开控制面板的程序，卸载安装的vscode</p>\n<p>或者</p>\n<p>找到安装目录点击unins000</p>\n<p><img src=\"/../imgs/image-20240517154457324-17159319055301.png\" alt=\"image-20240517154457324\"></p>\n<p>2.删除相关配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C: \\ Users \\ .vscode</span><br><span class=\"line\">C: \\ Users \\ AppData \\ Roaming \\ Code </span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<p>win+r输入以下内容</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%appdata%\t\t#删除 Code目录</span><br><span class=\"line\">%userprofile%\t#删除 .vscode</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://blog.csdn.net/2301_80868127/article/details/136386915\">彻底卸载VScode并重置本地配置数据-CSDN博客</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/n7zyDFOeHd9K5oSKz7Zg9Q\">vsCode离线安装remote-ssh插件搭建远程开发环境 (qq.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.安装vscode</p>\n<h1 id=\"一、安装vscode\"><a href=\"#一、安装vscode\" class=\"headerlink\" title=\"一、安装vscode\"></a>一、安装vscode</h1><p>1.安装vscode</p>\n<p>下载链接：<a href=\"https://code.visualstudio.com/Download#\">https://code.visualstudio.com/Download#</a></p>\n<p>2.安装VScode插件</p>\n<p><a href=\"https://marketplace.visualstudio.com/\">https://marketplace.visualstudio.com</a></p>\n<p>[Search results - remote | Visual Studio Code , Visual Studio Marketplace](<a href=\"https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All\">https://marketplace.visualstudio.com/search?term=remote&amp;target=VSCode&amp;category=All</a> categories&amp;sortBy&#x3D;Relevance)</p>\n<p>安装vscode时选择默认路径，安装完成后打开，安装扩展：<br>1、 C&#x2F;C++（就是有些教程里的cpptools）<br>2、 C&#x2F;C++ Clang Command Adapter：提供静态检测（Lint），很重要<br>3、 Code Runner：右键即可编译运行单文件，很方便<br>4、 Bracket Pair Colorizer：彩虹花括号<br>5、 Include Autocomplete：提供头文件名字的补全<br>6、 C&#x2F;C++ Snippets：Snippets 即重用代码块，<br>7、 One Dark Pro：大概是VS Code安装量最高的主题<br>8、 python<br>9、Clang-Format<br>10、Chinese （Simplified）Language Pack for Visual Studio Code：汉化包</p>\n<h1 id=\"二、卸载\"><a href=\"#二、卸载\" class=\"headerlink\" title=\"二、卸载\"></a>二、卸载</h1><p>1、打开控制面板的程序，卸载安装的vscode</p>\n<p>或者</p>\n<p>找到安装目录点击unins000</p>\n<p><img src=\"/../imgs/image-20240517154457324-17159319055301.png\" alt=\"image-20240517154457324\"></p>\n<p>2.删除相关配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C: \\ Users \\ .vscode</span><br><span class=\"line\">C: \\ Users \\ AppData \\ Roaming \\ Code </span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<p>win+r输入以下内容</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%appdata%\t\t#删除 Code目录</span><br><span class=\"line\">%userprofile%\t#删除 .vscode</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://blog.csdn.net/2301_80868127/article/details/136386915\">彻底卸载VScode并重置本地配置数据-CSDN博客</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/n7zyDFOeHd9K5oSKz7Zg9Q\">vsCode离线安装remote-ssh插件搭建远程开发环境 (qq.com)</a></p>\n"},{"title":"vscode-远程连接失败","date":"2024-05-17T09:14:04.000Z","_content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n可能在服务端/root/.vscode-server/bin这个目录存在一个与你本地vscode版本不一致的文件夹，删除这个对应的文件夹重新连接就行了\n\n# 先删除本地和服务端的know_hosts \n\n![image-20240517171503577](../imgs/image-20240517171503577.png)\n\n\n\n[vscode远程连接提示过程试图写入的管道不存在_过程试图写入的管道不存在vscode-CSDN博客](https://blog.csdn.net/baidu_39131915/article/details/116302847)\n","source":"_posts/vscode-远程连接失败.md","raw":"---\ntitle: vscode-远程连接失败\ncategories:\n  - test\ntags:\n  - vscode\ndate: 2024-05-17 17:14:4\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n可能在服务端/root/.vscode-server/bin这个目录存在一个与你本地vscode版本不一致的文件夹，删除这个对应的文件夹重新连接就行了\n\n# 先删除本地和服务端的know_hosts \n\n![image-20240517171503577](../imgs/image-20240517171503577.png)\n\n\n\n[vscode远程连接提示过程试图写入的管道不存在_过程试图写入的管道不存在vscode-CSDN博客](https://blog.csdn.net/baidu_39131915/article/details/116302847)\n","slug":"vscode-远程连接失败","published":1,"updated":"2024-05-17T09:17:07.395Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwagumwd0001npw0h9fu9ufz","content":"<p>可能在服务端&#x2F;root&#x2F;.vscode-server&#x2F;bin这个目录存在一个与你本地vscode版本不一致的文件夹，删除这个对应的文件夹重新连接就行了</p>\n<h1 id=\"先删除本地和服务端的know-hosts\"><a href=\"#先删除本地和服务端的know-hosts\" class=\"headerlink\" title=\"先删除本地和服务端的know_hosts\"></a>先删除本地和服务端的know_hosts</h1><p><img src=\"/../imgs/image-20240517171503577.png\" alt=\"image-20240517171503577\"></p>\n<p><a href=\"https://blog.csdn.net/baidu_39131915/article/details/116302847\">vscode远程连接提示过程试图写入的管道不存在_过程试图写入的管道不存在vscode-CSDN博客</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>可能在服务端&#x2F;root&#x2F;.vscode-server&#x2F;bin这个目录存在一个与你本地vscode版本不一致的文件夹，删除这个对应的文件夹重新连接就行了</p>\n<h1 id=\"先删除本地和服务端的know-hosts\"><a href=\"#先删除本地和服务端的know-hosts\" class=\"headerlink\" title=\"先删除本地和服务端的know_hosts\"></a>先删除本地和服务端的know_hosts</h1><p><img src=\"/../imgs/image-20240517171503577.png\" alt=\"image-20240517171503577\"></p>\n<p><a href=\"https://blog.csdn.net/baidu_39131915/article/details/116302847\">vscode远程连接提示过程试图写入的管道不存在_过程试图写入的管道不存在vscode-CSDN博客</a></p>\n"},{"title":"Windows下通过ssh挂载远程服务器目录","date":"2024-05-25T03:27:05.000Z","_content":"\n\n\n\n\n### 下载\n\n直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。\n\n- sshfs-win：https://github.com/billziss-gh/sshfs-win/releases\n- winfsp：https://github.com/billziss-gh/winfsp/releases\n- SSHFS-Win Manager：https://github.com/evsar3/sshfs-win-manager/releases (GUI，可选)\n\n### 快速使用\n\n可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。\n\n#### 方式A：使用GUI（推荐）\n\n新建连接\n\n安装好上述3个软件后，打开 GUI 界面如下，点击 `Add Connection`：\n\n![img](../imgs/38433cbf3936910bd982dbe3edad457f.png)\n\nSSHFS-Win Manager GUI 主界面\n\n依次填写每一项内容：\n\n- NAME：给远程服务器取个名字\n- Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：[SSH密钥管理及免密码登陆](https://blog.xieqk.com/posts/3517905979.html)]）\n- Remote：远程目录配置，挂载后将成为本地对应盘符的根目录\n- Local：本地盘符设置（注意不要与现有盘符冲突）\n\n示例如下：\n\n![img](../imgs/10679e86d7d5de085f10f418602d3fc0.png)\n\n添加连接\n\n点击 `Save` 保存。\n\n挂在远程目录\n\n在主界面中点击`连接`按钮，即可将远程目录挂在到本地：\n\n![img](../imgs/b5509514fe3ed5e171527650e89113df.png)\n\n添加新连接后的主界面\n\n此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面`连接`按钮左边的`打开文件夹`按钮即可进入目录。\n\n![img](../imgs/9a41a7910eae90cbc4133263b56065b4.png)\n\n本地挂载成功\n\n长期使用建议在主界面的设置中打开`开机自启`：\n\n打开开机启动\n\n![img](../imgs/8191070c413a2f5053f4fa1fff32375d.png)\n\n\n\n#### 方式B：手动挂载\n\n挂载路径\n\n**1. SSH 使用默认端口（22）**\n\n此时，对应的 ssh 登陆命令为 `ssh username@remote_ip`，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：\n\n```\n# 根目录\n\\\\sshfs.r\\username@remote_ip\\\n\n# home 目录\n\\\\sshfs\\username@remote_ip\\\n# 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\\n```\n\n例如：`\\\\sshfs.r\\xieqk@10.168.9.87\\`，注意路径里面的分隔符为 windows 使用的反斜杠 `\\`。\n\n**2. SSH 使用其它端口（外网端口转发连接内网服务器）**\n\n此时，ssh 登陆命令为 `ssh -p port username@remote_ip`，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 `remote_ip` 后加上 `!port` 即可：\n\n```\n# 根目录\n\\\\sshfs.r\\username@remote_ip\\\n\n# home 目录\n\\\\sshfs\\username@remote_ip\\\n# 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\\n```\n\n例如：`\\\\sshfs.r\\xieqk@168.10.9.87!34567\\`。\n\n登陆挂载远程目录\n\n将上述 `sshfs` 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（**注意：**弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 `sshfs` 路径之中，所以此处只需正常输入远程用户对应的密码即可。）\n\n对于常用的远程目录，建议通过 `映射网络驱动器` 长期挂载于本地。\n\n![img](../imgs/a1e47db6d3e144affe47566fed629e9e.png)\n\n映射网络驱动器\n\n在 `映射网络驱动器` 中，可自行分配驱动器盘号，然后在 `文件夹` 处输入上述 `sshfs` 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。\n\n![img](../imgs/675b07d51113aeaf1b18b08b1fda130b.png)\n\n输入 sshfs 路径\n\n之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：\n\n![img](../imgs/84fe4ccf655091b45ffcad9c61def517.png)\n\n本地挂载成功\n\n详细参数（可跳过，需要时再查看）\n\nsshfs-win 具体语法形式如下，其中 `[]` 中的内容为选填项，若为默认值可不填：\n\n```\n\\\\sshfs\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n\\\\sshfs.r\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n\\\\sshfs.k\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n```\n\n\n\n- `REMUSER`: 即 remote user，指 SSH 登陆远程主机时的用户名。\n- `HOST`：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址\n- `PORT`：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).\n- `PATH`：进入的远程服务器路径，可按照如下设置:\n  - 前缀 `sshfs` 对应为 `HOST:~REMUSER/PATH`，即远程服务器上相对于该用户 `home` 目录的相对路径：`/home/remote_user/PATH`。\n  - 前缀 `sshfs.r` 对应为 `HOST:/PATH` 即远程服务器上相对于根(root)目录的路径：`/PATH`。\n  - 前缀 `sshfs.k` 与第一项相同，对应为 `HOST:~REMUSER/PATH`，但它使用 Windows 本地当前用户位于 `%USERPROFILE%/.ssh/id_rsa` 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠[SSH 密钥管理及免密码登陆](https://blog.xieqk.com/posts/3517905979.html)），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可）\n- `LOCUSER` windows本地用户名，可不填。\n\n\n\n\n\n转：\n\nhttps://blog.csdn.net/qq_31811537/article/details/124721621\n","source":"_posts/Windows下通过ssh挂载远程服务器目录.md","raw":"---\ntitle: Windows下通过ssh挂载远程服务器目录\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-05-25 11:27:05\n---\n\n\n\n\n\n### 下载\n\n直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。\n\n- sshfs-win：https://github.com/billziss-gh/sshfs-win/releases\n- winfsp：https://github.com/billziss-gh/winfsp/releases\n- SSHFS-Win Manager：https://github.com/evsar3/sshfs-win-manager/releases (GUI，可选)\n\n### 快速使用\n\n可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。\n\n#### 方式A：使用GUI（推荐）\n\n新建连接\n\n安装好上述3个软件后，打开 GUI 界面如下，点击 `Add Connection`：\n\n![img](../imgs/38433cbf3936910bd982dbe3edad457f.png)\n\nSSHFS-Win Manager GUI 主界面\n\n依次填写每一项内容：\n\n- NAME：给远程服务器取个名字\n- Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：[SSH密钥管理及免密码登陆](https://blog.xieqk.com/posts/3517905979.html)]）\n- Remote：远程目录配置，挂载后将成为本地对应盘符的根目录\n- Local：本地盘符设置（注意不要与现有盘符冲突）\n\n示例如下：\n\n![img](../imgs/10679e86d7d5de085f10f418602d3fc0.png)\n\n添加连接\n\n点击 `Save` 保存。\n\n挂在远程目录\n\n在主界面中点击`连接`按钮，即可将远程目录挂在到本地：\n\n![img](../imgs/b5509514fe3ed5e171527650e89113df.png)\n\n添加新连接后的主界面\n\n此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面`连接`按钮左边的`打开文件夹`按钮即可进入目录。\n\n![img](../imgs/9a41a7910eae90cbc4133263b56065b4.png)\n\n本地挂载成功\n\n长期使用建议在主界面的设置中打开`开机自启`：\n\n打开开机启动\n\n![img](../imgs/8191070c413a2f5053f4fa1fff32375d.png)\n\n\n\n#### 方式B：手动挂载\n\n挂载路径\n\n**1. SSH 使用默认端口（22）**\n\n此时，对应的 ssh 登陆命令为 `ssh username@remote_ip`，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：\n\n```\n# 根目录\n\\\\sshfs.r\\username@remote_ip\\\n\n# home 目录\n\\\\sshfs\\username@remote_ip\\\n# 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\\n```\n\n例如：`\\\\sshfs.r\\xieqk@10.168.9.87\\`，注意路径里面的分隔符为 windows 使用的反斜杠 `\\`。\n\n**2. SSH 使用其它端口（外网端口转发连接内网服务器）**\n\n此时，ssh 登陆命令为 `ssh -p port username@remote_ip`，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 `remote_ip` 后加上 `!port` 即可：\n\n```\n# 根目录\n\\\\sshfs.r\\username@remote_ip\\\n\n# home 目录\n\\\\sshfs\\username@remote_ip\\\n# 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\\n```\n\n例如：`\\\\sshfs.r\\xieqk@168.10.9.87!34567\\`。\n\n登陆挂载远程目录\n\n将上述 `sshfs` 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（**注意：**弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 `sshfs` 路径之中，所以此处只需正常输入远程用户对应的密码即可。）\n\n对于常用的远程目录，建议通过 `映射网络驱动器` 长期挂载于本地。\n\n![img](../imgs/a1e47db6d3e144affe47566fed629e9e.png)\n\n映射网络驱动器\n\n在 `映射网络驱动器` 中，可自行分配驱动器盘号，然后在 `文件夹` 处输入上述 `sshfs` 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。\n\n![img](../imgs/675b07d51113aeaf1b18b08b1fda130b.png)\n\n输入 sshfs 路径\n\n之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：\n\n![img](../imgs/84fe4ccf655091b45ffcad9c61def517.png)\n\n本地挂载成功\n\n详细参数（可跳过，需要时再查看）\n\nsshfs-win 具体语法形式如下，其中 `[]` 中的内容为选填项，若为默认值可不填：\n\n```\n\\\\sshfs\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n\\\\sshfs.r\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n\\\\sshfs.k\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]\n```\n\n\n\n- `REMUSER`: 即 remote user，指 SSH 登陆远程主机时的用户名。\n- `HOST`：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址\n- `PORT`：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).\n- `PATH`：进入的远程服务器路径，可按照如下设置:\n  - 前缀 `sshfs` 对应为 `HOST:~REMUSER/PATH`，即远程服务器上相对于该用户 `home` 目录的相对路径：`/home/remote_user/PATH`。\n  - 前缀 `sshfs.r` 对应为 `HOST:/PATH` 即远程服务器上相对于根(root)目录的路径：`/PATH`。\n  - 前缀 `sshfs.k` 与第一项相同，对应为 `HOST:~REMUSER/PATH`，但它使用 Windows 本地当前用户位于 `%USERPROFILE%/.ssh/id_rsa` 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠[SSH 密钥管理及免密码登陆](https://blog.xieqk.com/posts/3517905979.html)），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可）\n- `LOCUSER` windows本地用户名，可不填。\n\n\n\n\n\n转：\n\nhttps://blog.csdn.net/qq_31811537/article/details/124721621\n","slug":"Windows下通过ssh挂载远程服务器目录","published":1,"updated":"2024-05-25T03:32:29.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwlk2mex0000anw01kfwh17t","content":"<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。</p>\n<ul>\n<li>sshfs-win：<a href=\"https://github.com/billziss-gh/sshfs-win/releases\">https://github.com/billziss-gh/sshfs-win/releases</a></li>\n<li>winfsp：<a href=\"https://github.com/billziss-gh/winfsp/releases\">https://github.com/billziss-gh/winfsp/releases</a></li>\n<li>SSHFS-Win Manager：<a href=\"https://github.com/evsar3/sshfs-win-manager/releases\">https://github.com/evsar3/sshfs-win-manager/releases</a> (GUI，可选)</li>\n</ul>\n<h3 id=\"快速使用\"><a href=\"#快速使用\" class=\"headerlink\" title=\"快速使用\"></a>快速使用</h3><p>可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。</p>\n<h4 id=\"方式A：使用GUI（推荐）\"><a href=\"#方式A：使用GUI（推荐）\" class=\"headerlink\" title=\"方式A：使用GUI（推荐）\"></a>方式A：使用GUI（推荐）</h4><p>新建连接</p>\n<p>安装好上述3个软件后，打开 GUI 界面如下，点击 <code>Add Connection</code>：</p>\n<p><img src=\"/../imgs/38433cbf3936910bd982dbe3edad457f.png\" alt=\"img\"></p>\n<p>SSHFS-Win Manager GUI 主界面</p>\n<p>依次填写每一项内容：</p>\n<ul>\n<li>NAME：给远程服务器取个名字</li>\n<li>Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：<a href=\"https://blog.xieqk.com/posts/3517905979.html\">SSH密钥管理及免密码登陆</a>]）</li>\n<li>Remote：远程目录配置，挂载后将成为本地对应盘符的根目录</li>\n<li>Local：本地盘符设置（注意不要与现有盘符冲突）</li>\n</ul>\n<p>示例如下：</p>\n<p><img src=\"/../imgs/10679e86d7d5de085f10f418602d3fc0.png\" alt=\"img\"></p>\n<p>添加连接</p>\n<p>点击 <code>Save</code> 保存。</p>\n<p>挂在远程目录</p>\n<p>在主界面中点击<code>连接</code>按钮，即可将远程目录挂在到本地：</p>\n<p><img src=\"/../imgs/b5509514fe3ed5e171527650e89113df.png\" alt=\"img\"></p>\n<p>添加新连接后的主界面</p>\n<p>此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面<code>连接</code>按钮左边的<code>打开文件夹</code>按钮即可进入目录。</p>\n<p><img src=\"/../imgs/9a41a7910eae90cbc4133263b56065b4.png\" alt=\"img\"></p>\n<p>本地挂载成功</p>\n<p>长期使用建议在主界面的设置中打开<code>开机自启</code>：</p>\n<p>打开开机启动</p>\n<p><img src=\"/../imgs/8191070c413a2f5053f4fa1fff32375d.png\" alt=\"img\"></p>\n<h4 id=\"方式B：手动挂载\"><a href=\"#方式B：手动挂载\" class=\"headerlink\" title=\"方式B：手动挂载\"></a>方式B：手动挂载</h4><p>挂载路径</p>\n<p><strong>1. SSH 使用默认端口（22）</strong></p>\n<p>此时，对应的 ssh 登陆命令为 <code>ssh username@remote_ip</code>，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 根目录</span><br><span class=\"line\">\\\\sshfs.r\\username@remote_ip\\</span><br><span class=\"line\"></span><br><span class=\"line\"># home 目录</span><br><span class=\"line\">\\\\sshfs\\username@remote_ip\\</span><br><span class=\"line\"># 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\</span><br></pre></td></tr></table></figure>\n\n<p>例如：<code>\\\\sshfs.r\\xieqk@10.168.9.87\\</code>，注意路径里面的分隔符为 windows 使用的反斜杠 <code>\\</code>。</p>\n<p><strong>2. SSH 使用其它端口（外网端口转发连接内网服务器）</strong></p>\n<p>此时，ssh 登陆命令为 <code>ssh -p port username@remote_ip</code>，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 <code>remote_ip</code> 后加上 <code>!port</code> 即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 根目录</span><br><span class=\"line\">\\\\sshfs.r\\username@remote_ip\\</span><br><span class=\"line\"></span><br><span class=\"line\"># home 目录</span><br><span class=\"line\">\\\\sshfs\\username@remote_ip\\</span><br><span class=\"line\"># 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\</span><br></pre></td></tr></table></figure>\n\n<p>例如：<code>\\\\sshfs.r\\xieqk@168.10.9.87!34567\\</code>。</p>\n<p>登陆挂载远程目录</p>\n<p>将上述 <code>sshfs</code> 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（<strong>注意：</strong>弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 <code>sshfs</code> 路径之中，所以此处只需正常输入远程用户对应的密码即可。）</p>\n<p>对于常用的远程目录，建议通过 <code>映射网络驱动器</code> 长期挂载于本地。</p>\n<p><img src=\"/../imgs/a1e47db6d3e144affe47566fed629e9e.png\" alt=\"img\"></p>\n<p>映射网络驱动器</p>\n<p>在 <code>映射网络驱动器</code> 中，可自行分配驱动器盘号，然后在 <code>文件夹</code> 处输入上述 <code>sshfs</code> 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。</p>\n<p><img src=\"/../imgs/675b07d51113aeaf1b18b08b1fda130b.png\" alt=\"img\"></p>\n<p>输入 sshfs 路径</p>\n<p>之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：</p>\n<p><img src=\"/../imgs/84fe4ccf655091b45ffcad9c61def517.png\" alt=\"img\"></p>\n<p>本地挂载成功</p>\n<p>详细参数（可跳过，需要时再查看）</p>\n<p>sshfs-win 具体语法形式如下，其中 <code>[]</code> 中的内容为选填项，若为默认值可不填：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\sshfs\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br><span class=\"line\">\\\\sshfs.r\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br><span class=\"line\">\\\\sshfs.k\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><code>REMUSER</code>: 即 remote user，指 SSH 登陆远程主机时的用户名。</li>\n<li><code>HOST</code>：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址</li>\n<li><code>PORT</code>：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).</li>\n<li><code>PATH</code>：进入的远程服务器路径，可按照如下设置:<ul>\n<li>前缀 <code>sshfs</code> 对应为 <code>HOST:~REMUSER/PATH</code>，即远程服务器上相对于该用户 <code>home</code> 目录的相对路径：<code>/home/remote_user/PATH</code>。</li>\n<li>前缀 <code>sshfs.r</code> 对应为 <code>HOST:/PATH</code> 即远程服务器上相对于根(root)目录的路径：<code>/PATH</code>。</li>\n<li>前缀 <code>sshfs.k</code> 与第一项相同，对应为 <code>HOST:~REMUSER/PATH</code>，但它使用 Windows 本地当前用户位于 <code>%USERPROFILE%/.ssh/id_rsa</code> 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠<a href=\"https://blog.xieqk.com/posts/3517905979.html\">SSH 密钥管理及免密码登陆</a>），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可）</li>\n</ul>\n</li>\n<li><code>LOCUSER</code> windows本地用户名，可不填。</li>\n</ul>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/qq_31811537/article/details/124721621\">https://blog.csdn.net/qq_31811537/article/details/124721621</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。</p>\n<ul>\n<li>sshfs-win：<a href=\"https://github.com/billziss-gh/sshfs-win/releases\">https://github.com/billziss-gh/sshfs-win/releases</a></li>\n<li>winfsp：<a href=\"https://github.com/billziss-gh/winfsp/releases\">https://github.com/billziss-gh/winfsp/releases</a></li>\n<li>SSHFS-Win Manager：<a href=\"https://github.com/evsar3/sshfs-win-manager/releases\">https://github.com/evsar3/sshfs-win-manager/releases</a> (GUI，可选)</li>\n</ul>\n<h3 id=\"快速使用\"><a href=\"#快速使用\" class=\"headerlink\" title=\"快速使用\"></a>快速使用</h3><p>可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。</p>\n<h4 id=\"方式A：使用GUI（推荐）\"><a href=\"#方式A：使用GUI（推荐）\" class=\"headerlink\" title=\"方式A：使用GUI（推荐）\"></a>方式A：使用GUI（推荐）</h4><p>新建连接</p>\n<p>安装好上述3个软件后，打开 GUI 界面如下，点击 <code>Add Connection</code>：</p>\n<p><img src=\"/../imgs/38433cbf3936910bd982dbe3edad457f.png\" alt=\"img\"></p>\n<p>SSHFS-Win Manager GUI 主界面</p>\n<p>依次填写每一项内容：</p>\n<ul>\n<li>NAME：给远程服务器取个名字</li>\n<li>Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：<a href=\"https://blog.xieqk.com/posts/3517905979.html\">SSH密钥管理及免密码登陆</a>]）</li>\n<li>Remote：远程目录配置，挂载后将成为本地对应盘符的根目录</li>\n<li>Local：本地盘符设置（注意不要与现有盘符冲突）</li>\n</ul>\n<p>示例如下：</p>\n<p><img src=\"/../imgs/10679e86d7d5de085f10f418602d3fc0.png\" alt=\"img\"></p>\n<p>添加连接</p>\n<p>点击 <code>Save</code> 保存。</p>\n<p>挂在远程目录</p>\n<p>在主界面中点击<code>连接</code>按钮，即可将远程目录挂在到本地：</p>\n<p><img src=\"/../imgs/b5509514fe3ed5e171527650e89113df.png\" alt=\"img\"></p>\n<p>添加新连接后的主界面</p>\n<p>此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面<code>连接</code>按钮左边的<code>打开文件夹</code>按钮即可进入目录。</p>\n<p><img src=\"/../imgs/9a41a7910eae90cbc4133263b56065b4.png\" alt=\"img\"></p>\n<p>本地挂载成功</p>\n<p>长期使用建议在主界面的设置中打开<code>开机自启</code>：</p>\n<p>打开开机启动</p>\n<p><img src=\"/../imgs/8191070c413a2f5053f4fa1fff32375d.png\" alt=\"img\"></p>\n<h4 id=\"方式B：手动挂载\"><a href=\"#方式B：手动挂载\" class=\"headerlink\" title=\"方式B：手动挂载\"></a>方式B：手动挂载</h4><p>挂载路径</p>\n<p><strong>1. SSH 使用默认端口（22）</strong></p>\n<p>此时，对应的 ssh 登陆命令为 <code>ssh username@remote_ip</code>，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 根目录</span><br><span class=\"line\">\\\\sshfs.r\\username@remote_ip\\</span><br><span class=\"line\"></span><br><span class=\"line\"># home 目录</span><br><span class=\"line\">\\\\sshfs\\username@remote_ip\\</span><br><span class=\"line\"># 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\</span><br></pre></td></tr></table></figure>\n\n<p>例如：<code>\\\\sshfs.r\\xieqk@10.168.9.87\\</code>，注意路径里面的分隔符为 windows 使用的反斜杠 <code>\\</code>。</p>\n<p><strong>2. SSH 使用其它端口（外网端口转发连接内网服务器）</strong></p>\n<p>此时，ssh 登陆命令为 <code>ssh -p port username@remote_ip</code>，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 <code>remote_ip</code> 后加上 <code>!port</code> 即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 根目录</span><br><span class=\"line\">\\\\sshfs.r\\username@remote_ip\\</span><br><span class=\"line\"></span><br><span class=\"line\"># home 目录</span><br><span class=\"line\">\\\\sshfs\\username@remote_ip\\</span><br><span class=\"line\"># 或者 \\\\sshfs.r\\username@remote_ip\\home\\username\\</span><br></pre></td></tr></table></figure>\n\n<p>例如：<code>\\\\sshfs.r\\xieqk@168.10.9.87!34567\\</code>。</p>\n<p>登陆挂载远程目录</p>\n<p>将上述 <code>sshfs</code> 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（<strong>注意：</strong>弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 <code>sshfs</code> 路径之中，所以此处只需正常输入远程用户对应的密码即可。）</p>\n<p>对于常用的远程目录，建议通过 <code>映射网络驱动器</code> 长期挂载于本地。</p>\n<p><img src=\"/../imgs/a1e47db6d3e144affe47566fed629e9e.png\" alt=\"img\"></p>\n<p>映射网络驱动器</p>\n<p>在 <code>映射网络驱动器</code> 中，可自行分配驱动器盘号，然后在 <code>文件夹</code> 处输入上述 <code>sshfs</code> 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。</p>\n<p><img src=\"/../imgs/675b07d51113aeaf1b18b08b1fda130b.png\" alt=\"img\"></p>\n<p>输入 sshfs 路径</p>\n<p>之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：</p>\n<p><img src=\"/../imgs/84fe4ccf655091b45ffcad9c61def517.png\" alt=\"img\"></p>\n<p>本地挂载成功</p>\n<p>详细参数（可跳过，需要时再查看）</p>\n<p>sshfs-win 具体语法形式如下，其中 <code>[]</code> 中的内容为选填项，若为默认值可不填：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\sshfs\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br><span class=\"line\">\\\\sshfs.r\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br><span class=\"line\">\\\\sshfs.k\\[LOCUSER=]REMUSER@HOST[!PORT][\\PATH]</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><code>REMUSER</code>: 即 remote user，指 SSH 登陆远程主机时的用户名。</li>\n<li><code>HOST</code>：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址</li>\n<li><code>PORT</code>：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).</li>\n<li><code>PATH</code>：进入的远程服务器路径，可按照如下设置:<ul>\n<li>前缀 <code>sshfs</code> 对应为 <code>HOST:~REMUSER/PATH</code>，即远程服务器上相对于该用户 <code>home</code> 目录的相对路径：<code>/home/remote_user/PATH</code>。</li>\n<li>前缀 <code>sshfs.r</code> 对应为 <code>HOST:/PATH</code> 即远程服务器上相对于根(root)目录的路径：<code>/PATH</code>。</li>\n<li>前缀 <code>sshfs.k</code> 与第一项相同，对应为 <code>HOST:~REMUSER/PATH</code>，但它使用 Windows 本地当前用户位于 <code>%USERPROFILE%/.ssh/id_rsa</code> 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠<a href=\"https://blog.xieqk.com/posts/3517905979.html\">SSH 密钥管理及免密码登陆</a>），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可）</li>\n</ul>\n</li>\n<li><code>LOCUSER</code> windows本地用户名，可不填。</li>\n</ul>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/qq_31811537/article/details/124721621\">https://blog.csdn.net/qq_31811537/article/details/124721621</a></p>\n"},{"title":"01以太网ethernet-概念","date":"2024-05-23T07:30:58.000Z","_content":"\n\n\n## stmmac\n\ndrivers/net/stmicro/stmmac\n\n> stmmac 是一种以太网媒体访问控制器(Ethernet MAC, EMAC)的实现,由ST Microelectronics公司开发和维护\n\n## dwmac\n\n>`dwmac` 是由 Synopsys 公司开发的一种广泛应用于系统芯片 (SoC) 设计中的以太网媒体访问控制器 (Ethernet MAC, EMAC) 实现\n\n## rgmii\n\n>RGMII(Reduced Gigabit Media Independent Interface)是一种以太网物理层(PHY)接口标准,主要用于连接系统芯片(SoC)与以太网收发器(PHY)之间。\n>\n>1. 接口速率:\n>   - RGMII 支持 10/100/1000Mbps 三种以太网速率。\n>2. 引脚数量:\n>   - RGMII 使用 24 个引脚(双向各 12 个)来传输数据和控制信号。\n>3. 时序要求:\n>   - RGMII 接口需要严格的时序要求,包括数据和时钟之间的相位关系等。\n>4. 信号类型:\n>   - RGMII 使用LVCMOS电平的并行数据信号,以及独立的发送和接收时钟信号。\n\n\n\n## cru\n\n>CRU 是 Clock and Reset Unit 的缩写,指时钟和复位单元。它在系统芯片(SoC)中扮演着非常重要的角色。\n>\n>CRU 的主要功能包括:\n>\n>1. 时钟生成和管理:\n>   - 生成和分配各种内部时钟信号,如 CPU 时钟、总线时钟等。\n>   - 提供时钟切换和动态调频等功能,用于电源管理和性能优化。\n>2. 复位控制:\n>   - 生成和分配各种内部复位信号,如系统复位、模块复位等。\n>   - 提供复位同步和延迟功能,确保复位信号的正确传播。\n>3. 时钟/复位状态监控:\n>   - 监控时钟和复位信号的状态,并提供相关中断和状态寄存器。\n>   - 用于诊断和调试时钟/复位相关的问题。\n>\n>CRU 通常作为 SoC 中的一个独立模块,集中管理整个系统的时钟和复位相关功能。它与 CPU、内存、外设等模块紧密交互,确保系统稳定可靠地运行。\n>\n>CRU 的设计和实现通常由 SoC 设计团队负责,需要考虑时钟源、复位策略、功耗、时序等多方面因素。它是构建高性能、低功耗 SoC 的关键组件之一。\n\n\n\n\n\n## rk3588-gmac驱动\n\nkernel-5.10\n\nkernel/drivers/net/ethernet/stmicro/stmmac\n\n```\nrk_gmac_probe\n\tstmmac_probe_config_dt\n\t\tstmmac_dt_phy\n```\n\n\n\n","source":"_posts/01以太网ethernet-概念.md","raw":"---\ntitle: 01以太网ethernet-概念\ncategories:\n  - driver\ntags:\n  - ethrnet\ndate: 2024-05-23 15:30:58\n---\n\n\n\n## stmmac\n\ndrivers/net/stmicro/stmmac\n\n> stmmac 是一种以太网媒体访问控制器(Ethernet MAC, EMAC)的实现,由ST Microelectronics公司开发和维护\n\n## dwmac\n\n>`dwmac` 是由 Synopsys 公司开发的一种广泛应用于系统芯片 (SoC) 设计中的以太网媒体访问控制器 (Ethernet MAC, EMAC) 实现\n\n## rgmii\n\n>RGMII(Reduced Gigabit Media Independent Interface)是一种以太网物理层(PHY)接口标准,主要用于连接系统芯片(SoC)与以太网收发器(PHY)之间。\n>\n>1. 接口速率:\n>   - RGMII 支持 10/100/1000Mbps 三种以太网速率。\n>2. 引脚数量:\n>   - RGMII 使用 24 个引脚(双向各 12 个)来传输数据和控制信号。\n>3. 时序要求:\n>   - RGMII 接口需要严格的时序要求,包括数据和时钟之间的相位关系等。\n>4. 信号类型:\n>   - RGMII 使用LVCMOS电平的并行数据信号,以及独立的发送和接收时钟信号。\n\n\n\n## cru\n\n>CRU 是 Clock and Reset Unit 的缩写,指时钟和复位单元。它在系统芯片(SoC)中扮演着非常重要的角色。\n>\n>CRU 的主要功能包括:\n>\n>1. 时钟生成和管理:\n>   - 生成和分配各种内部时钟信号,如 CPU 时钟、总线时钟等。\n>   - 提供时钟切换和动态调频等功能,用于电源管理和性能优化。\n>2. 复位控制:\n>   - 生成和分配各种内部复位信号,如系统复位、模块复位等。\n>   - 提供复位同步和延迟功能,确保复位信号的正确传播。\n>3. 时钟/复位状态监控:\n>   - 监控时钟和复位信号的状态,并提供相关中断和状态寄存器。\n>   - 用于诊断和调试时钟/复位相关的问题。\n>\n>CRU 通常作为 SoC 中的一个独立模块,集中管理整个系统的时钟和复位相关功能。它与 CPU、内存、外设等模块紧密交互,确保系统稳定可靠地运行。\n>\n>CRU 的设计和实现通常由 SoC 设计团队负责,需要考虑时钟源、复位策略、功耗、时序等多方面因素。它是构建高性能、低功耗 SoC 的关键组件之一。\n\n\n\n\n\n## rk3588-gmac驱动\n\nkernel-5.10\n\nkernel/drivers/net/ethernet/stmicro/stmmac\n\n```\nrk_gmac_probe\n\tstmmac_probe_config_dt\n\t\tstmmac_dt_phy\n```\n\n\n\n","slug":"01以太网ethernet-概念","published":1,"updated":"2024-05-25T05:21:33.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwlnyyfs0000ozw0ay2kbg9h","content":"<h2 id=\"stmmac\"><a href=\"#stmmac\" class=\"headerlink\" title=\"stmmac\"></a>stmmac</h2><p>drivers&#x2F;net&#x2F;stmicro&#x2F;stmmac</p>\n<blockquote>\n<p>stmmac 是一种以太网媒体访问控制器(Ethernet MAC, EMAC)的实现,由ST Microelectronics公司开发和维护</p>\n</blockquote>\n<h2 id=\"dwmac\"><a href=\"#dwmac\" class=\"headerlink\" title=\"dwmac\"></a>dwmac</h2><blockquote>\n<p><code>dwmac</code> 是由 Synopsys 公司开发的一种广泛应用于系统芯片 (SoC) 设计中的以太网媒体访问控制器 (Ethernet MAC, EMAC) 实现</p>\n</blockquote>\n<h2 id=\"rgmii\"><a href=\"#rgmii\" class=\"headerlink\" title=\"rgmii\"></a>rgmii</h2><blockquote>\n<p>RGMII(Reduced Gigabit Media Independent Interface)是一种以太网物理层(PHY)接口标准,主要用于连接系统芯片(SoC)与以太网收发器(PHY)之间。</p>\n<ol>\n<li>接口速率:</li>\n</ol>\n<ul>\n<li>RGMII 支持 10&#x2F;100&#x2F;1000Mbps 三种以太网速率。</li>\n</ul>\n<ol start=\"2\">\n<li>引脚数量:</li>\n</ol>\n<ul>\n<li>RGMII 使用 24 个引脚(双向各 12 个)来传输数据和控制信号。</li>\n</ul>\n<ol start=\"3\">\n<li>时序要求:</li>\n</ol>\n<ul>\n<li>RGMII 接口需要严格的时序要求,包括数据和时钟之间的相位关系等。</li>\n</ul>\n<ol start=\"4\">\n<li>信号类型:</li>\n</ol>\n<ul>\n<li>RGMII 使用LVCMOS电平的并行数据信号,以及独立的发送和接收时钟信号。</li>\n</ul>\n</blockquote>\n<h2 id=\"cru\"><a href=\"#cru\" class=\"headerlink\" title=\"cru\"></a>cru</h2><blockquote>\n<p>CRU 是 Clock and Reset Unit 的缩写,指时钟和复位单元。它在系统芯片(SoC)中扮演着非常重要的角色。</p>\n<p>CRU 的主要功能包括:</p>\n<ol>\n<li>时钟生成和管理:</li>\n</ol>\n<ul>\n<li>生成和分配各种内部时钟信号,如 CPU 时钟、总线时钟等。</li>\n<li>提供时钟切换和动态调频等功能,用于电源管理和性能优化。</li>\n</ul>\n<ol start=\"2\">\n<li>复位控制:</li>\n</ol>\n<ul>\n<li>生成和分配各种内部复位信号,如系统复位、模块复位等。</li>\n<li>提供复位同步和延迟功能,确保复位信号的正确传播。</li>\n</ul>\n<ol start=\"3\">\n<li>时钟&#x2F;复位状态监控:</li>\n</ol>\n<ul>\n<li>监控时钟和复位信号的状态,并提供相关中断和状态寄存器。</li>\n<li>用于诊断和调试时钟&#x2F;复位相关的问题。</li>\n</ul>\n<p>CRU 通常作为 SoC 中的一个独立模块,集中管理整个系统的时钟和复位相关功能。它与 CPU、内存、外设等模块紧密交互,确保系统稳定可靠地运行。</p>\n<p>CRU 的设计和实现通常由 SoC 设计团队负责,需要考虑时钟源、复位策略、功耗、时序等多方面因素。它是构建高性能、低功耗 SoC 的关键组件之一。</p>\n</blockquote>\n<h2 id=\"rk3588-gmac驱动\"><a href=\"#rk3588-gmac驱动\" class=\"headerlink\" title=\"rk3588-gmac驱动\"></a>rk3588-gmac驱动</h2><p>kernel-5.10</p>\n<p>kernel&#x2F;drivers&#x2F;net&#x2F;ethernet&#x2F;stmicro&#x2F;stmmac</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rk_gmac_probe</span><br><span class=\"line\">\tstmmac_probe_config_dt</span><br><span class=\"line\">\t\tstmmac_dt_phy</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"stmmac\"><a href=\"#stmmac\" class=\"headerlink\" title=\"stmmac\"></a>stmmac</h2><p>drivers&#x2F;net&#x2F;stmicro&#x2F;stmmac</p>\n<blockquote>\n<p>stmmac 是一种以太网媒体访问控制器(Ethernet MAC, EMAC)的实现,由ST Microelectronics公司开发和维护</p>\n</blockquote>\n<h2 id=\"dwmac\"><a href=\"#dwmac\" class=\"headerlink\" title=\"dwmac\"></a>dwmac</h2><blockquote>\n<p><code>dwmac</code> 是由 Synopsys 公司开发的一种广泛应用于系统芯片 (SoC) 设计中的以太网媒体访问控制器 (Ethernet MAC, EMAC) 实现</p>\n</blockquote>\n<h2 id=\"rgmii\"><a href=\"#rgmii\" class=\"headerlink\" title=\"rgmii\"></a>rgmii</h2><blockquote>\n<p>RGMII(Reduced Gigabit Media Independent Interface)是一种以太网物理层(PHY)接口标准,主要用于连接系统芯片(SoC)与以太网收发器(PHY)之间。</p>\n<ol>\n<li>接口速率:</li>\n</ol>\n<ul>\n<li>RGMII 支持 10&#x2F;100&#x2F;1000Mbps 三种以太网速率。</li>\n</ul>\n<ol start=\"2\">\n<li>引脚数量:</li>\n</ol>\n<ul>\n<li>RGMII 使用 24 个引脚(双向各 12 个)来传输数据和控制信号。</li>\n</ul>\n<ol start=\"3\">\n<li>时序要求:</li>\n</ol>\n<ul>\n<li>RGMII 接口需要严格的时序要求,包括数据和时钟之间的相位关系等。</li>\n</ul>\n<ol start=\"4\">\n<li>信号类型:</li>\n</ol>\n<ul>\n<li>RGMII 使用LVCMOS电平的并行数据信号,以及独立的发送和接收时钟信号。</li>\n</ul>\n</blockquote>\n<h2 id=\"cru\"><a href=\"#cru\" class=\"headerlink\" title=\"cru\"></a>cru</h2><blockquote>\n<p>CRU 是 Clock and Reset Unit 的缩写,指时钟和复位单元。它在系统芯片(SoC)中扮演着非常重要的角色。</p>\n<p>CRU 的主要功能包括:</p>\n<ol>\n<li>时钟生成和管理:</li>\n</ol>\n<ul>\n<li>生成和分配各种内部时钟信号,如 CPU 时钟、总线时钟等。</li>\n<li>提供时钟切换和动态调频等功能,用于电源管理和性能优化。</li>\n</ul>\n<ol start=\"2\">\n<li>复位控制:</li>\n</ol>\n<ul>\n<li>生成和分配各种内部复位信号,如系统复位、模块复位等。</li>\n<li>提供复位同步和延迟功能,确保复位信号的正确传播。</li>\n</ul>\n<ol start=\"3\">\n<li>时钟&#x2F;复位状态监控:</li>\n</ol>\n<ul>\n<li>监控时钟和复位信号的状态,并提供相关中断和状态寄存器。</li>\n<li>用于诊断和调试时钟&#x2F;复位相关的问题。</li>\n</ul>\n<p>CRU 通常作为 SoC 中的一个独立模块,集中管理整个系统的时钟和复位相关功能。它与 CPU、内存、外设等模块紧密交互,确保系统稳定可靠地运行。</p>\n<p>CRU 的设计和实现通常由 SoC 设计团队负责,需要考虑时钟源、复位策略、功耗、时序等多方面因素。它是构建高性能、低功耗 SoC 的关键组件之一。</p>\n</blockquote>\n<h2 id=\"rk3588-gmac驱动\"><a href=\"#rk3588-gmac驱动\" class=\"headerlink\" title=\"rk3588-gmac驱动\"></a>rk3588-gmac驱动</h2><p>kernel-5.10</p>\n<p>kernel&#x2F;drivers&#x2F;net&#x2F;ethernet&#x2F;stmicro&#x2F;stmmac</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rk_gmac_probe</span><br><span class=\"line\">\tstmmac_probe_config_dt</span><br><span class=\"line\">\t\tstmmac_dt_phy</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"操作系统中的缺页","date":"2024-05-27T09:48:11.000Z","_content":"\n\n\n缺页是引入了虚拟内存后的一个概念。操作系统启动后，在内存中维护着一个虚拟地址表，进程需要的虚拟地址在虚拟地址表中记录。一个程序被加载运行时，只是加载了很少的一部分到内存，另外一部分在需要时再从磁盘载入。被加载到内存的部分标识为“驻留”，而未被加载到内存的部分标为“未驻留”。操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻留”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示\"缺页\"。这个时候，操作系统触发一个“缺页”的硬件陷阱，系统从磁盘换入这部分未“驻留”的代码。\n       引入了分页机制(也就有了缺页机制)，则系统只需要加载程序的部分代码到内存，就可以创建进程运行， 需要程序的另一部分时再从磁盘载入并运行，从而允许比内存大很多的程序同时在内存运行。\n\n转：\n\nhttps://blog.csdn.net/ComputerInBook/article/details/101112983\n","source":"_posts/操作系统中的缺页.md","raw":"---\ntitle: 操作系统中的缺页\ncategories:\n  - test\ntags:\n  - 缺页\ndate: 2024-05-27 17:48:11\n---\n\n\n\n缺页是引入了虚拟内存后的一个概念。操作系统启动后，在内存中维护着一个虚拟地址表，进程需要的虚拟地址在虚拟地址表中记录。一个程序被加载运行时，只是加载了很少的一部分到内存，另外一部分在需要时再从磁盘载入。被加载到内存的部分标识为“驻留”，而未被加载到内存的部分标为“未驻留”。操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻留”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示\"缺页\"。这个时候，操作系统触发一个“缺页”的硬件陷阱，系统从磁盘换入这部分未“驻留”的代码。\n       引入了分页机制(也就有了缺页机制)，则系统只需要加载程序的部分代码到内存，就可以创建进程运行， 需要程序的另一部分时再从磁盘载入并运行，从而允许比内存大很多的程序同时在内存运行。\n\n转：\n\nhttps://blog.csdn.net/ComputerInBook/article/details/101112983\n","slug":"操作系统中的缺页","published":1,"updated":"2024-05-27T09:53:53.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwoskrac000190w0b4um8252","content":"<p>缺页是引入了虚拟内存后的一个概念。操作系统启动后，在内存中维护着一个虚拟地址表，进程需要的虚拟地址在虚拟地址表中记录。一个程序被加载运行时，只是加载了很少的一部分到内存，另外一部分在需要时再从磁盘载入。被加载到内存的部分标识为“驻留”，而未被加载到内存的部分标为“未驻留”。操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻留”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示”缺页”。这个时候，操作系统触发一个“缺页”的硬件陷阱，系统从磁盘换入这部分未“驻留”的代码。<br>       引入了分页机制(也就有了缺页机制)，则系统只需要加载程序的部分代码到内存，就可以创建进程运行， 需要程序的另一部分时再从磁盘载入并运行，从而允许比内存大很多的程序同时在内存运行。</p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/ComputerInBook/article/details/101112983\">https://blog.csdn.net/ComputerInBook/article/details/101112983</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>缺页是引入了虚拟内存后的一个概念。操作系统启动后，在内存中维护着一个虚拟地址表，进程需要的虚拟地址在虚拟地址表中记录。一个程序被加载运行时，只是加载了很少的一部分到内存，另外一部分在需要时再从磁盘载入。被加载到内存的部分标识为“驻留”，而未被加载到内存的部分标为“未驻留”。操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻留”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示”缺页”。这个时候，操作系统触发一个“缺页”的硬件陷阱，系统从磁盘换入这部分未“驻留”的代码。<br>       引入了分页机制(也就有了缺页机制)，则系统只需要加载程序的部分代码到内存，就可以创建进程运行， 需要程序的另一部分时再从磁盘载入并运行，从而允许比内存大很多的程序同时在内存运行。</p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/ComputerInBook/article/details/101112983\">https://blog.csdn.net/ComputerInBook/article/details/101112983</a></p>\n"},{"title":"shell脚本-符合意义","date":"2024-05-29T06:31:03.000Z","_content":"\n\n\n### 一、概述\n\nshell中有两类字符：普通字符、元字符。\n\n#### 1. 普通字符\n\n在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本；\n\n#### 2. 元字符\n\n是Shell的保留字符，在Shell中有着特殊的含义。\n\n![ ](../imgs/2ef32c1ce3654484b236af25368bdab1.png)\n\n![img](../imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png)\n\nshell中字符`$`的各种用法。\n\n### 二、[转义字符](https://so.csdn.net/so/search?q=转义字符&spm=1001.2101.3001.7020)$\n\n在linux shell脚本中经常用到字符`$`，下面是`$`的一些常见用法\n\n名称\t含义\n$#\t传给脚本的参数个数\n$0\t脚本本身的名字\n$1\t传递给该shell脚本的第一个参数\n$2\t传递给该shell脚本的第二个参数\n$@\t传给脚本的所有参数的列表\n$*\t以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个\n$$\t脚本运行的当前进程ID号\n$?\t显示最后命令的退出状态，0表示没有错误，其他表示有错误\n\n#### 实例1\n\n建立脚本peng.sh如下：\n\n```bash\n#/bin/bash\ntotal=$[ $1 * $2 + $3 ]\necho \"$1 * $2 + $3 = $total\"\n```\n\n运行如下：\n\n```bash\n./peng.sh 4 5 6\n1\n```\n\n结果如下：\n\n![ ](../imgs/efcc46bc1fb845e898a37da989107ef9.png)\n\n#### 实例2\n\n当把字符串输入给shell脚本的时候，注意是以空格作为分隔符，如果字符串本身就有空格的话，那么用双引号或者单引号，比如\n\n```bash\n#/bin/bash\necho \"$1 is pretty nice!\"\n```\n\n运行如下：\n\n```bash\n./peng.sh 一口Linux\n```\n\n结果如下：\n![ ](../imgs/0a6cf9231486414a8095f6dd113a2c7d.png)\n\n#### 实例3\n\n```bash\n#!/bin/sh\necho \"参数个数:$#\"\necho \"脚本名字:$0\"\necho \"参数1:$1\"\necho \"参数2:$2\"\necho \"所有参数列表:$@\"\necho \"pid:$$\"\nif [ $1 = 100 ]\nthen\n echo \"命令退出状态：$?\" \n exit 0 #参数正确，退出状态为0\nelse\n echo \"命令退出状态：$?\"\n exit 1 #参数错误，退出状态1\nfi\n```\n\n执行结果：\n\n![img](../imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png)\n\n#### 实例4\n\n使用for循环进行参数遍历\n\n示例：\n\n```\n#!/bin/bash\nnumber=65             #定义一个退出值\nindex=1               #定义一个计数器\nif [ -z \"$1\" ];then   #对用户输入的参数做判断，如果未输入参数则返回脚本的用法并退出，退出值65\n   echo \"Usage:$0 + 参数\"\n   exit $number\nfi\necho \"listing args with \\$*:\"    #在屏幕输入，在$*中遍历参数\nfor arg in $*                                          \ndo\n   echo \"arg: $index = $arg\"                 \n   let index+=1\ndone\necho\nindex=1                         #将计数器重新设置为1\necho \"listing args with \\\"\\$@\\\":\"    #在\"$@\"中遍历参数\nfor arg in \"$@\"\ndo\n   echo \"arg: $index = $arg\"\n   let index+=1\ndone\n\n```\n\n![ ](../imgs/36d83bdde0524001a910df7a8c9c3083.png)\n\n![ ](../imgs/2a8ad08662864bc293b3c520e486c473.png)\n\n#### 实例5\n\n小技巧1：在\"∗ \" 和 *\"和∗\"和*中遍历参数的区别\n\n示例：\n\n```\n#!/bin/bash\nnumber=11\nif [ $# -eq 0 ];then\n   echo \"Usage: $0 + 参数\"\n   exit $number\nfi\nfor i in $*               #在$*中遍历参数，此时每个参数都是独立的，会遍历$#次\ndo\n   echo $i\ndone\necho\nfor i in \"$*\"            #在\"$*\"中遍历参数，此时\"$*\"被扩展为包含所有位置参数的单个字符串，只遍历一次\ndo\n   echo $i\ndone\n\n```\n\n![ ](../imgs/325ec497200142f98be97ec17d2c9cf3.png)\n\n转：\n\n[shell脚本中$0 $1 $# $@ $* $? $$ 的各种符号意义详解_shell $0-CSDN博客](https://blog.csdn.net/daocaokafei/article/details/120050007)\n","source":"_posts/shell脚本-符合意义.md","raw":"---\ntitle: shell脚本-符合意义\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-05-29 14:31:03\n---\n\n\n\n### 一、概述\n\nshell中有两类字符：普通字符、元字符。\n\n#### 1. 普通字符\n\n在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本；\n\n#### 2. 元字符\n\n是Shell的保留字符，在Shell中有着特殊的含义。\n\n![ ](../imgs/2ef32c1ce3654484b236af25368bdab1.png)\n\n![img](../imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png)\n\nshell中字符`$`的各种用法。\n\n### 二、[转义字符](https://so.csdn.net/so/search?q=转义字符&spm=1001.2101.3001.7020)$\n\n在linux shell脚本中经常用到字符`$`，下面是`$`的一些常见用法\n\n名称\t含义\n$#\t传给脚本的参数个数\n$0\t脚本本身的名字\n$1\t传递给该shell脚本的第一个参数\n$2\t传递给该shell脚本的第二个参数\n$@\t传给脚本的所有参数的列表\n$*\t以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个\n$$\t脚本运行的当前进程ID号\n$?\t显示最后命令的退出状态，0表示没有错误，其他表示有错误\n\n#### 实例1\n\n建立脚本peng.sh如下：\n\n```bash\n#/bin/bash\ntotal=$[ $1 * $2 + $3 ]\necho \"$1 * $2 + $3 = $total\"\n```\n\n运行如下：\n\n```bash\n./peng.sh 4 5 6\n1\n```\n\n结果如下：\n\n![ ](../imgs/efcc46bc1fb845e898a37da989107ef9.png)\n\n#### 实例2\n\n当把字符串输入给shell脚本的时候，注意是以空格作为分隔符，如果字符串本身就有空格的话，那么用双引号或者单引号，比如\n\n```bash\n#/bin/bash\necho \"$1 is pretty nice!\"\n```\n\n运行如下：\n\n```bash\n./peng.sh 一口Linux\n```\n\n结果如下：\n![ ](../imgs/0a6cf9231486414a8095f6dd113a2c7d.png)\n\n#### 实例3\n\n```bash\n#!/bin/sh\necho \"参数个数:$#\"\necho \"脚本名字:$0\"\necho \"参数1:$1\"\necho \"参数2:$2\"\necho \"所有参数列表:$@\"\necho \"pid:$$\"\nif [ $1 = 100 ]\nthen\n echo \"命令退出状态：$?\" \n exit 0 #参数正确，退出状态为0\nelse\n echo \"命令退出状态：$?\"\n exit 1 #参数错误，退出状态1\nfi\n```\n\n执行结果：\n\n![img](../imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png)\n\n#### 实例4\n\n使用for循环进行参数遍历\n\n示例：\n\n```\n#!/bin/bash\nnumber=65             #定义一个退出值\nindex=1               #定义一个计数器\nif [ -z \"$1\" ];then   #对用户输入的参数做判断，如果未输入参数则返回脚本的用法并退出，退出值65\n   echo \"Usage:$0 + 参数\"\n   exit $number\nfi\necho \"listing args with \\$*:\"    #在屏幕输入，在$*中遍历参数\nfor arg in $*                                          \ndo\n   echo \"arg: $index = $arg\"                 \n   let index+=1\ndone\necho\nindex=1                         #将计数器重新设置为1\necho \"listing args with \\\"\\$@\\\":\"    #在\"$@\"中遍历参数\nfor arg in \"$@\"\ndo\n   echo \"arg: $index = $arg\"\n   let index+=1\ndone\n\n```\n\n![ ](../imgs/36d83bdde0524001a910df7a8c9c3083.png)\n\n![ ](../imgs/2a8ad08662864bc293b3c520e486c473.png)\n\n#### 实例5\n\n小技巧1：在\"∗ \" 和 *\"和∗\"和*中遍历参数的区别\n\n示例：\n\n```\n#!/bin/bash\nnumber=11\nif [ $# -eq 0 ];then\n   echo \"Usage: $0 + 参数\"\n   exit $number\nfi\nfor i in $*               #在$*中遍历参数，此时每个参数都是独立的，会遍历$#次\ndo\n   echo $i\ndone\necho\nfor i in \"$*\"            #在\"$*\"中遍历参数，此时\"$*\"被扩展为包含所有位置参数的单个字符串，只遍历一次\ndo\n   echo $i\ndone\n\n```\n\n![ ](../imgs/325ec497200142f98be97ec17d2c9cf3.png)\n\n转：\n\n[shell脚本中$0 $1 $# $@ $* $? $$ 的各种符号意义详解_shell $0-CSDN博客](https://blog.csdn.net/daocaokafei/article/details/120050007)\n","slug":"shell脚本-符合意义","published":1,"updated":"2024-05-29T06:49:00.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwrgv1zm0000o9w01mxf2xve","content":"<h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h3><p>shell中有两类字符：普通字符、元字符。</p>\n<h4 id=\"1-普通字符\"><a href=\"#1-普通字符\" class=\"headerlink\" title=\"1. 普通字符\"></a>1. 普通字符</h4><p>在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本；</p>\n<h4 id=\"2-元字符\"><a href=\"#2-元字符\" class=\"headerlink\" title=\"2. 元字符\"></a>2. 元字符</h4><p>是Shell的保留字符，在Shell中有着特殊的含义。</p>\n<p><img src=\"/../imgs/2ef32c1ce3654484b236af25368bdab1.png\" alt=\" \"></p>\n<p><img src=\"/../imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png\" alt=\"img\"></p>\n<p>shell中字符<code>$</code>的各种用法。</p>\n<h3 id=\"二、转义字符\"><a href=\"#二、转义字符\" class=\"headerlink\" title=\"二、转义字符$\"></a>二、<a href=\"https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6&spm=1001.2101.3001.7020\">转义字符</a>$</h3><p>在linux shell脚本中经常用到字符<code>$</code>，下面是<code>$</code>的一些常见用法</p>\n<p>名称\t含义<br>$#\t传给脚本的参数个数<br>$0\t脚本本身的名字<br>$1\t传递给该shell脚本的第一个参数<br>$2\t传递给该shell脚本的第二个参数<br>$@\t传给脚本的所有参数的列表<br>$*\t以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个<br>$$\t脚本运行的当前进程ID号<br>$?\t显示最后命令的退出状态，0表示没有错误，其他表示有错误</p>\n<h4 id=\"实例1\"><a href=\"#实例1\" class=\"headerlink\" title=\"实例1\"></a>实例1</h4><p>建立脚本peng.sh如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#/bin/bash</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> + <span class=\"variable\">$3</span> ]</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> + <span class=\"variable\">$3</span> = <span class=\"variable\">$total</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./peng.sh 4 5 6</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<p><img src=\"/../imgs/efcc46bc1fb845e898a37da989107ef9.png\" alt=\" \"></p>\n<h4 id=\"实例2\"><a href=\"#实例2\" class=\"headerlink\" title=\"实例2\"></a>实例2</h4><p>当把字符串输入给shell脚本的时候，注意是以空格作为分隔符，如果字符串本身就有空格的话，那么用双引号或者单引号，比如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#/bin/bash</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> is pretty nice!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./peng.sh 一口Linux</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：<br><img src=\"/../imgs/0a6cf9231486414a8095f6dd113a2c7d.png\" alt=\" \"></p>\n<h4 id=\"实例3\"><a href=\"#实例3\" class=\"headerlink\" title=\"实例3\"></a>实例3</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数个数:<span class=\"variable\">$#</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;脚本名字:<span class=\"variable\">$0</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数1:<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数2:<span class=\"variable\">$2</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;所有参数列表:<span class=\"variable\">$@</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;pid:$$&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> = 100 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;命令退出状态：$?&quot;</span> </span><br><span class=\"line\"> <span class=\"built_in\">exit</span> 0 <span class=\"comment\">#参数正确，退出状态为0</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;命令退出状态：$?&quot;</span></span><br><span class=\"line\"> <span class=\"built_in\">exit</span> 1 <span class=\"comment\">#参数错误，退出状态1</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<p><img src=\"/../imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png\" alt=\"img\"></p>\n<h4 id=\"实例4\"><a href=\"#实例4\" class=\"headerlink\" title=\"实例4\"></a>实例4</h4><p>使用for循环进行参数遍历</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">number=65             #定义一个退出值</span><br><span class=\"line\">index=1               #定义一个计数器</span><br><span class=\"line\">if [ -z &quot;$1&quot; ];then   #对用户输入的参数做判断，如果未输入参数则返回脚本的用法并退出，退出值65</span><br><span class=\"line\">   echo &quot;Usage:$0 + 参数&quot;</span><br><span class=\"line\">   exit $number</span><br><span class=\"line\">fi</span><br><span class=\"line\">echo &quot;listing args with \\$*:&quot;    #在屏幕输入，在$*中遍历参数</span><br><span class=\"line\">for arg in $*                                          </span><br><span class=\"line\">do</span><br><span class=\"line\">   echo &quot;arg: $index = $arg&quot;                 </span><br><span class=\"line\">   let index+=1</span><br><span class=\"line\">done</span><br><span class=\"line\">echo</span><br><span class=\"line\">index=1                         #将计数器重新设置为1</span><br><span class=\"line\">echo &quot;listing args with \\&quot;\\$@\\&quot;:&quot;    #在&quot;$@&quot;中遍历参数</span><br><span class=\"line\">for arg in &quot;$@&quot;</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo &quot;arg: $index = $arg&quot;</span><br><span class=\"line\">   let index+=1</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../imgs/36d83bdde0524001a910df7a8c9c3083.png\" alt=\" \"></p>\n<p><img src=\"/../imgs/2a8ad08662864bc293b3c520e486c473.png\" alt=\" \"></p>\n<h4 id=\"实例5\"><a href=\"#实例5\" class=\"headerlink\" title=\"实例5\"></a>实例5</h4><p>小技巧1：在”∗ “ 和 <em>“和∗”和</em>中遍历参数的区别</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">number=11</span><br><span class=\"line\">if [ $# -eq 0 ];then</span><br><span class=\"line\">   echo &quot;Usage: $0 + 参数&quot;</span><br><span class=\"line\">   exit $number</span><br><span class=\"line\">fi</span><br><span class=\"line\">for i in $*               #在$*中遍历参数，此时每个参数都是独立的，会遍历$#次</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\">echo</span><br><span class=\"line\">for i in &quot;$*&quot;            #在&quot;$*&quot;中遍历参数，此时&quot;$*&quot;被扩展为包含所有位置参数的单个字符串，只遍历一次</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../imgs/325ec497200142f98be97ec17d2c9cf3.png\" alt=\" \"></p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/daocaokafei/article/details/120050007\">shell脚本中$0 $1 $# $@ $* $? $$ 的各种符号意义详解_shell $0-CSDN博客</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h3><p>shell中有两类字符：普通字符、元字符。</p>\n<h4 id=\"1-普通字符\"><a href=\"#1-普通字符\" class=\"headerlink\" title=\"1. 普通字符\"></a>1. 普通字符</h4><p>在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本；</p>\n<h4 id=\"2-元字符\"><a href=\"#2-元字符\" class=\"headerlink\" title=\"2. 元字符\"></a>2. 元字符</h4><p>是Shell的保留字符，在Shell中有着特殊的含义。</p>\n<p><img src=\"/../imgs/2ef32c1ce3654484b236af25368bdab1.png\" alt=\" \"></p>\n<p><img src=\"/../imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png\" alt=\"img\"></p>\n<p>shell中字符<code>$</code>的各种用法。</p>\n<h3 id=\"二、转义字符\"><a href=\"#二、转义字符\" class=\"headerlink\" title=\"二、转义字符$\"></a>二、<a href=\"https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6&spm=1001.2101.3001.7020\">转义字符</a>$</h3><p>在linux shell脚本中经常用到字符<code>$</code>，下面是<code>$</code>的一些常见用法</p>\n<p>名称\t含义<br>$#\t传给脚本的参数个数<br>$0\t脚本本身的名字<br>$1\t传递给该shell脚本的第一个参数<br>$2\t传递给该shell脚本的第二个参数<br>$@\t传给脚本的所有参数的列表<br>$*\t以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个<br>$$\t脚本运行的当前进程ID号<br>$?\t显示最后命令的退出状态，0表示没有错误，其他表示有错误</p>\n<h4 id=\"实例1\"><a href=\"#实例1\" class=\"headerlink\" title=\"实例1\"></a>实例1</h4><p>建立脚本peng.sh如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#/bin/bash</span></span><br><span class=\"line\">total=$[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> + <span class=\"variable\">$3</span> ]</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> + <span class=\"variable\">$3</span> = <span class=\"variable\">$total</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./peng.sh 4 5 6</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<p><img src=\"/../imgs/efcc46bc1fb845e898a37da989107ef9.png\" alt=\" \"></p>\n<h4 id=\"实例2\"><a href=\"#实例2\" class=\"headerlink\" title=\"实例2\"></a>实例2</h4><p>当把字符串输入给shell脚本的时候，注意是以空格作为分隔符，如果字符串本身就有空格的话，那么用双引号或者单引号，比如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#/bin/bash</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span> is pretty nice!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./peng.sh 一口Linux</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：<br><img src=\"/../imgs/0a6cf9231486414a8095f6dd113a2c7d.png\" alt=\" \"></p>\n<h4 id=\"实例3\"><a href=\"#实例3\" class=\"headerlink\" title=\"实例3\"></a>实例3</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数个数:<span class=\"variable\">$#</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;脚本名字:<span class=\"variable\">$0</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数1:<span class=\"variable\">$1</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;参数2:<span class=\"variable\">$2</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;所有参数列表:<span class=\"variable\">$@</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;pid:$$&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> = 100 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;命令退出状态：$?&quot;</span> </span><br><span class=\"line\"> <span class=\"built_in\">exit</span> 0 <span class=\"comment\">#参数正确，退出状态为0</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;命令退出状态：$?&quot;</span></span><br><span class=\"line\"> <span class=\"built_in\">exit</span> 1 <span class=\"comment\">#参数错误，退出状态1</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<p><img src=\"/../imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png\" alt=\"img\"></p>\n<h4 id=\"实例4\"><a href=\"#实例4\" class=\"headerlink\" title=\"实例4\"></a>实例4</h4><p>使用for循环进行参数遍历</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">number=65             #定义一个退出值</span><br><span class=\"line\">index=1               #定义一个计数器</span><br><span class=\"line\">if [ -z &quot;$1&quot; ];then   #对用户输入的参数做判断，如果未输入参数则返回脚本的用法并退出，退出值65</span><br><span class=\"line\">   echo &quot;Usage:$0 + 参数&quot;</span><br><span class=\"line\">   exit $number</span><br><span class=\"line\">fi</span><br><span class=\"line\">echo &quot;listing args with \\$*:&quot;    #在屏幕输入，在$*中遍历参数</span><br><span class=\"line\">for arg in $*                                          </span><br><span class=\"line\">do</span><br><span class=\"line\">   echo &quot;arg: $index = $arg&quot;                 </span><br><span class=\"line\">   let index+=1</span><br><span class=\"line\">done</span><br><span class=\"line\">echo</span><br><span class=\"line\">index=1                         #将计数器重新设置为1</span><br><span class=\"line\">echo &quot;listing args with \\&quot;\\$@\\&quot;:&quot;    #在&quot;$@&quot;中遍历参数</span><br><span class=\"line\">for arg in &quot;$@&quot;</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo &quot;arg: $index = $arg&quot;</span><br><span class=\"line\">   let index+=1</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../imgs/36d83bdde0524001a910df7a8c9c3083.png\" alt=\" \"></p>\n<p><img src=\"/../imgs/2a8ad08662864bc293b3c520e486c473.png\" alt=\" \"></p>\n<h4 id=\"实例5\"><a href=\"#实例5\" class=\"headerlink\" title=\"实例5\"></a>实例5</h4><p>小技巧1：在”∗ “ 和 <em>“和∗”和</em>中遍历参数的区别</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">number=11</span><br><span class=\"line\">if [ $# -eq 0 ];then</span><br><span class=\"line\">   echo &quot;Usage: $0 + 参数&quot;</span><br><span class=\"line\">   exit $number</span><br><span class=\"line\">fi</span><br><span class=\"line\">for i in $*               #在$*中遍历参数，此时每个参数都是独立的，会遍历$#次</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\">echo</span><br><span class=\"line\">for i in &quot;$*&quot;            #在&quot;$*&quot;中遍历参数，此时&quot;$*&quot;被扩展为包含所有位置参数的单个字符串，只遍历一次</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../imgs/325ec497200142f98be97ec17d2c9cf3.png\" alt=\" \"></p>\n<p>转：</p>\n<p><a href=\"https://blog.csdn.net/daocaokafei/article/details/120050007\">shell脚本中$0 $1 $# $@ $* $? $$ 的各种符号意义详解_shell $0-CSDN博客</a></p>\n"},{"title":"dtb to dts","date":"2024-05-30T03:05:15.000Z","_content":"\n[toc]\n\n## [rk3588] dtc path\n\nlinux/kernel/scripts/dtc/dtc \n\nandroid/out/soong/host/linux-x86/bin/dtc\n\n## 使用[adb](https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020)获取fdt文件\n\n```\nadb root\nadb pull /sys/firmware/fdt d:\t\npwd\n```\n\n## 使用以下指令生成dts文件\n\n```\ncd ./out/soong/host/linux-x86/bin/dtc\n./dtc -I dtb -O dts –o fdt2dts.dts fdt\n```\n","source":"_posts/dtb-to-dts.md","raw":"---\ntitle: dtb to dts\ncategories:\n  - kernel\ntags:\n  - dtb\n  - dts\ndate: 2024-05-30 11:05:15\n---\n\n[toc]\n\n## [rk3588] dtc path\n\nlinux/kernel/scripts/dtc/dtc \n\nandroid/out/soong/host/linux-x86/bin/dtc\n\n## 使用[adb](https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020)获取fdt文件\n\n```\nadb root\nadb pull /sys/firmware/fdt d:\t\npwd\n```\n\n## 使用以下指令生成dts文件\n\n```\ncd ./out/soong/host/linux-x86/bin/dtc\n./dtc -I dtb -O dts –o fdt2dts.dts fdt\n```\n","slug":"dtb-to-dts","published":1,"updated":"2024-05-30T03:06:58.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwsoctx000008iw0f5a48f47","content":"<p>[toc]</p>\n<h2 id=\"rk3588-dtc-path\"><a href=\"#rk3588-dtc-path\" class=\"headerlink\" title=\"[rk3588] dtc path\"></a>[rk3588] dtc path</h2><p>linux&#x2F;kernel&#x2F;scripts&#x2F;dtc&#x2F;dtc </p>\n<p>android&#x2F;out&#x2F;soong&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;dtc</p>\n<h2 id=\"使用adb获取fdt文件\"><a href=\"#使用adb获取fdt文件\" class=\"headerlink\" title=\"使用adb获取fdt文件\"></a>使用<a href=\"https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020\">adb</a>获取fdt文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb root</span><br><span class=\"line\">adb pull /sys/firmware/fdt d:\t</span><br><span class=\"line\">pwd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用以下指令生成dts文件\"><a href=\"#使用以下指令生成dts文件\" class=\"headerlink\" title=\"使用以下指令生成dts文件\"></a>使用以下指令生成dts文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ./out/soong/host/linux-x86/bin/dtc</span><br><span class=\"line\">./dtc -I dtb -O dts –o fdt2dts.dts fdt</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h2 id=\"rk3588-dtc-path\"><a href=\"#rk3588-dtc-path\" class=\"headerlink\" title=\"[rk3588] dtc path\"></a>[rk3588] dtc path</h2><p>linux&#x2F;kernel&#x2F;scripts&#x2F;dtc&#x2F;dtc </p>\n<p>android&#x2F;out&#x2F;soong&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;dtc</p>\n<h2 id=\"使用adb获取fdt文件\"><a href=\"#使用adb获取fdt文件\" class=\"headerlink\" title=\"使用adb获取fdt文件\"></a>使用<a href=\"https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020\">adb</a>获取fdt文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb root</span><br><span class=\"line\">adb pull /sys/firmware/fdt d:\t</span><br><span class=\"line\">pwd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用以下指令生成dts文件\"><a href=\"#使用以下指令生成dts文件\" class=\"headerlink\" title=\"使用以下指令生成dts文件\"></a>使用以下指令生成dts文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ./out/soong/host/linux-x86/bin/dtc</span><br><span class=\"line\">./dtc -I dtb -O dts –o fdt2dts.dts fdt</span><br></pre></td></tr></table></figure>\n"},{"title":"struct-dev-debug","date":"2024-06-03T02:10:43.000Z","_content":"\n最近调试pinctrl时需要打印全部的state\n\n可以通过struct dev查看 pinctrl client的相关信息,因为pinctrl client是通过设备树配置的，通过probe会构造struct dev\n\n在设备树中,pinctrl client 设备节点会包含 `pinctrl-names` 和 `pinctrl-0` 等属性,用于描述引脚配置\n\n可以使用 `dev_dbg()`、`dev_info()` 等宏来打印这个 `struct device *dev` 的调试信息\n\n```\nstruct pinctrl_state *state;\nstruct pinctrl_desc *desc;\nstruct device *dev;\nstruct pinctrl *p;\n\t\ndev = pctldev->dev;\ndesc = pctldev->desc;\np = pctldev->p;\n\nprintk(KERN_ERR\"[%s][%d]Device name: %s\\n\", __func__, __LINE__, dev_name(dev));\nprintk(KERN_ERR\"[%s][%d]Device type: %s\\n\", __func__, __LINE__, dev->type ? dev->type->name : \"unknown\");\nprintk(KERN_ERR\"[%s][%d]Device driver: %s\\n\", __func__, __LINE__, dev->driver ? dev->driver->name : \"unknown\");\nprintk(KERN_ERR\"[%s][%d]desc->name %s\\n\", __func__, __LINE__, desc->name);\nlist_for_each_entry(state, &p->states, node) {\n\tprintk(KERN_ERR\"[%s][%d] state->name %s\\n\", __func__, __LINE__, state->name);\n}\n```\n\n","source":"_posts/struct-dev-debug.md","raw":"---\ntitle: struct-dev-debug\ncategories:\n  - test\ntags:\n  - debug\ndate: 2024-06-03 10:10:43\n---\n\n最近调试pinctrl时需要打印全部的state\n\n可以通过struct dev查看 pinctrl client的相关信息,因为pinctrl client是通过设备树配置的，通过probe会构造struct dev\n\n在设备树中,pinctrl client 设备节点会包含 `pinctrl-names` 和 `pinctrl-0` 等属性,用于描述引脚配置\n\n可以使用 `dev_dbg()`、`dev_info()` 等宏来打印这个 `struct device *dev` 的调试信息\n\n```\nstruct pinctrl_state *state;\nstruct pinctrl_desc *desc;\nstruct device *dev;\nstruct pinctrl *p;\n\t\ndev = pctldev->dev;\ndesc = pctldev->desc;\np = pctldev->p;\n\nprintk(KERN_ERR\"[%s][%d]Device name: %s\\n\", __func__, __LINE__, dev_name(dev));\nprintk(KERN_ERR\"[%s][%d]Device type: %s\\n\", __func__, __LINE__, dev->type ? dev->type->name : \"unknown\");\nprintk(KERN_ERR\"[%s][%d]Device driver: %s\\n\", __func__, __LINE__, dev->driver ? dev->driver->name : \"unknown\");\nprintk(KERN_ERR\"[%s][%d]desc->name %s\\n\", __func__, __LINE__, desc->name);\nlist_for_each_entry(state, &p->states, node) {\n\tprintk(KERN_ERR\"[%s][%d] state->name %s\\n\", __func__, __LINE__, state->name);\n}\n```\n\n","slug":"struct-dev-debug","published":1,"updated":"2024-06-03T03:29:10.625Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwyex3u100008iw09myx1v78","content":"<p>最近调试pinctrl时需要打印全部的state</p>\n<p>可以通过struct dev查看 pinctrl client的相关信息,因为pinctrl client是通过设备树配置的，通过probe会构造struct dev</p>\n<p>在设备树中,pinctrl client 设备节点会包含 <code>pinctrl-names</code> 和 <code>pinctrl-0</code> 等属性,用于描述引脚配置</p>\n<p>可以使用 <code>dev_dbg()</code>、<code>dev_info()</code> 等宏来打印这个 <code>struct device *dev</code> 的调试信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct pinctrl_state *state;</span><br><span class=\"line\">struct pinctrl_desc *desc;</span><br><span class=\"line\">struct device *dev;</span><br><span class=\"line\">struct pinctrl *p;</span><br><span class=\"line\">\t</span><br><span class=\"line\">dev = pctldev-&gt;dev;</span><br><span class=\"line\">desc = pctldev-&gt;desc;</span><br><span class=\"line\">p = pctldev-&gt;p;</span><br><span class=\"line\"></span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device name: %s\\n&quot;, __func__, __LINE__, dev_name(dev));</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device type: %s\\n&quot;, __func__, __LINE__, dev-&gt;type ? dev-&gt;type-&gt;name : &quot;unknown&quot;);</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device driver: %s\\n&quot;, __func__, __LINE__, dev-&gt;driver ? dev-&gt;driver-&gt;name : &quot;unknown&quot;);</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]desc-&gt;name %s\\n&quot;, __func__, __LINE__, desc-&gt;name);</span><br><span class=\"line\">list_for_each_entry(state, &amp;p-&gt;states, node) &#123;</span><br><span class=\"line\">\tprintk(KERN_ERR&quot;[%s][%d] state-&gt;name %s\\n&quot;, __func__, __LINE__, state-&gt;name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>最近调试pinctrl时需要打印全部的state</p>\n<p>可以通过struct dev查看 pinctrl client的相关信息,因为pinctrl client是通过设备树配置的，通过probe会构造struct dev</p>\n<p>在设备树中,pinctrl client 设备节点会包含 <code>pinctrl-names</code> 和 <code>pinctrl-0</code> 等属性,用于描述引脚配置</p>\n<p>可以使用 <code>dev_dbg()</code>、<code>dev_info()</code> 等宏来打印这个 <code>struct device *dev</code> 的调试信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct pinctrl_state *state;</span><br><span class=\"line\">struct pinctrl_desc *desc;</span><br><span class=\"line\">struct device *dev;</span><br><span class=\"line\">struct pinctrl *p;</span><br><span class=\"line\">\t</span><br><span class=\"line\">dev = pctldev-&gt;dev;</span><br><span class=\"line\">desc = pctldev-&gt;desc;</span><br><span class=\"line\">p = pctldev-&gt;p;</span><br><span class=\"line\"></span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device name: %s\\n&quot;, __func__, __LINE__, dev_name(dev));</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device type: %s\\n&quot;, __func__, __LINE__, dev-&gt;type ? dev-&gt;type-&gt;name : &quot;unknown&quot;);</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]Device driver: %s\\n&quot;, __func__, __LINE__, dev-&gt;driver ? dev-&gt;driver-&gt;name : &quot;unknown&quot;);</span><br><span class=\"line\">printk(KERN_ERR&quot;[%s][%d]desc-&gt;name %s\\n&quot;, __func__, __LINE__, desc-&gt;name);</span><br><span class=\"line\">list_for_each_entry(state, &amp;p-&gt;states, node) &#123;</span><br><span class=\"line\">\tprintk(KERN_ERR&quot;[%s][%d] state-&gt;name %s\\n&quot;, __func__, __LINE__, state-&gt;name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"systemctl-详解","date":"2024-06-03T06:10:50.000Z","_content":"\n## 一、Systemd简介\n\nSystemd是由红帽公司的一名叫做Lennart Poettering的员工开发，systemd是Linux系统中最新的初始化系统（init）,它主要的设计目的是克服Sys V 固有的缺点，提高系统的启动速度，systemd和upstart是竞争对手，ubantu上使用的是upstart的启动方式，centos7上使用systemd替换了Sys V，Systemd目录是要取代Unix时代依赖一直在使用的init系统，兼容SysV和LSB的启动脚本，而且能够在进程启动中更有效地引导加载服务。\nsystem：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其他进程，根据管理，字母d是守护进程（daemon）的缩写，systemd这个名字的含义就是它要守护整个系统。\n\n## 二、Systemd新特性\n\n- 系统引导时实现服务并行启动\n- 按需启动守护进程\n- 自动化的服务依赖关系管理\n- 同时采用socket式与D-Bus总线式激活服务\n- 系统状态快照和恢复\n- 利用Linux的cgroups监视进程\n- 维护挂载点和自动挂载点\n- 各服务间基于依赖关系进行精密控制\n\n\n\n## 三、Systemd核心概念\n\n- Unit\n  表示不同类型的sytemd对象，通过配置文件进行标识和配置，文件中主要包含了系统服务，监听socket、保存的系统快照以及其他与init相关的信息\n- 配置文件:\n  /usr/lib/systemd/system：每个服务最主要的启动脚本设置，类似于之前的/etc/initd.d\n  /run/system/system：系统执行过程中所产生的服务脚本，比上面的目录优先运行\n  /etc/system/system：管理员建立的执行脚本，类似于/etc/rc.d/rcN.d/Sxx类的功能，比上面目录优先运行，在三者之中，此目录优先级最高\n\n## 四、Unit类型\n\n- systemctl -t help ：查看unit类型\n\n- service unit：文件扩展名为.service，用于定义系统服务\n\n- target unit：文件扩展名为.target，用于模拟实现“运行级别”\n\n- device unit: .device,用于定义内核识别的设备\n\n- mount unit ：.mount，定义文件系统挂载点\n\n- socket unit ：.socket,用于标识进程间通信用的socket文件，也可以在系统启动时，延迟启动服务，实现按需启动\n\n- snapshot unit：.snapshot，关系系统快照\n\n- swap unit：.swap，用于表示swap设备\n\n- automount unit：.automount，文件系统的自动挂载点如：/misc目录\n\n- path unit：.path，用于定义文件系统中的一个文件或目录使用，常用于当文件系统变化时，延迟激活服务，如spool目录\n\n- time：.timer由systemd管理的计时器\n\n  注：使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式，如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的挂载点会自动转化为相应的.mount单元，例如/home等价于home.mount设备会自动转化为相应的.device单元，所以/dev/sd2等价于dev-sda2.device\n\n\n\n## 五、关键特性\n\n- 基于socket的激活机制：socket与服务进程分离\n- 基于D-Bus的激活机制\n- 基于device的激活机制\n- 基于path的激活机制\n- 系统快照：保存各unit的当前状态信息于持久存储设备中想后兼容sysv init脚本\n\n\n\n## 六、不兼容\n\n- systemctl命令固定不变，不可扩展\n- 非由systemd启动的服务，systemctl无语与之通信和控制，如：使用之前sys v风格管理的进程就无法收systemd控制\n\n\n\n## 七、Systemd基本工具\n\n监视和控制systemd的主要命令是systemctl。该命令可用于查看系统状态和管理系统及服务。\n\n- 管理服务\n\n命令：systemctl  command name.service\n\n启动：service name start –>systemctl start name.service\n\n停止：service name stop –>systemctl stop name.service\n\n重启：service name restart–>systemctl restart name.service\n\n状态：service name status–>systemctl status name.service\n\n- 条件式重启(已启动才重启，否则不做任何操作)\n  `systemctl try-restart name.service`\n\n- 重载或重启服务(先加载，然后再启动)\n  `systemctl reload-or-try-restart name.service`\n\n- 禁止自动和手动启动\n  `systemctl mask name.service` \n  执行此条命令实则创建了一个链接 ln -s '/dev/null' '/etc/systemd/system/sshd.service'\n\n- 取消禁止\n  `systemctl unmask name.service` \n  删除此前创建的链接\n\n- 服务查看(查看某服务当前激活与否的状态)\n  `systemctl is-active name.service` \n  如果启动会显示active，否则会显示unknown\n\n- 查看所有已经激活的服务\n  `systemctl list-units –t|–type service`\n\n- 查看所有服务\n\n  systemctl list-units –t service -a\n\n  设定某服务开机启动\n\n- `chkconfig name on–>systemctl enable name.service`\n\n设定某服务开机禁止启动\n`chkconfig name off –>systemctl disable name.service`\n\n查看所有服务的开机自启状态\n`chkconfig –list–>systemctl list-unit-files -t service` \n\n\n\n- 用来列出该服务在那些运行级别下启用或禁用\n\nchkconfig sshd –list –>ls /etc/system/system/*.wants/sshd.service\n\n[root@www ~]# ls /etc/systemd/system/*.wants/sshd.service\n\n/etc/systemd/system/multi-user.target.wants/sshd.service\n\n- 查看服务是否开机自启\n  `systemctl is-enabled name.servcice`\n- 查看服务的依赖关系\n  `systemctl list-dependencies`  \n\n- 查看启动失败的服务\n  `systemctl -failed -t service`\n- 查看服务单元的启用和禁用状态\n  `systemctl list-unit-files –t=service`\n- 杀死进程\n  `systemctl kill 进程名`   \n  [图片上传失败...(image-53509-1519920006718)]\n- 服务状态\n  systemctl list-units -t service -a 显示状态\n  loaded：unit配置文件已处理\n  active（running）：一次或多次持续处理的运行\n  active（exited）：成功完成一次性的配置\n  active（waiting）:运行中，等待一个事件\n  inactive：不运行\n  enabled：开机启动\n  disabled：开机不启动\n  static：开机不启动，但可以被另一个启用的服务激活\n\n- 运行级别\n  target units：\n  unit配置文件：.target 以target结尾的文件\n  ls /usr/lib/system/system/*.target\n  systemctl list-unit-files -type target -all\n  0–>runlevel0.target, poweroff.target\n  1–>runlevel1.target, rescue.target\n  2–>runlevel2.target, muti-user.target\n  3–>runlevel3.target, mutil-user.target\n  4–>runlevel4.target, multi-user.target\n  5–>runlevel5.target, graphical.target\n  6–>runlevel6.target, reboot.target\n\n  \n\n- 查看依赖性\n  `systemctl list-dependencies graphical.target`\n\n- 查看默认运行级别\n  systemctl get-default 在Sys V风格的系统上是查看/etc/inittab文件其中有一条id:5:initdefault:\n\n- 级别切换\n  `systemctl isolate muti-user.target` \n  注意：只有当/lib/system/system/*.target文件中AllowIsolate=yes时才能奇幻（修改文件需执行systemctl daemon-reload生效）\n\n- 设定默认运行级别\n  `systemctl set-default muti-user.target`     \n  实则将multi-user.target链接至default.target\n  `ls –l /etc/system/system/default.target`\n\n- 进入紧急救援模式\n  `systemctl rescue`\n\n- 切换至emergency模式\n  `systemctl emergency`\n\n- 在systemd风格的系统上还能使用sysv风格系统上的关机，重启等命令，指示将该命令链接到systemctl的一个软链接\n  关机：`systemctl halt systemctl poweroff` \n  重启：`systemctl reboot`   \n  挂起：`systemctl suspend`   \n  休眠：`systemctl hibernate`   \n  休眠并挂起：`systemctl hybrid-sleep`\n\n> 使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式\n>\n> 如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的\n>\n> 挂载点会自动转化为相应的.mount单元，例如/home等价于home.mount\n>\n> 设备会自动转化为相应的.device单元，所以/dev/sd2等价于dev-sda2.device\n> 加载initramfs驱动模块\n>\n> 加载内核选项\n>\n> 内核初始化，centos7使用systemd代替init\n>\n> 执行initrd.target所有单元，包括挂载/etc/fstab\n>\n> 从initramfs根文件系统切换到磁盘根目录\n>\n> systemd执行默认target配置，配置文件/etc/systemd/default.target /etc/systemd/system/\n>\n> systemd执行sysinit.target初始化系统及basic.target准备操作系统\n>\n> systemd启动multi-user.target下的本机与服务器服务\n>\n> systemd执行multi-user.target下的/etc/rc.d/rc.local\n>\n> systemd执行multi-user.target下的getty.target及登入服务\n>\n> systemd执行graphical需要的服务（此为图形界面所有）\n\n## unit文件格式\n\n以#开头的行后面的内容会被认为是注释\n相关布尔值，1、yes、on、ture都是开启，0、no、off、false都是关闭\n时间单位默认是秒\n\n\n\n## Unit文件组成\n\n- [Unit]：定义与Unit类型无关的通用选项，用于提供unit的扫描信息，unit行为及依赖关系等\n- [Service]：与特定类型相关的专用选项；此处为Service类型\n- [Install]：定义由“systemctl enable及systemctl disable”命令在实现服务启用或禁用时用到的一些选项\n\n## unit段常用选项\n\n- Description：描述信息\n\n  After：定义unit的启动次序，表示当前unit应该晚育那些unit启动，其功能与before相反\n  Requires：依赖到的其他units，强依赖，被一来的units无法激活时，当前unit即无法激活\n  Wants：依赖到的其他units，弱依赖\n  Conflicts：定义units间的冲突关系\n\n## Service段常用选项\n\n- Type：定义硬性ExecStart及相关参数的功能的unit进程启动类型\n- simple：默认值；这个daemon主要有ExecStart接的指令串来启动，启动后常驻于内存中\n- forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务原生父程序在启动结束后就会终止\n- onshot：用于执行一项任务，随后立即退出的服务，不会常驻于内存中\n- notify：与simple相同，但约定服务会在就绪后想systemd发送一个信号，需要配合NotifyAccess来让Systemd接收消息\n- idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才只能即可的服务\n- EnvironmentFile：环境配置文件\n- ExeStart：指明启动unit要运行命令或脚本的绝对路径\n- ExeStartPre：ExecStart前运行\n- ExeStartPost：ExecStart后运行\n- ExecStop：指明停止unit要运行的命令或脚本\n- Restart：当设定Restart=1时，则当次daemon服务意外终止后，会在此自动启动此服务\n\n## Install段常用选项\n\n- Alias：别名(可使用systemctl command Alial.service)\n  RequiredBy:被那些units所依赖，强依赖\n  WantedBy：被那些units所依赖，弱依赖\n  Also：安装本服务的时候还要安装别的相关服务\n  注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载次配置文件，而后可以选择重启：`systemctl daemon-reload`\n","source":"_posts/systemctl-详解.md","raw":"---\ntitle: systemctl-详解\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-06-03 14:10:50\n---\n\n## 一、Systemd简介\n\nSystemd是由红帽公司的一名叫做Lennart Poettering的员工开发，systemd是Linux系统中最新的初始化系统（init）,它主要的设计目的是克服Sys V 固有的缺点，提高系统的启动速度，systemd和upstart是竞争对手，ubantu上使用的是upstart的启动方式，centos7上使用systemd替换了Sys V，Systemd目录是要取代Unix时代依赖一直在使用的init系统，兼容SysV和LSB的启动脚本，而且能够在进程启动中更有效地引导加载服务。\nsystem：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其他进程，根据管理，字母d是守护进程（daemon）的缩写，systemd这个名字的含义就是它要守护整个系统。\n\n## 二、Systemd新特性\n\n- 系统引导时实现服务并行启动\n- 按需启动守护进程\n- 自动化的服务依赖关系管理\n- 同时采用socket式与D-Bus总线式激活服务\n- 系统状态快照和恢复\n- 利用Linux的cgroups监视进程\n- 维护挂载点和自动挂载点\n- 各服务间基于依赖关系进行精密控制\n\n\n\n## 三、Systemd核心概念\n\n- Unit\n  表示不同类型的sytemd对象，通过配置文件进行标识和配置，文件中主要包含了系统服务，监听socket、保存的系统快照以及其他与init相关的信息\n- 配置文件:\n  /usr/lib/systemd/system：每个服务最主要的启动脚本设置，类似于之前的/etc/initd.d\n  /run/system/system：系统执行过程中所产生的服务脚本，比上面的目录优先运行\n  /etc/system/system：管理员建立的执行脚本，类似于/etc/rc.d/rcN.d/Sxx类的功能，比上面目录优先运行，在三者之中，此目录优先级最高\n\n## 四、Unit类型\n\n- systemctl -t help ：查看unit类型\n\n- service unit：文件扩展名为.service，用于定义系统服务\n\n- target unit：文件扩展名为.target，用于模拟实现“运行级别”\n\n- device unit: .device,用于定义内核识别的设备\n\n- mount unit ：.mount，定义文件系统挂载点\n\n- socket unit ：.socket,用于标识进程间通信用的socket文件，也可以在系统启动时，延迟启动服务，实现按需启动\n\n- snapshot unit：.snapshot，关系系统快照\n\n- swap unit：.swap，用于表示swap设备\n\n- automount unit：.automount，文件系统的自动挂载点如：/misc目录\n\n- path unit：.path，用于定义文件系统中的一个文件或目录使用，常用于当文件系统变化时，延迟激活服务，如spool目录\n\n- time：.timer由systemd管理的计时器\n\n  注：使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式，如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的挂载点会自动转化为相应的.mount单元，例如/home等价于home.mount设备会自动转化为相应的.device单元，所以/dev/sd2等价于dev-sda2.device\n\n\n\n## 五、关键特性\n\n- 基于socket的激活机制：socket与服务进程分离\n- 基于D-Bus的激活机制\n- 基于device的激活机制\n- 基于path的激活机制\n- 系统快照：保存各unit的当前状态信息于持久存储设备中想后兼容sysv init脚本\n\n\n\n## 六、不兼容\n\n- systemctl命令固定不变，不可扩展\n- 非由systemd启动的服务，systemctl无语与之通信和控制，如：使用之前sys v风格管理的进程就无法收systemd控制\n\n\n\n## 七、Systemd基本工具\n\n监视和控制systemd的主要命令是systemctl。该命令可用于查看系统状态和管理系统及服务。\n\n- 管理服务\n\n命令：systemctl  command name.service\n\n启动：service name start –>systemctl start name.service\n\n停止：service name stop –>systemctl stop name.service\n\n重启：service name restart–>systemctl restart name.service\n\n状态：service name status–>systemctl status name.service\n\n- 条件式重启(已启动才重启，否则不做任何操作)\n  `systemctl try-restart name.service`\n\n- 重载或重启服务(先加载，然后再启动)\n  `systemctl reload-or-try-restart name.service`\n\n- 禁止自动和手动启动\n  `systemctl mask name.service` \n  执行此条命令实则创建了一个链接 ln -s '/dev/null' '/etc/systemd/system/sshd.service'\n\n- 取消禁止\n  `systemctl unmask name.service` \n  删除此前创建的链接\n\n- 服务查看(查看某服务当前激活与否的状态)\n  `systemctl is-active name.service` \n  如果启动会显示active，否则会显示unknown\n\n- 查看所有已经激活的服务\n  `systemctl list-units –t|–type service`\n\n- 查看所有服务\n\n  systemctl list-units –t service -a\n\n  设定某服务开机启动\n\n- `chkconfig name on–>systemctl enable name.service`\n\n设定某服务开机禁止启动\n`chkconfig name off –>systemctl disable name.service`\n\n查看所有服务的开机自启状态\n`chkconfig –list–>systemctl list-unit-files -t service` \n\n\n\n- 用来列出该服务在那些运行级别下启用或禁用\n\nchkconfig sshd –list –>ls /etc/system/system/*.wants/sshd.service\n\n[root@www ~]# ls /etc/systemd/system/*.wants/sshd.service\n\n/etc/systemd/system/multi-user.target.wants/sshd.service\n\n- 查看服务是否开机自启\n  `systemctl is-enabled name.servcice`\n- 查看服务的依赖关系\n  `systemctl list-dependencies`  \n\n- 查看启动失败的服务\n  `systemctl -failed -t service`\n- 查看服务单元的启用和禁用状态\n  `systemctl list-unit-files –t=service`\n- 杀死进程\n  `systemctl kill 进程名`   \n  [图片上传失败...(image-53509-1519920006718)]\n- 服务状态\n  systemctl list-units -t service -a 显示状态\n  loaded：unit配置文件已处理\n  active（running）：一次或多次持续处理的运行\n  active（exited）：成功完成一次性的配置\n  active（waiting）:运行中，等待一个事件\n  inactive：不运行\n  enabled：开机启动\n  disabled：开机不启动\n  static：开机不启动，但可以被另一个启用的服务激活\n\n- 运行级别\n  target units：\n  unit配置文件：.target 以target结尾的文件\n  ls /usr/lib/system/system/*.target\n  systemctl list-unit-files -type target -all\n  0–>runlevel0.target, poweroff.target\n  1–>runlevel1.target, rescue.target\n  2–>runlevel2.target, muti-user.target\n  3–>runlevel3.target, mutil-user.target\n  4–>runlevel4.target, multi-user.target\n  5–>runlevel5.target, graphical.target\n  6–>runlevel6.target, reboot.target\n\n  \n\n- 查看依赖性\n  `systemctl list-dependencies graphical.target`\n\n- 查看默认运行级别\n  systemctl get-default 在Sys V风格的系统上是查看/etc/inittab文件其中有一条id:5:initdefault:\n\n- 级别切换\n  `systemctl isolate muti-user.target` \n  注意：只有当/lib/system/system/*.target文件中AllowIsolate=yes时才能奇幻（修改文件需执行systemctl daemon-reload生效）\n\n- 设定默认运行级别\n  `systemctl set-default muti-user.target`     \n  实则将multi-user.target链接至default.target\n  `ls –l /etc/system/system/default.target`\n\n- 进入紧急救援模式\n  `systemctl rescue`\n\n- 切换至emergency模式\n  `systemctl emergency`\n\n- 在systemd风格的系统上还能使用sysv风格系统上的关机，重启等命令，指示将该命令链接到systemctl的一个软链接\n  关机：`systemctl halt systemctl poweroff` \n  重启：`systemctl reboot`   \n  挂起：`systemctl suspend`   \n  休眠：`systemctl hibernate`   \n  休眠并挂起：`systemctl hybrid-sleep`\n\n> 使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式\n>\n> 如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的\n>\n> 挂载点会自动转化为相应的.mount单元，例如/home等价于home.mount\n>\n> 设备会自动转化为相应的.device单元，所以/dev/sd2等价于dev-sda2.device\n> 加载initramfs驱动模块\n>\n> 加载内核选项\n>\n> 内核初始化，centos7使用systemd代替init\n>\n> 执行initrd.target所有单元，包括挂载/etc/fstab\n>\n> 从initramfs根文件系统切换到磁盘根目录\n>\n> systemd执行默认target配置，配置文件/etc/systemd/default.target /etc/systemd/system/\n>\n> systemd执行sysinit.target初始化系统及basic.target准备操作系统\n>\n> systemd启动multi-user.target下的本机与服务器服务\n>\n> systemd执行multi-user.target下的/etc/rc.d/rc.local\n>\n> systemd执行multi-user.target下的getty.target及登入服务\n>\n> systemd执行graphical需要的服务（此为图形界面所有）\n\n## unit文件格式\n\n以#开头的行后面的内容会被认为是注释\n相关布尔值，1、yes、on、ture都是开启，0、no、off、false都是关闭\n时间单位默认是秒\n\n\n\n## Unit文件组成\n\n- [Unit]：定义与Unit类型无关的通用选项，用于提供unit的扫描信息，unit行为及依赖关系等\n- [Service]：与特定类型相关的专用选项；此处为Service类型\n- [Install]：定义由“systemctl enable及systemctl disable”命令在实现服务启用或禁用时用到的一些选项\n\n## unit段常用选项\n\n- Description：描述信息\n\n  After：定义unit的启动次序，表示当前unit应该晚育那些unit启动，其功能与before相反\n  Requires：依赖到的其他units，强依赖，被一来的units无法激活时，当前unit即无法激活\n  Wants：依赖到的其他units，弱依赖\n  Conflicts：定义units间的冲突关系\n\n## Service段常用选项\n\n- Type：定义硬性ExecStart及相关参数的功能的unit进程启动类型\n- simple：默认值；这个daemon主要有ExecStart接的指令串来启动，启动后常驻于内存中\n- forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务原生父程序在启动结束后就会终止\n- onshot：用于执行一项任务，随后立即退出的服务，不会常驻于内存中\n- notify：与simple相同，但约定服务会在就绪后想systemd发送一个信号，需要配合NotifyAccess来让Systemd接收消息\n- idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才只能即可的服务\n- EnvironmentFile：环境配置文件\n- ExeStart：指明启动unit要运行命令或脚本的绝对路径\n- ExeStartPre：ExecStart前运行\n- ExeStartPost：ExecStart后运行\n- ExecStop：指明停止unit要运行的命令或脚本\n- Restart：当设定Restart=1时，则当次daemon服务意外终止后，会在此自动启动此服务\n\n## Install段常用选项\n\n- Alias：别名(可使用systemctl command Alial.service)\n  RequiredBy:被那些units所依赖，强依赖\n  WantedBy：被那些units所依赖，弱依赖\n  Also：安装本服务的时候还要安装别的相关服务\n  注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载次配置文件，而后可以选择重启：`systemctl daemon-reload`\n","slug":"systemctl-详解","published":1,"updated":"2024-06-03T06:13:44.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwyksja60000ijw0dbptaw6i","content":"<h2 id=\"一、Systemd简介\"><a href=\"#一、Systemd简介\" class=\"headerlink\" title=\"一、Systemd简介\"></a>一、Systemd简介</h2><p>Systemd是由红帽公司的一名叫做Lennart Poettering的员工开发，systemd是Linux系统中最新的初始化系统（init）,它主要的设计目的是克服Sys V 固有的缺点，提高系统的启动速度，systemd和upstart是竞争对手，ubantu上使用的是upstart的启动方式，centos7上使用systemd替换了Sys V，Systemd目录是要取代Unix时代依赖一直在使用的init系统，兼容SysV和LSB的启动脚本，而且能够在进程启动中更有效地引导加载服务。<br>system：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其他进程，根据管理，字母d是守护进程（daemon）的缩写，systemd这个名字的含义就是它要守护整个系统。</p>\n<h2 id=\"二、Systemd新特性\"><a href=\"#二、Systemd新特性\" class=\"headerlink\" title=\"二、Systemd新特性\"></a>二、Systemd新特性</h2><ul>\n<li>系统引导时实现服务并行启动</li>\n<li>按需启动守护进程</li>\n<li>自动化的服务依赖关系管理</li>\n<li>同时采用socket式与D-Bus总线式激活服务</li>\n<li>系统状态快照和恢复</li>\n<li>利用Linux的cgroups监视进程</li>\n<li>维护挂载点和自动挂载点</li>\n<li>各服务间基于依赖关系进行精密控制</li>\n</ul>\n<h2 id=\"三、Systemd核心概念\"><a href=\"#三、Systemd核心概念\" class=\"headerlink\" title=\"三、Systemd核心概念\"></a>三、Systemd核心概念</h2><ul>\n<li>Unit<br>表示不同类型的sytemd对象，通过配置文件进行标识和配置，文件中主要包含了系统服务，监听socket、保存的系统快照以及其他与init相关的信息</li>\n<li>配置文件:<br>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system：每个服务最主要的启动脚本设置，类似于之前的&#x2F;etc&#x2F;initd.d<br>&#x2F;run&#x2F;system&#x2F;system：系统执行过程中所产生的服务脚本，比上面的目录优先运行<br>&#x2F;etc&#x2F;system&#x2F;system：管理员建立的执行脚本，类似于&#x2F;etc&#x2F;rc.d&#x2F;rcN.d&#x2F;Sxx类的功能，比上面目录优先运行，在三者之中，此目录优先级最高</li>\n</ul>\n<h2 id=\"四、Unit类型\"><a href=\"#四、Unit类型\" class=\"headerlink\" title=\"四、Unit类型\"></a>四、Unit类型</h2><ul>\n<li><p>systemctl -t help ：查看unit类型</p>\n</li>\n<li><p>service unit：文件扩展名为.service，用于定义系统服务</p>\n</li>\n<li><p>target unit：文件扩展名为.target，用于模拟实现“运行级别”</p>\n</li>\n<li><p>device unit: .device,用于定义内核识别的设备</p>\n</li>\n<li><p>mount unit ：.mount，定义文件系统挂载点</p>\n</li>\n<li><p>socket unit ：.socket,用于标识进程间通信用的socket文件，也可以在系统启动时，延迟启动服务，实现按需启动</p>\n</li>\n<li><p>snapshot unit：.snapshot，关系系统快照</p>\n</li>\n<li><p>swap unit：.swap，用于表示swap设备</p>\n</li>\n<li><p>automount unit：.automount，文件系统的自动挂载点如：&#x2F;misc目录</p>\n</li>\n<li><p>path unit：.path，用于定义文件系统中的一个文件或目录使用，常用于当文件系统变化时，延迟激活服务，如spool目录</p>\n</li>\n<li><p>time：.timer由systemd管理的计时器</p>\n<p>注：使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式，如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的挂载点会自动转化为相应的.mount单元，例如&#x2F;home等价于home.mount设备会自动转化为相应的.device单元，所以&#x2F;dev&#x2F;sd2等价于dev-sda2.device</p>\n</li>\n</ul>\n<h2 id=\"五、关键特性\"><a href=\"#五、关键特性\" class=\"headerlink\" title=\"五、关键特性\"></a>五、关键特性</h2><ul>\n<li>基于socket的激活机制：socket与服务进程分离</li>\n<li>基于D-Bus的激活机制</li>\n<li>基于device的激活机制</li>\n<li>基于path的激活机制</li>\n<li>系统快照：保存各unit的当前状态信息于持久存储设备中想后兼容sysv init脚本</li>\n</ul>\n<h2 id=\"六、不兼容\"><a href=\"#六、不兼容\" class=\"headerlink\" title=\"六、不兼容\"></a>六、不兼容</h2><ul>\n<li>systemctl命令固定不变，不可扩展</li>\n<li>非由systemd启动的服务，systemctl无语与之通信和控制，如：使用之前sys v风格管理的进程就无法收systemd控制</li>\n</ul>\n<h2 id=\"七、Systemd基本工具\"><a href=\"#七、Systemd基本工具\" class=\"headerlink\" title=\"七、Systemd基本工具\"></a>七、Systemd基本工具</h2><p>监视和控制systemd的主要命令是systemctl。该命令可用于查看系统状态和管理系统及服务。</p>\n<ul>\n<li>管理服务</li>\n</ul>\n<p>命令：systemctl  command name.service</p>\n<p>启动：service name start –&gt;systemctl start name.service</p>\n<p>停止：service name stop –&gt;systemctl stop name.service</p>\n<p>重启：service name restart–&gt;systemctl restart name.service</p>\n<p>状态：service name status–&gt;systemctl status name.service</p>\n<ul>\n<li><p>条件式重启(已启动才重启，否则不做任何操作)<br><code>systemctl try-restart name.service</code></p>\n</li>\n<li><p>重载或重启服务(先加载，然后再启动)<br><code>systemctl reload-or-try-restart name.service</code></p>\n</li>\n<li><p>禁止自动和手动启动<br><code>systemctl mask name.service</code><br>执行此条命令实则创建了一个链接 ln -s ‘&#x2F;dev&#x2F;null’ ‘&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;sshd.service’</p>\n</li>\n<li><p>取消禁止<br><code>systemctl unmask name.service</code><br>删除此前创建的链接</p>\n</li>\n<li><p>服务查看(查看某服务当前激活与否的状态)<br><code>systemctl is-active name.service</code><br>如果启动会显示active，否则会显示unknown</p>\n</li>\n<li><p>查看所有已经激活的服务<br><code>systemctl list-units –t|–type service</code></p>\n</li>\n<li><p>查看所有服务</p>\n<p>systemctl list-units –t service -a</p>\n<p>设定某服务开机启动</p>\n</li>\n<li><p><code>chkconfig name on–&gt;systemctl enable name.service</code></p>\n</li>\n</ul>\n<p>设定某服务开机禁止启动<br><code>chkconfig name off –&gt;systemctl disable name.service</code></p>\n<p>查看所有服务的开机自启状态<br><code>chkconfig –list–&gt;systemctl list-unit-files -t service</code> </p>\n<ul>\n<li>用来列出该服务在那些运行级别下启用或禁用</li>\n</ul>\n<p>chkconfig sshd –list –&gt;ls &#x2F;etc&#x2F;system&#x2F;system&#x2F;*.wants&#x2F;sshd.service</p>\n<p>[root@www ~]# ls &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;*.wants&#x2F;sshd.service</p>\n<p>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;sshd.service</p>\n<ul>\n<li><p>查看服务是否开机自启<br><code>systemctl is-enabled name.servcice</code></p>\n</li>\n<li><p>查看服务的依赖关系<br><code>systemctl list-dependencies</code>  </p>\n</li>\n<li><p>查看启动失败的服务<br><code>systemctl -failed -t service</code></p>\n</li>\n<li><p>查看服务单元的启用和禁用状态<br><code>systemctl list-unit-files –t=service</code></p>\n</li>\n<li><p>杀死进程<br><code>systemctl kill 进程名</code><br>[图片上传失败…(image-53509-1519920006718)]</p>\n</li>\n<li><p>服务状态<br>systemctl list-units -t service -a 显示状态<br>loaded：unit配置文件已处理<br>active（running）：一次或多次持续处理的运行<br>active（exited）：成功完成一次性的配置<br>active（waiting）:运行中，等待一个事件<br>inactive：不运行<br>enabled：开机启动<br>disabled：开机不启动<br>static：开机不启动，但可以被另一个启用的服务激活</p>\n</li>\n<li><p>运行级别<br>target units：<br>unit配置文件：.target 以target结尾的文件<br>ls &#x2F;usr&#x2F;lib&#x2F;system&#x2F;system&#x2F;*.target<br>systemctl list-unit-files -type target -all<br>0–&gt;runlevel0.target, poweroff.target<br>1–&gt;runlevel1.target, rescue.target<br>2–&gt;runlevel2.target, muti-user.target<br>3–&gt;runlevel3.target, mutil-user.target<br>4–&gt;runlevel4.target, multi-user.target<br>5–&gt;runlevel5.target, graphical.target<br>6–&gt;runlevel6.target, reboot.target</p>\n</li>\n<li><p>查看依赖性<br><code>systemctl list-dependencies graphical.target</code></p>\n</li>\n<li><p>查看默认运行级别<br>systemctl get-default 在Sys V风格的系统上是查看&#x2F;etc&#x2F;inittab文件其中有一条id:5:initdefault:</p>\n</li>\n<li><p>级别切换<br><code>systemctl isolate muti-user.target</code><br>注意：只有当&#x2F;lib&#x2F;system&#x2F;system&#x2F;*.target文件中AllowIsolate&#x3D;yes时才能奇幻（修改文件需执行systemctl daemon-reload生效）</p>\n</li>\n<li><p>设定默认运行级别<br><code>systemctl set-default muti-user.target</code><br>实则将multi-user.target链接至default.target<br><code>ls –l /etc/system/system/default.target</code></p>\n</li>\n<li><p>进入紧急救援模式<br><code>systemctl rescue</code></p>\n</li>\n<li><p>切换至emergency模式<br><code>systemctl emergency</code></p>\n</li>\n<li><p>在systemd风格的系统上还能使用sysv风格系统上的关机，重启等命令，指示将该命令链接到systemctl的一个软链接<br>关机：<code>systemctl halt systemctl poweroff</code><br>重启：<code>systemctl reboot</code><br>挂起：<code>systemctl suspend</code><br>休眠：<code>systemctl hibernate</code><br>休眠并挂起：<code>systemctl hybrid-sleep</code></p>\n</li>\n</ul>\n<blockquote>\n<p>使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式</p>\n<p>如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的</p>\n<p>挂载点会自动转化为相应的.mount单元，例如&#x2F;home等价于home.mount</p>\n<p>设备会自动转化为相应的.device单元，所以&#x2F;dev&#x2F;sd2等价于dev-sda2.device<br>加载initramfs驱动模块</p>\n<p>加载内核选项</p>\n<p>内核初始化，centos7使用systemd代替init</p>\n<p>执行initrd.target所有单元，包括挂载&#x2F;etc&#x2F;fstab</p>\n<p>从initramfs根文件系统切换到磁盘根目录</p>\n<p>systemd执行默认target配置，配置文件&#x2F;etc&#x2F;systemd&#x2F;default.target &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;</p>\n<p>systemd执行sysinit.target初始化系统及basic.target准备操作系统</p>\n<p>systemd启动multi-user.target下的本机与服务器服务</p>\n<p>systemd执行multi-user.target下的&#x2F;etc&#x2F;rc.d&#x2F;rc.local</p>\n<p>systemd执行multi-user.target下的getty.target及登入服务</p>\n<p>systemd执行graphical需要的服务（此为图形界面所有）</p>\n</blockquote>\n<h2 id=\"unit文件格式\"><a href=\"#unit文件格式\" class=\"headerlink\" title=\"unit文件格式\"></a>unit文件格式</h2><p>以#开头的行后面的内容会被认为是注释<br>相关布尔值，1、yes、on、ture都是开启，0、no、off、false都是关闭<br>时间单位默认是秒</p>\n<h2 id=\"Unit文件组成\"><a href=\"#Unit文件组成\" class=\"headerlink\" title=\"Unit文件组成\"></a>Unit文件组成</h2><ul>\n<li>[Unit]：定义与Unit类型无关的通用选项，用于提供unit的扫描信息，unit行为及依赖关系等</li>\n<li>[Service]：与特定类型相关的专用选项；此处为Service类型</li>\n<li>[Install]：定义由“systemctl enable及systemctl disable”命令在实现服务启用或禁用时用到的一些选项</li>\n</ul>\n<h2 id=\"unit段常用选项\"><a href=\"#unit段常用选项\" class=\"headerlink\" title=\"unit段常用选项\"></a>unit段常用选项</h2><ul>\n<li><p>Description：描述信息</p>\n<p>After：定义unit的启动次序，表示当前unit应该晚育那些unit启动，其功能与before相反<br>Requires：依赖到的其他units，强依赖，被一来的units无法激活时，当前unit即无法激活<br>Wants：依赖到的其他units，弱依赖<br>Conflicts：定义units间的冲突关系</p>\n</li>\n</ul>\n<h2 id=\"Service段常用选项\"><a href=\"#Service段常用选项\" class=\"headerlink\" title=\"Service段常用选项\"></a>Service段常用选项</h2><ul>\n<li>Type：定义硬性ExecStart及相关参数的功能的unit进程启动类型</li>\n<li>simple：默认值；这个daemon主要有ExecStart接的指令串来启动，启动后常驻于内存中</li>\n<li>forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务原生父程序在启动结束后就会终止</li>\n<li>onshot：用于执行一项任务，随后立即退出的服务，不会常驻于内存中</li>\n<li>notify：与simple相同，但约定服务会在就绪后想systemd发送一个信号，需要配合NotifyAccess来让Systemd接收消息</li>\n<li>idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才只能即可的服务</li>\n<li>EnvironmentFile：环境配置文件</li>\n<li>ExeStart：指明启动unit要运行命令或脚本的绝对路径</li>\n<li>ExeStartPre：ExecStart前运行</li>\n<li>ExeStartPost：ExecStart后运行</li>\n<li>ExecStop：指明停止unit要运行的命令或脚本</li>\n<li>Restart：当设定Restart&#x3D;1时，则当次daemon服务意外终止后，会在此自动启动此服务</li>\n</ul>\n<h2 id=\"Install段常用选项\"><a href=\"#Install段常用选项\" class=\"headerlink\" title=\"Install段常用选项\"></a>Install段常用选项</h2><ul>\n<li>Alias：别名(可使用systemctl command Alial.service)<br>RequiredBy:被那些units所依赖，强依赖<br>WantedBy：被那些units所依赖，弱依赖<br>Also：安装本服务的时候还要安装别的相关服务<br>注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载次配置文件，而后可以选择重启：<code>systemctl daemon-reload</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、Systemd简介\"><a href=\"#一、Systemd简介\" class=\"headerlink\" title=\"一、Systemd简介\"></a>一、Systemd简介</h2><p>Systemd是由红帽公司的一名叫做Lennart Poettering的员工开发，systemd是Linux系统中最新的初始化系统（init）,它主要的设计目的是克服Sys V 固有的缺点，提高系统的启动速度，systemd和upstart是竞争对手，ubantu上使用的是upstart的启动方式，centos7上使用systemd替换了Sys V，Systemd目录是要取代Unix时代依赖一直在使用的init系统，兼容SysV和LSB的启动脚本，而且能够在进程启动中更有效地引导加载服务。<br>system：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其他进程，根据管理，字母d是守护进程（daemon）的缩写，systemd这个名字的含义就是它要守护整个系统。</p>\n<h2 id=\"二、Systemd新特性\"><a href=\"#二、Systemd新特性\" class=\"headerlink\" title=\"二、Systemd新特性\"></a>二、Systemd新特性</h2><ul>\n<li>系统引导时实现服务并行启动</li>\n<li>按需启动守护进程</li>\n<li>自动化的服务依赖关系管理</li>\n<li>同时采用socket式与D-Bus总线式激活服务</li>\n<li>系统状态快照和恢复</li>\n<li>利用Linux的cgroups监视进程</li>\n<li>维护挂载点和自动挂载点</li>\n<li>各服务间基于依赖关系进行精密控制</li>\n</ul>\n<h2 id=\"三、Systemd核心概念\"><a href=\"#三、Systemd核心概念\" class=\"headerlink\" title=\"三、Systemd核心概念\"></a>三、Systemd核心概念</h2><ul>\n<li>Unit<br>表示不同类型的sytemd对象，通过配置文件进行标识和配置，文件中主要包含了系统服务，监听socket、保存的系统快照以及其他与init相关的信息</li>\n<li>配置文件:<br>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system：每个服务最主要的启动脚本设置，类似于之前的&#x2F;etc&#x2F;initd.d<br>&#x2F;run&#x2F;system&#x2F;system：系统执行过程中所产生的服务脚本，比上面的目录优先运行<br>&#x2F;etc&#x2F;system&#x2F;system：管理员建立的执行脚本，类似于&#x2F;etc&#x2F;rc.d&#x2F;rcN.d&#x2F;Sxx类的功能，比上面目录优先运行，在三者之中，此目录优先级最高</li>\n</ul>\n<h2 id=\"四、Unit类型\"><a href=\"#四、Unit类型\" class=\"headerlink\" title=\"四、Unit类型\"></a>四、Unit类型</h2><ul>\n<li><p>systemctl -t help ：查看unit类型</p>\n</li>\n<li><p>service unit：文件扩展名为.service，用于定义系统服务</p>\n</li>\n<li><p>target unit：文件扩展名为.target，用于模拟实现“运行级别”</p>\n</li>\n<li><p>device unit: .device,用于定义内核识别的设备</p>\n</li>\n<li><p>mount unit ：.mount，定义文件系统挂载点</p>\n</li>\n<li><p>socket unit ：.socket,用于标识进程间通信用的socket文件，也可以在系统启动时，延迟启动服务，实现按需启动</p>\n</li>\n<li><p>snapshot unit：.snapshot，关系系统快照</p>\n</li>\n<li><p>swap unit：.swap，用于表示swap设备</p>\n</li>\n<li><p>automount unit：.automount，文件系统的自动挂载点如：&#x2F;misc目录</p>\n</li>\n<li><p>path unit：.path，用于定义文件系统中的一个文件或目录使用，常用于当文件系统变化时，延迟激活服务，如spool目录</p>\n</li>\n<li><p>time：.timer由systemd管理的计时器</p>\n<p>注：使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式，如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的挂载点会自动转化为相应的.mount单元，例如&#x2F;home等价于home.mount设备会自动转化为相应的.device单元，所以&#x2F;dev&#x2F;sd2等价于dev-sda2.device</p>\n</li>\n</ul>\n<h2 id=\"五、关键特性\"><a href=\"#五、关键特性\" class=\"headerlink\" title=\"五、关键特性\"></a>五、关键特性</h2><ul>\n<li>基于socket的激活机制：socket与服务进程分离</li>\n<li>基于D-Bus的激活机制</li>\n<li>基于device的激活机制</li>\n<li>基于path的激活机制</li>\n<li>系统快照：保存各unit的当前状态信息于持久存储设备中想后兼容sysv init脚本</li>\n</ul>\n<h2 id=\"六、不兼容\"><a href=\"#六、不兼容\" class=\"headerlink\" title=\"六、不兼容\"></a>六、不兼容</h2><ul>\n<li>systemctl命令固定不变，不可扩展</li>\n<li>非由systemd启动的服务，systemctl无语与之通信和控制，如：使用之前sys v风格管理的进程就无法收systemd控制</li>\n</ul>\n<h2 id=\"七、Systemd基本工具\"><a href=\"#七、Systemd基本工具\" class=\"headerlink\" title=\"七、Systemd基本工具\"></a>七、Systemd基本工具</h2><p>监视和控制systemd的主要命令是systemctl。该命令可用于查看系统状态和管理系统及服务。</p>\n<ul>\n<li>管理服务</li>\n</ul>\n<p>命令：systemctl  command name.service</p>\n<p>启动：service name start –&gt;systemctl start name.service</p>\n<p>停止：service name stop –&gt;systemctl stop name.service</p>\n<p>重启：service name restart–&gt;systemctl restart name.service</p>\n<p>状态：service name status–&gt;systemctl status name.service</p>\n<ul>\n<li><p>条件式重启(已启动才重启，否则不做任何操作)<br><code>systemctl try-restart name.service</code></p>\n</li>\n<li><p>重载或重启服务(先加载，然后再启动)<br><code>systemctl reload-or-try-restart name.service</code></p>\n</li>\n<li><p>禁止自动和手动启动<br><code>systemctl mask name.service</code><br>执行此条命令实则创建了一个链接 ln -s ‘&#x2F;dev&#x2F;null’ ‘&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;sshd.service’</p>\n</li>\n<li><p>取消禁止<br><code>systemctl unmask name.service</code><br>删除此前创建的链接</p>\n</li>\n<li><p>服务查看(查看某服务当前激活与否的状态)<br><code>systemctl is-active name.service</code><br>如果启动会显示active，否则会显示unknown</p>\n</li>\n<li><p>查看所有已经激活的服务<br><code>systemctl list-units –t|–type service</code></p>\n</li>\n<li><p>查看所有服务</p>\n<p>systemctl list-units –t service -a</p>\n<p>设定某服务开机启动</p>\n</li>\n<li><p><code>chkconfig name on–&gt;systemctl enable name.service</code></p>\n</li>\n</ul>\n<p>设定某服务开机禁止启动<br><code>chkconfig name off –&gt;systemctl disable name.service</code></p>\n<p>查看所有服务的开机自启状态<br><code>chkconfig –list–&gt;systemctl list-unit-files -t service</code> </p>\n<ul>\n<li>用来列出该服务在那些运行级别下启用或禁用</li>\n</ul>\n<p>chkconfig sshd –list –&gt;ls &#x2F;etc&#x2F;system&#x2F;system&#x2F;*.wants&#x2F;sshd.service</p>\n<p>[root@www ~]# ls &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;*.wants&#x2F;sshd.service</p>\n<p>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;sshd.service</p>\n<ul>\n<li><p>查看服务是否开机自启<br><code>systemctl is-enabled name.servcice</code></p>\n</li>\n<li><p>查看服务的依赖关系<br><code>systemctl list-dependencies</code>  </p>\n</li>\n<li><p>查看启动失败的服务<br><code>systemctl -failed -t service</code></p>\n</li>\n<li><p>查看服务单元的启用和禁用状态<br><code>systemctl list-unit-files –t=service</code></p>\n</li>\n<li><p>杀死进程<br><code>systemctl kill 进程名</code><br>[图片上传失败…(image-53509-1519920006718)]</p>\n</li>\n<li><p>服务状态<br>systemctl list-units -t service -a 显示状态<br>loaded：unit配置文件已处理<br>active（running）：一次或多次持续处理的运行<br>active（exited）：成功完成一次性的配置<br>active（waiting）:运行中，等待一个事件<br>inactive：不运行<br>enabled：开机启动<br>disabled：开机不启动<br>static：开机不启动，但可以被另一个启用的服务激活</p>\n</li>\n<li><p>运行级别<br>target units：<br>unit配置文件：.target 以target结尾的文件<br>ls &#x2F;usr&#x2F;lib&#x2F;system&#x2F;system&#x2F;*.target<br>systemctl list-unit-files -type target -all<br>0–&gt;runlevel0.target, poweroff.target<br>1–&gt;runlevel1.target, rescue.target<br>2–&gt;runlevel2.target, muti-user.target<br>3–&gt;runlevel3.target, mutil-user.target<br>4–&gt;runlevel4.target, multi-user.target<br>5–&gt;runlevel5.target, graphical.target<br>6–&gt;runlevel6.target, reboot.target</p>\n</li>\n<li><p>查看依赖性<br><code>systemctl list-dependencies graphical.target</code></p>\n</li>\n<li><p>查看默认运行级别<br>systemctl get-default 在Sys V风格的系统上是查看&#x2F;etc&#x2F;inittab文件其中有一条id:5:initdefault:</p>\n</li>\n<li><p>级别切换<br><code>systemctl isolate muti-user.target</code><br>注意：只有当&#x2F;lib&#x2F;system&#x2F;system&#x2F;*.target文件中AllowIsolate&#x3D;yes时才能奇幻（修改文件需执行systemctl daemon-reload生效）</p>\n</li>\n<li><p>设定默认运行级别<br><code>systemctl set-default muti-user.target</code><br>实则将multi-user.target链接至default.target<br><code>ls –l /etc/system/system/default.target</code></p>\n</li>\n<li><p>进入紧急救援模式<br><code>systemctl rescue</code></p>\n</li>\n<li><p>切换至emergency模式<br><code>systemctl emergency</code></p>\n</li>\n<li><p>在systemd风格的系统上还能使用sysv风格系统上的关机，重启等命令，指示将该命令链接到systemctl的一个软链接<br>关机：<code>systemctl halt systemctl poweroff</code><br>重启：<code>systemctl reboot</code><br>挂起：<code>systemctl suspend</code><br>休眠：<code>systemctl hibernate</code><br>休眠并挂起：<code>systemctl hybrid-sleep</code></p>\n</li>\n</ul>\n<blockquote>\n<p>使用systemctl控制单元时，通常需要使用单元文件的全名，包括扩展名，但是有些单元可以在systemctl中使用简写方式</p>\n<p>如果无扩展名，systemctl默认把扩展名当做.service。例如netcfg和netcfg.service是等同的</p>\n<p>挂载点会自动转化为相应的.mount单元，例如&#x2F;home等价于home.mount</p>\n<p>设备会自动转化为相应的.device单元，所以&#x2F;dev&#x2F;sd2等价于dev-sda2.device<br>加载initramfs驱动模块</p>\n<p>加载内核选项</p>\n<p>内核初始化，centos7使用systemd代替init</p>\n<p>执行initrd.target所有单元，包括挂载&#x2F;etc&#x2F;fstab</p>\n<p>从initramfs根文件系统切换到磁盘根目录</p>\n<p>systemd执行默认target配置，配置文件&#x2F;etc&#x2F;systemd&#x2F;default.target &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;</p>\n<p>systemd执行sysinit.target初始化系统及basic.target准备操作系统</p>\n<p>systemd启动multi-user.target下的本机与服务器服务</p>\n<p>systemd执行multi-user.target下的&#x2F;etc&#x2F;rc.d&#x2F;rc.local</p>\n<p>systemd执行multi-user.target下的getty.target及登入服务</p>\n<p>systemd执行graphical需要的服务（此为图形界面所有）</p>\n</blockquote>\n<h2 id=\"unit文件格式\"><a href=\"#unit文件格式\" class=\"headerlink\" title=\"unit文件格式\"></a>unit文件格式</h2><p>以#开头的行后面的内容会被认为是注释<br>相关布尔值，1、yes、on、ture都是开启，0、no、off、false都是关闭<br>时间单位默认是秒</p>\n<h2 id=\"Unit文件组成\"><a href=\"#Unit文件组成\" class=\"headerlink\" title=\"Unit文件组成\"></a>Unit文件组成</h2><ul>\n<li>[Unit]：定义与Unit类型无关的通用选项，用于提供unit的扫描信息，unit行为及依赖关系等</li>\n<li>[Service]：与特定类型相关的专用选项；此处为Service类型</li>\n<li>[Install]：定义由“systemctl enable及systemctl disable”命令在实现服务启用或禁用时用到的一些选项</li>\n</ul>\n<h2 id=\"unit段常用选项\"><a href=\"#unit段常用选项\" class=\"headerlink\" title=\"unit段常用选项\"></a>unit段常用选项</h2><ul>\n<li><p>Description：描述信息</p>\n<p>After：定义unit的启动次序，表示当前unit应该晚育那些unit启动，其功能与before相反<br>Requires：依赖到的其他units，强依赖，被一来的units无法激活时，当前unit即无法激活<br>Wants：依赖到的其他units，弱依赖<br>Conflicts：定义units间的冲突关系</p>\n</li>\n</ul>\n<h2 id=\"Service段常用选项\"><a href=\"#Service段常用选项\" class=\"headerlink\" title=\"Service段常用选项\"></a>Service段常用选项</h2><ul>\n<li>Type：定义硬性ExecStart及相关参数的功能的unit进程启动类型</li>\n<li>simple：默认值；这个daemon主要有ExecStart接的指令串来启动，启动后常驻于内存中</li>\n<li>forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务原生父程序在启动结束后就会终止</li>\n<li>onshot：用于执行一项任务，随后立即退出的服务，不会常驻于内存中</li>\n<li>notify：与simple相同，但约定服务会在就绪后想systemd发送一个信号，需要配合NotifyAccess来让Systemd接收消息</li>\n<li>idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才只能即可的服务</li>\n<li>EnvironmentFile：环境配置文件</li>\n<li>ExeStart：指明启动unit要运行命令或脚本的绝对路径</li>\n<li>ExeStartPre：ExecStart前运行</li>\n<li>ExeStartPost：ExecStart后运行</li>\n<li>ExecStop：指明停止unit要运行的命令或脚本</li>\n<li>Restart：当设定Restart&#x3D;1时，则当次daemon服务意外终止后，会在此自动启动此服务</li>\n</ul>\n<h2 id=\"Install段常用选项\"><a href=\"#Install段常用选项\" class=\"headerlink\" title=\"Install段常用选项\"></a>Install段常用选项</h2><ul>\n<li>Alias：别名(可使用systemctl command Alial.service)<br>RequiredBy:被那些units所依赖，强依赖<br>WantedBy：被那些units所依赖，弱依赖<br>Also：安装本服务的时候还要安装别的相关服务<br>注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载次配置文件，而后可以选择重启：<code>systemctl daemon-reload</code></li>\n</ul>\n"},{"title":"linux-内存管理","date":"2024-06-17T08:21:33.000Z","_content":"\n## 一、内存寻址\n\n## 1.内存地址\n\n### 逻辑地址(logical address)\n\n包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离\n\n### 线性地址（linear address）（也称虚拟地址  virtual address）\n\n是一个32位无符号整数，可以用来表示最高达4G的地址。线性地址通常用十六进制数字来表示，值的范围从0x0000 0000 到 0xffff ffff\n\n### 物理地址（physical address）\n\n用于内存芯片级内存单元寻址。它们与从处理器的地址引脚发送到内存总线的电信号相对应\n\n### 内存控制单元（MMU）\n\n通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址；接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换位一个物理地址\n\n逻辑地址--->`分页单元`--->线性地址--->`分页单元`--->物理地址\n\n\n\n分段：\n\nGDT\n\nLDT\n\n逻辑地址是段内的偏移\n\n能够跑最大进程数 = （256 - 4）/ 2 = 126个进程\n\n一个进程的逻辑地址 分配虚拟地址位64M\n\n所以可以分配的最大地址为126 * 64 = 8G\n\n但是0.11的内核规定最多为NR_TASKS=64\n\n所以线性地址为64*64 = 4G\n\n分段机制：逻辑地址 ---》线性地址\n\n分页机制：线性地址 ---》物理内存的映射\n\n在操作系统中有多个页目录表，但是当前使用的只有一个，并且这个页目录表存储地址在CR3寄存器中，表在head.S中被创建\n\n\n\n\n\n1.在运行应用程序的时候，是把所有的代码和数据全部加载到内存中么?如果不是那么在用到一些代码而这些代码不在内存中该怎么办?\n\n2.在fork一个进程的时候，我们完全的为子进程拷贝了父进程的内存空间，那么这个进程的拷贝\n是真的创建了两个完全一个的内存块在物理内存中么?如果不是那操作系统是怎么做的（写时拷贝)\n\n \n\n","source":"_posts/linux-内存管理.md","raw":"---\ntitle: linux-内存管理\ncategories:\n  - kernel\ntags:\n  - 内存管理\ndate: 2024-06-17 16:21:33\n---\n\n## 一、内存寻址\n\n## 1.内存地址\n\n### 逻辑地址(logical address)\n\n包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离\n\n### 线性地址（linear address）（也称虚拟地址  virtual address）\n\n是一个32位无符号整数，可以用来表示最高达4G的地址。线性地址通常用十六进制数字来表示，值的范围从0x0000 0000 到 0xffff ffff\n\n### 物理地址（physical address）\n\n用于内存芯片级内存单元寻址。它们与从处理器的地址引脚发送到内存总线的电信号相对应\n\n### 内存控制单元（MMU）\n\n通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址；接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换位一个物理地址\n\n逻辑地址--->`分页单元`--->线性地址--->`分页单元`--->物理地址\n\n\n\n分段：\n\nGDT\n\nLDT\n\n逻辑地址是段内的偏移\n\n能够跑最大进程数 = （256 - 4）/ 2 = 126个进程\n\n一个进程的逻辑地址 分配虚拟地址位64M\n\n所以可以分配的最大地址为126 * 64 = 8G\n\n但是0.11的内核规定最多为NR_TASKS=64\n\n所以线性地址为64*64 = 4G\n\n分段机制：逻辑地址 ---》线性地址\n\n分页机制：线性地址 ---》物理内存的映射\n\n在操作系统中有多个页目录表，但是当前使用的只有一个，并且这个页目录表存储地址在CR3寄存器中，表在head.S中被创建\n\n\n\n\n\n1.在运行应用程序的时候，是把所有的代码和数据全部加载到内存中么?如果不是那么在用到一些代码而这些代码不在内存中该怎么办?\n\n2.在fork一个进程的时候，我们完全的为子进程拷贝了父进程的内存空间，那么这个进程的拷贝\n是真的创建了两个完全一个的内存块在物理内存中么?如果不是那操作系统是怎么做的（写时拷贝)\n\n \n\n","slug":"linux-内存管理","published":1,"updated":"2024-06-18T11:33:54.019Z","_id":"clxkbblhq0000gjw08hd3guux","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、内存寻址\"><a href=\"#一、内存寻址\" class=\"headerlink\" title=\"一、内存寻址\"></a>一、内存寻址</h2><h2 id=\"1-内存地址\"><a href=\"#1-内存地址\" class=\"headerlink\" title=\"1.内存地址\"></a>1.内存地址</h2><h3 id=\"逻辑地址-logical-address\"><a href=\"#逻辑地址-logical-address\" class=\"headerlink\" title=\"逻辑地址(logical address)\"></a>逻辑地址(logical address)</h3><p>包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离</p>\n<h3 id=\"线性地址（linear-address）（也称虚拟地址-virtual-address）\"><a href=\"#线性地址（linear-address）（也称虚拟地址-virtual-address）\" class=\"headerlink\" title=\"线性地址（linear address）（也称虚拟地址  virtual address）\"></a>线性地址（linear address）（也称虚拟地址  virtual address）</h3><p>是一个32位无符号整数，可以用来表示最高达4G的地址。线性地址通常用十六进制数字来表示，值的范围从0x0000 0000 到 0xffff ffff</p>\n<h3 id=\"物理地址（physical-address）\"><a href=\"#物理地址（physical-address）\" class=\"headerlink\" title=\"物理地址（physical address）\"></a>物理地址（physical address）</h3><p>用于内存芯片级内存单元寻址。它们与从处理器的地址引脚发送到内存总线的电信号相对应</p>\n<h3 id=\"内存控制单元（MMU）\"><a href=\"#内存控制单元（MMU）\" class=\"headerlink\" title=\"内存控制单元（MMU）\"></a>内存控制单元（MMU）</h3><p>通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址；接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换位一个物理地址</p>\n<p>逻辑地址—&gt;<code>分页单元</code>—&gt;线性地址—&gt;<code>分页单元</code>—&gt;物理地址</p>\n<p>分段：</p>\n<p>GDT</p>\n<p>LDT</p>\n<p>逻辑地址是段内的偏移</p>\n<p>能够跑最大进程数 &#x3D; （256 - 4）&#x2F; 2 &#x3D; 126个进程</p>\n<p>一个进程的逻辑地址 分配虚拟地址位64M</p>\n<p>所以可以分配的最大地址为126 * 64 &#x3D; 8G</p>\n<p>但是0.11的内核规定最多为NR_TASKS&#x3D;64</p>\n<p>所以线性地址为64*64 &#x3D; 4G</p>\n<p>分段机制：逻辑地址 —》线性地址</p>\n<p>分页机制：线性地址 —》物理内存的映射</p>\n<p>在操作系统中有多个页目录表，但是当前使用的只有一个，并且这个页目录表存储地址在CR3寄存器中，表在head.S中被创建</p>\n<p>1.在运行应用程序的时候，是把所有的代码和数据全部加载到内存中么?如果不是那么在用到一些代码而这些代码不在内存中该怎么办?</p>\n<p>2.在fork一个进程的时候，我们完全的为子进程拷贝了父进程的内存空间，那么这个进程的拷贝<br>是真的创建了两个完全一个的内存块在物理内存中么?如果不是那操作系统是怎么做的（写时拷贝)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、内存寻址\"><a href=\"#一、内存寻址\" class=\"headerlink\" title=\"一、内存寻址\"></a>一、内存寻址</h2><h2 id=\"1-内存地址\"><a href=\"#1-内存地址\" class=\"headerlink\" title=\"1.内存地址\"></a>1.内存地址</h2><h3 id=\"逻辑地址-logical-address\"><a href=\"#逻辑地址-logical-address\" class=\"headerlink\" title=\"逻辑地址(logical address)\"></a>逻辑地址(logical address)</h3><p>包含在机器语言指令中用来指定一个操作数或一条指令的地址。每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离</p>\n<h3 id=\"线性地址（linear-address）（也称虚拟地址-virtual-address）\"><a href=\"#线性地址（linear-address）（也称虚拟地址-virtual-address）\" class=\"headerlink\" title=\"线性地址（linear address）（也称虚拟地址  virtual address）\"></a>线性地址（linear address）（也称虚拟地址  virtual address）</h3><p>是一个32位无符号整数，可以用来表示最高达4G的地址。线性地址通常用十六进制数字来表示，值的范围从0x0000 0000 到 0xffff ffff</p>\n<h3 id=\"物理地址（physical-address）\"><a href=\"#物理地址（physical-address）\" class=\"headerlink\" title=\"物理地址（physical address）\"></a>物理地址（physical address）</h3><p>用于内存芯片级内存单元寻址。它们与从处理器的地址引脚发送到内存总线的电信号相对应</p>\n<h3 id=\"内存控制单元（MMU）\"><a href=\"#内存控制单元（MMU）\" class=\"headerlink\" title=\"内存控制单元（MMU）\"></a>内存控制单元（MMU）</h3><p>通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址；接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换位一个物理地址</p>\n<p>逻辑地址—&gt;<code>分页单元</code>—&gt;线性地址—&gt;<code>分页单元</code>—&gt;物理地址</p>\n<p>分段：</p>\n<p>GDT</p>\n<p>LDT</p>\n<p>逻辑地址是段内的偏移</p>\n<p>能够跑最大进程数 &#x3D; （256 - 4）&#x2F; 2 &#x3D; 126个进程</p>\n<p>一个进程的逻辑地址 分配虚拟地址位64M</p>\n<p>所以可以分配的最大地址为126 * 64 &#x3D; 8G</p>\n<p>但是0.11的内核规定最多为NR_TASKS&#x3D;64</p>\n<p>所以线性地址为64*64 &#x3D; 4G</p>\n<p>分段机制：逻辑地址 —》线性地址</p>\n<p>分页机制：线性地址 —》物理内存的映射</p>\n<p>在操作系统中有多个页目录表，但是当前使用的只有一个，并且这个页目录表存储地址在CR3寄存器中，表在head.S中被创建</p>\n<p>1.在运行应用程序的时候，是把所有的代码和数据全部加载到内存中么?如果不是那么在用到一些代码而这些代码不在内存中该怎么办?</p>\n<p>2.在fork一个进程的时候，我们完全的为子进程拷贝了父进程的内存空间，那么这个进程的拷贝<br>是真的创建了两个完全一个的内存块在物理内存中么?如果不是那操作系统是怎么做的（写时拷贝)</p>\n"},{"title":"设备驱动-reversed-memory-预留内存","date":"2024-06-19T01:56:22.000Z","_content":"\nRESERVEDMEM_OF_DECLARE 对 dts 中预留的内存进行匹配和初始化\n\n在 include/linux/of_reserved_mem.h \n\n```\nstruct reserved_mem {\n\tconst char\t\t\t*name;\n\tunsigned long\t\t\tfdt_node;\n\tunsigned long\t\t\tphandle;\n\tconst struct reserved_mem_ops\t*ops;\n\tphys_addr_t\t\t\tbase;\n\tphys_addr_t\t\t\tsize;\n\tvoid\t\t\t\t*priv;\n};\n\nstruct reserved_mem_ops {\n\tint\t(*device_init)(struct reserved_mem *rmem,\n\t\t\t       struct device *dev);\n\tvoid\t(*device_release)(struct reserved_mem *rmem,\n\t\t\t\t  struct device *dev);\n};\n\ntypedef int (*reservedmem_of_init_fn)(struct reserved_mem *rmem);\n\n#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  \n\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)\n\n```\n\n## RESERVEDMEM_OF_DECLARE\n\nRESERVEDMEM_OF_DECLARE 在 include/linux/of_reserved_mem.h \n\n_OF_DECLARE 在 include/linux/of.h \n\n```\n\n#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  \n\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)\n//name 就是一个名称 ， 用来构建变量名称 \n//compat 是字符串，和 dts 中的 compatible  字符串匹配 \n//init 是一个函数 ， 这个函数 类型 需要 是  reservedmem_of_init_fn 这样的类型，即 返回 int , 参数为  reserved_mem 指针； \n\n#if defined(CONFIG_OF) && !defined(MODULE)\t//确保不是在内核模块中使用\n#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__used __section(\"__\" #table \"_of_table\")\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn  }\n#else\n#define _OF_DECLARE(table, name, compat, fn, fn_type)//如果是在内核模块中使用\t\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__attribute__((unused))\t\t\t\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn }\n#endif\n//构建一个 static 的 struct of_device_id  对象  __of_table__name  ，这个对象放在   __reservedmem_of_table   这个 section  里面 \n//对象的 compatible 赋值为  compat 字符串；   .data 赋值为  fn \n//(fn==(fn_type)NULL)?  这个 检查， 主要作用就是 检查  fn 函数 类型  是 fn_type 。 如果不是，编译就会报错 \n\n```\n\n示例：\n\n```\n\n.dts\n\n/{\n\treserved-memory {\n\t\t#address-cells = <0x2>;\n\t\t#size-cells = <0x2>;\n\t\tranges;\n\n\t\tminidump-elf-mem {\n\t\t\tcompatible = \"minidump-elf-reserved-memory\";\n\t\t\tno-map;\t//保留内存区域不应该被内核映射到虚拟地址空间，应用程序无法直接访问这块内存区域,它是专门留给内核使用的\n\t\t\tsize = <0x0 0x1300000>;\t//保留内存区域的大小\n\t\t\talignment = <0x0 0x100000>;\t//(1MB)对齐\n\t\t\talloc-ranges = <0x0 0x40000000 0x0 0x40000000>;\t//可以在物理地址范围0x40000000到0x80000000内分配\n\t\t};\n\t};\n};\n\n.c\n\nphys_addr_t g_mindump_ram_phy_base;\nEXPORT_SYMBOL(g_mindump_ram_phy_base);\nunsigned long g_mindump_ram_len;\nEXPORT_SYMBOL(g_mindump_ram_len);\n\nint reserve_memory_minidump_elf_fn(struct reserved_mem *rmem)\n{\n\tpr_info(DFT_TAG \"[W]%s: name: %s,base: 0x%llx,size: 0x%llx\\n\",\n\t\t__func__, rmem->name, (unsigned long long)rmem->base,\n\t\t(unsigned long long)rmem->size);\n\tg_mindump_ram_phy_base = rmem->base;\n\tg_mindump_ram_len = rmem->size;\n\treturn 0;\n}\n\nRESERVEDMEM_OF_DECLARE(minidump_elf_reserve_memory, \"minidump-elf-reserved-memory\",\n\t\t\treserve_memory_minidump_elf_fn);\n\t\t\t\n定义了 一个  \nstruct of_device_id    __of_device_minidump_elf_reserve_memory  =  {\n\t.compatible = \"minidump-elf-reserved-memory\" , \n\t.data = reserve_memory_minidump_elf_fn \n} ; \n```\n\n## dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数\n\n```\n setup_arch\n  --->arm64_memblock_init\n         --->early_init_fdt_scan_reserved_mem\n              --->fdt_init_reserved_mem\n                    --->__reserved_mem_init_node\n```\n\n### fdt_init_reserved_mem\n\ndrivers/of/of_reserved_mem.c\n\n```\nvoid __init fdt_init_reserved_mem(void)\n{\n\tint i;\n\n\t/* check for overlapping reserved regions */\n\t__rmem_check_for_overlap();\n\n\tfor (i = 0; i < reserved_mem_count; i++) {\t//处理每一块 reserved memory \n\t\tstruct reserved_mem *rmem = &reserved_mem[i];\n\t\tunsigned long node = rmem->fdt_node;\n\t\tint len;\n\t\tconst __be32 *prop;\n\t\tint err = 0;\n\t\tbool nomap;\n\n\t\tnomap = of_get_flat_dt_prop(node, \"no-map\", NULL) != NULL;\n\t\tprop = of_get_flat_dt_prop(node, \"phandle\", &len);\n\t\tif (!prop)\n\t\t\tprop = of_get_flat_dt_prop(node, \"linux,phandle\", &len);\n\t\tif (prop)\n\t\t\trmem->phandle = of_read_number(prop, len/4);\n\n\t\tif (rmem->size == 0) //如果还没有为 node 预留内存，则使用  __reserved_mem_alloc_size ，继续解析 node 的 dts 中的 参数，预留内存。\n\t\t\terr = __reserved_mem_alloc_size(node, rmem->name,\n\t\t\t\t\t\t &rmem->base, &rmem->size);\n\t\tif (err == 0) { //说明预留内存成功， 对预留的这部分内存   调用 __reserved_mem_init_node 函数（下面详述） \n\t\t\terr = __reserved_mem_init_node(rmem);\n\t\t\tif (err != 0 && err != -ENOENT) {\t// 如果 __reserved_mem init node 失败了， 则需要释放 预留的这部分内存 先 memblock free \n\t\t\t\tpr_info(\"node %s compatible matching fail\\n\",\n\t\t\t\t\trmem->name);\n\t\t\t\tmemblock_free(rmem->base, rmem->size);\n\t\t\t\tif (nomap)\t\t\t\t\t\t//如果 有 nomap 属性，则还需要进一步把这块内存 add 到 memblock 的memory type 的 链表中\n\t\t\t\t\tmemblock_add(rmem->base, rmem->size);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n###  __reserved_mem_init_node \n\ndrivers/of/of_reserved_mem.c\n\n```\nstatic int __init __reserved_mem_init_node(struct reserved_mem *rmem)\n{\n\textern const struct of_device_id __reservedmem_of_table[];\n\tconst struct of_device_id *i;\n\tint ret = -ENOENT;\n\n\tfor (i = __reservedmem_of_table; i < &__rmem_of_table_sentinel; i++) {\n\t\t//对 rmem ，遍历    __reservedmem_of_table   这个 section  里面 的所有 of_device_id  对象 \n\t\treservedmem_of_init_fn initfn = i->data;\n\t\tconst char *compat = i->compatible;\n\t\t// rmem 的 fdt_node 和  of_device_id 对象的 compat  （char * 字符串）   进行匹配 \n\t\tif (!of_flat_dt_is_compatible(rmem->fdt_node, compat))\n\t\t\tcontinue;\n\t\t//匹配成功，调用 of_device_id 的 data 字段 里面存放的函数 。 initfn( rmem )\n\t\tret = initfn(rmem);\n\t\tif (ret == 0) {\n\t\t\tpr_info(\"initialized node %s, compatible id %s\\n\",\n\t\t\t\trmem->name, compat);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n```\n\ndts 中，通常使用 memory-region 将设备和 reserved memory 关联起来，如下：\n\n![img](../imgs/2704972-20220410142315999-1415044429.jpg)\n\n fb0 通过 memory-region 关联到 display_reserved 这块 reserved memory 上面；\n\n## of_reserved_mem_device_init\n\ninclude/linux/of_reserved_mem.h \n\n传入参数 dev， 找到 dev 中 memory-region 对应的 reserved memory .\n\n然后调用 reserved_memory 对象的 ops->device_init( reserved_memory * rmem, device * dev );\n\n```\nstatic inline int of_reserved_mem_device_init(struct device *dev)\n{\n\treturn of_reserved_mem_device_init_by_idx(dev, dev->of_node, 0);\n}\n```\n\n## of_reserved_mem_device_init_by_idx \n\n从 of_reserved_mem_device_init 进入时，dev , dev_node, idx = 0 ;\n\n```\nint of_reserved_mem_device_init_by_idx(struct device *dev,\n\t\t\t\t       struct device_node *np, int idx)\n{\n\tstruct rmem_assigned_device *rd;\n\tstruct device_node *target;\n\tstruct reserved_mem *rmem;\n\tint ret;\n\n\tif (!np || !dev)\n\t\treturn -EINVAL;\n\n\ttarget = of_parse_phandle(np, \"memory-region\", idx); //通过 memory-region 找对应的 reserved memory \n\tif (!target)\n\t\treturn -ENODEV;\n\n\tif (!of_device_is_available(target)) {\n\t\tof_node_put(target);\n\t\treturn 0;\n\t}\n\n\trmem = __find_rmem(target);\n\tof_node_put(target);\n\n\tif (!rmem || !rmem->ops || !rmem->ops->device_init) //检查 有 rmem->ops   rmem->ops->device_init 函数 \n\t\treturn -EINVAL;\n\n\trd = kmalloc(sizeof(struct rmem_assigned_device), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\tret = rmem->ops->device_init(rmem, dev); //调用  rmem->ops->device_init(rmem, dev) \n\tif (ret == 0) { \t\t\t\t\t\t//成功的话，就 将 建立的对象 reserved_memory_device \n\t\trd->dev = dev; \n\t\trd->rmem = rmem;\n\n\t\tmutex_lock(&of_rmem_assigned_device_mutex);\n\t\tlist_add(&rd->list, &of_rmem_assigned_device_list);//加入到  of_rmem_assigned_device_list 里面 ,记录 rmem 分配到 device 里面\n\t\tmutex_unlock(&of_rmem_assigned_device_mutex);\n\n\t\tdev_info(dev, \"assigned reserved memory node %s\\n\", rmem->name);\n\t} else {\n\t\tkfree(rd);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);\n```\n","source":"_posts/设备驱动-reversed-memory-预留内存.md","raw":"---\ntitle: 设备驱动-reversed-memory-预留内存\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-06-19 09:56:22\n---\n\nRESERVEDMEM_OF_DECLARE 对 dts 中预留的内存进行匹配和初始化\n\n在 include/linux/of_reserved_mem.h \n\n```\nstruct reserved_mem {\n\tconst char\t\t\t*name;\n\tunsigned long\t\t\tfdt_node;\n\tunsigned long\t\t\tphandle;\n\tconst struct reserved_mem_ops\t*ops;\n\tphys_addr_t\t\t\tbase;\n\tphys_addr_t\t\t\tsize;\n\tvoid\t\t\t\t*priv;\n};\n\nstruct reserved_mem_ops {\n\tint\t(*device_init)(struct reserved_mem *rmem,\n\t\t\t       struct device *dev);\n\tvoid\t(*device_release)(struct reserved_mem *rmem,\n\t\t\t\t  struct device *dev);\n};\n\ntypedef int (*reservedmem_of_init_fn)(struct reserved_mem *rmem);\n\n#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  \n\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)\n\n```\n\n## RESERVEDMEM_OF_DECLARE\n\nRESERVEDMEM_OF_DECLARE 在 include/linux/of_reserved_mem.h \n\n_OF_DECLARE 在 include/linux/of.h \n\n```\n\n#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  \n\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)\n//name 就是一个名称 ， 用来构建变量名称 \n//compat 是字符串，和 dts 中的 compatible  字符串匹配 \n//init 是一个函数 ， 这个函数 类型 需要 是  reservedmem_of_init_fn 这样的类型，即 返回 int , 参数为  reserved_mem 指针； \n\n#if defined(CONFIG_OF) && !defined(MODULE)\t//确保不是在内核模块中使用\n#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__used __section(\"__\" #table \"_of_table\")\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn  }\n#else\n#define _OF_DECLARE(table, name, compat, fn, fn_type)//如果是在内核模块中使用\t\t\t\\\n\tstatic const struct of_device_id __of_table_##name\t\t\\\n\t\t__attribute__((unused))\t\t\t\t\t\\\n\t\t = { .compatible = compat,\t\t\t\t\\\n\t\t     .data = (fn == (fn_type)NULL) ? fn : fn }\n#endif\n//构建一个 static 的 struct of_device_id  对象  __of_table__name  ，这个对象放在   __reservedmem_of_table   这个 section  里面 \n//对象的 compatible 赋值为  compat 字符串；   .data 赋值为  fn \n//(fn==(fn_type)NULL)?  这个 检查， 主要作用就是 检查  fn 函数 类型  是 fn_type 。 如果不是，编译就会报错 \n\n```\n\n示例：\n\n```\n\n.dts\n\n/{\n\treserved-memory {\n\t\t#address-cells = <0x2>;\n\t\t#size-cells = <0x2>;\n\t\tranges;\n\n\t\tminidump-elf-mem {\n\t\t\tcompatible = \"minidump-elf-reserved-memory\";\n\t\t\tno-map;\t//保留内存区域不应该被内核映射到虚拟地址空间，应用程序无法直接访问这块内存区域,它是专门留给内核使用的\n\t\t\tsize = <0x0 0x1300000>;\t//保留内存区域的大小\n\t\t\talignment = <0x0 0x100000>;\t//(1MB)对齐\n\t\t\talloc-ranges = <0x0 0x40000000 0x0 0x40000000>;\t//可以在物理地址范围0x40000000到0x80000000内分配\n\t\t};\n\t};\n};\n\n.c\n\nphys_addr_t g_mindump_ram_phy_base;\nEXPORT_SYMBOL(g_mindump_ram_phy_base);\nunsigned long g_mindump_ram_len;\nEXPORT_SYMBOL(g_mindump_ram_len);\n\nint reserve_memory_minidump_elf_fn(struct reserved_mem *rmem)\n{\n\tpr_info(DFT_TAG \"[W]%s: name: %s,base: 0x%llx,size: 0x%llx\\n\",\n\t\t__func__, rmem->name, (unsigned long long)rmem->base,\n\t\t(unsigned long long)rmem->size);\n\tg_mindump_ram_phy_base = rmem->base;\n\tg_mindump_ram_len = rmem->size;\n\treturn 0;\n}\n\nRESERVEDMEM_OF_DECLARE(minidump_elf_reserve_memory, \"minidump-elf-reserved-memory\",\n\t\t\treserve_memory_minidump_elf_fn);\n\t\t\t\n定义了 一个  \nstruct of_device_id    __of_device_minidump_elf_reserve_memory  =  {\n\t.compatible = \"minidump-elf-reserved-memory\" , \n\t.data = reserve_memory_minidump_elf_fn \n} ; \n```\n\n## dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数\n\n```\n setup_arch\n  --->arm64_memblock_init\n         --->early_init_fdt_scan_reserved_mem\n              --->fdt_init_reserved_mem\n                    --->__reserved_mem_init_node\n```\n\n### fdt_init_reserved_mem\n\ndrivers/of/of_reserved_mem.c\n\n```\nvoid __init fdt_init_reserved_mem(void)\n{\n\tint i;\n\n\t/* check for overlapping reserved regions */\n\t__rmem_check_for_overlap();\n\n\tfor (i = 0; i < reserved_mem_count; i++) {\t//处理每一块 reserved memory \n\t\tstruct reserved_mem *rmem = &reserved_mem[i];\n\t\tunsigned long node = rmem->fdt_node;\n\t\tint len;\n\t\tconst __be32 *prop;\n\t\tint err = 0;\n\t\tbool nomap;\n\n\t\tnomap = of_get_flat_dt_prop(node, \"no-map\", NULL) != NULL;\n\t\tprop = of_get_flat_dt_prop(node, \"phandle\", &len);\n\t\tif (!prop)\n\t\t\tprop = of_get_flat_dt_prop(node, \"linux,phandle\", &len);\n\t\tif (prop)\n\t\t\trmem->phandle = of_read_number(prop, len/4);\n\n\t\tif (rmem->size == 0) //如果还没有为 node 预留内存，则使用  __reserved_mem_alloc_size ，继续解析 node 的 dts 中的 参数，预留内存。\n\t\t\terr = __reserved_mem_alloc_size(node, rmem->name,\n\t\t\t\t\t\t &rmem->base, &rmem->size);\n\t\tif (err == 0) { //说明预留内存成功， 对预留的这部分内存   调用 __reserved_mem_init_node 函数（下面详述） \n\t\t\terr = __reserved_mem_init_node(rmem);\n\t\t\tif (err != 0 && err != -ENOENT) {\t// 如果 __reserved_mem init node 失败了， 则需要释放 预留的这部分内存 先 memblock free \n\t\t\t\tpr_info(\"node %s compatible matching fail\\n\",\n\t\t\t\t\trmem->name);\n\t\t\t\tmemblock_free(rmem->base, rmem->size);\n\t\t\t\tif (nomap)\t\t\t\t\t\t//如果 有 nomap 属性，则还需要进一步把这块内存 add 到 memblock 的memory type 的 链表中\n\t\t\t\t\tmemblock_add(rmem->base, rmem->size);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n###  __reserved_mem_init_node \n\ndrivers/of/of_reserved_mem.c\n\n```\nstatic int __init __reserved_mem_init_node(struct reserved_mem *rmem)\n{\n\textern const struct of_device_id __reservedmem_of_table[];\n\tconst struct of_device_id *i;\n\tint ret = -ENOENT;\n\n\tfor (i = __reservedmem_of_table; i < &__rmem_of_table_sentinel; i++) {\n\t\t//对 rmem ，遍历    __reservedmem_of_table   这个 section  里面 的所有 of_device_id  对象 \n\t\treservedmem_of_init_fn initfn = i->data;\n\t\tconst char *compat = i->compatible;\n\t\t// rmem 的 fdt_node 和  of_device_id 对象的 compat  （char * 字符串）   进行匹配 \n\t\tif (!of_flat_dt_is_compatible(rmem->fdt_node, compat))\n\t\t\tcontinue;\n\t\t//匹配成功，调用 of_device_id 的 data 字段 里面存放的函数 。 initfn( rmem )\n\t\tret = initfn(rmem);\n\t\tif (ret == 0) {\n\t\t\tpr_info(\"initialized node %s, compatible id %s\\n\",\n\t\t\t\trmem->name, compat);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n```\n\ndts 中，通常使用 memory-region 将设备和 reserved memory 关联起来，如下：\n\n![img](../imgs/2704972-20220410142315999-1415044429.jpg)\n\n fb0 通过 memory-region 关联到 display_reserved 这块 reserved memory 上面；\n\n## of_reserved_mem_device_init\n\ninclude/linux/of_reserved_mem.h \n\n传入参数 dev， 找到 dev 中 memory-region 对应的 reserved memory .\n\n然后调用 reserved_memory 对象的 ops->device_init( reserved_memory * rmem, device * dev );\n\n```\nstatic inline int of_reserved_mem_device_init(struct device *dev)\n{\n\treturn of_reserved_mem_device_init_by_idx(dev, dev->of_node, 0);\n}\n```\n\n## of_reserved_mem_device_init_by_idx \n\n从 of_reserved_mem_device_init 进入时，dev , dev_node, idx = 0 ;\n\n```\nint of_reserved_mem_device_init_by_idx(struct device *dev,\n\t\t\t\t       struct device_node *np, int idx)\n{\n\tstruct rmem_assigned_device *rd;\n\tstruct device_node *target;\n\tstruct reserved_mem *rmem;\n\tint ret;\n\n\tif (!np || !dev)\n\t\treturn -EINVAL;\n\n\ttarget = of_parse_phandle(np, \"memory-region\", idx); //通过 memory-region 找对应的 reserved memory \n\tif (!target)\n\t\treturn -ENODEV;\n\n\tif (!of_device_is_available(target)) {\n\t\tof_node_put(target);\n\t\treturn 0;\n\t}\n\n\trmem = __find_rmem(target);\n\tof_node_put(target);\n\n\tif (!rmem || !rmem->ops || !rmem->ops->device_init) //检查 有 rmem->ops   rmem->ops->device_init 函数 \n\t\treturn -EINVAL;\n\n\trd = kmalloc(sizeof(struct rmem_assigned_device), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\tret = rmem->ops->device_init(rmem, dev); //调用  rmem->ops->device_init(rmem, dev) \n\tif (ret == 0) { \t\t\t\t\t\t//成功的话，就 将 建立的对象 reserved_memory_device \n\t\trd->dev = dev; \n\t\trd->rmem = rmem;\n\n\t\tmutex_lock(&of_rmem_assigned_device_mutex);\n\t\tlist_add(&rd->list, &of_rmem_assigned_device_list);//加入到  of_rmem_assigned_device_list 里面 ,记录 rmem 分配到 device 里面\n\t\tmutex_unlock(&of_rmem_assigned_device_mutex);\n\n\t\tdev_info(dev, \"assigned reserved memory node %s\\n\", rmem->name);\n\t} else {\n\t\tkfree(rd);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);\n```\n","slug":"设备驱动-reversed-memory-预留内存","published":1,"updated":"2024-06-19T08:30:39.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxlkqk1600008iw06by4bx94","content":"<p>RESERVEDMEM_OF_DECLARE 对 dts 中预留的内存进行匹配和初始化</p>\n<p>在 include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct reserved_mem &#123;</span><br><span class=\"line\">\tconst char\t\t\t*name;</span><br><span class=\"line\">\tunsigned long\t\t\tfdt_node;</span><br><span class=\"line\">\tunsigned long\t\t\tphandle;</span><br><span class=\"line\">\tconst struct reserved_mem_ops\t*ops;</span><br><span class=\"line\">\tphys_addr_t\t\t\tbase;</span><br><span class=\"line\">\tphys_addr_t\t\t\tsize;</span><br><span class=\"line\">\tvoid\t\t\t\t*priv;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct reserved_mem_ops &#123;</span><br><span class=\"line\">\tint\t(*device_init)(struct reserved_mem *rmem,</span><br><span class=\"line\">\t\t\t       struct device *dev);</span><br><span class=\"line\">\tvoid\t(*device_release)(struct reserved_mem *rmem,</span><br><span class=\"line\">\t\t\t\t  struct device *dev);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef int (*reservedmem_of_init_fn)(struct reserved_mem *rmem);</span><br><span class=\"line\"></span><br><span class=\"line\">#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  </span><br><span class=\"line\">\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RESERVEDMEM-OF-DECLARE\"><a href=\"#RESERVEDMEM-OF-DECLARE\" class=\"headerlink\" title=\"RESERVEDMEM_OF_DECLARE\"></a>RESERVEDMEM_OF_DECLARE</h2><p>RESERVEDMEM_OF_DECLARE 在 include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<p>_OF_DECLARE 在 include&#x2F;linux&#x2F;of.h </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  </span><br><span class=\"line\">\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)</span><br><span class=\"line\">//name 就是一个名称 ， 用来构建变量名称 </span><br><span class=\"line\">//compat 是字符串，和 dts 中的 compatible  字符串匹配 </span><br><span class=\"line\">//init 是一个函数 ， 这个函数 类型 需要 是  reservedmem_of_init_fn 这样的类型，即 返回 int , 参数为  reserved_mem 指针； </span><br><span class=\"line\"></span><br><span class=\"line\">#if defined(CONFIG_OF) &amp;&amp; !defined(MODULE)\t//确保不是在内核模块中使用</span><br><span class=\"line\">#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\</span><br><span class=\"line\">\tstatic const struct of_device_id __of_table_##name\t\t\\</span><br><span class=\"line\">\t\t__used __section(&quot;__&quot; #table &quot;_of_table&quot;)\t\t\\</span><br><span class=\"line\">\t\t = &#123; .compatible = compat,\t\t\t\t\\</span><br><span class=\"line\">\t\t     .data = (fn == (fn_type)NULL) ? fn : fn  &#125;</span><br><span class=\"line\">#else</span><br><span class=\"line\">#define _OF_DECLARE(table, name, compat, fn, fn_type)//如果是在内核模块中使用\t\t\t\\</span><br><span class=\"line\">\tstatic const struct of_device_id __of_table_##name\t\t\\</span><br><span class=\"line\">\t\t__attribute__((unused))\t\t\t\t\t\\</span><br><span class=\"line\">\t\t = &#123; .compatible = compat,\t\t\t\t\\</span><br><span class=\"line\">\t\t     .data = (fn == (fn_type)NULL) ? fn : fn &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">//构建一个 static 的 struct of_device_id  对象  __of_table__name  ，这个对象放在   __reservedmem_of_table   这个 section  里面 </span><br><span class=\"line\">//对象的 compatible 赋值为  compat 字符串；   .data 赋值为  fn </span><br><span class=\"line\">//(fn==(fn_type)NULL)?  这个 检查， 主要作用就是 检查  fn 函数 类型  是 fn_type 。 如果不是，编译就会报错 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.dts</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;</span><br><span class=\"line\">\treserved-memory &#123;</span><br><span class=\"line\">\t\t#address-cells = &lt;0x2&gt;;</span><br><span class=\"line\">\t\t#size-cells = &lt;0x2&gt;;</span><br><span class=\"line\">\t\tranges;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tminidump-elf-mem &#123;</span><br><span class=\"line\">\t\t\tcompatible = &quot;minidump-elf-reserved-memory&quot;;</span><br><span class=\"line\">\t\t\tno-map;\t//保留内存区域不应该被内核映射到虚拟地址空间，应用程序无法直接访问这块内存区域,它是专门留给内核使用的</span><br><span class=\"line\">\t\t\tsize = &lt;0x0 0x1300000&gt;;\t//保留内存区域的大小</span><br><span class=\"line\">\t\t\talignment = &lt;0x0 0x100000&gt;;\t//(1MB)对齐</span><br><span class=\"line\">\t\t\talloc-ranges = &lt;0x0 0x40000000 0x0 0x40000000&gt;;\t//可以在物理地址范围0x40000000到0x80000000内分配</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">.c</span><br><span class=\"line\"></span><br><span class=\"line\">phys_addr_t g_mindump_ram_phy_base;</span><br><span class=\"line\">EXPORT_SYMBOL(g_mindump_ram_phy_base);</span><br><span class=\"line\">unsigned long g_mindump_ram_len;</span><br><span class=\"line\">EXPORT_SYMBOL(g_mindump_ram_len);</span><br><span class=\"line\"></span><br><span class=\"line\">int reserve_memory_minidump_elf_fn(struct reserved_mem *rmem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpr_info(DFT_TAG &quot;[W]%s: name: %s,base: 0x%llx,size: 0x%llx\\n&quot;,</span><br><span class=\"line\">\t\t__func__, rmem-&gt;name, (unsigned long long)rmem-&gt;base,</span><br><span class=\"line\">\t\t(unsigned long long)rmem-&gt;size);</span><br><span class=\"line\">\tg_mindump_ram_phy_base = rmem-&gt;base;</span><br><span class=\"line\">\tg_mindump_ram_len = rmem-&gt;size;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">RESERVEDMEM_OF_DECLARE(minidump_elf_reserve_memory, &quot;minidump-elf-reserved-memory&quot;,</span><br><span class=\"line\">\t\t\treserve_memory_minidump_elf_fn);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">定义了 一个  </span><br><span class=\"line\">struct of_device_id    __of_device_minidump_elf_reserve_memory  =  &#123;</span><br><span class=\"line\">\t.compatible = &quot;minidump-elf-reserved-memory&quot; , </span><br><span class=\"line\">\t.data = reserve_memory_minidump_elf_fn </span><br><span class=\"line\">&#125; ; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"dts-中reserved-memory-解析和调用匹配的-of-device-id-的-data-函数\"><a href=\"#dts-中reserved-memory-解析和调用匹配的-of-device-id-的-data-函数\" class=\"headerlink\" title=\"dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数\"></a>dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup_arch</span><br><span class=\"line\"> ---&gt;arm64_memblock_init</span><br><span class=\"line\">        ---&gt;early_init_fdt_scan_reserved_mem</span><br><span class=\"line\">             ---&gt;fdt_init_reserved_mem</span><br><span class=\"line\">                   ---&gt;__reserved_mem_init_node</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fdt-init-reserved-mem\"><a href=\"#fdt-init-reserved-mem\" class=\"headerlink\" title=\"fdt_init_reserved_mem\"></a>fdt_init_reserved_mem</h3><p>drivers&#x2F;of&#x2F;of_reserved_mem.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void __init fdt_init_reserved_mem(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/* check for overlapping reserved regions */</span><br><span class=\"line\">\t__rmem_check_for_overlap();</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (i = 0; i &lt; reserved_mem_count; i++) &#123;\t//处理每一块 reserved memory </span><br><span class=\"line\">\t\tstruct reserved_mem *rmem = &amp;reserved_mem[i];</span><br><span class=\"line\">\t\tunsigned long node = rmem-&gt;fdt_node;</span><br><span class=\"line\">\t\tint len;</span><br><span class=\"line\">\t\tconst __be32 *prop;</span><br><span class=\"line\">\t\tint err = 0;</span><br><span class=\"line\">\t\tbool nomap;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnomap = of_get_flat_dt_prop(node, &quot;no-map&quot;, NULL) != NULL;</span><br><span class=\"line\">\t\tprop = of_get_flat_dt_prop(node, &quot;phandle&quot;, &amp;len);</span><br><span class=\"line\">\t\tif (!prop)</span><br><span class=\"line\">\t\t\tprop = of_get_flat_dt_prop(node, &quot;linux,phandle&quot;, &amp;len);</span><br><span class=\"line\">\t\tif (prop)</span><br><span class=\"line\">\t\t\trmem-&gt;phandle = of_read_number(prop, len/4);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (rmem-&gt;size == 0) //如果还没有为 node 预留内存，则使用  __reserved_mem_alloc_size ，继续解析 node 的 dts 中的 参数，预留内存。</span><br><span class=\"line\">\t\t\terr = __reserved_mem_alloc_size(node, rmem-&gt;name,</span><br><span class=\"line\">\t\t\t\t\t\t &amp;rmem-&gt;base, &amp;rmem-&gt;size);</span><br><span class=\"line\">\t\tif (err == 0) &#123; //说明预留内存成功， 对预留的这部分内存   调用 __reserved_mem_init_node 函数（下面详述） </span><br><span class=\"line\">\t\t\terr = __reserved_mem_init_node(rmem);</span><br><span class=\"line\">\t\t\tif (err != 0 &amp;&amp; err != -ENOENT) &#123;\t// 如果 __reserved_mem init node 失败了， 则需要释放 预留的这部分内存 先 memblock free </span><br><span class=\"line\">\t\t\t\tpr_info(&quot;node %s compatible matching fail\\n&quot;,</span><br><span class=\"line\">\t\t\t\t\trmem-&gt;name);</span><br><span class=\"line\">\t\t\t\tmemblock_free(rmem-&gt;base, rmem-&gt;size);</span><br><span class=\"line\">\t\t\t\tif (nomap)\t\t\t\t\t\t//如果 有 nomap 属性，则还需要进一步把这块内存 add 到 memblock 的memory type 的 链表中</span><br><span class=\"line\">\t\t\t\t\tmemblock_add(rmem-&gt;base, rmem-&gt;size);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reserved-mem-init-node\"><a href=\"#reserved-mem-init-node\" class=\"headerlink\" title=\"__reserved_mem_init_node\"></a>__reserved_mem_init_node</h3><p>drivers&#x2F;of&#x2F;of_reserved_mem.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int __init __reserved_mem_init_node(struct reserved_mem *rmem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\textern const struct of_device_id __reservedmem_of_table[];</span><br><span class=\"line\">\tconst struct of_device_id *i;</span><br><span class=\"line\">\tint ret = -ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (i = __reservedmem_of_table; i &lt; &amp;__rmem_of_table_sentinel; i++) &#123;</span><br><span class=\"line\">\t\t//对 rmem ，遍历    __reservedmem_of_table   这个 section  里面 的所有 of_device_id  对象 </span><br><span class=\"line\">\t\treservedmem_of_init_fn initfn = i-&gt;data;</span><br><span class=\"line\">\t\tconst char *compat = i-&gt;compatible;</span><br><span class=\"line\">\t\t// rmem 的 fdt_node 和  of_device_id 对象的 compat  （char * 字符串）   进行匹配 </span><br><span class=\"line\">\t\tif (!of_flat_dt_is_compatible(rmem-&gt;fdt_node, compat))</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t//匹配成功，调用 of_device_id 的 data 字段 里面存放的函数 。 initfn( rmem )</span><br><span class=\"line\">\t\tret = initfn(rmem);</span><br><span class=\"line\">\t\tif (ret == 0) &#123;</span><br><span class=\"line\">\t\t\tpr_info(&quot;initialized node %s, compatible id %s\\n&quot;,</span><br><span class=\"line\">\t\t\t\trmem-&gt;name, compat);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>dts 中，通常使用 memory-region 将设备和 reserved memory 关联起来，如下：</p>\n<p><img src=\"/../imgs/2704972-20220410142315999-1415044429.jpg\" alt=\"img\"></p>\n<p> fb0 通过 memory-region 关联到 display_reserved 这块 reserved memory 上面；</p>\n<h2 id=\"of-reserved-mem-device-init\"><a href=\"#of-reserved-mem-device-init\" class=\"headerlink\" title=\"of_reserved_mem_device_init\"></a>of_reserved_mem_device_init</h2><p>include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<p>传入参数 dev， 找到 dev 中 memory-region 对应的 reserved memory .</p>\n<p>然后调用 reserved_memory 对象的 ops-&gt;device_init( reserved_memory * rmem, device * dev );</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline int of_reserved_mem_device_init(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn of_reserved_mem_device_init_by_idx(dev, dev-&gt;of_node, 0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"of-reserved-mem-device-init-by-idx\"><a href=\"#of-reserved-mem-device-init-by-idx\" class=\"headerlink\" title=\"of_reserved_mem_device_init_by_idx\"></a>of_reserved_mem_device_init_by_idx</h2><p>从 of_reserved_mem_device_init 进入时，dev , dev_node, idx &#x3D; 0 ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int of_reserved_mem_device_init_by_idx(struct device *dev,</span><br><span class=\"line\">\t\t\t\t       struct device_node *np, int idx)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstruct rmem_assigned_device *rd;</span><br><span class=\"line\">\tstruct device_node *target;</span><br><span class=\"line\">\tstruct reserved_mem *rmem;</span><br><span class=\"line\">\tint ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!np || !dev)</span><br><span class=\"line\">\t\treturn -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttarget = of_parse_phandle(np, &quot;memory-region&quot;, idx); //通过 memory-region 找对应的 reserved memory </span><br><span class=\"line\">\tif (!target)</span><br><span class=\"line\">\t\treturn -ENODEV;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!of_device_is_available(target)) &#123;</span><br><span class=\"line\">\t\tof_node_put(target);</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trmem = __find_rmem(target);</span><br><span class=\"line\">\tof_node_put(target);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!rmem || !rmem-&gt;ops || !rmem-&gt;ops-&gt;device_init) //检查 有 rmem-&gt;ops   rmem-&gt;ops-&gt;device_init 函数 </span><br><span class=\"line\">\t\treturn -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\trd = kmalloc(sizeof(struct rmem_assigned_device), GFP_KERNEL);</span><br><span class=\"line\">\tif (!rd)</span><br><span class=\"line\">\t\treturn -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = rmem-&gt;ops-&gt;device_init(rmem, dev); //调用  rmem-&gt;ops-&gt;device_init(rmem, dev) </span><br><span class=\"line\">\tif (ret == 0) &#123; \t\t\t\t\t\t//成功的话，就 将 建立的对象 reserved_memory_device </span><br><span class=\"line\">\t\trd-&gt;dev = dev; </span><br><span class=\"line\">\t\trd-&gt;rmem = rmem;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmutex_lock(&amp;of_rmem_assigned_device_mutex);</span><br><span class=\"line\">\t\tlist_add(&amp;rd-&gt;list, &amp;of_rmem_assigned_device_list);//加入到  of_rmem_assigned_device_list 里面 ,记录 rmem 分配到 device 里面</span><br><span class=\"line\">\t\tmutex_unlock(&amp;of_rmem_assigned_device_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdev_info(dev, &quot;assigned reserved memory node %s\\n&quot;, rmem-&gt;name);</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tkfree(rd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>RESERVEDMEM_OF_DECLARE 对 dts 中预留的内存进行匹配和初始化</p>\n<p>在 include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct reserved_mem &#123;</span><br><span class=\"line\">\tconst char\t\t\t*name;</span><br><span class=\"line\">\tunsigned long\t\t\tfdt_node;</span><br><span class=\"line\">\tunsigned long\t\t\tphandle;</span><br><span class=\"line\">\tconst struct reserved_mem_ops\t*ops;</span><br><span class=\"line\">\tphys_addr_t\t\t\tbase;</span><br><span class=\"line\">\tphys_addr_t\t\t\tsize;</span><br><span class=\"line\">\tvoid\t\t\t\t*priv;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct reserved_mem_ops &#123;</span><br><span class=\"line\">\tint\t(*device_init)(struct reserved_mem *rmem,</span><br><span class=\"line\">\t\t\t       struct device *dev);</span><br><span class=\"line\">\tvoid\t(*device_release)(struct reserved_mem *rmem,</span><br><span class=\"line\">\t\t\t\t  struct device *dev);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef int (*reservedmem_of_init_fn)(struct reserved_mem *rmem);</span><br><span class=\"line\"></span><br><span class=\"line\">#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  </span><br><span class=\"line\">\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RESERVEDMEM-OF-DECLARE\"><a href=\"#RESERVEDMEM-OF-DECLARE\" class=\"headerlink\" title=\"RESERVEDMEM_OF_DECLARE\"></a>RESERVEDMEM_OF_DECLARE</h2><p>RESERVEDMEM_OF_DECLARE 在 include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<p>_OF_DECLARE 在 include&#x2F;linux&#x2F;of.h </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#define RESERVEDMEM_OF_DECLARE(name, compat, init)\t\t\t\\  </span><br><span class=\"line\">\t_OF_DECLARE(reservedmem, name, compat, init, reservedmem_of_init_fn)</span><br><span class=\"line\">//name 就是一个名称 ， 用来构建变量名称 </span><br><span class=\"line\">//compat 是字符串，和 dts 中的 compatible  字符串匹配 </span><br><span class=\"line\">//init 是一个函数 ， 这个函数 类型 需要 是  reservedmem_of_init_fn 这样的类型，即 返回 int , 参数为  reserved_mem 指针； </span><br><span class=\"line\"></span><br><span class=\"line\">#if defined(CONFIG_OF) &amp;&amp; !defined(MODULE)\t//确保不是在内核模块中使用</span><br><span class=\"line\">#define _OF_DECLARE(table, name, compat, fn, fn_type)\t\t\t\\</span><br><span class=\"line\">\tstatic const struct of_device_id __of_table_##name\t\t\\</span><br><span class=\"line\">\t\t__used __section(&quot;__&quot; #table &quot;_of_table&quot;)\t\t\\</span><br><span class=\"line\">\t\t = &#123; .compatible = compat,\t\t\t\t\\</span><br><span class=\"line\">\t\t     .data = (fn == (fn_type)NULL) ? fn : fn  &#125;</span><br><span class=\"line\">#else</span><br><span class=\"line\">#define _OF_DECLARE(table, name, compat, fn, fn_type)//如果是在内核模块中使用\t\t\t\\</span><br><span class=\"line\">\tstatic const struct of_device_id __of_table_##name\t\t\\</span><br><span class=\"line\">\t\t__attribute__((unused))\t\t\t\t\t\\</span><br><span class=\"line\">\t\t = &#123; .compatible = compat,\t\t\t\t\\</span><br><span class=\"line\">\t\t     .data = (fn == (fn_type)NULL) ? fn : fn &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">//构建一个 static 的 struct of_device_id  对象  __of_table__name  ，这个对象放在   __reservedmem_of_table   这个 section  里面 </span><br><span class=\"line\">//对象的 compatible 赋值为  compat 字符串；   .data 赋值为  fn </span><br><span class=\"line\">//(fn==(fn_type)NULL)?  这个 检查， 主要作用就是 检查  fn 函数 类型  是 fn_type 。 如果不是，编译就会报错 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.dts</span><br><span class=\"line\"></span><br><span class=\"line\">/&#123;</span><br><span class=\"line\">\treserved-memory &#123;</span><br><span class=\"line\">\t\t#address-cells = &lt;0x2&gt;;</span><br><span class=\"line\">\t\t#size-cells = &lt;0x2&gt;;</span><br><span class=\"line\">\t\tranges;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tminidump-elf-mem &#123;</span><br><span class=\"line\">\t\t\tcompatible = &quot;minidump-elf-reserved-memory&quot;;</span><br><span class=\"line\">\t\t\tno-map;\t//保留内存区域不应该被内核映射到虚拟地址空间，应用程序无法直接访问这块内存区域,它是专门留给内核使用的</span><br><span class=\"line\">\t\t\tsize = &lt;0x0 0x1300000&gt;;\t//保留内存区域的大小</span><br><span class=\"line\">\t\t\talignment = &lt;0x0 0x100000&gt;;\t//(1MB)对齐</span><br><span class=\"line\">\t\t\talloc-ranges = &lt;0x0 0x40000000 0x0 0x40000000&gt;;\t//可以在物理地址范围0x40000000到0x80000000内分配</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">.c</span><br><span class=\"line\"></span><br><span class=\"line\">phys_addr_t g_mindump_ram_phy_base;</span><br><span class=\"line\">EXPORT_SYMBOL(g_mindump_ram_phy_base);</span><br><span class=\"line\">unsigned long g_mindump_ram_len;</span><br><span class=\"line\">EXPORT_SYMBOL(g_mindump_ram_len);</span><br><span class=\"line\"></span><br><span class=\"line\">int reserve_memory_minidump_elf_fn(struct reserved_mem *rmem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpr_info(DFT_TAG &quot;[W]%s: name: %s,base: 0x%llx,size: 0x%llx\\n&quot;,</span><br><span class=\"line\">\t\t__func__, rmem-&gt;name, (unsigned long long)rmem-&gt;base,</span><br><span class=\"line\">\t\t(unsigned long long)rmem-&gt;size);</span><br><span class=\"line\">\tg_mindump_ram_phy_base = rmem-&gt;base;</span><br><span class=\"line\">\tg_mindump_ram_len = rmem-&gt;size;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">RESERVEDMEM_OF_DECLARE(minidump_elf_reserve_memory, &quot;minidump-elf-reserved-memory&quot;,</span><br><span class=\"line\">\t\t\treserve_memory_minidump_elf_fn);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">定义了 一个  </span><br><span class=\"line\">struct of_device_id    __of_device_minidump_elf_reserve_memory  =  &#123;</span><br><span class=\"line\">\t.compatible = &quot;minidump-elf-reserved-memory&quot; , </span><br><span class=\"line\">\t.data = reserve_memory_minidump_elf_fn </span><br><span class=\"line\">&#125; ; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"dts-中reserved-memory-解析和调用匹配的-of-device-id-的-data-函数\"><a href=\"#dts-中reserved-memory-解析和调用匹配的-of-device-id-的-data-函数\" class=\"headerlink\" title=\"dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数\"></a>dts 中reserved memory 解析和调用匹配的 of_device_id 的 .data 函数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup_arch</span><br><span class=\"line\"> ---&gt;arm64_memblock_init</span><br><span class=\"line\">        ---&gt;early_init_fdt_scan_reserved_mem</span><br><span class=\"line\">             ---&gt;fdt_init_reserved_mem</span><br><span class=\"line\">                   ---&gt;__reserved_mem_init_node</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"fdt-init-reserved-mem\"><a href=\"#fdt-init-reserved-mem\" class=\"headerlink\" title=\"fdt_init_reserved_mem\"></a>fdt_init_reserved_mem</h3><p>drivers&#x2F;of&#x2F;of_reserved_mem.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void __init fdt_init_reserved_mem(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/* check for overlapping reserved regions */</span><br><span class=\"line\">\t__rmem_check_for_overlap();</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (i = 0; i &lt; reserved_mem_count; i++) &#123;\t//处理每一块 reserved memory </span><br><span class=\"line\">\t\tstruct reserved_mem *rmem = &amp;reserved_mem[i];</span><br><span class=\"line\">\t\tunsigned long node = rmem-&gt;fdt_node;</span><br><span class=\"line\">\t\tint len;</span><br><span class=\"line\">\t\tconst __be32 *prop;</span><br><span class=\"line\">\t\tint err = 0;</span><br><span class=\"line\">\t\tbool nomap;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnomap = of_get_flat_dt_prop(node, &quot;no-map&quot;, NULL) != NULL;</span><br><span class=\"line\">\t\tprop = of_get_flat_dt_prop(node, &quot;phandle&quot;, &amp;len);</span><br><span class=\"line\">\t\tif (!prop)</span><br><span class=\"line\">\t\t\tprop = of_get_flat_dt_prop(node, &quot;linux,phandle&quot;, &amp;len);</span><br><span class=\"line\">\t\tif (prop)</span><br><span class=\"line\">\t\t\trmem-&gt;phandle = of_read_number(prop, len/4);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (rmem-&gt;size == 0) //如果还没有为 node 预留内存，则使用  __reserved_mem_alloc_size ，继续解析 node 的 dts 中的 参数，预留内存。</span><br><span class=\"line\">\t\t\terr = __reserved_mem_alloc_size(node, rmem-&gt;name,</span><br><span class=\"line\">\t\t\t\t\t\t &amp;rmem-&gt;base, &amp;rmem-&gt;size);</span><br><span class=\"line\">\t\tif (err == 0) &#123; //说明预留内存成功， 对预留的这部分内存   调用 __reserved_mem_init_node 函数（下面详述） </span><br><span class=\"line\">\t\t\terr = __reserved_mem_init_node(rmem);</span><br><span class=\"line\">\t\t\tif (err != 0 &amp;&amp; err != -ENOENT) &#123;\t// 如果 __reserved_mem init node 失败了， 则需要释放 预留的这部分内存 先 memblock free </span><br><span class=\"line\">\t\t\t\tpr_info(&quot;node %s compatible matching fail\\n&quot;,</span><br><span class=\"line\">\t\t\t\t\trmem-&gt;name);</span><br><span class=\"line\">\t\t\t\tmemblock_free(rmem-&gt;base, rmem-&gt;size);</span><br><span class=\"line\">\t\t\t\tif (nomap)\t\t\t\t\t\t//如果 有 nomap 属性，则还需要进一步把这块内存 add 到 memblock 的memory type 的 链表中</span><br><span class=\"line\">\t\t\t\t\tmemblock_add(rmem-&gt;base, rmem-&gt;size);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reserved-mem-init-node\"><a href=\"#reserved-mem-init-node\" class=\"headerlink\" title=\"__reserved_mem_init_node\"></a>__reserved_mem_init_node</h3><p>drivers&#x2F;of&#x2F;of_reserved_mem.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int __init __reserved_mem_init_node(struct reserved_mem *rmem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\textern const struct of_device_id __reservedmem_of_table[];</span><br><span class=\"line\">\tconst struct of_device_id *i;</span><br><span class=\"line\">\tint ret = -ENOENT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (i = __reservedmem_of_table; i &lt; &amp;__rmem_of_table_sentinel; i++) &#123;</span><br><span class=\"line\">\t\t//对 rmem ，遍历    __reservedmem_of_table   这个 section  里面 的所有 of_device_id  对象 </span><br><span class=\"line\">\t\treservedmem_of_init_fn initfn = i-&gt;data;</span><br><span class=\"line\">\t\tconst char *compat = i-&gt;compatible;</span><br><span class=\"line\">\t\t// rmem 的 fdt_node 和  of_device_id 对象的 compat  （char * 字符串）   进行匹配 </span><br><span class=\"line\">\t\tif (!of_flat_dt_is_compatible(rmem-&gt;fdt_node, compat))</span><br><span class=\"line\">\t\t\tcontinue;</span><br><span class=\"line\">\t\t//匹配成功，调用 of_device_id 的 data 字段 里面存放的函数 。 initfn( rmem )</span><br><span class=\"line\">\t\tret = initfn(rmem);</span><br><span class=\"line\">\t\tif (ret == 0) &#123;</span><br><span class=\"line\">\t\t\tpr_info(&quot;initialized node %s, compatible id %s\\n&quot;,</span><br><span class=\"line\">\t\t\t\trmem-&gt;name, compat);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>dts 中，通常使用 memory-region 将设备和 reserved memory 关联起来，如下：</p>\n<p><img src=\"/../imgs/2704972-20220410142315999-1415044429.jpg\" alt=\"img\"></p>\n<p> fb0 通过 memory-region 关联到 display_reserved 这块 reserved memory 上面；</p>\n<h2 id=\"of-reserved-mem-device-init\"><a href=\"#of-reserved-mem-device-init\" class=\"headerlink\" title=\"of_reserved_mem_device_init\"></a>of_reserved_mem_device_init</h2><p>include&#x2F;linux&#x2F;of_reserved_mem.h </p>\n<p>传入参数 dev， 找到 dev 中 memory-region 对应的 reserved memory .</p>\n<p>然后调用 reserved_memory 对象的 ops-&gt;device_init( reserved_memory * rmem, device * dev );</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline int of_reserved_mem_device_init(struct device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn of_reserved_mem_device_init_by_idx(dev, dev-&gt;of_node, 0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"of-reserved-mem-device-init-by-idx\"><a href=\"#of-reserved-mem-device-init-by-idx\" class=\"headerlink\" title=\"of_reserved_mem_device_init_by_idx\"></a>of_reserved_mem_device_init_by_idx</h2><p>从 of_reserved_mem_device_init 进入时，dev , dev_node, idx &#x3D; 0 ;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int of_reserved_mem_device_init_by_idx(struct device *dev,</span><br><span class=\"line\">\t\t\t\t       struct device_node *np, int idx)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstruct rmem_assigned_device *rd;</span><br><span class=\"line\">\tstruct device_node *target;</span><br><span class=\"line\">\tstruct reserved_mem *rmem;</span><br><span class=\"line\">\tint ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!np || !dev)</span><br><span class=\"line\">\t\treturn -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttarget = of_parse_phandle(np, &quot;memory-region&quot;, idx); //通过 memory-region 找对应的 reserved memory </span><br><span class=\"line\">\tif (!target)</span><br><span class=\"line\">\t\treturn -ENODEV;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!of_device_is_available(target)) &#123;</span><br><span class=\"line\">\t\tof_node_put(target);</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trmem = __find_rmem(target);</span><br><span class=\"line\">\tof_node_put(target);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!rmem || !rmem-&gt;ops || !rmem-&gt;ops-&gt;device_init) //检查 有 rmem-&gt;ops   rmem-&gt;ops-&gt;device_init 函数 </span><br><span class=\"line\">\t\treturn -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">\trd = kmalloc(sizeof(struct rmem_assigned_device), GFP_KERNEL);</span><br><span class=\"line\">\tif (!rd)</span><br><span class=\"line\">\t\treturn -ENOMEM;</span><br><span class=\"line\"></span><br><span class=\"line\">\tret = rmem-&gt;ops-&gt;device_init(rmem, dev); //调用  rmem-&gt;ops-&gt;device_init(rmem, dev) </span><br><span class=\"line\">\tif (ret == 0) &#123; \t\t\t\t\t\t//成功的话，就 将 建立的对象 reserved_memory_device </span><br><span class=\"line\">\t\trd-&gt;dev = dev; </span><br><span class=\"line\">\t\trd-&gt;rmem = rmem;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmutex_lock(&amp;of_rmem_assigned_device_mutex);</span><br><span class=\"line\">\t\tlist_add(&amp;rd-&gt;list, &amp;of_rmem_assigned_device_list);//加入到  of_rmem_assigned_device_list 里面 ,记录 rmem 分配到 device 里面</span><br><span class=\"line\">\t\tmutex_unlock(&amp;of_rmem_assigned_device_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tdev_info(dev, &quot;assigned reserved memory node %s\\n&quot;, rmem-&gt;name);</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tkfree(rd);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL_GPL(of_reserved_mem_device_init_by_idx);</span><br></pre></td></tr></table></figure>\n"},{"title":"kernel-workqueue","date":"2024-06-21T09:26:17.000Z","_content":"\n一、workqueue的作用及在Linux中断处理中的应用\n1.1、workqueue的概述\nLinux工作队列（Workqueue）是一个内核中的机制，它可以异步执行一些任务。在Linux内核中，当需要处理一些不是紧急的、需要后台执行的任务时，就会将这些任务加入到工作队列中，然后由内核计划适当的时间来执行这些任务。\n\n工作队列的特点是异步执行，即任务的执行不会阻塞当前进程，而是交给后台线程进行处理。这种方式可以避免阻塞主线程，提高系统的响应速度和并发能力。\n\n工作队列具有多种使用场景，比如定时器事件、网络I/O事件、驱动程序事件等，都可以通过工作队列来异步处理。\n\n1.2、workqueue在Linux中断处理中的作用\nworkqueue是一种异步执行工作的机制，它可以在Linux中断处理中使用。当内核需要异步执行某些任务时，可以使用workqueue机制。\n\n在Linux中断处理中，有些操作不能直接执行，因为它们可能会阻塞中断处理程序。例如，如果一个中断处理程序需要访问磁盘，那么它可能需要等待磁盘访问完成才能继续执行，这将导致中断处理程序的延迟和性能下降。为了避免这种情况，可以使用workqueue机制。\n\nworkqueue机制允许中断处理程序将任务提交给工作队列，在稍后的时间异步执行。这样，中断处理程序可以立即返回，并且不会阻塞其他中断处理程序的执行。工作队列是一组线程，它们可以同时执行多个任务。当工作队列中有任务时，内核会自动调度线程来执行任务。\n\nworkqueue机制是一种非常有效的机制，可以帮助内核异步执行任务，提高系统的性能和可靠性。\n![在这里插入图片描述](../imgs/d32faea7d5004b979cc98527aa0973e8.png)\n\n二、workqueue的实现原理\nworkqueue通过使用worker线程池来执行延迟性任务，能够提高系统的吞吐量和响应速度，适用于需要进行异步任务调度的场景。\n\nworkqueue是Linux系统中用于实现异步任务调度的机制，它允许驱动程序和内核线程安排延迟执行的工作。\n\nworkqueue由一个或多个worker线程池组成，每个worker线程都会不断地从workqueue中获取需要执行的工作项。\n当驱动程序或内核模块需要执行一些延迟性的任务时，可以将这些任务封装成工作项（work）并添加到workqueue队列中。\nworker线程在空闲时，从workqueue队列中取出一个工作项，并将其放入自己的私有队列中，等待执行。\n一旦worker线程完成当前正在执行的工作项，就会从自己的私有队列中取出下一个工作项进行处理。\n若workqueue队列中没有可用的工作项，则worker线程会等待直到有新的工作项被添加到队列中。\n在workqueue中，还提供了几种不同的队列类型，如普通队列、高优先级队列和延迟队列等，以满足不同场景下的需求。\n2.1、工作队列和工作者线程的关系\n工作队列和工作者线程是相互依存的关系，它们通过协同工作来处理系统中的任务。\n\n工作队列是一个先进先出的任务列表，其中包含需要被执行的任务。工作者线程则是实际执行这些任务的线程。当有新的任务添加到工作队列中时，工作者线程会自动从队列中取出任务并执行。\n\n工作者线程通常是由内核创建的，其数量可以根据系统负载情况进行调整。当任务数量增加时，可以增加工作者线程的数量以加快任务处理速度。而当任务数量减少时，可以减少工作者线程的数量以节省系统资源。\n![在这里插入图片描述](../imgs/2b8686c61a24478a8112e4b83228f177.png)\n\n2.2、工作队列的创建和销毁\n在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：\n\n创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。\n销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。\n例如，创建和销毁一个名为“my_work”的工作队列：\n\n工作队列的创建和销毁\n在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：\n\n创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。\n销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。\n2.3、工作者线程的创建和销毁\nLinux 内核中的工作者线程是一种特殊的内核线程，用于执行一些异步的、需要花费较长时间或者需要消耗大量 CPU 资源的任务。它们主要用于处理 I/O 操作、网络操作、文件系统缓存等等。\n\n在 Linux 内核中，工作者线程的创建和销毁是由系统自动管理的。当进程请求创建一个工作者线程时，内核会检查当前是否有可用的空闲线程。如果没有，则会创建一个新的线程。当任务完成后，工作者线程会被回收并返回到线程池中，以备下次使用。\n\n为了提高效率，Linux 内核还可以在运行时动态地调整线程池中工作者线程的数量。当系统负载较高时，内核会增加线程池中的线程数量，以处理更多的任务。当负载降低时，内核会减少线程池中的线程数量，以节省资源。\n\n例如，展示如何在 Linux 内核中创建和销毁工作者线程：\n```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#if 1\n#define YYHDEBUG(fmt, ...) \\\n    printk(KERN_ERR \"yyh debug [%s][%d] \" fmt, __func__, __LINE__, ##__VA_ARGS__)\n#else \n#define YYHDEBUG(debug)\n#endif\nstatic struct workqueue_struct *my_wq;\n\ntypedef struct {\n    struct work_struct my_work;\n    int x;\n} my_work_t;\n\nstatic void my_work_handler(struct work_struct *work)\n{\n    my_work_t *my_work = (my_work_t *)work;\n    YYHDEBUG(\"my_work_handler: x=%d\\n\", my_work->x);\n    kfree(my_work);\n}\n\nstatic int __init my_module_init(void)\n{\n    my_work_t *my_work;\n\n    /* 创建工作者队列 */\n    my_wq = create_workqueue(\"my_queue\");\n    if (!my_wq) {\n        YYHDEBUG(\"create_workqueue failed!\\n\");\n        return -1;\n    }\n\n    /* 创建并提交工作者线程 */\n    my_work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);\n    if (!my_work) {\n        YYHDEBUG(\"kmalloc failed!\\n\");\n        return -1;\n    }\n    INIT_WORK((struct work_struct *)my_work, my_work_handler);\n    my_work->x = 1;\n    queue_work(my_wq, (struct work_struct *)my_work);\n\n    return 0;\n}\n\nstatic void __exit my_module_exit(void)\n{\n    /* 销毁工作者队列 */\n    flush_workqueue(my_wq);\n    destroy_workqueue(my_wq);\n}\n\nmodule_init(my_module_init);\nmodule_exit(my_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lion Long\");\nMODULE_DESCRIPTION(\"A simple example Linux module.\");\n```\n\n例子展示了如何创建一个名为“my_queue”的工作者队列，然后创建一个工作者线程来处理一个名为“my_work”的工作对象。“my_work_handler”函数将打印出传递给工作对象的参数“x”，并释放工作对象的内存。在模块初始化期间，创建工作者队列和工作对象，并提交工作对象到队列中。在模块退出期间，销毁工作者队列。\n\nLinux 内核中的工作者线程是一种非常重要的机制，能够显著提高系统的性能和响应速度。虽然用户无法直接控制工作者线程的创建和销毁，但可以通过一些系统调优技巧来优化工作者线程的使用效果。\n2.4、扩展知识：用户态线程的创建\n线程创建：\n\n```\n#include <pthread.h>\n\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                   void *(*start_routine)(void*), void *arg);\n```\n\n该函数用于创建一个新的线程，并将其添加到调用进程中。参数 thread 是指向新线程标识符的指针，参数 attr 是指向线程属性的指针（通常为 NULL），参数 start_routine 是指向线程执行函数的指针，参数 arg 是传递给线程执行函数的参数。\n\n线程销毁：\n\n```\nvoid pthread_exit(void *value_ptr);\n```\n\n该函数用于终止当前线程，并返回一个指针值。这个值可以由其他线程通过 pthread_join 函数获取，也可以被忽略。\n\n```\nint pthread_join(pthread_t thread, void **value_ptr);\n```\n\n\n\n该函数用于阻塞当前线程，直到指定的线程 thread 终止。如果指针 value_ptr 不为 NULL，则会将线程的返回值存储在 value_ptr 指向的位置中。\n\n注意：如果线程没有被显式地分离，则它将一直存在于内存中，直到进程结束。因此，在创建线程时，应该考虑是否需要将它们分离或者等待它们的结束。\n\n\n原文链接：https://blog.csdn.net/Long_xu/article/details/1314057422.2\n","source":"_posts/kernel-workqueue.md","raw":"---\ntitle: kernel-workqueue\ncategories:\n  - test\ntags:\n  - test\ndate: 2024-06-21 17:26:17\n---\n\n一、workqueue的作用及在Linux中断处理中的应用\n1.1、workqueue的概述\nLinux工作队列（Workqueue）是一个内核中的机制，它可以异步执行一些任务。在Linux内核中，当需要处理一些不是紧急的、需要后台执行的任务时，就会将这些任务加入到工作队列中，然后由内核计划适当的时间来执行这些任务。\n\n工作队列的特点是异步执行，即任务的执行不会阻塞当前进程，而是交给后台线程进行处理。这种方式可以避免阻塞主线程，提高系统的响应速度和并发能力。\n\n工作队列具有多种使用场景，比如定时器事件、网络I/O事件、驱动程序事件等，都可以通过工作队列来异步处理。\n\n1.2、workqueue在Linux中断处理中的作用\nworkqueue是一种异步执行工作的机制，它可以在Linux中断处理中使用。当内核需要异步执行某些任务时，可以使用workqueue机制。\n\n在Linux中断处理中，有些操作不能直接执行，因为它们可能会阻塞中断处理程序。例如，如果一个中断处理程序需要访问磁盘，那么它可能需要等待磁盘访问完成才能继续执行，这将导致中断处理程序的延迟和性能下降。为了避免这种情况，可以使用workqueue机制。\n\nworkqueue机制允许中断处理程序将任务提交给工作队列，在稍后的时间异步执行。这样，中断处理程序可以立即返回，并且不会阻塞其他中断处理程序的执行。工作队列是一组线程，它们可以同时执行多个任务。当工作队列中有任务时，内核会自动调度线程来执行任务。\n\nworkqueue机制是一种非常有效的机制，可以帮助内核异步执行任务，提高系统的性能和可靠性。\n![在这里插入图片描述](../imgs/d32faea7d5004b979cc98527aa0973e8.png)\n\n二、workqueue的实现原理\nworkqueue通过使用worker线程池来执行延迟性任务，能够提高系统的吞吐量和响应速度，适用于需要进行异步任务调度的场景。\n\nworkqueue是Linux系统中用于实现异步任务调度的机制，它允许驱动程序和内核线程安排延迟执行的工作。\n\nworkqueue由一个或多个worker线程池组成，每个worker线程都会不断地从workqueue中获取需要执行的工作项。\n当驱动程序或内核模块需要执行一些延迟性的任务时，可以将这些任务封装成工作项（work）并添加到workqueue队列中。\nworker线程在空闲时，从workqueue队列中取出一个工作项，并将其放入自己的私有队列中，等待执行。\n一旦worker线程完成当前正在执行的工作项，就会从自己的私有队列中取出下一个工作项进行处理。\n若workqueue队列中没有可用的工作项，则worker线程会等待直到有新的工作项被添加到队列中。\n在workqueue中，还提供了几种不同的队列类型，如普通队列、高优先级队列和延迟队列等，以满足不同场景下的需求。\n2.1、工作队列和工作者线程的关系\n工作队列和工作者线程是相互依存的关系，它们通过协同工作来处理系统中的任务。\n\n工作队列是一个先进先出的任务列表，其中包含需要被执行的任务。工作者线程则是实际执行这些任务的线程。当有新的任务添加到工作队列中时，工作者线程会自动从队列中取出任务并执行。\n\n工作者线程通常是由内核创建的，其数量可以根据系统负载情况进行调整。当任务数量增加时，可以增加工作者线程的数量以加快任务处理速度。而当任务数量减少时，可以减少工作者线程的数量以节省系统资源。\n![在这里插入图片描述](../imgs/2b8686c61a24478a8112e4b83228f177.png)\n\n2.2、工作队列的创建和销毁\n在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：\n\n创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。\n销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。\n例如，创建和销毁一个名为“my_work”的工作队列：\n\n工作队列的创建和销毁\n在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：\n\n创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。\n销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。\n2.3、工作者线程的创建和销毁\nLinux 内核中的工作者线程是一种特殊的内核线程，用于执行一些异步的、需要花费较长时间或者需要消耗大量 CPU 资源的任务。它们主要用于处理 I/O 操作、网络操作、文件系统缓存等等。\n\n在 Linux 内核中，工作者线程的创建和销毁是由系统自动管理的。当进程请求创建一个工作者线程时，内核会检查当前是否有可用的空闲线程。如果没有，则会创建一个新的线程。当任务完成后，工作者线程会被回收并返回到线程池中，以备下次使用。\n\n为了提高效率，Linux 内核还可以在运行时动态地调整线程池中工作者线程的数量。当系统负载较高时，内核会增加线程池中的线程数量，以处理更多的任务。当负载降低时，内核会减少线程池中的线程数量，以节省资源。\n\n例如，展示如何在 Linux 内核中创建和销毁工作者线程：\n```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#if 1\n#define YYHDEBUG(fmt, ...) \\\n    printk(KERN_ERR \"yyh debug [%s][%d] \" fmt, __func__, __LINE__, ##__VA_ARGS__)\n#else \n#define YYHDEBUG(debug)\n#endif\nstatic struct workqueue_struct *my_wq;\n\ntypedef struct {\n    struct work_struct my_work;\n    int x;\n} my_work_t;\n\nstatic void my_work_handler(struct work_struct *work)\n{\n    my_work_t *my_work = (my_work_t *)work;\n    YYHDEBUG(\"my_work_handler: x=%d\\n\", my_work->x);\n    kfree(my_work);\n}\n\nstatic int __init my_module_init(void)\n{\n    my_work_t *my_work;\n\n    /* 创建工作者队列 */\n    my_wq = create_workqueue(\"my_queue\");\n    if (!my_wq) {\n        YYHDEBUG(\"create_workqueue failed!\\n\");\n        return -1;\n    }\n\n    /* 创建并提交工作者线程 */\n    my_work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);\n    if (!my_work) {\n        YYHDEBUG(\"kmalloc failed!\\n\");\n        return -1;\n    }\n    INIT_WORK((struct work_struct *)my_work, my_work_handler);\n    my_work->x = 1;\n    queue_work(my_wq, (struct work_struct *)my_work);\n\n    return 0;\n}\n\nstatic void __exit my_module_exit(void)\n{\n    /* 销毁工作者队列 */\n    flush_workqueue(my_wq);\n    destroy_workqueue(my_wq);\n}\n\nmodule_init(my_module_init);\nmodule_exit(my_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lion Long\");\nMODULE_DESCRIPTION(\"A simple example Linux module.\");\n```\n\n例子展示了如何创建一个名为“my_queue”的工作者队列，然后创建一个工作者线程来处理一个名为“my_work”的工作对象。“my_work_handler”函数将打印出传递给工作对象的参数“x”，并释放工作对象的内存。在模块初始化期间，创建工作者队列和工作对象，并提交工作对象到队列中。在模块退出期间，销毁工作者队列。\n\nLinux 内核中的工作者线程是一种非常重要的机制，能够显著提高系统的性能和响应速度。虽然用户无法直接控制工作者线程的创建和销毁，但可以通过一些系统调优技巧来优化工作者线程的使用效果。\n2.4、扩展知识：用户态线程的创建\n线程创建：\n\n```\n#include <pthread.h>\n\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                   void *(*start_routine)(void*), void *arg);\n```\n\n该函数用于创建一个新的线程，并将其添加到调用进程中。参数 thread 是指向新线程标识符的指针，参数 attr 是指向线程属性的指针（通常为 NULL），参数 start_routine 是指向线程执行函数的指针，参数 arg 是传递给线程执行函数的参数。\n\n线程销毁：\n\n```\nvoid pthread_exit(void *value_ptr);\n```\n\n该函数用于终止当前线程，并返回一个指针值。这个值可以由其他线程通过 pthread_join 函数获取，也可以被忽略。\n\n```\nint pthread_join(pthread_t thread, void **value_ptr);\n```\n\n\n\n该函数用于阻塞当前线程，直到指定的线程 thread 终止。如果指针 value_ptr 不为 NULL，则会将线程的返回值存储在 value_ptr 指向的位置中。\n\n注意：如果线程没有被显式地分离，则它将一直存在于内存中，直到进程结束。因此，在创建线程时，应该考虑是否需要将它们分离或者等待它们的结束。\n\n\n原文链接：https://blog.csdn.net/Long_xu/article/details/1314057422.2\n","slug":"kernel-workqueue","published":1,"updated":"2024-06-24T08:42:10.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clxss7yyq00018jw0bm510aot","content":"<p>一、workqueue的作用及在Linux中断处理中的应用<br>1.1、workqueue的概述<br>Linux工作队列（Workqueue）是一个内核中的机制，它可以异步执行一些任务。在Linux内核中，当需要处理一些不是紧急的、需要后台执行的任务时，就会将这些任务加入到工作队列中，然后由内核计划适当的时间来执行这些任务。</p>\n<p>工作队列的特点是异步执行，即任务的执行不会阻塞当前进程，而是交给后台线程进行处理。这种方式可以避免阻塞主线程，提高系统的响应速度和并发能力。</p>\n<p>工作队列具有多种使用场景，比如定时器事件、网络I&#x2F;O事件、驱动程序事件等，都可以通过工作队列来异步处理。</p>\n<p>1.2、workqueue在Linux中断处理中的作用<br>workqueue是一种异步执行工作的机制，它可以在Linux中断处理中使用。当内核需要异步执行某些任务时，可以使用workqueue机制。</p>\n<p>在Linux中断处理中，有些操作不能直接执行，因为它们可能会阻塞中断处理程序。例如，如果一个中断处理程序需要访问磁盘，那么它可能需要等待磁盘访问完成才能继续执行，这将导致中断处理程序的延迟和性能下降。为了避免这种情况，可以使用workqueue机制。</p>\n<p>workqueue机制允许中断处理程序将任务提交给工作队列，在稍后的时间异步执行。这样，中断处理程序可以立即返回，并且不会阻塞其他中断处理程序的执行。工作队列是一组线程，它们可以同时执行多个任务。当工作队列中有任务时，内核会自动调度线程来执行任务。</p>\n<p>workqueue机制是一种非常有效的机制，可以帮助内核异步执行任务，提高系统的性能和可靠性。<br><img src=\"/../imgs/d32faea7d5004b979cc98527aa0973e8.png\" alt=\"在这里插入图片描述\"></p>\n<p>二、workqueue的实现原理<br>workqueue通过使用worker线程池来执行延迟性任务，能够提高系统的吞吐量和响应速度，适用于需要进行异步任务调度的场景。</p>\n<p>workqueue是Linux系统中用于实现异步任务调度的机制，它允许驱动程序和内核线程安排延迟执行的工作。</p>\n<p>workqueue由一个或多个worker线程池组成，每个worker线程都会不断地从workqueue中获取需要执行的工作项。<br>当驱动程序或内核模块需要执行一些延迟性的任务时，可以将这些任务封装成工作项（work）并添加到workqueue队列中。<br>worker线程在空闲时，从workqueue队列中取出一个工作项，并将其放入自己的私有队列中，等待执行。<br>一旦worker线程完成当前正在执行的工作项，就会从自己的私有队列中取出下一个工作项进行处理。<br>若workqueue队列中没有可用的工作项，则worker线程会等待直到有新的工作项被添加到队列中。<br>在workqueue中，还提供了几种不同的队列类型，如普通队列、高优先级队列和延迟队列等，以满足不同场景下的需求。<br>2.1、工作队列和工作者线程的关系<br>工作队列和工作者线程是相互依存的关系，它们通过协同工作来处理系统中的任务。</p>\n<p>工作队列是一个先进先出的任务列表，其中包含需要被执行的任务。工作者线程则是实际执行这些任务的线程。当有新的任务添加到工作队列中时，工作者线程会自动从队列中取出任务并执行。</p>\n<p>工作者线程通常是由内核创建的，其数量可以根据系统负载情况进行调整。当任务数量增加时，可以增加工作者线程的数量以加快任务处理速度。而当任务数量减少时，可以减少工作者线程的数量以节省系统资源。<br><img src=\"/../imgs/2b8686c61a24478a8112e4b83228f177.png\" alt=\"在这里插入图片描述\"></p>\n<p>2.2、工作队列的创建和销毁<br>在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：</p>\n<p>创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。<br>销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。<br>例如，创建和销毁一个名为“my_work”的工作队列：</p>\n<p>工作队列的创建和销毁<br>在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：</p>\n<p>创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。<br>销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。<br>2.3、工作者线程的创建和销毁<br>Linux 内核中的工作者线程是一种特殊的内核线程，用于执行一些异步的、需要花费较长时间或者需要消耗大量 CPU 资源的任务。它们主要用于处理 I&#x2F;O 操作、网络操作、文件系统缓存等等。</p>\n<p>在 Linux 内核中，工作者线程的创建和销毁是由系统自动管理的。当进程请求创建一个工作者线程时，内核会检查当前是否有可用的空闲线程。如果没有，则会创建一个新的线程。当任务完成后，工作者线程会被回收并返回到线程池中，以备下次使用。</p>\n<p>为了提高效率，Linux 内核还可以在运行时动态地调整线程池中工作者线程的数量。当系统负载较高时，内核会增加线程池中的线程数量，以处理更多的任务。当负载降低时，内核会减少线程池中的线程数量，以节省资源。</p>\n<p>例如，展示如何在 Linux 内核中创建和销毁工作者线程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;linux/module.h&gt;</span><br><span class=\"line\">#include &lt;linux/kernel.h&gt;</span><br><span class=\"line\">#include &lt;linux/workqueue.h&gt;</span><br><span class=\"line\">#if 1</span><br><span class=\"line\">#define YYHDEBUG(fmt, ...) \\</span><br><span class=\"line\">    printk(KERN_ERR &quot;yyh debug [%s][%d] &quot; fmt, __func__, __LINE__, ##__VA_ARGS__)</span><br><span class=\"line\">#else </span><br><span class=\"line\">#define YYHDEBUG(debug)</span><br><span class=\"line\">#endif</span><br><span class=\"line\">static struct workqueue_struct *my_wq;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    struct work_struct my_work;</span><br><span class=\"line\">    int x;</span><br><span class=\"line\">&#125; my_work_t;</span><br><span class=\"line\"></span><br><span class=\"line\">static void my_work_handler(struct work_struct *work)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    my_work_t *my_work = (my_work_t *)work;</span><br><span class=\"line\">    YYHDEBUG(&quot;my_work_handler: x=%d\\n&quot;, my_work-&gt;x);</span><br><span class=\"line\">    kfree(my_work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static int __init my_module_init(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    my_work_t *my_work;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 创建工作者队列 */</span><br><span class=\"line\">    my_wq = create_workqueue(&quot;my_queue&quot;);</span><br><span class=\"line\">    if (!my_wq) &#123;</span><br><span class=\"line\">        YYHDEBUG(&quot;create_workqueue failed!\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 创建并提交工作者线程 */</span><br><span class=\"line\">    my_work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);</span><br><span class=\"line\">    if (!my_work) &#123;</span><br><span class=\"line\">        YYHDEBUG(&quot;kmalloc failed!\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    INIT_WORK((struct work_struct *)my_work, my_work_handler);</span><br><span class=\"line\">    my_work-&gt;x = 1;</span><br><span class=\"line\">    queue_work(my_wq, (struct work_struct *)my_work);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __exit my_module_exit(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /* 销毁工作者队列 */</span><br><span class=\"line\">    flush_workqueue(my_wq);</span><br><span class=\"line\">    destroy_workqueue(my_wq);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_module_init);</span><br><span class=\"line\">module_exit(my_module_exit);</span><br><span class=\"line\"></span><br><span class=\"line\">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class=\"line\">MODULE_AUTHOR(&quot;Lion Long&quot;);</span><br><span class=\"line\">MODULE_DESCRIPTION(&quot;A simple example Linux module.&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>例子展示了如何创建一个名为“my_queue”的工作者队列，然后创建一个工作者线程来处理一个名为“my_work”的工作对象。“my_work_handler”函数将打印出传递给工作对象的参数“x”，并释放工作对象的内存。在模块初始化期间，创建工作者队列和工作对象，并提交工作对象到队列中。在模块退出期间，销毁工作者队列。</p>\n<p>Linux 内核中的工作者线程是一种非常重要的机制，能够显著提高系统的性能和响应速度。虽然用户无法直接控制工作者线程的创建和销毁，但可以通过一些系统调优技巧来优化工作者线程的使用效果。<br>2.4、扩展知识：用户态线程的创建<br>线程创建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;pthread.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span><br><span class=\"line\">                   void *(*start_routine)(void*), void *arg);</span><br></pre></td></tr></table></figure>\n\n<p>该函数用于创建一个新的线程，并将其添加到调用进程中。参数 thread 是指向新线程标识符的指针，参数 attr 是指向线程属性的指针（通常为 NULL），参数 start_routine 是指向线程执行函数的指针，参数 arg 是传递给线程执行函数的参数。</p>\n<p>线程销毁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void pthread_exit(void *value_ptr);</span><br></pre></td></tr></table></figure>\n\n<p>该函数用于终止当前线程，并返回一个指针值。这个值可以由其他线程通过 pthread_join 函数获取，也可以被忽略。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int pthread_join(pthread_t thread, void **value_ptr);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>该函数用于阻塞当前线程，直到指定的线程 thread 终止。如果指针 value_ptr 不为 NULL，则会将线程的返回值存储在 value_ptr 指向的位置中。</p>\n<p>注意：如果线程没有被显式地分离，则它将一直存在于内存中，直到进程结束。因此，在创建线程时，应该考虑是否需要将它们分离或者等待它们的结束。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Long_xu/article/details/1314057422.2\">https://blog.csdn.net/Long_xu/article/details/1314057422.2</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、workqueue的作用及在Linux中断处理中的应用<br>1.1、workqueue的概述<br>Linux工作队列（Workqueue）是一个内核中的机制，它可以异步执行一些任务。在Linux内核中，当需要处理一些不是紧急的、需要后台执行的任务时，就会将这些任务加入到工作队列中，然后由内核计划适当的时间来执行这些任务。</p>\n<p>工作队列的特点是异步执行，即任务的执行不会阻塞当前进程，而是交给后台线程进行处理。这种方式可以避免阻塞主线程，提高系统的响应速度和并发能力。</p>\n<p>工作队列具有多种使用场景，比如定时器事件、网络I&#x2F;O事件、驱动程序事件等，都可以通过工作队列来异步处理。</p>\n<p>1.2、workqueue在Linux中断处理中的作用<br>workqueue是一种异步执行工作的机制，它可以在Linux中断处理中使用。当内核需要异步执行某些任务时，可以使用workqueue机制。</p>\n<p>在Linux中断处理中，有些操作不能直接执行，因为它们可能会阻塞中断处理程序。例如，如果一个中断处理程序需要访问磁盘，那么它可能需要等待磁盘访问完成才能继续执行，这将导致中断处理程序的延迟和性能下降。为了避免这种情况，可以使用workqueue机制。</p>\n<p>workqueue机制允许中断处理程序将任务提交给工作队列，在稍后的时间异步执行。这样，中断处理程序可以立即返回，并且不会阻塞其他中断处理程序的执行。工作队列是一组线程，它们可以同时执行多个任务。当工作队列中有任务时，内核会自动调度线程来执行任务。</p>\n<p>workqueue机制是一种非常有效的机制，可以帮助内核异步执行任务，提高系统的性能和可靠性。<br><img src=\"/../imgs/d32faea7d5004b979cc98527aa0973e8.png\" alt=\"在这里插入图片描述\"></p>\n<p>二、workqueue的实现原理<br>workqueue通过使用worker线程池来执行延迟性任务，能够提高系统的吞吐量和响应速度，适用于需要进行异步任务调度的场景。</p>\n<p>workqueue是Linux系统中用于实现异步任务调度的机制，它允许驱动程序和内核线程安排延迟执行的工作。</p>\n<p>workqueue由一个或多个worker线程池组成，每个worker线程都会不断地从workqueue中获取需要执行的工作项。<br>当驱动程序或内核模块需要执行一些延迟性的任务时，可以将这些任务封装成工作项（work）并添加到workqueue队列中。<br>worker线程在空闲时，从workqueue队列中取出一个工作项，并将其放入自己的私有队列中，等待执行。<br>一旦worker线程完成当前正在执行的工作项，就会从自己的私有队列中取出下一个工作项进行处理。<br>若workqueue队列中没有可用的工作项，则worker线程会等待直到有新的工作项被添加到队列中。<br>在workqueue中，还提供了几种不同的队列类型，如普通队列、高优先级队列和延迟队列等，以满足不同场景下的需求。<br>2.1、工作队列和工作者线程的关系<br>工作队列和工作者线程是相互依存的关系，它们通过协同工作来处理系统中的任务。</p>\n<p>工作队列是一个先进先出的任务列表，其中包含需要被执行的任务。工作者线程则是实际执行这些任务的线程。当有新的任务添加到工作队列中时，工作者线程会自动从队列中取出任务并执行。</p>\n<p>工作者线程通常是由内核创建的，其数量可以根据系统负载情况进行调整。当任务数量增加时，可以增加工作者线程的数量以加快任务处理速度。而当任务数量减少时，可以减少工作者线程的数量以节省系统资源。<br><img src=\"/../imgs/2b8686c61a24478a8112e4b83228f177.png\" alt=\"在这里插入图片描述\"></p>\n<p>2.2、工作队列的创建和销毁<br>在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：</p>\n<p>创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。<br>销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。<br>例如，创建和销毁一个名为“my_work”的工作队列：</p>\n<p>工作队列的创建和销毁<br>在Linux内核中，工作队列通过struct workqueue_struct结构体来表示。创建和销毁工作队列通常通过以下函数：</p>\n<p>创建工作队列：create_workqueue(const char *name); 该函数创建并返回一个指向工作队列的指针。参数name是工作队列的名称。<br>销毁工作队列：destroy_workqueue(struct workqueue_struct *wq); 该函数销毁由指针wq所表示的工作队列。<br>2.3、工作者线程的创建和销毁<br>Linux 内核中的工作者线程是一种特殊的内核线程，用于执行一些异步的、需要花费较长时间或者需要消耗大量 CPU 资源的任务。它们主要用于处理 I&#x2F;O 操作、网络操作、文件系统缓存等等。</p>\n<p>在 Linux 内核中，工作者线程的创建和销毁是由系统自动管理的。当进程请求创建一个工作者线程时，内核会检查当前是否有可用的空闲线程。如果没有，则会创建一个新的线程。当任务完成后，工作者线程会被回收并返回到线程池中，以备下次使用。</p>\n<p>为了提高效率，Linux 内核还可以在运行时动态地调整线程池中工作者线程的数量。当系统负载较高时，内核会增加线程池中的线程数量，以处理更多的任务。当负载降低时，内核会减少线程池中的线程数量，以节省资源。</p>\n<p>例如，展示如何在 Linux 内核中创建和销毁工作者线程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;linux/module.h&gt;</span><br><span class=\"line\">#include &lt;linux/kernel.h&gt;</span><br><span class=\"line\">#include &lt;linux/workqueue.h&gt;</span><br><span class=\"line\">#if 1</span><br><span class=\"line\">#define YYHDEBUG(fmt, ...) \\</span><br><span class=\"line\">    printk(KERN_ERR &quot;yyh debug [%s][%d] &quot; fmt, __func__, __LINE__, ##__VA_ARGS__)</span><br><span class=\"line\">#else </span><br><span class=\"line\">#define YYHDEBUG(debug)</span><br><span class=\"line\">#endif</span><br><span class=\"line\">static struct workqueue_struct *my_wq;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    struct work_struct my_work;</span><br><span class=\"line\">    int x;</span><br><span class=\"line\">&#125; my_work_t;</span><br><span class=\"line\"></span><br><span class=\"line\">static void my_work_handler(struct work_struct *work)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    my_work_t *my_work = (my_work_t *)work;</span><br><span class=\"line\">    YYHDEBUG(&quot;my_work_handler: x=%d\\n&quot;, my_work-&gt;x);</span><br><span class=\"line\">    kfree(my_work);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static int __init my_module_init(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    my_work_t *my_work;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 创建工作者队列 */</span><br><span class=\"line\">    my_wq = create_workqueue(&quot;my_queue&quot;);</span><br><span class=\"line\">    if (!my_wq) &#123;</span><br><span class=\"line\">        YYHDEBUG(&quot;create_workqueue failed!\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* 创建并提交工作者线程 */</span><br><span class=\"line\">    my_work = (my_work_t *)kmalloc(sizeof(my_work_t), GFP_KERNEL);</span><br><span class=\"line\">    if (!my_work) &#123;</span><br><span class=\"line\">        YYHDEBUG(&quot;kmalloc failed!\\n&quot;);</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    INIT_WORK((struct work_struct *)my_work, my_work_handler);</span><br><span class=\"line\">    my_work-&gt;x = 1;</span><br><span class=\"line\">    queue_work(my_wq, (struct work_struct *)my_work);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __exit my_module_exit(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /* 销毁工作者队列 */</span><br><span class=\"line\">    flush_workqueue(my_wq);</span><br><span class=\"line\">    destroy_workqueue(my_wq);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(my_module_init);</span><br><span class=\"line\">module_exit(my_module_exit);</span><br><span class=\"line\"></span><br><span class=\"line\">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class=\"line\">MODULE_AUTHOR(&quot;Lion Long&quot;);</span><br><span class=\"line\">MODULE_DESCRIPTION(&quot;A simple example Linux module.&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>例子展示了如何创建一个名为“my_queue”的工作者队列，然后创建一个工作者线程来处理一个名为“my_work”的工作对象。“my_work_handler”函数将打印出传递给工作对象的参数“x”，并释放工作对象的内存。在模块初始化期间，创建工作者队列和工作对象，并提交工作对象到队列中。在模块退出期间，销毁工作者队列。</p>\n<p>Linux 内核中的工作者线程是一种非常重要的机制，能够显著提高系统的性能和响应速度。虽然用户无法直接控制工作者线程的创建和销毁，但可以通过一些系统调优技巧来优化工作者线程的使用效果。<br>2.4、扩展知识：用户态线程的创建<br>线程创建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;pthread.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span><br><span class=\"line\">                   void *(*start_routine)(void*), void *arg);</span><br></pre></td></tr></table></figure>\n\n<p>该函数用于创建一个新的线程，并将其添加到调用进程中。参数 thread 是指向新线程标识符的指针，参数 attr 是指向线程属性的指针（通常为 NULL），参数 start_routine 是指向线程执行函数的指针，参数 arg 是传递给线程执行函数的参数。</p>\n<p>线程销毁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void pthread_exit(void *value_ptr);</span><br></pre></td></tr></table></figure>\n\n<p>该函数用于终止当前线程，并返回一个指针值。这个值可以由其他线程通过 pthread_join 函数获取，也可以被忽略。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int pthread_join(pthread_t thread, void **value_ptr);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>该函数用于阻塞当前线程，直到指定的线程 thread 终止。如果指针 value_ptr 不为 NULL，则会将线程的返回值存储在 value_ptr 指向的位置中。</p>\n<p>注意：如果线程没有被显式地分离，则它将一直存在于内存中，直到进程结束。因此，在创建线程时，应该考虑是否需要将它们分离或者等待它们的结束。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/Long_xu/article/details/1314057422.2\">https://blog.csdn.net/Long_xu/article/details/1314057422.2</a></p>\n"},{"title":"小爱同学控制电脑开关","date":"2024-07-02T12:50:22.000Z","_content":"\n\n\n# 一、环境准备\n\nwin11、小爱音箱、esp32(通过wol唤醒电脑)、巴法云平台注册\n\n这里使用的是esp32-cam\n\n![image-20240702211605888](../imgs/image-20240702211605888.png)\n\n# 二、开关机原理\n\n开机利用WOL技术，Wake-On-LAN简称WOL，是一种电源管理功能；如果存在网络活动，则允许设备将操作系统从待机或休眠模式中唤醒。许多主板厂商支持IBM提出的网络唤醒标准。该标准允许网络管理员远程打开PC机电源,以便进行文件升级、资源跟踪和设备清点等工作。WOL在还未广泛的采用,但在网络时代却具有广阔的发展前景。Wake-On-LAN的实现，主要是向目标主机发送特殊格式的数据包，是AMD公司制作的MagicPacket这套软件以生成网络唤醒所需要的特殊数据包，俗称魔术包（Magic Packet）。MagicPacket格式虽然只是AMD公司开发推广的技术，并非世界公认的标准，但是仍然受到很多网卡制造商的支持，因此许多具有网络唤醒功能的网卡都能与之兼容。wol基本实现原理实现是向需要被唤醒的终端网卡发送`FFFFFFFFFFFFFF+目标主机MAC地址(重复16次)`所组成的一个数据包，网卡收到数据后终端。（需要主板支持WOL，在BIOS中设置打开）\n\nwol参考：https://blog.csdn.net/a18359388932/article/details/126949062\n\n关机则通过获取巴法云获取关机指令，再通过python执行关机命令实现。\n\n## 数据传输框架\n\n小爱其实是不直接操作内网被控的电脑，而是通过小爱给一个第三方物联网平台巴法云发送一个消息，而你内网要部署一个用来接收巴法云下发的消息的程序，一旦接收到状态有发生变化，就执行一些执行，比如发送魔术包开机，再比如通过脚本ssh登录你的主机Windows主机执行关机命令.\n\n![xiaoaiui.png](../imgs/xiaoaiui.png)\n\n# 三、环境搭建\n\n## 1.巴法云平台设置\n\n打开巴法科技&巴法云-巴法设备云-巴法物联网云平台 (bemfa.com)，点击注册\n\nTCP创客云-》新建主题 pc006 -》设置昵称为电脑\n\n注意：\n\n新建主题的名称`pc`可以任意修改，但末尾必须是006，表示开关设备\n\n修改设备昵称，这个昵称`电脑`就是后面在米家中控制的名称\n\n记住私钥、主题（`pc006`）后续会用到\n\n![image-20240702214224123](../imgs/image-20240702214224123.png)\n\n## 2.米家设置\n\n打开手机app`米家`-我的-添加其他平台-添加-选择巴法-登录巴法账号-同步设备；\n\n同步成功后会显示出电脑图标，后面就可以通过小爱同学语音控制\"打开电脑\"\n\n## 3.windows网络唤醒设置\n\n进入BIOS设置wol（自行百度设置）\n\n1.打开设备管理器，点击网络适配器，右键属性，将电源管理的两个勾勾打上；\n\n![电源管理](../imgs/cce3ff865e6348cb9da8625fe5b92fe0.png)\n\n在高级设置里面将关机网络唤醒和魔术封包唤醒开启\n\n![网络唤醒](../imgs/82c684268ac443d191e73eb73b60aec4.png)\n\n## 4.搭建esp32开发环境并部署\n\n参考：\n\nhttps://blog.csdn.net/weixin_43935402/article/details/125590294\n\n环境搭建完毕后：\n\n本项目使用 Arduino 框架。\n\n- WakeOnLan : https://github.com/a7md0/WakeOnLan\n- AsyncTCP : https://github.com/me-no-dev/AsyncTCP\n\n参考：\n\nhttps://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main\n\n## （1）新建项目\n\n![image-20240702220340059](../imgs/image-20240702220340059.png)\n\n## （2）导入esp32库\n\n![image-20240702220502413](../imgs/image-20240702220502413.png)\n\n## （3） 添加库\n\n![image-20240702220705763](../imgs/image-20240702220705763.png)\n\n添加库WakeOnLan \n\n![image-20240702220828261](../imgs/image-20240702220828261.png)\n\n添加库AsyncTCP \n\n![image-20240702220932130](../imgs/image-20240702220932130.png)\n\n## （4）导入库\n\n![image-20240702221037900](../imgs/image-20240702221037900.png)\n\n添加文件bemfa_client.hpp、wifi_helper.hpp：\n\n![image-20240702221620487](../imgs/image-20240702221620487.png)\n\n将main.cpp拷贝到.ino文件中\n\n![image-20240702222853017](../imgs/image-20240702222853017.png)\n\n\n\n```\n#include \"bemfa_client.hpp\"\n#include \"WakeOnLan.h\"\n#include \"wifi_helper.hpp\"\n\nBemfaClient* bemfaClient;\nWifiHelper* wifiHelper;\n\nWiFiUDP UDP;\nWakeOnLan WOL(UDP);\n\nconst int LED_Pin = 2;\n\nconst char *SSID = \"xxx\";  // wifi名称\nconst char *PSW = \"xxx\";  // wifi密码\n\nconst char *UID = \"xxx\";  // 巴法云的UID\nconst char *TOPIC = \"pc006\";  // 巴法云中创建的TOPIC(不是昵称)\n\nconst char *TARGET_MAC_ADDR = \"xxx\";  // 要启动的电脑的MAC地址\n\nvoid blinkTwice() {\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n    delay(200);\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"Beginning...\");\n    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);\n    bemfaClient = new BemfaClient(UID, TOPIC);\n    bemfaClient->addCommand(\"on\", []{\n        Serial.println(\"Send magic packet\");\n        WOL.setRepeat(3, 100);\n        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());\n        WOL.sendMagicPacket(TARGET_MAC_ADDR);\n        blinkTwice();\n    });\n}\n\nvoid loop() {\n    wifiHelper->tick();\n    bemfaClient->tick();\n}\n```\n\n编译烧录即可，然后通过小爱同学“打开电脑”即可控制电脑开机\n\n## 5.关机python脚本配置\n\n安装python\n\n参考：https://docs.python.org/zh-cn/3/using/index.html\n\n```\n#安装相关依赖\npip install requests\npip install schedule\npip install pyinstaller\n```\n\npython打包\nhttps://www.cnblogs.com/weilaiqinkong/p/17240065.html\n\n如：pyinstaller -F -w main.py\n\n巴法云平台tcp连接参考：https://bbs.bemfa.com/81\n\n### main.py\n\n```\n\n# -*- coding: utf-8\nimport socket\nimport threading\nimport time\nimport os\nimport shutil\nimport sys\nimport getpass\n\ndef connTCP():\n    global tcp_client_socket\n    # 创建socket\n    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # IP 和端口\n    server_ip = 'bemfa.com'\n    server_port = 8344\n    try:\n        # 连接服务器\n        tcp_client_socket.connect((server_ip, server_port))\n        #发送订阅指令\n        substr = 'cmd=1&uid=巴法云私钥&topic=pc006\\r\\n'\n        tcp_client_socket.send(substr.encode(\"utf-8\"))\n    except:\n        time.sleep(2)\n        connTCP()\n\n#心跳\ndef Ping():\n    # 发送心跳\n    try:\n        keeplive = 'ping\\r\\n'\n        tcp_client_socket.send(keeplive.encode(\"utf-8\"))\n    except:\n        time.sleep(2)\n        connTCP()\n    #开启定时，30秒发送一次心跳\n    t = threading.Timer(30,Ping)\n    t.start()\n\n\nconnTCP()\nPing()\n\nwhile True:\n    # 接收服务器发送过来的数据\n    recvData = tcp_client_socket.recv(1024)\n    if len(recvData) != 0:\n        data = recvData.decode('utf-8')\n        print('recv:', data)\n        if \"on\" in data:\n            print(\"do nothing!\")\n        elif \"off\" in data:\n            print(\"starting poweroff after 3s ...\")\n            # 3s后 系统自动关机\n            print(os.system('shutdown -s -t 3'))\n    else:\n        print(\"conn err\")\n        connTCP()\n\n```\n\n设置main.exe开机启动\n\nhttps://www.cnblogs.com/muxiaomu/p/16649990.html","source":"_posts/小爱同学控制电脑开关.md","raw":"---\ntitle: 小爱同学控制电脑开关\ncategories:\n  - test\ntags:\n  - test\n  - wol \ndate: 2024-07-02 20:50:22\n---\n\n\n\n# 一、环境准备\n\nwin11、小爱音箱、esp32(通过wol唤醒电脑)、巴法云平台注册\n\n这里使用的是esp32-cam\n\n![image-20240702211605888](../imgs/image-20240702211605888.png)\n\n# 二、开关机原理\n\n开机利用WOL技术，Wake-On-LAN简称WOL，是一种电源管理功能；如果存在网络活动，则允许设备将操作系统从待机或休眠模式中唤醒。许多主板厂商支持IBM提出的网络唤醒标准。该标准允许网络管理员远程打开PC机电源,以便进行文件升级、资源跟踪和设备清点等工作。WOL在还未广泛的采用,但在网络时代却具有广阔的发展前景。Wake-On-LAN的实现，主要是向目标主机发送特殊格式的数据包，是AMD公司制作的MagicPacket这套软件以生成网络唤醒所需要的特殊数据包，俗称魔术包（Magic Packet）。MagicPacket格式虽然只是AMD公司开发推广的技术，并非世界公认的标准，但是仍然受到很多网卡制造商的支持，因此许多具有网络唤醒功能的网卡都能与之兼容。wol基本实现原理实现是向需要被唤醒的终端网卡发送`FFFFFFFFFFFFFF+目标主机MAC地址(重复16次)`所组成的一个数据包，网卡收到数据后终端。（需要主板支持WOL，在BIOS中设置打开）\n\nwol参考：https://blog.csdn.net/a18359388932/article/details/126949062\n\n关机则通过获取巴法云获取关机指令，再通过python执行关机命令实现。\n\n## 数据传输框架\n\n小爱其实是不直接操作内网被控的电脑，而是通过小爱给一个第三方物联网平台巴法云发送一个消息，而你内网要部署一个用来接收巴法云下发的消息的程序，一旦接收到状态有发生变化，就执行一些执行，比如发送魔术包开机，再比如通过脚本ssh登录你的主机Windows主机执行关机命令.\n\n![xiaoaiui.png](../imgs/xiaoaiui.png)\n\n# 三、环境搭建\n\n## 1.巴法云平台设置\n\n打开巴法科技&巴法云-巴法设备云-巴法物联网云平台 (bemfa.com)，点击注册\n\nTCP创客云-》新建主题 pc006 -》设置昵称为电脑\n\n注意：\n\n新建主题的名称`pc`可以任意修改，但末尾必须是006，表示开关设备\n\n修改设备昵称，这个昵称`电脑`就是后面在米家中控制的名称\n\n记住私钥、主题（`pc006`）后续会用到\n\n![image-20240702214224123](../imgs/image-20240702214224123.png)\n\n## 2.米家设置\n\n打开手机app`米家`-我的-添加其他平台-添加-选择巴法-登录巴法账号-同步设备；\n\n同步成功后会显示出电脑图标，后面就可以通过小爱同学语音控制\"打开电脑\"\n\n## 3.windows网络唤醒设置\n\n进入BIOS设置wol（自行百度设置）\n\n1.打开设备管理器，点击网络适配器，右键属性，将电源管理的两个勾勾打上；\n\n![电源管理](../imgs/cce3ff865e6348cb9da8625fe5b92fe0.png)\n\n在高级设置里面将关机网络唤醒和魔术封包唤醒开启\n\n![网络唤醒](../imgs/82c684268ac443d191e73eb73b60aec4.png)\n\n## 4.搭建esp32开发环境并部署\n\n参考：\n\nhttps://blog.csdn.net/weixin_43935402/article/details/125590294\n\n环境搭建完毕后：\n\n本项目使用 Arduino 框架。\n\n- WakeOnLan : https://github.com/a7md0/WakeOnLan\n- AsyncTCP : https://github.com/me-no-dev/AsyncTCP\n\n参考：\n\nhttps://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main\n\n## （1）新建项目\n\n![image-20240702220340059](../imgs/image-20240702220340059.png)\n\n## （2）导入esp32库\n\n![image-20240702220502413](../imgs/image-20240702220502413.png)\n\n## （3） 添加库\n\n![image-20240702220705763](../imgs/image-20240702220705763.png)\n\n添加库WakeOnLan \n\n![image-20240702220828261](../imgs/image-20240702220828261.png)\n\n添加库AsyncTCP \n\n![image-20240702220932130](../imgs/image-20240702220932130.png)\n\n## （4）导入库\n\n![image-20240702221037900](../imgs/image-20240702221037900.png)\n\n添加文件bemfa_client.hpp、wifi_helper.hpp：\n\n![image-20240702221620487](../imgs/image-20240702221620487.png)\n\n将main.cpp拷贝到.ino文件中\n\n![image-20240702222853017](../imgs/image-20240702222853017.png)\n\n\n\n```\n#include \"bemfa_client.hpp\"\n#include \"WakeOnLan.h\"\n#include \"wifi_helper.hpp\"\n\nBemfaClient* bemfaClient;\nWifiHelper* wifiHelper;\n\nWiFiUDP UDP;\nWakeOnLan WOL(UDP);\n\nconst int LED_Pin = 2;\n\nconst char *SSID = \"xxx\";  // wifi名称\nconst char *PSW = \"xxx\";  // wifi密码\n\nconst char *UID = \"xxx\";  // 巴法云的UID\nconst char *TOPIC = \"pc006\";  // 巴法云中创建的TOPIC(不是昵称)\n\nconst char *TARGET_MAC_ADDR = \"xxx\";  // 要启动的电脑的MAC地址\n\nvoid blinkTwice() {\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n    delay(200);\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"Beginning...\");\n    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);\n    bemfaClient = new BemfaClient(UID, TOPIC);\n    bemfaClient->addCommand(\"on\", []{\n        Serial.println(\"Send magic packet\");\n        WOL.setRepeat(3, 100);\n        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());\n        WOL.sendMagicPacket(TARGET_MAC_ADDR);\n        blinkTwice();\n    });\n}\n\nvoid loop() {\n    wifiHelper->tick();\n    bemfaClient->tick();\n}\n```\n\n编译烧录即可，然后通过小爱同学“打开电脑”即可控制电脑开机\n\n## 5.关机python脚本配置\n\n安装python\n\n参考：https://docs.python.org/zh-cn/3/using/index.html\n\n```\n#安装相关依赖\npip install requests\npip install schedule\npip install pyinstaller\n```\n\npython打包\nhttps://www.cnblogs.com/weilaiqinkong/p/17240065.html\n\n如：pyinstaller -F -w main.py\n\n巴法云平台tcp连接参考：https://bbs.bemfa.com/81\n\n### main.py\n\n```\n\n# -*- coding: utf-8\nimport socket\nimport threading\nimport time\nimport os\nimport shutil\nimport sys\nimport getpass\n\ndef connTCP():\n    global tcp_client_socket\n    # 创建socket\n    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # IP 和端口\n    server_ip = 'bemfa.com'\n    server_port = 8344\n    try:\n        # 连接服务器\n        tcp_client_socket.connect((server_ip, server_port))\n        #发送订阅指令\n        substr = 'cmd=1&uid=巴法云私钥&topic=pc006\\r\\n'\n        tcp_client_socket.send(substr.encode(\"utf-8\"))\n    except:\n        time.sleep(2)\n        connTCP()\n\n#心跳\ndef Ping():\n    # 发送心跳\n    try:\n        keeplive = 'ping\\r\\n'\n        tcp_client_socket.send(keeplive.encode(\"utf-8\"))\n    except:\n        time.sleep(2)\n        connTCP()\n    #开启定时，30秒发送一次心跳\n    t = threading.Timer(30,Ping)\n    t.start()\n\n\nconnTCP()\nPing()\n\nwhile True:\n    # 接收服务器发送过来的数据\n    recvData = tcp_client_socket.recv(1024)\n    if len(recvData) != 0:\n        data = recvData.decode('utf-8')\n        print('recv:', data)\n        if \"on\" in data:\n            print(\"do nothing!\")\n        elif \"off\" in data:\n            print(\"starting poweroff after 3s ...\")\n            # 3s后 系统自动关机\n            print(os.system('shutdown -s -t 3'))\n    else:\n        print(\"conn err\")\n        connTCP()\n\n```\n\n设置main.exe开机启动\n\nhttps://www.cnblogs.com/muxiaomu/p/16649990.html","slug":"小爱同学控制电脑开关","published":1,"updated":"2024-07-02T14:40:15.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly4inxow0000rujuc2c9apuy","content":"<h1 id=\"一、环境准备\"><a href=\"#一、环境准备\" class=\"headerlink\" title=\"一、环境准备\"></a>一、环境准备</h1><p>win11、小爱音箱、esp32(通过wol唤醒电脑)、巴法云平台注册</p>\n<p>这里使用的是esp32-cam</p>\n<p><img src=\"/../imgs/image-20240702211605888.png\" alt=\"image-20240702211605888\"></p>\n<h1 id=\"二、开关机原理\"><a href=\"#二、开关机原理\" class=\"headerlink\" title=\"二、开关机原理\"></a>二、开关机原理</h1><p>开机利用WOL技术，Wake-On-LAN简称WOL，是一种电源管理功能；如果存在网络活动，则允许设备将操作系统从待机或休眠模式中唤醒。许多主板厂商支持IBM提出的网络唤醒标准。该标准允许网络管理员远程打开PC机电源,以便进行文件升级、资源跟踪和设备清点等工作。WOL在还未广泛的采用,但在网络时代却具有广阔的发展前景。Wake-On-LAN的实现，主要是向目标主机发送特殊格式的数据包，是AMD公司制作的MagicPacket这套软件以生成网络唤醒所需要的特殊数据包，俗称魔术包（Magic Packet）。MagicPacket格式虽然只是AMD公司开发推广的技术，并非世界公认的标准，但是仍然受到很多网卡制造商的支持，因此许多具有网络唤醒功能的网卡都能与之兼容。wol基本实现原理实现是向需要被唤醒的终端网卡发送<code>FFFFFFFFFFFFFF+目标主机MAC地址(重复16次)</code>所组成的一个数据包，网卡收到数据后终端。（需要主板支持WOL，在BIOS中设置打开）</p>\n<p>wol参考：<a href=\"https://blog.csdn.net/a18359388932/article/details/126949062\">https://blog.csdn.net/a18359388932/article/details/126949062</a></p>\n<p>关机则通过获取巴法云获取关机指令，再通过python执行关机命令实现。</p>\n<h2 id=\"数据传输框架\"><a href=\"#数据传输框架\" class=\"headerlink\" title=\"数据传输框架\"></a>数据传输框架</h2><p>小爱其实是不直接操作内网被控的电脑，而是通过小爱给一个第三方物联网平台巴法云发送一个消息，而你内网要部署一个用来接收巴法云下发的消息的程序，一旦接收到状态有发生变化，就执行一些执行，比如发送魔术包开机，再比如通过脚本ssh登录你的主机Windows主机执行关机命令.</p>\n<p><img src=\"/../imgs/xiaoaiui.png\" alt=\"xiaoaiui.png\"></p>\n<h1 id=\"三、环境搭建\"><a href=\"#三、环境搭建\" class=\"headerlink\" title=\"三、环境搭建\"></a>三、环境搭建</h1><h2 id=\"1-巴法云平台设置\"><a href=\"#1-巴法云平台设置\" class=\"headerlink\" title=\"1.巴法云平台设置\"></a>1.巴法云平台设置</h2><p>打开巴法科技&amp;巴法云-巴法设备云-巴法物联网云平台 (bemfa.com)，点击注册</p>\n<p>TCP创客云-》新建主题 pc006 -》设置昵称为电脑</p>\n<p>注意：</p>\n<p>新建主题的名称<code>pc</code>可以任意修改，但末尾必须是006，表示开关设备</p>\n<p>修改设备昵称，这个昵称<code>电脑</code>就是后面在米家中控制的名称</p>\n<p>记住私钥、主题（<code>pc006</code>）后续会用到</p>\n<p><img src=\"/../imgs/image-20240702214224123.png\" alt=\"image-20240702214224123\"></p>\n<h2 id=\"2-米家设置\"><a href=\"#2-米家设置\" class=\"headerlink\" title=\"2.米家设置\"></a>2.米家设置</h2><p>打开手机app<code>米家</code>-我的-添加其他平台-添加-选择巴法-登录巴法账号-同步设备；</p>\n<p>同步成功后会显示出电脑图标，后面就可以通过小爱同学语音控制”打开电脑”</p>\n<h2 id=\"3-windows网络唤醒设置\"><a href=\"#3-windows网络唤醒设置\" class=\"headerlink\" title=\"3.windows网络唤醒设置\"></a>3.windows网络唤醒设置</h2><p>进入BIOS设置wol（自行百度设置）</p>\n<p>1.打开设备管理器，点击网络适配器，右键属性，将电源管理的两个勾勾打上；</p>\n<p><img src=\"/../imgs/cce3ff865e6348cb9da8625fe5b92fe0.png\" alt=\"电源管理\"></p>\n<p>在高级设置里面将关机网络唤醒和魔术封包唤醒开启</p>\n<p><img src=\"/../imgs/82c684268ac443d191e73eb73b60aec4.png\" alt=\"网络唤醒\"></p>\n<h2 id=\"4-搭建esp32开发环境并部署\"><a href=\"#4-搭建esp32开发环境并部署\" class=\"headerlink\" title=\"4.搭建esp32开发环境并部署\"></a>4.搭建esp32开发环境并部署</h2><p>参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_43935402/article/details/125590294\">https://blog.csdn.net/weixin_43935402/article/details/125590294</a></p>\n<p>环境搭建完毕后：</p>\n<p>本项目使用 Arduino 框架。</p>\n<ul>\n<li>WakeOnLan : <a href=\"https://github.com/a7md0/WakeOnLan\">https://github.com/a7md0/WakeOnLan</a></li>\n<li>AsyncTCP : <a href=\"https://github.com/me-no-dev/AsyncTCP\">https://github.com/me-no-dev/AsyncTCP</a></li>\n</ul>\n<p>参考：</p>\n<p><a href=\"https://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main\">https://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main</a></p>\n<h2 id=\"（1）新建项目\"><a href=\"#（1）新建项目\" class=\"headerlink\" title=\"（1）新建项目\"></a>（1）新建项目</h2><p><img src=\"/../imgs/image-20240702220340059.png\" alt=\"image-20240702220340059\"></p>\n<h2 id=\"（2）导入esp32库\"><a href=\"#（2）导入esp32库\" class=\"headerlink\" title=\"（2）导入esp32库\"></a>（2）导入esp32库</h2><p><img src=\"/../imgs/image-20240702220502413.png\" alt=\"image-20240702220502413\"></p>\n<h2 id=\"（3）-添加库\"><a href=\"#（3）-添加库\" class=\"headerlink\" title=\"（3） 添加库\"></a>（3） 添加库</h2><p><img src=\"/../imgs/image-20240702220705763.png\" alt=\"image-20240702220705763\"></p>\n<p>添加库WakeOnLan </p>\n<p><img src=\"/../imgs/image-20240702220828261.png\" alt=\"image-20240702220828261\"></p>\n<p>添加库AsyncTCP </p>\n<p><img src=\"/../imgs/image-20240702220932130.png\" alt=\"image-20240702220932130\"></p>\n<h2 id=\"（4）导入库\"><a href=\"#（4）导入库\" class=\"headerlink\" title=\"（4）导入库\"></a>（4）导入库</h2><p><img src=\"/../imgs/image-20240702221037900.png\" alt=\"image-20240702221037900\"></p>\n<p>添加文件bemfa_client.hpp、wifi_helper.hpp：</p>\n<p><img src=\"/../imgs/image-20240702221620487.png\" alt=\"image-20240702221620487\"></p>\n<p>将main.cpp拷贝到.ino文件中</p>\n<p><img src=\"/../imgs/image-20240702222853017.png\" alt=\"image-20240702222853017\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;bemfa_client.hpp&quot;</span><br><span class=\"line\">#include &quot;WakeOnLan.h&quot;</span><br><span class=\"line\">#include &quot;wifi_helper.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">BemfaClient* bemfaClient;</span><br><span class=\"line\">WifiHelper* wifiHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">WiFiUDP UDP;</span><br><span class=\"line\">WakeOnLan WOL(UDP);</span><br><span class=\"line\"></span><br><span class=\"line\">const int LED_Pin = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">const char *SSID = &quot;xxx&quot;;  // wifi名称</span><br><span class=\"line\">const char *PSW = &quot;xxx&quot;;  // wifi密码</span><br><span class=\"line\"></span><br><span class=\"line\">const char *UID = &quot;xxx&quot;;  // 巴法云的UID</span><br><span class=\"line\">const char *TOPIC = &quot;pc006&quot;;  // 巴法云中创建的TOPIC(不是昵称)</span><br><span class=\"line\"></span><br><span class=\"line\">const char *TARGET_MAC_ADDR = &quot;xxx&quot;;  // 要启动的电脑的MAC地址</span><br><span class=\"line\"></span><br><span class=\"line\">void blinkTwice() &#123;</span><br><span class=\"line\">    digitalWrite(LED_Pin, HIGH);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, LOW);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, HIGH);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, LOW);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void setup() &#123;</span><br><span class=\"line\">    Serial.begin(115200);</span><br><span class=\"line\">    Serial.println(&quot;Beginning...&quot;);</span><br><span class=\"line\">    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);</span><br><span class=\"line\">    bemfaClient = new BemfaClient(UID, TOPIC);</span><br><span class=\"line\">    bemfaClient-&gt;addCommand(&quot;on&quot;, []&#123;</span><br><span class=\"line\">        Serial.println(&quot;Send magic packet&quot;);</span><br><span class=\"line\">        WOL.setRepeat(3, 100);</span><br><span class=\"line\">        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());</span><br><span class=\"line\">        WOL.sendMagicPacket(TARGET_MAC_ADDR);</span><br><span class=\"line\">        blinkTwice();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void loop() &#123;</span><br><span class=\"line\">    wifiHelper-&gt;tick();</span><br><span class=\"line\">    bemfaClient-&gt;tick();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译烧录即可，然后通过小爱同学“打开电脑”即可控制电脑开机</p>\n<h2 id=\"5-关机python脚本配置\"><a href=\"#5-关机python脚本配置\" class=\"headerlink\" title=\"5.关机python脚本配置\"></a>5.关机python脚本配置</h2><p>安装python</p>\n<p>参考：<a href=\"https://docs.python.org/zh-cn/3/using/index.html\">https://docs.python.org/zh-cn/3/using/index.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#安装相关依赖</span><br><span class=\"line\">pip install requests</span><br><span class=\"line\">pip install schedule</span><br><span class=\"line\">pip install pyinstaller</span><br></pre></td></tr></table></figure>\n\n<p>python打包<br><a href=\"https://www.cnblogs.com/weilaiqinkong/p/17240065.html\">https://www.cnblogs.com/weilaiqinkong/p/17240065.html</a></p>\n<p>如：pyinstaller -F -w main.py</p>\n<p>巴法云平台tcp连接参考：<a href=\"https://bbs.bemfa.com/81\">https://bbs.bemfa.com/81</a></p>\n<h3 id=\"main-py\"><a href=\"#main-py\" class=\"headerlink\" title=\"main.py\"></a>main.py</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># -*- coding: utf-8</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\">import os</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">import sys</span><br><span class=\"line\">import getpass</span><br><span class=\"line\"></span><br><span class=\"line\">def connTCP():</span><br><span class=\"line\">    global tcp_client_socket</span><br><span class=\"line\">    # 创建socket</span><br><span class=\"line\">    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">    # IP 和端口</span><br><span class=\"line\">    server_ip = &#x27;bemfa.com&#x27;</span><br><span class=\"line\">    server_port = 8344</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        # 连接服务器</span><br><span class=\"line\">        tcp_client_socket.connect((server_ip, server_port))</span><br><span class=\"line\">        #发送订阅指令</span><br><span class=\"line\">        substr = &#x27;cmd=1&amp;uid=巴法云私钥&amp;topic=pc006\\r\\n&#x27;</span><br><span class=\"line\">        tcp_client_socket.send(substr.encode(&quot;utf-8&quot;))</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\"></span><br><span class=\"line\">#心跳</span><br><span class=\"line\">def Ping():</span><br><span class=\"line\">    # 发送心跳</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        keeplive = &#x27;ping\\r\\n&#x27;</span><br><span class=\"line\">        tcp_client_socket.send(keeplive.encode(&quot;utf-8&quot;))</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\">    #开启定时，30秒发送一次心跳</span><br><span class=\"line\">    t = threading.Timer(30,Ping)</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">connTCP()</span><br><span class=\"line\">Ping()</span><br><span class=\"line\"></span><br><span class=\"line\">while True:</span><br><span class=\"line\">    # 接收服务器发送过来的数据</span><br><span class=\"line\">    recvData = tcp_client_socket.recv(1024)</span><br><span class=\"line\">    if len(recvData) != 0:</span><br><span class=\"line\">        data = recvData.decode(&#x27;utf-8&#x27;)</span><br><span class=\"line\">        print(&#x27;recv:&#x27;, data)</span><br><span class=\"line\">        if &quot;on&quot; in data:</span><br><span class=\"line\">            print(&quot;do nothing!&quot;)</span><br><span class=\"line\">        elif &quot;off&quot; in data:</span><br><span class=\"line\">            print(&quot;starting poweroff after 3s ...&quot;)</span><br><span class=\"line\">            # 3s后 系统自动关机</span><br><span class=\"line\">            print(os.system(&#x27;shutdown -s -t 3&#x27;))</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;conn err&quot;)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>设置main.exe开机启动</p>\n<p><a href=\"https://www.cnblogs.com/muxiaomu/p/16649990.html\">https://www.cnblogs.com/muxiaomu/p/16649990.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、环境准备\"><a href=\"#一、环境准备\" class=\"headerlink\" title=\"一、环境准备\"></a>一、环境准备</h1><p>win11、小爱音箱、esp32(通过wol唤醒电脑)、巴法云平台注册</p>\n<p>这里使用的是esp32-cam</p>\n<p><img src=\"/../imgs/image-20240702211605888.png\" alt=\"image-20240702211605888\"></p>\n<h1 id=\"二、开关机原理\"><a href=\"#二、开关机原理\" class=\"headerlink\" title=\"二、开关机原理\"></a>二、开关机原理</h1><p>开机利用WOL技术，Wake-On-LAN简称WOL，是一种电源管理功能；如果存在网络活动，则允许设备将操作系统从待机或休眠模式中唤醒。许多主板厂商支持IBM提出的网络唤醒标准。该标准允许网络管理员远程打开PC机电源,以便进行文件升级、资源跟踪和设备清点等工作。WOL在还未广泛的采用,但在网络时代却具有广阔的发展前景。Wake-On-LAN的实现，主要是向目标主机发送特殊格式的数据包，是AMD公司制作的MagicPacket这套软件以生成网络唤醒所需要的特殊数据包，俗称魔术包（Magic Packet）。MagicPacket格式虽然只是AMD公司开发推广的技术，并非世界公认的标准，但是仍然受到很多网卡制造商的支持，因此许多具有网络唤醒功能的网卡都能与之兼容。wol基本实现原理实现是向需要被唤醒的终端网卡发送<code>FFFFFFFFFFFFFF+目标主机MAC地址(重复16次)</code>所组成的一个数据包，网卡收到数据后终端。（需要主板支持WOL，在BIOS中设置打开）</p>\n<p>wol参考：<a href=\"https://blog.csdn.net/a18359388932/article/details/126949062\">https://blog.csdn.net/a18359388932/article/details/126949062</a></p>\n<p>关机则通过获取巴法云获取关机指令，再通过python执行关机命令实现。</p>\n<h2 id=\"数据传输框架\"><a href=\"#数据传输框架\" class=\"headerlink\" title=\"数据传输框架\"></a>数据传输框架</h2><p>小爱其实是不直接操作内网被控的电脑，而是通过小爱给一个第三方物联网平台巴法云发送一个消息，而你内网要部署一个用来接收巴法云下发的消息的程序，一旦接收到状态有发生变化，就执行一些执行，比如发送魔术包开机，再比如通过脚本ssh登录你的主机Windows主机执行关机命令.</p>\n<p><img src=\"/../imgs/xiaoaiui.png\" alt=\"xiaoaiui.png\"></p>\n<h1 id=\"三、环境搭建\"><a href=\"#三、环境搭建\" class=\"headerlink\" title=\"三、环境搭建\"></a>三、环境搭建</h1><h2 id=\"1-巴法云平台设置\"><a href=\"#1-巴法云平台设置\" class=\"headerlink\" title=\"1.巴法云平台设置\"></a>1.巴法云平台设置</h2><p>打开巴法科技&amp;巴法云-巴法设备云-巴法物联网云平台 (bemfa.com)，点击注册</p>\n<p>TCP创客云-》新建主题 pc006 -》设置昵称为电脑</p>\n<p>注意：</p>\n<p>新建主题的名称<code>pc</code>可以任意修改，但末尾必须是006，表示开关设备</p>\n<p>修改设备昵称，这个昵称<code>电脑</code>就是后面在米家中控制的名称</p>\n<p>记住私钥、主题（<code>pc006</code>）后续会用到</p>\n<p><img src=\"/../imgs/image-20240702214224123.png\" alt=\"image-20240702214224123\"></p>\n<h2 id=\"2-米家设置\"><a href=\"#2-米家设置\" class=\"headerlink\" title=\"2.米家设置\"></a>2.米家设置</h2><p>打开手机app<code>米家</code>-我的-添加其他平台-添加-选择巴法-登录巴法账号-同步设备；</p>\n<p>同步成功后会显示出电脑图标，后面就可以通过小爱同学语音控制”打开电脑”</p>\n<h2 id=\"3-windows网络唤醒设置\"><a href=\"#3-windows网络唤醒设置\" class=\"headerlink\" title=\"3.windows网络唤醒设置\"></a>3.windows网络唤醒设置</h2><p>进入BIOS设置wol（自行百度设置）</p>\n<p>1.打开设备管理器，点击网络适配器，右键属性，将电源管理的两个勾勾打上；</p>\n<p><img src=\"/../imgs/cce3ff865e6348cb9da8625fe5b92fe0.png\" alt=\"电源管理\"></p>\n<p>在高级设置里面将关机网络唤醒和魔术封包唤醒开启</p>\n<p><img src=\"/../imgs/82c684268ac443d191e73eb73b60aec4.png\" alt=\"网络唤醒\"></p>\n<h2 id=\"4-搭建esp32开发环境并部署\"><a href=\"#4-搭建esp32开发环境并部署\" class=\"headerlink\" title=\"4.搭建esp32开发环境并部署\"></a>4.搭建esp32开发环境并部署</h2><p>参考：</p>\n<p><a href=\"https://blog.csdn.net/weixin_43935402/article/details/125590294\">https://blog.csdn.net/weixin_43935402/article/details/125590294</a></p>\n<p>环境搭建完毕后：</p>\n<p>本项目使用 Arduino 框架。</p>\n<ul>\n<li>WakeOnLan : <a href=\"https://github.com/a7md0/WakeOnLan\">https://github.com/a7md0/WakeOnLan</a></li>\n<li>AsyncTCP : <a href=\"https://github.com/me-no-dev/AsyncTCP\">https://github.com/me-no-dev/AsyncTCP</a></li>\n</ul>\n<p>参考：</p>\n<p><a href=\"https://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main\">https://github.com/yeyt97/ESP32-Bemfa-WOL-Tool/tree/main</a></p>\n<h2 id=\"（1）新建项目\"><a href=\"#（1）新建项目\" class=\"headerlink\" title=\"（1）新建项目\"></a>（1）新建项目</h2><p><img src=\"/../imgs/image-20240702220340059.png\" alt=\"image-20240702220340059\"></p>\n<h2 id=\"（2）导入esp32库\"><a href=\"#（2）导入esp32库\" class=\"headerlink\" title=\"（2）导入esp32库\"></a>（2）导入esp32库</h2><p><img src=\"/../imgs/image-20240702220502413.png\" alt=\"image-20240702220502413\"></p>\n<h2 id=\"（3）-添加库\"><a href=\"#（3）-添加库\" class=\"headerlink\" title=\"（3） 添加库\"></a>（3） 添加库</h2><p><img src=\"/../imgs/image-20240702220705763.png\" alt=\"image-20240702220705763\"></p>\n<p>添加库WakeOnLan </p>\n<p><img src=\"/../imgs/image-20240702220828261.png\" alt=\"image-20240702220828261\"></p>\n<p>添加库AsyncTCP </p>\n<p><img src=\"/../imgs/image-20240702220932130.png\" alt=\"image-20240702220932130\"></p>\n<h2 id=\"（4）导入库\"><a href=\"#（4）导入库\" class=\"headerlink\" title=\"（4）导入库\"></a>（4）导入库</h2><p><img src=\"/../imgs/image-20240702221037900.png\" alt=\"image-20240702221037900\"></p>\n<p>添加文件bemfa_client.hpp、wifi_helper.hpp：</p>\n<p><img src=\"/../imgs/image-20240702221620487.png\" alt=\"image-20240702221620487\"></p>\n<p>将main.cpp拷贝到.ino文件中</p>\n<p><img src=\"/../imgs/image-20240702222853017.png\" alt=\"image-20240702222853017\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;bemfa_client.hpp&quot;</span><br><span class=\"line\">#include &quot;WakeOnLan.h&quot;</span><br><span class=\"line\">#include &quot;wifi_helper.hpp&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">BemfaClient* bemfaClient;</span><br><span class=\"line\">WifiHelper* wifiHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">WiFiUDP UDP;</span><br><span class=\"line\">WakeOnLan WOL(UDP);</span><br><span class=\"line\"></span><br><span class=\"line\">const int LED_Pin = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">const char *SSID = &quot;xxx&quot;;  // wifi名称</span><br><span class=\"line\">const char *PSW = &quot;xxx&quot;;  // wifi密码</span><br><span class=\"line\"></span><br><span class=\"line\">const char *UID = &quot;xxx&quot;;  // 巴法云的UID</span><br><span class=\"line\">const char *TOPIC = &quot;pc006&quot;;  // 巴法云中创建的TOPIC(不是昵称)</span><br><span class=\"line\"></span><br><span class=\"line\">const char *TARGET_MAC_ADDR = &quot;xxx&quot;;  // 要启动的电脑的MAC地址</span><br><span class=\"line\"></span><br><span class=\"line\">void blinkTwice() &#123;</span><br><span class=\"line\">    digitalWrite(LED_Pin, HIGH);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, LOW);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, HIGH);</span><br><span class=\"line\">    delay(200);</span><br><span class=\"line\">    digitalWrite(LED_Pin, LOW);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void setup() &#123;</span><br><span class=\"line\">    Serial.begin(115200);</span><br><span class=\"line\">    Serial.println(&quot;Beginning...&quot;);</span><br><span class=\"line\">    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);</span><br><span class=\"line\">    bemfaClient = new BemfaClient(UID, TOPIC);</span><br><span class=\"line\">    bemfaClient-&gt;addCommand(&quot;on&quot;, []&#123;</span><br><span class=\"line\">        Serial.println(&quot;Send magic packet&quot;);</span><br><span class=\"line\">        WOL.setRepeat(3, 100);</span><br><span class=\"line\">        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());</span><br><span class=\"line\">        WOL.sendMagicPacket(TARGET_MAC_ADDR);</span><br><span class=\"line\">        blinkTwice();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void loop() &#123;</span><br><span class=\"line\">    wifiHelper-&gt;tick();</span><br><span class=\"line\">    bemfaClient-&gt;tick();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译烧录即可，然后通过小爱同学“打开电脑”即可控制电脑开机</p>\n<h2 id=\"5-关机python脚本配置\"><a href=\"#5-关机python脚本配置\" class=\"headerlink\" title=\"5.关机python脚本配置\"></a>5.关机python脚本配置</h2><p>安装python</p>\n<p>参考：<a href=\"https://docs.python.org/zh-cn/3/using/index.html\">https://docs.python.org/zh-cn/3/using/index.html</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#安装相关依赖</span><br><span class=\"line\">pip install requests</span><br><span class=\"line\">pip install schedule</span><br><span class=\"line\">pip install pyinstaller</span><br></pre></td></tr></table></figure>\n\n<p>python打包<br><a href=\"https://www.cnblogs.com/weilaiqinkong/p/17240065.html\">https://www.cnblogs.com/weilaiqinkong/p/17240065.html</a></p>\n<p>如：pyinstaller -F -w main.py</p>\n<p>巴法云平台tcp连接参考：<a href=\"https://bbs.bemfa.com/81\">https://bbs.bemfa.com/81</a></p>\n<h3 id=\"main-py\"><a href=\"#main-py\" class=\"headerlink\" title=\"main.py\"></a>main.py</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># -*- coding: utf-8</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\">import os</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">import sys</span><br><span class=\"line\">import getpass</span><br><span class=\"line\"></span><br><span class=\"line\">def connTCP():</span><br><span class=\"line\">    global tcp_client_socket</span><br><span class=\"line\">    # 创建socket</span><br><span class=\"line\">    tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class=\"line\">    # IP 和端口</span><br><span class=\"line\">    server_ip = &#x27;bemfa.com&#x27;</span><br><span class=\"line\">    server_port = 8344</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        # 连接服务器</span><br><span class=\"line\">        tcp_client_socket.connect((server_ip, server_port))</span><br><span class=\"line\">        #发送订阅指令</span><br><span class=\"line\">        substr = &#x27;cmd=1&amp;uid=巴法云私钥&amp;topic=pc006\\r\\n&#x27;</span><br><span class=\"line\">        tcp_client_socket.send(substr.encode(&quot;utf-8&quot;))</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\"></span><br><span class=\"line\">#心跳</span><br><span class=\"line\">def Ping():</span><br><span class=\"line\">    # 发送心跳</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        keeplive = &#x27;ping\\r\\n&#x27;</span><br><span class=\"line\">        tcp_client_socket.send(keeplive.encode(&quot;utf-8&quot;))</span><br><span class=\"line\">    except:</span><br><span class=\"line\">        time.sleep(2)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\">    #开启定时，30秒发送一次心跳</span><br><span class=\"line\">    t = threading.Timer(30,Ping)</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">connTCP()</span><br><span class=\"line\">Ping()</span><br><span class=\"line\"></span><br><span class=\"line\">while True:</span><br><span class=\"line\">    # 接收服务器发送过来的数据</span><br><span class=\"line\">    recvData = tcp_client_socket.recv(1024)</span><br><span class=\"line\">    if len(recvData) != 0:</span><br><span class=\"line\">        data = recvData.decode(&#x27;utf-8&#x27;)</span><br><span class=\"line\">        print(&#x27;recv:&#x27;, data)</span><br><span class=\"line\">        if &quot;on&quot; in data:</span><br><span class=\"line\">            print(&quot;do nothing!&quot;)</span><br><span class=\"line\">        elif &quot;off&quot; in data:</span><br><span class=\"line\">            print(&quot;starting poweroff after 3s ...&quot;)</span><br><span class=\"line\">            # 3s后 系统自动关机</span><br><span class=\"line\">            print(os.system(&#x27;shutdown -s -t 3&#x27;))</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&quot;conn err&quot;)</span><br><span class=\"line\">        connTCP()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>设置main.exe开机启动</p>\n<p><a href=\"https://www.cnblogs.com/muxiaomu/p/16649990.html\">https://www.cnblogs.com/muxiaomu/p/16649990.html</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clvjcoaak0000r9w096yq3vus","category_id":"clvjcoaap0002r9w0crcqdq03","_id":"clvjcoaaw000cr9w08o1qg2p3"},{"post_id":"clvjcoaao0001r9w0de539y4w","category_id":"clvjcoaap0002r9w0crcqdq03","_id":"clvjcoaax000gr9w0ehtae99g"},{"post_id":"clvjcoaav000ar9w07gr4ho88","category_id":"clvjcoaap0002r9w0crcqdq03","_id":"clvjcoaax000kr9w0f4ky7c51"},{"post_id":"clvjcoaaw000er9w08cjhb54a","category_id":"clvjcoaap0002r9w0crcqdq03","_id":"clvjcoaay000lr9w0e3ria1o6"},{"post_id":"clvjcoaar0004r9w0en6ne5w9","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clvjcoaay000or9w00pce3443"},{"post_id":"clvjcoaas0005r9w0fujveufw","category_id":"clvjcoaax000ir9w04u7q98wg","_id":"clvjcoaaz000sr9w0djz70avq"},{"post_id":"clvjcoaas0006r9w0ciswdc7c","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clvjcoaaz000vr9w017tt2vjp"},{"post_id":"clvjcoaau0009r9w09xzi7r99","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clvjcoab0000xr9w0426fd2m5"},{"post_id":"clw7gjvto00004zw06cc94zms","category_id":"clw7gjvtt00024zw0fh4pclyx","_id":"clw7gjvtx00084zw03eyl828h"},{"post_id":"clw7gjvtv00044zw001hi1y1n","category_id":"clw7gupas000164w0bopbhhya","_id":"clw7gupat000564w05o3563ug"},{"post_id":"clw7gjvtr00014zw0fnm7f1ci","category_id":"clw7gupat000364w0drn50ao5","_id":"clw7gupau000664w072cd3et3"},{"post_id":"clw7y3oy60000zfapahvk834m","category_id":"clw7gupas000164w0bopbhhya","_id":"clw7y3oye0002zfapcfp3hcq1"},{"post_id":"clw8xrfbp00009gw0cohxazat","category_id":"clvjcoaax000ir9w04u7q98wg","_id":"clw8xrfbz00039gw03vt392oi"},{"post_id":"clw8xrfby00029gw0eobh98nt","category_id":"clvjcoaax000ir9w04u7q98wg","_id":"clw8xrfc000069gw07omohu0b"},{"post_id":"clw95434m0001auw046z4fp3s","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clw95434t0005auw07iq42zh6"},{"post_id":"clwa1rz3i0000prw00euv7b5w","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clwa1rz3o0002prw09c8i6o7o"},{"post_id":"clwabwixx0001ygw07nwzhs9w","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clwabwiy00003ygw0f0nz758x"},{"post_id":"clwadqd7500017pw0hxu7428y","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clwadqd7900037pw073thebjb"},{"post_id":"clwagumwd0001npw0h9fu9ufz","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clwagumwg0003npw0cp1nbie9"},{"post_id":"clwlk2mex0000anw01kfwh17t","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clwlk2mf00002anw0h5j70qzz"},{"post_id":"clwlnyyfs0000ozw0ay2kbg9h","category_id":"clw7gupat000364w0drn50ao5","_id":"clwlnyyfz0002ozw0glpcc8gz"},{"post_id":"clwoskrac000190w0b4um8252","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clwoskrai000390w09gnf5j2b"},{"post_id":"clwrgv1zm0000o9w01mxf2xve","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clwrgv1zq0002o9w09npqg92h"},{"post_id":"clwsoctx000008iw0f5a48f47","category_id":"clvjcoaax000ir9w04u7q98wg","_id":"clwsoctx600028iw01ubb1ezx"},{"post_id":"clwyex3u100008iw09myx1v78","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clwyex3ub00028iw01go2c7yz"},{"post_id":"clwyksja60000ijw0dbptaw6i","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clwyksjab0002ijw07cicdlro"},{"post_id":"clxkbblhq0000gjw08hd3guux","category_id":"clvjcoaax000ir9w04u7q98wg","_id":"clxkbblhy0002gjw000r2bir1"},{"post_id":"clxlkqk1600008iw06by4bx94","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clxlkqk1c00028iw0auvw8t9e"},{"post_id":"clxss7yyq00018jw0bm510aot","category_id":"clvjcoaav000br9w04s5fhod2","_id":"clxss7yyu00038jw0411k2zcl"},{"post_id":"cly4inxow0000rujuc2c9apuy","category_id":"clvjcoaav000br9w04s5fhod2","_id":"cly4inxp40002ruju0as695lr"}],"PostTag":[{"post_id":"clvjcoaak0000r9w096yq3vus","tag_id":"clvjcoaaq0003r9w08ymn3cfp","_id":"clvjcoaax000fr9w02xtp3tin"},{"post_id":"clvjcoaak0000r9w096yq3vus","tag_id":"clvjcoaat0008r9w05igj2bah","_id":"clvjcoaax000hr9w0gehbfdrt"},{"post_id":"clvjcoaao0001r9w0de539y4w","tag_id":"clvjcoaaw000dr9w04q1p9cdh","_id":"clvjcoaay000pr9w04nsc72sp"},{"post_id":"clvjcoaao0001r9w0de539y4w","tag_id":"clvjcoaat0008r9w05igj2bah","_id":"clvjcoaaz000qr9w0bnjl71ed"},{"post_id":"clvjcoaar0004r9w0en6ne5w9","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"clvjcoaaz000ur9w01h1d21ws"},{"post_id":"clvjcoaas0005r9w0fujveufw","tag_id":"clvjcoaaz000tr9w0a5za0wkx","_id":"clvjcoab0000zr9w06rk38a4e"},{"post_id":"clvjcoaas0005r9w0fujveufw","tag_id":"clvjcoaaz000wr9w0a7ntbfe6","_id":"clvjcoab00010r9w0ajuncswp"},{"post_id":"clvjcoaas0006r9w0ciswdc7c","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"clvjcoab00012r9w0b9ve9luz"},{"post_id":"clvjcoaau0009r9w09xzi7r99","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"clvjcoab10014r9w048v69qhr"},{"post_id":"clvjcoaav000ar9w07gr4ho88","tag_id":"clvjcoab00013r9w0c8xwbm67","_id":"clvjcoab10016r9w07u1chj94"},{"post_id":"clvjcoaav000ar9w07gr4ho88","tag_id":"clvjcoaat0008r9w05igj2bah","_id":"clvjcoab10017r9w06r3w5vfb"},{"post_id":"clvjcoaaw000er9w08cjhb54a","tag_id":"clvjcoab10015r9w0gy9m55qe","_id":"clvjcoab10018r9w00o6f31ht"},{"post_id":"clvjcoaaw000er9w08cjhb54a","tag_id":"clvjcoaat0008r9w05igj2bah","_id":"clvjcoab10019r9w0bne6eeju"},{"post_id":"clw7gjvtv00044zw001hi1y1n","tag_id":"clw7gjvtx00094zw03hlaf5nx","_id":"clw7gjvty000e4zw0hb5cb7g4"},{"post_id":"clw7gjvtv00044zw001hi1y1n","tag_id":"clw7gjvtx000b4zw073y0bgcy","_id":"clw7gjvty000f4zw0114f3d1e"},{"post_id":"clw7gjvtv00044zw001hi1y1n","tag_id":"clw7gjvtx000c4zw04prpfaj1","_id":"clw7gjvty000g4zw06kgv5plx"},{"post_id":"clw7gjvtr00014zw0fnm7f1ci","tag_id":"clw7gjvtu00034zw01k8ceqqd","_id":"clw7gupat000264w0a1wu7io7"},{"post_id":"clw7gjvto00004zw06cc94zms","tag_id":"clw7gupao000064w0fvoobl7z","_id":"clw7gupat000464w0gs92a2g2"},{"post_id":"clw7y3oy60000zfapahvk834m","tag_id":"clw7y3oyb0001zfaphpdt0wj3","_id":"clw7y3oye0003zfap8b679qb4"},{"post_id":"clw8xrfbp00009gw0cohxazat","tag_id":"clw8xrfbw00019gw0blydb92o","_id":"clw8xrfc000059gw09e0j2bi1"},{"post_id":"clw8xrfby00029gw0eobh98nt","tag_id":"clw8xrfbz00049gw025d8fta2","_id":"clw8xrfc000079gw00xnihtux"},{"post_id":"clw95434m0001auw046z4fp3s","tag_id":"clw95434q0003auw0arpwg82o","_id":"clw95434t0006auw0dn4t41a8"},{"post_id":"clwa1rz3i0000prw00euv7b5w","tag_id":"clwa1rz3m0001prw061nd5ybu","_id":"clwa1rz3p0003prw09kle7rz7"},{"post_id":"clwabwixx0001ygw07nwzhs9w","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"clwabwiy00002ygw0djgvck7g"},{"post_id":"clwadqd7500017pw0hxu7428y","tag_id":"clwadqd7700027pw06lcm7qdu","_id":"clwadqd7900047pw0gyy3f4nd"},{"post_id":"clwagumwd0001npw0h9fu9ufz","tag_id":"clwadqd7700027pw06lcm7qdu","_id":"clwagumwg0002npw0ewhu127v"},{"post_id":"clwlk2mex0000anw01kfwh17t","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"clwlk2mf00001anw0ec65ga0r"},{"post_id":"clwlnyyfs0000ozw0ay2kbg9h","tag_id":"clwlnyyfw0001ozw00ybyh0ua","_id":"clwlnyyg00003ozw0h0tahupg"},{"post_id":"clwoskrac000190w0b4um8252","tag_id":"clwoskraf000290w0befoghhj","_id":"clwoskrai000490w01zlwb6nu"},{"post_id":"clwrgv1zm0000o9w01mxf2xve","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"clwrgv1zq0001o9w07szu24p3"},{"post_id":"clwsoctx000008iw0f5a48f47","tag_id":"clwsoctx300018iw00k5y1q7j","_id":"clwsoctx700048iw0cm528hpc"},{"post_id":"clwsoctx000008iw0f5a48f47","tag_id":"clwsoctx600038iw0d17y1cbr","_id":"clwsoctx700058iw0800bbbwf"},{"post_id":"clwyex3u100008iw09myx1v78","tag_id":"clwyex3u700018iw0f2sf4p2l","_id":"clwyex3uc00038iw06urw4sop"},{"post_id":"clwyksja60000ijw0dbptaw6i","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"clwyksjaa0001ijw0a8rt5u4b"},{"post_id":"clxkbblhq0000gjw08hd3guux","tag_id":"clxkbblhu0001gjw0abif71sr","_id":"clxkbblhy0003gjw0feiw308a"},{"post_id":"clxlkqk1600008iw06by4bx94","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"clxlkqk1c00018iw0e5lv631g"},{"post_id":"clxss7yyq00018jw0bm510aot","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"clxss7yyu00028jw0h6lu3ml4"},{"post_id":"cly4inxow0000rujuc2c9apuy","tag_id":"clvjcoaay000nr9w0c45zbyxp","_id":"cly4inxp40003rujuazpx7luy"},{"post_id":"cly4inxow0000rujuc2c9apuy","tag_id":"cly4inxoz0001ruju80n6bir1","_id":"cly4inxp40004ruju5wa5b97e"}],"Tag":[{"name":"学习网站","_id":"clvjcoaaq0003r9w08ymn3cfp"},{"name":"rust","_id":"clvjcoaat0008r9w05igj2bah"},{"name":"rust环境搭建","_id":"clvjcoaaw000dr9w04q1p9cdh"},{"name":"test","_id":"clvjcoaay000nr9w0c45zbyxp"},{"name":"power","_id":"clvjcoaaz000tr9w0a5za0wkx"},{"name":"cpufreq","_id":"clvjcoaaz000wr9w0a7ntbfe6"},{"name":"rust基本类型","_id":"clvjcoab00013r9w0c8xwbm67"},{"name":"rust复合类型","_id":"clvjcoab10015r9w0gy9m55qe"},{"name":"block","_id":"clw7gjvtu00034zw01k8ceqqd"},{"name":"uboot","_id":"clw7gjvtw00064zw07bp6f6uj"},{"name":"fdt","_id":"clw7gjvtx00094zw03hlaf5nx"},{"name":"GPT","_id":"clw7gjvtx000b4zw073y0bgcy"},{"name":"rk3588","_id":"clw7gjvtx000c4zw04prpfaj1"},{"name":"vsfs","_id":"clw7gupao000064w0fvoobl7z"},{"name":"uboot概念","_id":"clw7y3oyb0001zfaphpdt0wj3"},{"name":"cgroup","_id":"clw8xrfbw00019gw0blydb92o"},{"name":"pinctrl","_id":"clw8xrfbz00049gw025d8fta2"},{"name":"PHY芯片","_id":"clw95434q0003auw0arpwg82o"},{"name":"Clion","_id":"clwa1rz3m0001prw061nd5ybu"},{"name":"vscode","_id":"clwadqd7700027pw06lcm7qdu"},{"name":"ethrnet","_id":"clwlnyyfw0001ozw00ybyh0ua"},{"name":"缺页","_id":"clwoskraf000290w0befoghhj"},{"name":"dtb","_id":"clwsoctx300018iw00k5y1q7j"},{"name":"dts","_id":"clwsoctx600038iw0d17y1cbr"},{"name":"debug","_id":"clwyex3u700018iw0f2sf4p2l"},{"name":"内存管理","_id":"clxkbblhu0001gjw0abif71sr"},{"name":"wol","_id":"cly4inxoz0001ruju80n6bir1"}]}}