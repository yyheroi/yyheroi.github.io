<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>dtb to dts</title>
      <link href="/2024/05/30/dtb-to-dts/"/>
      <url>/2024/05/30/dtb-to-dts/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="rk3588-dtc-path"><a href="#rk3588-dtc-path" class="headerlink" title="[rk3588] dtc path"></a>[rk3588] dtc path</h2><p>linux&#x2F;kernel&#x2F;scripts&#x2F;dtc&#x2F;dtc </p><p>android&#x2F;out&#x2F;soong&#x2F;host&#x2F;linux-x86&#x2F;bin&#x2F;dtc</p><h2 id="使用adb获取fdt文件"><a href="#使用adb获取fdt文件" class="headerlink" title="使用adb获取fdt文件"></a>使用<a href="https://so.csdn.net/so/search?q=adb&spm=1001.2101.3001.7020">adb</a>获取fdt文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb pull /sys/firmware/fdt d:</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><h2 id="使用以下指令生成dts文件"><a href="#使用以下指令生成dts文件" class="headerlink" title="使用以下指令生成dts文件"></a>使用以下指令生成dts文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./out/soong/host/linux-x86/bin/dtc</span><br><span class="line">./dtc -I dtb -O dts –o fdt2dts.dts fdt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dtb </tag>
            
            <tag> dts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本-符合意义</title>
      <link href="/2024/05/29/shell%E8%84%9A%E6%9C%AC-%E7%AC%A6%E5%90%88%E6%84%8F%E4%B9%89/"/>
      <url>/2024/05/29/shell%E8%84%9A%E6%9C%AC-%E7%AC%A6%E5%90%88%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>shell中有两类字符：普通字符、元字符。</p><h4 id="1-普通字符"><a href="#1-普通字符" class="headerlink" title="1. 普通字符"></a>1. 普通字符</h4><p>在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本；</p><h4 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h4><p>是Shell的保留字符，在Shell中有着特殊的含义。</p><p><img src="/../imgs/2ef32c1ce3654484b236af25368bdab1.png" alt=" "></p><p><img src="/../imgs/71cd5d51140f4c07a2cee5a4d9d90f45.png" alt="img"></p><p>shell中字符<code>$</code>的各种用法。</p><h3 id="二、转义字符"><a href="#二、转义字符" class="headerlink" title="二、转义字符$"></a>二、<a href="https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6&spm=1001.2101.3001.7020">转义字符</a>$</h3><p>在linux shell脚本中经常用到字符<code>$</code>，下面是<code>$</code>的一些常见用法</p><p>名称含义<br>$#传给脚本的参数个数<br>$0脚本本身的名字<br>$1传递给该shell脚本的第一个参数<br>$2传递给该shell脚本的第二个参数<br>$@传给脚本的所有参数的列表<br>$*以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个<br>$$脚本运行的当前进程ID号<br>$?显示最后命令的退出状态，0表示没有错误，其他表示有错误</p><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p>建立脚本peng.sh如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line">total=$[ <span class="variable">$1</span> * <span class="variable">$2</span> + <span class="variable">$3</span> ]</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> * <span class="variable">$2</span> + <span class="variable">$3</span> = <span class="variable">$total</span>&quot;</span></span><br></pre></td></tr></table></figure><p>运行如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./peng.sh 4 5 6</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/../imgs/efcc46bc1fb845e898a37da989107ef9.png" alt=" "></p><h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><p>当把字符串输入给shell脚本的时候，注意是以空格作为分隔符，如果字符串本身就有空格的话，那么用双引号或者单引号，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is pretty nice!&quot;</span></span><br></pre></td></tr></table></figure><p>运行如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./peng.sh 一口Linux</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="/../imgs/0a6cf9231486414a8095f6dd113a2c7d.png" alt=" "></p><h4 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;参数个数:<span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;脚本名字:<span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;参数1:<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;参数2:<span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;所有参数列表:<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;pid:$$&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> = 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;命令退出状态：$?&quot;</span> </span><br><span class="line"> <span class="built_in">exit</span> 0 <span class="comment">#参数正确，退出状态为0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;命令退出状态：$?&quot;</span></span><br><span class="line"> <span class="built_in">exit</span> 1 <span class="comment">#参数错误，退出状态1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/../imgs/37e37dd76e0f42eb8e7c4c0bb3aab3cd.png" alt="img"></p><h4 id="实例4"><a href="#实例4" class="headerlink" title="实例4"></a>实例4</h4><p>使用for循环进行参数遍历</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">number=65             #定义一个退出值</span><br><span class="line">index=1               #定义一个计数器</span><br><span class="line">if [ -z &quot;$1&quot; ];then   #对用户输入的参数做判断，如果未输入参数则返回脚本的用法并退出，退出值65</span><br><span class="line">   echo &quot;Usage:$0 + 参数&quot;</span><br><span class="line">   exit $number</span><br><span class="line">fi</span><br><span class="line">echo &quot;listing args with \$*:&quot;    #在屏幕输入，在$*中遍历参数</span><br><span class="line">for arg in $*                                          </span><br><span class="line">do</span><br><span class="line">   echo &quot;arg: $index = $arg&quot;                 </span><br><span class="line">   let index+=1</span><br><span class="line">done</span><br><span class="line">echo</span><br><span class="line">index=1                         #将计数器重新设置为1</span><br><span class="line">echo &quot;listing args with \&quot;\$@\&quot;:&quot;    #在&quot;$@&quot;中遍历参数</span><br><span class="line">for arg in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">   echo &quot;arg: $index = $arg&quot;</span><br><span class="line">   let index+=1</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../imgs/36d83bdde0524001a910df7a8c9c3083.png" alt=" "></p><p><img src="/../imgs/2a8ad08662864bc293b3c520e486c473.png" alt=" "></p><h4 id="实例5"><a href="#实例5" class="headerlink" title="实例5"></a>实例5</h4><p>小技巧1：在”∗ “ 和 <em>“和∗”和</em>中遍历参数的区别</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">number=11</span><br><span class="line">if [ $# -eq 0 ];then</span><br><span class="line">   echo &quot;Usage: $0 + 参数&quot;</span><br><span class="line">   exit $number</span><br><span class="line">fi</span><br><span class="line">for i in $*               #在$*中遍历参数，此时每个参数都是独立的，会遍历$#次</span><br><span class="line">do</span><br><span class="line">   echo $i</span><br><span class="line">done</span><br><span class="line">echo</span><br><span class="line">for i in &quot;$*&quot;            #在&quot;$*&quot;中遍历参数，此时&quot;$*&quot;被扩展为包含所有位置参数的单个字符串，只遍历一次</span><br><span class="line">do</span><br><span class="line">   echo $i</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../imgs/325ec497200142f98be97ec17d2c9cf3.png" alt=" "></p><p>转：</p><p><a href="https://blog.csdn.net/daocaokafei/article/details/120050007">shell脚本中$0 $1 $# $@ $* $? $$ 的各种符号意义详解_shell $0-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统中的缺页</title>
      <link href="/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BC%BA%E9%A1%B5/"/>
      <url>/2024/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BC%BA%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>缺页是引入了虚拟内存后的一个概念。操作系统启动后，在内存中维护着一个虚拟地址表，进程需要的虚拟地址在虚拟地址表中记录。一个程序被加载运行时，只是加载了很少的一部分到内存，另外一部分在需要时再从磁盘载入。被加载到内存的部分标识为“驻留”，而未被加载到内存的部分标为“未驻留”。操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻留”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示”缺页”。这个时候，操作系统触发一个“缺页”的硬件陷阱，系统从磁盘换入这部分未“驻留”的代码。<br>       引入了分页机制(也就有了缺页机制)，则系统只需要加载程序的部分代码到内存，就可以创建进程运行， 需要程序的另一部分时再从磁盘载入并运行，从而允许比内存大很多的程序同时在内存运行。</p><p>转：</p><p><a href="https://blog.csdn.net/ComputerInBook/article/details/101112983">https://blog.csdn.net/ComputerInBook/article/details/101112983</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缺页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下通过ssh挂载远程服务器目录</title>
      <link href="/2024/05/25/Windows%E4%B8%8B%E9%80%9A%E8%BF%87ssh%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%AE%E5%BD%95/"/>
      <url>/2024/05/25/Windows%E4%B8%8B%E9%80%9A%E8%BF%87ssh%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>直接前往 github 对应项目的 release 中下载最新版本即可，需注意 sshfs-win 对 winfsp 的最低版本依赖（下载最新版本一般即可满足），另外有GUI（用户图形操作界面）可供下载，建议下载。</p><ul><li>sshfs-win：<a href="https://github.com/billziss-gh/sshfs-win/releases">https://github.com/billziss-gh/sshfs-win/releases</a></li><li>winfsp：<a href="https://github.com/billziss-gh/winfsp/releases">https://github.com/billziss-gh/winfsp/releases</a></li><li>SSHFS-Win Manager：<a href="https://github.com/evsar3/sshfs-win-manager/releases">https://github.com/evsar3/sshfs-win-manager/releases</a> (GUI，可选)</li></ul><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>可使用GUI图形界面（方式A），亦可手动挂载（方式B），建议使用GUI图形界面。</p><h4 id="方式A：使用GUI（推荐）"><a href="#方式A：使用GUI（推荐）" class="headerlink" title="方式A：使用GUI（推荐）"></a>方式A：使用GUI（推荐）</h4><p>新建连接</p><p>安装好上述3个软件后，打开 GUI 界面如下，点击 <code>Add Connection</code>：</p><p><img src="/../imgs/38433cbf3936910bd982dbe3edad457f.png" alt="img"></p><p>SSHFS-Win Manager GUI 主界面</p><p>依次填写每一项内容：</p><ul><li>NAME：给远程服务器取个名字</li><li>Connection：远程服务器配置，如IP、端口、远程用户名、验证方式（密码，或密钥[参考：<a href="https://blog.xieqk.com/posts/3517905979.html">SSH密钥管理及免密码登陆</a>]）</li><li>Remote：远程目录配置，挂载后将成为本地对应盘符的根目录</li><li>Local：本地盘符设置（注意不要与现有盘符冲突）</li></ul><p>示例如下：</p><p><img src="/../imgs/10679e86d7d5de085f10f418602d3fc0.png" alt="img"></p><p>添加连接</p><p>点击 <code>Save</code> 保存。</p><p>挂在远程目录</p><p>在主界面中点击<code>连接</code>按钮，即可将远程目录挂在到本地：</p><p><img src="/../imgs/b5509514fe3ed5e171527650e89113df.png" alt="img"></p><p>添加新连接后的主界面</p><p>此时远程目录已经出现在了本地资源管理器中，未出现可刷新一下，或直接点击GUI主界面<code>连接</code>按钮左边的<code>打开文件夹</code>按钮即可进入目录。</p><p><img src="/../imgs/9a41a7910eae90cbc4133263b56065b4.png" alt="img"></p><p>本地挂载成功</p><p>长期使用建议在主界面的设置中打开<code>开机自启</code>：</p><p>打开开机启动</p><p><img src="/../imgs/8191070c413a2f5053f4fa1fff32375d.png" alt="img"></p><h4 id="方式B：手动挂载"><a href="#方式B：手动挂载" class="headerlink" title="方式B：手动挂载"></a>方式B：手动挂载</h4><p>挂载路径</p><p><strong>1. SSH 使用默认端口（22）</strong></p><p>此时，对应的 ssh 登陆命令为 <code>ssh username@remote_ip</code>，那么使用 sshfs-win 挂载远程服务器根目录和 home 目录的地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 根目录</span><br><span class="line">\\sshfs.r\username@remote_ip\</span><br><span class="line"></span><br><span class="line"># home 目录</span><br><span class="line">\\sshfs\username@remote_ip\</span><br><span class="line"># 或者 \\sshfs.r\username@remote_ip\home\username\</span><br></pre></td></tr></table></figure><p>例如：<code>\\sshfs.r\xieqk@10.168.9.87\</code>，注意路径里面的分隔符为 windows 使用的反斜杠 <code>\</code>。</p><p><strong>2. SSH 使用其它端口（外网端口转发连接内网服务器）</strong></p><p>此时，ssh 登陆命令为 <code>ssh -p port username@remote_ip</code>，对应的 sshfs-win 挂载远程服务器根目录和 home 目录的地址在之前的 <code>remote_ip</code> 后加上 <code>!port</code> 即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 根目录</span><br><span class="line">\\sshfs.r\username@remote_ip\</span><br><span class="line"></span><br><span class="line"># home 目录</span><br><span class="line">\\sshfs\username@remote_ip\</span><br><span class="line"># 或者 \\sshfs.r\username@remote_ip\home\username\</span><br></pre></td></tr></table></figure><p>例如：<code>\\sshfs.r\xieqk@168.10.9.87!34567\</code>。</p><p>登陆挂载远程目录</p><p>将上述 <code>sshfs</code> 路径输入 windows 文件资源管理器地址栏，输入密码即可进入。（<strong>注意：</strong>弹窗中的账号显示的为 windows 的本地账号，不用修改。远程服务器的用户名已经包含在之前的 <code>sshfs</code> 路径之中，所以此处只需正常输入远程用户对应的密码即可。）</p><p>对于常用的远程目录，建议通过 <code>映射网络驱动器</code> 长期挂载于本地。</p><p><img src="/../imgs/a1e47db6d3e144affe47566fed629e9e.png" alt="img"></p><p>映射网络驱动器</p><p>在 <code>映射网络驱动器</code> 中，可自行分配驱动器盘号，然后在 <code>文件夹</code> 处输入上述 <code>sshfs</code> 路径，点击完成后在弹出的登录框处输入密码即可完成挂载。</p><p><img src="/../imgs/675b07d51113aeaf1b18b08b1fda130b.png" alt="img"></p><p>输入 sshfs 路径</p><p>之后，可在 windows 文件浏览器的网络位置中看到已经挂载的所有远程目录：</p><p><img src="/../imgs/84fe4ccf655091b45ffcad9c61def517.png" alt="img"></p><p>本地挂载成功</p><p>详细参数（可跳过，需要时再查看）</p><p>sshfs-win 具体语法形式如下，其中 <code>[]</code> 中的内容为选填项，若为默认值可不填：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\\sshfs\[LOCUSER=]REMUSER@HOST[!PORT][\PATH]</span><br><span class="line">\\sshfs.r\[LOCUSER=]REMUSER@HOST[!PORT][\PATH]</span><br><span class="line">\\sshfs.k\[LOCUSER=]REMUSER@HOST[!PORT][\PATH]</span><br></pre></td></tr></table></figure><ul><li><code>REMUSER</code>: 即 remote user，指 SSH 登陆远程主机时的用户名。</li><li><code>HOST</code>：远程服务器，如 IP 地址，DNS 服务器名称 或 DNS 服务器 IP 地址</li><li><code>PORT</code>：SSH 登陆所使用的端口号 (选填，默认为 SSH(22) 端口).</li><li><code>PATH</code>：进入的远程服务器路径，可按照如下设置:<ul><li>前缀 <code>sshfs</code> 对应为 <code>HOST:~REMUSER/PATH</code>，即远程服务器上相对于该用户 <code>home</code> 目录的相对路径：<code>/home/remote_user/PATH</code>。</li><li>前缀 <code>sshfs.r</code> 对应为 <code>HOST:/PATH</code> 即远程服务器上相对于根(root)目录的路径：<code>/PATH</code>。</li><li>前缀 <code>sshfs.k</code> 与第一项相同，对应为 <code>HOST:~REMUSER/PATH</code>，但它使用 Windows 本地当前用户位于 <code>%USERPROFILE%/.ssh/id_rsa</code> 下的 SSH 密钥进行认证（需进行远程服务器配置，可参靠<a href="https://blog.xieqk.com/posts/3517905979.html">SSH 密钥管理及免密码登陆</a>），不需要输入密码。（备注：使用前两项连接时，windows 也会提醒记住密码，所以只需要第一次输入密码并记住即可）</li></ul></li><li><code>LOCUSER</code> windows本地用户名，可不填。</li></ul><p>转：</p><p><a href="https://blog.csdn.net/qq_31811537/article/details/124721621">https://blog.csdn.net/qq_31811537/article/details/124721621</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01以太网ethernet-概念</title>
      <link href="/2024/05/23/01%E4%BB%A5%E5%A4%AA%E7%BD%91ethernet-%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/05/23/01%E4%BB%A5%E5%A4%AA%E7%BD%91ethernet-%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="stmmac"><a href="#stmmac" class="headerlink" title="stmmac"></a>stmmac</h2><p>drivers&#x2F;net&#x2F;stmicro&#x2F;stmmac</p><blockquote><p>stmmac 是一种以太网媒体访问控制器(Ethernet MAC, EMAC)的实现,由ST Microelectronics公司开发和维护</p></blockquote><h2 id="dwmac"><a href="#dwmac" class="headerlink" title="dwmac"></a>dwmac</h2><blockquote><p><code>dwmac</code> 是由 Synopsys 公司开发的一种广泛应用于系统芯片 (SoC) 设计中的以太网媒体访问控制器 (Ethernet MAC, EMAC) 实现</p></blockquote><h2 id="rgmii"><a href="#rgmii" class="headerlink" title="rgmii"></a>rgmii</h2><blockquote><p>RGMII(Reduced Gigabit Media Independent Interface)是一种以太网物理层(PHY)接口标准,主要用于连接系统芯片(SoC)与以太网收发器(PHY)之间。</p><ol><li>接口速率:</li></ol><ul><li>RGMII 支持 10&#x2F;100&#x2F;1000Mbps 三种以太网速率。</li></ul><ol start="2"><li>引脚数量:</li></ol><ul><li>RGMII 使用 24 个引脚(双向各 12 个)来传输数据和控制信号。</li></ul><ol start="3"><li>时序要求:</li></ol><ul><li>RGMII 接口需要严格的时序要求,包括数据和时钟之间的相位关系等。</li></ul><ol start="4"><li>信号类型:</li></ol><ul><li>RGMII 使用LVCMOS电平的并行数据信号,以及独立的发送和接收时钟信号。</li></ul></blockquote><h2 id="cru"><a href="#cru" class="headerlink" title="cru"></a>cru</h2><blockquote><p>CRU 是 Clock and Reset Unit 的缩写,指时钟和复位单元。它在系统芯片(SoC)中扮演着非常重要的角色。</p><p>CRU 的主要功能包括:</p><ol><li>时钟生成和管理:</li></ol><ul><li>生成和分配各种内部时钟信号,如 CPU 时钟、总线时钟等。</li><li>提供时钟切换和动态调频等功能,用于电源管理和性能优化。</li></ul><ol start="2"><li>复位控制:</li></ol><ul><li>生成和分配各种内部复位信号,如系统复位、模块复位等。</li><li>提供复位同步和延迟功能,确保复位信号的正确传播。</li></ul><ol start="3"><li>时钟&#x2F;复位状态监控:</li></ol><ul><li>监控时钟和复位信号的状态,并提供相关中断和状态寄存器。</li><li>用于诊断和调试时钟&#x2F;复位相关的问题。</li></ul><p>CRU 通常作为 SoC 中的一个独立模块,集中管理整个系统的时钟和复位相关功能。它与 CPU、内存、外设等模块紧密交互,确保系统稳定可靠地运行。</p><p>CRU 的设计和实现通常由 SoC 设计团队负责,需要考虑时钟源、复位策略、功耗、时序等多方面因素。它是构建高性能、低功耗 SoC 的关键组件之一。</p></blockquote><h2 id="rk3588-gmac驱动"><a href="#rk3588-gmac驱动" class="headerlink" title="rk3588-gmac驱动"></a>rk3588-gmac驱动</h2><p>kernel-5.10</p><p>kernel&#x2F;drivers&#x2F;net&#x2F;ethernet&#x2F;stmicro&#x2F;stmmac</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rk_gmac_probe</span><br><span class="line">stmmac_probe_config_dt</span><br><span class="line">stmmac_dt_phy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethrnet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode-远程连接失败</title>
      <link href="/2024/05/17/vscode-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/"/>
      <url>/2024/05/17/vscode-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<p>可能在服务端&#x2F;root&#x2F;.vscode-server&#x2F;bin这个目录存在一个与你本地vscode版本不一致的文件夹，删除这个对应的文件夹重新连接就行了</p><h1 id="先删除本地和服务端的know-hosts"><a href="#先删除本地和服务端的know-hosts" class="headerlink" title="先删除本地和服务端的know_hosts"></a>先删除本地和服务端的know_hosts</h1><p><img src="/../imgs/image-20240517171503577.png" alt="image-20240517171503577"></p><p><a href="https://blog.csdn.net/baidu_39131915/article/details/116302847">vscode远程连接提示过程试图写入的管道不存在_过程试图写入的管道不存在vscode-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode-安装-卸载</title>
      <link href="/2024/05/17/vscode-%E5%AE%89%E8%A3%85-%E5%8D%B8%E8%BD%BD/"/>
      <url>/2024/05/17/vscode-%E5%AE%89%E8%A3%85-%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>1.安装vscode</p><h1 id="一、安装vscode"><a href="#一、安装vscode" class="headerlink" title="一、安装vscode"></a>一、安装vscode</h1><p>1.安装vscode</p><p>下载链接：<a href="https://code.visualstudio.com/Download#">https://code.visualstudio.com/Download#</a></p><p>2.安装VScode插件</p><p><a href="https://marketplace.visualstudio.com/">https://marketplace.visualstudio.com</a></p><p>[Search results - remote | Visual Studio Code , Visual Studio Marketplace](<a href="https://marketplace.visualstudio.com/search?term=remote&target=VSCode&category=All">https://marketplace.visualstudio.com/search?term=remote&amp;target=VSCode&amp;category=All</a> categories&amp;sortBy&#x3D;Relevance)</p><p>安装vscode时选择默认路径，安装完成后打开，安装扩展：<br>1、 C&#x2F;C++（就是有些教程里的cpptools）<br>2、 C&#x2F;C++ Clang Command Adapter：提供静态检测（Lint），很重要<br>3、 Code Runner：右键即可编译运行单文件，很方便<br>4、 Bracket Pair Colorizer：彩虹花括号<br>5、 Include Autocomplete：提供头文件名字的补全<br>6、 C&#x2F;C++ Snippets：Snippets 即重用代码块，<br>7、 One Dark Pro：大概是VS Code安装量最高的主题<br>8、 python<br>9、Clang-Format<br>10、Chinese （Simplified）Language Pack for Visual Studio Code：汉化包</p><h1 id="二、卸载"><a href="#二、卸载" class="headerlink" title="二、卸载"></a>二、卸载</h1><p>1、打开控制面板的程序，卸载安装的vscode</p><p>或者</p><p>找到安装目录点击unins000</p><p><img src="/../imgs/image-20240517154457324-17159319055301.png" alt="image-20240517154457324"></p><p>2.删除相关配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C: \ Users \ .vscode</span><br><span class="line">C: \ Users \ AppData \ Roaming \ Code </span><br></pre></td></tr></table></figure><p>或者</p><p>win+r输入以下内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%appdata%#删除 Code目录</span><br><span class="line">%userprofile%#删除 .vscode</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/2301_80868127/article/details/136386915">彻底卸载VScode并重置本地配置数据-CSDN博客</a></p><p><a href="https://mp.weixin.qq.com/s/n7zyDFOeHd9K5oSKz7Zg9Q">vsCode离线安装remote-ssh插件搭建远程开发环境 (qq.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARMv8架构-内存虚拟化</title>
      <link href="/2024/05/17/ARMv8%E6%9E%B6%E6%9E%84-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
      <url>/2024/05/17/ARMv8%E6%9E%B6%E6%9E%84-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>ARM64为支持内存虚拟化，可以将地址类型分为如下三种：</p><ul><li><p><strong>VA（虚拟地址）</strong></p><p> 最大宽度为48bit，VA地址空间可分为底部VA和顶部VA两个子区域，每个VM子区域最大支持256T<br> 底部VA：0x0000_0000_0000_0000 &#x3D;&gt;0x0000_FFFF_FFFF_FFFF<br> 顶部VA：0xFFFF_0000_0000_0000 &#x3D;&gt;0xFFFF_FFFF_FFFF_FFFF</p></li><li><p><strong>IPA（中间物理地址）</strong></p><p> 如果不支持Stage 2转换，那么IPA&#x3D;&#x3D;PA。如果支持Stage 2，IPA作为Stage 1的OA(Output Adress)，IPA作为Stage 2的IA(Input Adress)。它最大支持48bit。</p></li><li><p><strong>PA（物理地址）</strong></p><p> 物理内存单元映射中地址，可以看做是PE到内存系统的输出地址(OA)，其最大支持48bit。</p></li></ul><p><img src="/..%5Cimgs%5Cimage2019-5-10_14-22-29.png" alt="图2 ARM64内存虚拟化"></p><p> 上图是ARM64内存虚拟化的框图，虚拟机通过TTBRn_EL1完成Stage 1的地址转换，将虚拟机使用的VA转换成IPA。然后再通过VTTBR_EL2完成Stage 2的地址转换，将IPA转换成PA。</p><p><img src="/../imgs/image2019-5-10_14-24-0.png" alt=" 图2 Stage 1地址转换"></p><p>上图是Stage 1（一阶地址转换图）图解，其转换过程如下：</p><table><thead><tr><th>TTBR 寄存器提供Level 0查找的基地址，通过此基地址和IA[n:39] &#x3D;&gt; 查找到Level 1基地址</th></tr></thead><tbody><tr><td>Level 1基地址结合IA[38：30]&#x3D;&gt; 查找到Level2 的基地址</td></tr><tr><td>Level 2基地址结合IA[29：21]&#x3D;&gt; 查找到Level3 的基地址</td></tr><tr><td>Level 3基地址结合IA[20：12]&#x3D;&gt; 查找物理页框所在地址OA</td></tr><tr><td>最后得到需要的物理地址PA[47：0] &lt;&#x3D; OA[47:12] + IA[11：0]</td></tr></tbody></table><p><img src="/../imgs/image2019-5-10_14-24-58.png" alt=" 图3 Stage 2地址转换"></p><p> 上图是Stage 2（二阶地址转换图）图解，，其转换过程如下：</p><table><thead><tr><th>Stage 2有级联table的概念，可以减少level的级数</th></tr></thead><tbody><tr><td>所谓级联就是假如有IA[40:0]，而Level1解析地址段为IA[38:30]，超过了2个bit，而2^40 &#x3D; 2^2*2^38，所以相当于要2^2个这样的translation table来实现级联解析。ARMv8规定，Stage 2最多支持4-bit级联，也就是最大级联2^4 &#x3D;&#x3D; 16个translation table级联解析.以达到减少查找level的目的.</td></tr><tr><td>VTTBR_EL2寄存器提供初始Level查找基地址，Stage 2只为EL2服务</td></tr><tr><td>同Stage 1，Level 1支持1GB的内存block，Level 2支持2MB的内存block</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clion202204-破解</title>
      <link href="/2024/05/17/Clion202204-%E7%A0%B4%E8%A7%A3/"/>
      <url>/2024/05/17/Clion202204-%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>此教程为CLion 2022.2.4 破解教程，且此教程以及下面提供的破解补丁适用与2022.2以后的新版本。<br>2022年11月10日亲测有效，mac与windows均测试完美破解</p><h3 id="CLion-下载"><a href="#CLion-下载" class="headerlink" title="CLion 下载"></a>CLion 下载</h3><p>Clion官网下载地址：<a href="https://www.jetbrains.com.cn/clion/download/other.html">https://www.jetbrains.com.cn/clion/download/other.html</a></p><p><img src="/../imgs/1894089-20230211102247487-1038132289.png" alt="image"></p><p>找到2022.2.4的，然后根据自己的电脑系统选择。Windows的下载Windows，Mac的下载Mac的。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>直接上面的地址下载安装即可，安装完后记得不要打开，打开后也要先关闭，这里步骤就忽略了，安装很简单。</p><ul><li><strong>卸载老版本 CLion(未安装则不用管，跳过看下面步骤)</strong><br>注意，安装新版本之前，如果本机安装过老版本的, 需要先彻底卸载，以免两者冲突，导致破解失败。<br><strong>安装太简单了，步骤就忽略了。</strong></li></ul><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><h3 id="破解补丁下载"><a href="#破解补丁下载" class="headerlink" title="破解补丁下载"></a>破解补丁下载</h3><p>破解补丁下载地址：<a href="https://kohler.lanzouo.com/iS5E40n7ojba">https://kohler.lanzouo.com/iS5E40n7ojba</a></p><h3 id="Windows版破解"><a href="#Windows版破解" class="headerlink" title="Windows版破解"></a>Windows版破解</h3><p>下载破解补丁后，解压得到，如下图：</p><p><img src="/../imgs/1894089-20230211102659035-421863408.png" alt="image"></p><p>将上面图示的补丁的所属文件夹 <code>/jetbra</code> 复制电脑某个位置，我是放置到了 桌面目录下（不推荐，自己选个D盘目录或者其他位置），<br>点击进入<code>/jetbra</code> 补丁目录，再点击进入<code>/scripts</code> 文件夹，双击执行 <code>install-all-user.vbs</code> 破解脚本：</p><p><img src="/../imgs/1894089-20230211102807063-1324567688.png" alt="image"></p><p><strong>注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。</strong></p><p><img src="/../imgs/1894089-20230211102825164-1230499662.png" alt="image"></p><p>会提示安装补丁需要等待数秒。点击<strong>【确定】</strong>按钮后，过程大概 10 - 30 秒，如看到弹框提示 Done 时，表示激活破解成功：</p><p><img src="/../imgs/1894089-20230211102841861-1500251037.png" alt="image"></p><h3 id="mac版破解"><a href="#mac版破解" class="headerlink" title="mac版破解"></a>mac版破解</h3><p><strong>Mac &#x2F; Linux</strong> 系统与上面 Windows 系统一样，需将补丁所属文件<code>/jetbra</code> 复制到某个路径，且<strong>路径不能包含空格与中文</strong>。</p><p>之后，打开终端，进入到<code>/jetbra/scripts</code> 文件夹， 执行 <code>install.sh</code>脚本, 命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash install.sh</span><br></pre></td></tr></table></figure><p>看到提示 Done , 表示激活成功。</p><p><img src="/../imgs/1894089-20230211104108634-1740893276.png" alt="image"></p><p><strong>Mac &#x2F; Linux</strong> 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，<strong>Mac &#x2F; Linux 需重启系统</strong>，以确保环境变量生效。</p><h3 id="linux版破解"><a href="#linux版破解" class="headerlink" title="linux版破解"></a>linux版破解</h3><p>和mac版一样，参考mac,这里就不做介绍了。</p><h3 id="重启-CLion"><a href="#重启-CLion" class="headerlink" title="重启 CLion"></a>重启 CLion</h3><p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p><p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p><p><strong>脚本执行成功后，一定要重启 CLion</strong>!!!</p><h2 id="填入指定激活码完成激活"><a href="#填入指定激活码完成激活" class="headerlink" title="填入指定激活码完成激活"></a>填入指定激活码完成激活</h2><p>打开文件夹里的激活码，粘贴到输入框内，点击 <code>Activate</code> 按钮，就激活成功了。</p><p><img src="/../imgs/1894089-20230211104238842-2069324840.png" alt="image"></p><p><img src="/../imgs/1894089-20230211104310444-38131101.png" alt="image"></p><p>激活成功后，就可以开心的 coding 了 ~</p><p><img src="/../imgs/1894089-20230211104336300-896542684.png" alt="image"></p><p>转：</p><p><a href="https://www.cnblogs.com/kohler21/p/17111018.html">CLion 2022.2.4破解教程详细图解mac,windows,linux均适用 - 愚生浅末 - 博客园 (cnblogs.com)</a></p><p>参考：</p><p><a href="https://cloud.tencent.com/developer/article/1406250">使用Clion优雅的完全远程自动同步和远程调试c++-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHY芯片</title>
      <link href="/2024/05/16/PHY%E8%8A%AF%E7%89%87/"/>
      <url>/2024/05/16/PHY%E8%8A%AF%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="PHY（physical-Layer，PHY）"><a href="#PHY（physical-Layer，PHY）" class="headerlink" title="PHY（physical Layer，PHY）"></a>PHY（physical Layer，PHY）</h1><h2 id="什么是PHY？"><a href="#什么是PHY？" class="headerlink" title="什么是PHY？"></a>什么是PHY？</h2><p>物理层芯片称为PHY、数据链路层芯片称为MAC</p><p>可以看到PHY的数据是<a href="https://so.csdn.net/so/search?q=RJ45&spm=1001.2101.3001.7020">RJ45</a>网络接口（网线口）穿过了的差分信号，而PHY作用就是将差分信号转为数字信号，这块内容不用深究，制造商都设计好了。</p><p>那我们干什么呢？（主要是对phy芯片进行模式选择，比如工作速率，工作模式）</p><h2 id="什么是RJ45接口？"><a href="#什么是RJ45接口？" class="headerlink" title="什么是RJ45接口？"></a>什么是RJ45接口？</h2><p>RJ45接口通常用于数据传输，最常见的应用为网卡接口。RJ-45端口是我们最常见的端口之一，是比较常见的<a href="https://www.zhihu.com/search?q=%E5%8F%8C%E7%BB%9E%E7%BA%BF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D">双绞线</a>以太网端口，因为在快速以太网中也主要采用双绞线作为传输介质。</p><p>RJ45型网线插头又称水晶头，共由八芯做成，广泛应用于局域网和ADSL宽带上网用户的网络设备间网线（称作五类线或双绞线）的连接。</p><p>RJ45接头根据线的排序不同主要分两种，一种是橙白、橙、绿白、蓝、蓝白、绿、棕白、棕；另一种是绿白、绿、橙白、蓝、蓝白、橙、棕白、棕；因此使用RJ45接头的线也有两种即：直通线、交叉线。分别称作<a href="https://www.zhihu.com/search?q=T568A%E7%BA%BF%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3477234795%7D">T568A线序</a>和T568B线序。</p><p>RJ45插座连接器接口内部是金属，注意不能受潮或者接触到水，否则会造成短路现象。</p><h2 id="为什么要熟悉RJ45网口"><a href="#为什么要熟悉RJ45网口" class="headerlink" title="为什么要熟悉RJ45网口"></a>为什么要熟悉RJ45网口</h2><p>上面说到针对phy芯片我们只要进行模式选择（下文会介绍使用<a href="https://so.csdn.net/so/search?q=mdio&spm=1001.2101.3001.7020">mdio</a>接口，通过寄存器控制）</p><p>那模式选择后，如何查看是否有效呢？最简单直接的就是通过RJ45网口的指示灯查看</p><p><img src="/../imgs/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16-17158590663256.png" alt="img"></p><p>RJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，<strong>绿色亮的话表示网络连接正常，黄色闪烁的话说明当前正在进行网络通信</strong>，<strong>黄灯闪动频率快表示网速</strong>好，这两个灯由 PHY 芯片控制。</p><h2 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h2><p><img src="/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><h2 id="两个模块进行通信"><a href="#两个模块进行通信" class="headerlink" title="两个模块进行通信"></a>两个模块进行通信</h2><p>下图是两个主控直接的通信，比如我们的电脑 和 路由器 ，但是如果没有中间的介质还能连接网络吗？答案是可以的</p><p>如果phy芯片没有，那么可以直接通过两个mac连接进行通信，之所以需要mac 、phy、变压器的目的是为了转换数据类型适配所以的网线，但是在一些电路上，没必要加这么多东西</p><p>比如搭载 Linux系统的arm芯片想要网络，可以直接通过mac和网卡芯片连接获取，这时候就需要通过RGMII接口或者MII接口 和 MDIO 连接网卡芯片。</p><p>（网卡芯片内置也是mac+phy，有的只有mac 层这个要看具体的手册）</p><p><img src="/../img/84b0b5e31bb246c0a970ace7c71a3f82.png" alt="img"></p><h2 id="什么是MDIO协议"><a href="#什么是MDIO协议" class="headerlink" title="什么是MDIO协议"></a>什么是MDIO协议</h2><p>mido协议即SMI协议</p><p>SMI协议也是一种通信协议类似与I2C协议但是通信方式不一样</p><p>SMI包含两根信号线，一个MDC时钟线，一个MDIO双向传输的数据线，</p><p>如图为SMI应用框图。STA设备通过MDIO接口与PHY通信。STA（StaTIon Management）为主控设备，比如MCU、MAC、ONU等。PHY为从设备。一个STA最多管理32个PHY。MDC信号由STA控制，MDIO信号根据通信方式的不同可以由STA或者PHY接管控制。如图通常MDIO会接一个电阻上拉至接口电源。</p><p><img src="/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><h2 id="MDIO的作用"><a href="#MDIO的作用" class="headerlink" title="MDIO的作用"></a>MDIO的作用</h2><p>从上面的连接图可以看到MDIO是用来连接主设备和多个PHY设备，并且通过MDIO来传输数据</p><p>那么传输的是数据是哪些呢？主要是传输链接状态、传输速度与选择、断电、低功率<a href="https://baike.baidu.com/item/%E4%BC%91%E7%9C%A0%E7%8A%B6%E6%80%81?fromModule=lemma_inlink">休眠状态</a>、TX&#x2F;RX模式选择、<a href="https://baike.baidu.com/item/%E8%87%AA%E5%8A%A8%E5%8D%8F%E5%95%86/7765053?fromModule=lemma_inlink">自动协商</a>控制、环回模式控制等。</p><h3 id="MDIO没那么重要"><a href="#MDIO没那么重要" class="headerlink" title="MDIO没那么重要"></a>MDIO没那么重要</h3><p>MDIO在上面说到的两个模块通信，我提到了 arm芯片和网卡芯片直接需要，那么这个真的有必要吗？其实没必要连接！！！</p><p>换个话说 不连接也可以使得网络畅通，因为网络的数据传输时靠RGMII不是靠MDIO，MDIO的作用仅仅只是用来查看一些状态和功能，还有简单的控制，而这些简单的控制是完全可以有网卡芯片内置去写死，arm层只要和网卡的写的一直就可以通讯。</p><p>但是为什么很多时候需要通过mdio来进行读写控制，这个只是在网络通讯正常后的升级优化，用来方便查看状态，就像写了个前端网页来看后台数据。</p><p>如果mido没有读通，或者读取的数据是0xfffff，那么不一定是mdio的问题，很多时候是网卡本身没有启动！</p><h2 id="MDIO读写时序"><a href="#MDIO读写时序" class="headerlink" title="MDIO读写时序"></a>MDIO读写时序</h2><p><img src="/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZGFpc3kuc2t5ZQ==,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>Preamble：32bits的前导码</p><p>Start：2bit的开始位。</p><p>OP Code：2bits的操作码，10表示读，01表示写。</p><p>PHYAD：5bits的PHY地址。</p><p>REGAD：5bits的寄存器地址，即要读或写的寄存器。</p><p>Turn Around：2bits的TA，在读命令中，MDIO在此时由MAC驱动改为PHY驱动，并等待一个时钟周期准备发送数据。在写命令中，不需要MDIO方向发生变化，则只是等待两个时钟周期准备写入数据。</p><p>Data：16bits数据，在读命令中，PHY芯片将读到的对应PHYAD的REGAD寄存器的数据写到Data中，在写命令中，MAC将要写入对应PHYAD的REGAD寄存器的值写入Data中。</p><p>Idle：空闲状态，此时MDIO无源驱动，处高阻状态，但一般用上拉电阻使其处在高电平，上拉电阻一般为1.5K。<br>为什么说读取的phy最多32个<br>因为mdio中读取的phy只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个，但这是从读取的方式判断的，而mdio读取是依照phy芯片本身地址空间就5为</p><h2 id="为什么说reg地址最多32个"><a href="#为什么说reg地址最多32个" class="headerlink" title="为什么说reg地址最多32个"></a>为什么说reg地址最多32个</h2><p>同样mdio中读取的reg只提供5bit的字节即最高11111 转成十进制就是31即0-31就是32个</p><p> PHY 芯片寄存器地址空间为 5 位，地址 0-31 共 32 个寄存器， IEEE 定义了 0-15 这 16 个寄存器的功能， 16<code>~</code>31 这 16 个寄存器由厂商自行实现。 也就是说不管你用的哪个厂家的 PHY 芯片，其中 0<code>~</code>15 这 16 个寄存器是一模一样的。 仅靠这 16 个寄存器是完全可以驱动起 PHY 芯片的，至少能保证基本的网络数据通信。</p><p>转：</p><p><a href="https://blog.csdn.net/qq_40715266/article/details/124095801">PHY芯片快速深度理解（持续更新中……）-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/148538791">PHY（Physical Layer，PHY） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHY芯片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cgroup</title>
      <link href="/2024/05/16/cgroup/"/>
      <url>/2024/05/16/cgroup/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>cgroup是linux内核实现、用于控制linux系统资源的组件。因此要了解cgroup，首先从引入这个组件的kernel文档中寻找。</p><p>去到举世闻名的<a href="http://www.kernel.org/">www.kernel.org</a></p><p>找到介绍文档：Documentation&#x2F;cgroup-v1&#x2F;cgroups.txt</p><h2 id="1-什么是cgroup"><a href="#1-什么是cgroup" class="headerlink" title="1 什么是cgroup?"></a>1 什么是cgroup?</h2><blockquote><p>cgroup ，控制组，它提供了一套机制用于控制一组特定进程对资源的使用。cgroup绑定一个进程集合到一个或多个子系统上。</p><p>subsystem，子系统，一个通过cgroup提供的工具和接口来管理进程集合的模块。一个子系统就是一个典型的“资源控制器”，用来调度资源或者控制资源使用的上限。其实每种资源就是一个子系统。子系统可以是以进程为单位的任何东西，比如虚拟化子系统、内存子系统。</p><p>hierarchy，层级树，多个cgroup的集合，这些集合构成的树叫hierarchy。可以认为这是一个资源树，附着在这上面的进程可以使用的资源上限必须受树上节点（cgroup）的控制。hierarchy上的层次关系通过cgroupfs虚拟文件系统显示。系统允许多个hierarchy同时存在，每个hierachy包含系统中的部分或者全部进程集合。</p><p>cgroupfs是用户管理操纵cgroup的主要接口：通过在cgroupfs文件系统中创建目录，实现cgroup的创建；通过向目录下的属性文件写入内容，设置cgroup对资源的控制；向task属性文件写入进程ID，可以将进程绑定到某个cgroup，以此达到控制进程资源使用的目的；也可以列出cgroup包含的进程pid。这些操作影响的是sysfs关联的hierarchy，对其它hierarchy没有影响。</p><p>对于cgroup，其本身的作用只是任务跟踪。但其它系统（比如cpusets，cpuacct），可以利用cgroup的这个功能实现一些新的属性，比如统计或者控制一个cgroup中进程可以访问的资源。举个例子，cpusets子系统可以将进程绑定到特定的cpu和内存节点上。</p></blockquote><p>2 为什么需要cgroup?</p><blockquote><p>这个问题相当于问cgroup重要吗？有哪些地方用到了。回答是重要，又不重要。如果你用到了，那就重要，如果没有用到，那就不重要。呵呵呵~~~~其实挺重要的。cgroup的主要运用是资源跟踪。我接触的场景就是用cgroup控制虚拟机进程或者docker进程可以使用的资源。当你想在linux对应用进程做资源访问控制的时候，cgroup就派上用场了。</p></blockquote><h2 id="3-cgroup怎么实现的？"><a href="#3-cgroup怎么实现的？" class="headerlink" title="3 cgroup怎么实现的？"></a>3 cgroup怎么实现的？</h2><blockquote><p>——    系统中的每个进程（task_struct，后面用task代指）都持有一个指向css_set结构的指针。</p><p>——    一个css_set结构体包含了一组指向cgroup_subsys_state对象的指针（所以一个task可以附加到多个cgroup上），每个cgroup_subsys_state在系统中都有注册。task结构体没有直接指向hierarchy中一个节点（cgroup）的指针。但可以通过其包含的cgroup_subsys_state间接确定。这样设计的原因是cpu对subsystem state的访问很频繁，但涉及到将task绑定到cgroup的操作却不多。task中还有个双向链表cg_list，这个链表维护所有同属于一个css_set的tasks。</p><p>——    用户可以通过cgroupfs文件系统来浏览cgroup hierarchy。</p><p>——    用户可以列出任意一个cgroup上附着的task PID</p><p>cgroup在kernel中除了本身功能的实现外，在kernel中还有两处修改：</p><p>——    在kernel启动时对root cgroup的初始化和css_set结构体的初始化。这个在init&#x2F;main.c文件中实现。</p><p>——    在task的创建（fork）和退出（exit）阶段，对应地将task与css_set进行绑定和解绑。</p><p>另外，cgroup为了向用户提供操作接口，特别开发了一个虚拟文件系统类型（cgroupfs），这个文件系统与sysfs，proc类似。cgroupfs是向用户展示cgroup的hierarchy，通知kernel用户对cgroup改动的窗口。挂载cgroupfs时通过选项（-otype）指定要挂载的子系统类型，如果不指定，默认挂载所有的注册的子系统。</p><p>如果新挂载的cgroup关联的hierachy与系统中存在的hierarchy完全一样，那么cgroupfs会拒绝挂载。如果没有匹配到相同的hierarchy，但新挂载hierachy声明的资源正在被已经存在的hierarchy使用，挂载会报-EBUSY错误。</p><p>当前cgroup还没有实现向已经存在的cgroup hierarchy绑定新子系统的操作，将子系统从cgroup hierachy解绑也不允许。这些操作在未来也许会支持，但也可能会进一步产生错误恢复的一系列问题。</p><p>卸载cgroupfs时，如果它的子cgroupfs还在活动，那么子cgroupfs还是会持续生效。直到所有的子cgroupfs不再活动，卸载cgroupfs才会真正生效。</p><p>cgroupfs下不能再挂载其它类型的文件系统。所有对cgroup的查询修改都只通过cgroupfs文件系统来完成。</p><p>系统中的所有task，在&#x2F;proc&#x2F;pid目录下都有一个名为cgroup的文件，这个文件展示了该task相对cgroupfs 根的路径。通过查看这个文件，可以了解一个进程在cgroup hierarchy的位置。以此得到task可以使用的资源信息。</p><p>cgroupfs中目录表示cgroup，每个目录在创建时默认生成如下的属性文件，这些文件描述了cgroup的信息：</p><p>——    tasks: 所有附属于这个cgroup的进程ID列表。tasks文件中增加进程ID，表示将进程加入这个cgroup，进程能够使用的资源受cgroup限制。</p><p>——    cgroup.procs: 所有附属于这个cgroup线程组ID，将TGID写入这个文件后，TGID所在进程包含的所有线程都加入这个cgroup，这些线程受cgroup限制。</p></blockquote><blockquote><p>PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。<br>TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。<br>PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。<br>SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。<br>——    notify_on_release flag: 标记退出时是否运行release agent</p><p>——    release_agent: 制定要运行的release agent的路径，这个属性文件只在cgroup的顶层目录中存在。</p><p>以上文件是每个cgroup基本的属性文件，对于不同的子系统，对应的cgroup可能会有其它附加的属性文件，存在于其对应的cgroup目录之下。</p><p>通过mkdir命令创建cgroup，通过向目录下的文件写入适当的数值设置修改cgroup的属性。</p><p>嵌套的cgroups，指定了层级结构，以此将系统资源划分成嵌套的，动态可变的更小的资源块。</p><p>一个进程可以附加到多个不同的cgroup中，只要这些cgroup不在同一个层级树上即可。因为cgroupfs会保证新挂载的cgroup关联的层级树全局唯一。子进程在被创建后默认附加到父进程所在的cgroup，后面用户可以根据需要将其移动到别的cgroup。</p><p>当进程从一个cgroup被移动到另一个cgroup。进程的task_struct会获取一个新的css_set指针：如果这个cgroup所在的css_set已经存在就重用这个css_set，否则就新分配一个css_set。kernel会在全局的hash表中查找确认cgroup所属的css_set是否存在。</p></blockquote><h2 id="4-notify-on-release-是做什么的？"><a href="#4-notify-on-release-是做什么的？" class="headerlink" title="4 notify_on_release 是做什么的？"></a>4 notify_on_release 是做什么的？</h2><blockquote><p>如果cgroup中使能notify_on_release，cgroup中的最后一个进程被移除，最后一个子cgroup也被删除时，cgroup会主动通知kernel。接收到消息的kernel会执行release_agent文件中指定的程序。notify_on_release默认是关闭的，release_agent的内容默认为空，子cgroup在创建时会继承父cgroup中notify_on_relase和release_agent的属性。所以这两个文件只存在于cgroupfs的顶层目录中。</p></blockquote><h2 id="5-clone-children有什么用？"><a href="#5-clone-children有什么用？" class="headerlink" title="5 clone_children有什么用？"></a>5 clone_children有什么用？</h2><blockquote><p>clone_chilren仅针对cpu绑定（cpuset），如果clone_children使能，新的cpuset cgroup在初始化时会继承父cgroup的属性。</p></blockquote><h2 id="6-cgroup怎么用？"><a href="#6-cgroup怎么用？" class="headerlink" title="6 cgroup怎么用？"></a>6 cgroup怎么用？</h2><blockquote><p>假设现在要将一个新的任务加入到cgroup，功能是将该任务的进程在指定的cpu上运行，因此我们使用”cpuset”cgroup 子系统，操作的大致步骤如下：</p><p>1）mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup </p><p>挂载cgroup根文件系统，类型为tmpfs</p><p>2）mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p><p>在cgroupfs根目录下创建子cgroup，名为cpuset</p><p>3）mount -t cgroup -o cpuset cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p><p>将名为cpuset的cgroup关联到cpuset子系统</p><p>4）在cpuset目录下创建目录，生成一个子cgroup，属性文件中写入相应内容，设置属性。</p><p>5）启动需要限制的进程，查找其对应的进程ID，将其写入对应的task文件中</p><p>以下操作步骤是创建一个名为”Charlie”的cgroup，这个cgroup的资源包含cpu2，cpu3和内存节点1，将shell进程附加到这个cgroup。</p><p>mount -t tmpfs cgroup_root &#x2F;sys&#x2F;fs&#x2F;cgroup</p><p>mkdir &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p><p>mount -t cgroup cpuset -o cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p><p>cd &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p><p>mkdir Charlie</p><p>cd Charlie</p><p>echo 2-3 &gt; cpuset.cpus</p><p>echo 1 &gt; cpuset.mems</p><p>echo $$ &gt; tasks</p><p>sh</p><p>cat &#x2F;proc&#x2F;self&#x2F;cgroup</p></blockquote><p>转：</p><p> <a href="https://blog.csdn.net/huang987246510/article/details/80765628">https://blog.csdn.net/huang987246510/article/details/80765628</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cgroup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinctrl</title>
      <link href="/2024/05/16/pinctrl/"/>
      <url>/2024/05/16/pinctrl/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>查看具体设备树中的宏定义</p><p>include&#x2F;dt-bindings&#x2F;gpio&#x2F;gpio.h</p><p>include&#x2F;dt-bindings&#x2F;pinctrl&#x2F;rockchip.h</p><p>dt-bindings&#x2F;clock&#x2F;rk3588-cru.h</p><p>查看物理单系统中的pinctrl配置，获取物理外设真实的device name</p><p>  cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;pinctrl&#x2F;pinctrl-maps</p><p>pinctrl的三大作用,有助于理解相关结构体</p><p>1.引脚枚举与命名 enumerating and naming</p><p>2.引脚服用 Multiplexing：比如用作GPIO、I2C或其他功能</p><p>3.引脚配置 Configuration：比如上拉、下拉、open drain、驱动强度等</p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pinctrl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uboot-01-概念</title>
      <link href="/2024/05/15/uboot-01-%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/05/15/uboot-01-%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>uboot(Universal Boot Loader)</p><p>uboot 官网为 <a href="http://www.denx.de/wiki/U-Boot/">http://www.denx.de/wiki/U-Boot/</a></p><p>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段<br>bootloader 程序。这段 bootloader 程序会先初始化DDR 等外设，然后将 Linux 内核从 flash(NAND，<br>NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核</p><p>uboot主要目的是为系统启动做准备</p><p>uboot是一种通用的bootloader，支持多种架构</p><h1 id="uboot常见命令"><a href="#uboot常见命令" class="headerlink" title="uboot常见命令"></a>uboot常见命令</h1>]]></content>
      
      
      <categories>
          
          <category> uboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uboot概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP-40-VSFS</title>
      <link href="/2024/05/15/OSTEP-40-VSFS/"/>
      <url>/2024/05/15/OSTEP-40-VSFS/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf">https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/40.pdf</a></p><p>磁盘上的哪些结构存储文件系统的数据和元数据？</p><p>当一个进程打开一个文件时会发生什么？</p><p>在读取或写入期间访问哪些磁盘结构？</p>]]></content>
      
      
      <categories>
          
          <category> OSTEP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vsfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot-fdt-GPT</title>
      <link href="/2024/05/15/U-Boot-fdt-GPT/"/>
      <url>/2024/05/15/U-Boot-fdt-GPT/</url>
      
        <content type="html"><![CDATA[<p>U-Boot官网:<a href="https://docs.u-boot.org/en/latest/">https://docs.u-boot.org/en/latest/</a></p><p>u-boot启动流程</p><ul><li>板子上电以后，首先执行的是ROM中的一段启动代码。启动代码<strong>根据寄存器&#x2F;外部管脚配置</strong>，确定是进入下载模式，还是从某介质(Flash&#x2F;EMMC&#x2F;SD卡等存储设备)启动u-boot</li></ul><blockquote><p>ROM中的代码是固化的，无法修改</p></blockquote><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><blockquote><p>FDT，flatted device tree，扁平设备树，简单来说，就是将部分设备信息结构存放到device tree文件中。</p><p>uboot最终将其编译成dtb文件，使用过程中通过解析该dtb来获取板级设备信息。  </p></blockquote><blockquote><p>U-boot的dtb和kernel中的dtb是一致的，有关fdt的详细介绍，参考doc&#x2F;README.fdt-control</p></blockquote><h3 id="dtb在U-boot中的位置"><a href="#dtb在U-boot中的位置" class="headerlink" title="dtb在U-boot中的位置"></a>dtb在U-boot中的位置</h3><ul><li>dtb能够以两种形式编译到U-boot的镜像中</li></ul><ol><li>dtb和u-boot的bin文件分离(imx6q中使用的这种方式，在.config文件中可以查看到)</li></ol><blockquote><p>通过CONFIG_OF_SEPARATE宏定义使能，dtb最后会追加到u-boot的bin文件的最后面，通过u-boot的结束地址符号_end符号来获取dtb的地址</p></blockquote><ol><li>dtb集成到u-boot的bin文件内部</li></ol><blockquote><p>通过CONFIG_OF_EMBED宏定义使能，dtb会位于u-boot的.dtb.init.rodata段中，通过__dtb_dt_begin符号来获取dtb</p></blockquote><ol><li>获取dts文件的地址gd-&gt;fdt_blob</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 宏用来表示是否把dtb文件放在uboot.bin的文件中</span><br><span class="line">CONFIG_OF_EMBED</span><br><span class="line"></span><br><span class="line">// 单独编译dtb文件</span><br><span class="line">CONFIG_OF_SEPARATE，编译出来的dtb放在uboot.bin的最后面，就是dtb追加到uboot的bin文件后面时，通过_end符号来获取dtb地址</span><br><span class="line"></span><br><span class="line">gd-&gt;fdt_blob = (ulong *)&amp;_end;</span><br><span class="line"></span><br><span class="line">// 可以通过fdtcontroladdr环境变量来指定fdt的地址</span><br><span class="line">gd-&gt;fdt_blob = (void *)getenv_ulong(&quot;fdtcontroladdr&quot;, 16,</span><br><span class="line">(uintptr_t)gd-&gt;fdt_blob); </span><br></pre></td></tr></table></figure><h3 id="dtb解析接口"><a href="#dtb解析接口" class="headerlink" title="dtb解析接口"></a>dtb解析接口</h3><ul><li>定义在lib&#x2F;fdtdec.c文件中，节点变量node中存放的是偏移地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 获得dtb下某个节点的路径path的偏移，偏移就代表这个节点</span><br><span class="line">int fdt_path_offset(const void *fdt, const char *path)</span><br><span class="line">eg：node = fdt_path_offset(gd-&gt;fdt_blob, “/aliases”);</span><br><span class="line"></span><br><span class="line">// 获得节点node的某个字符串属性值</span><br><span class="line">const void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)</span><br><span class="line">eg： mac = fdt_getprop(gd-&gt;fdt_blob, node, “mac-address”, &amp;len);</span><br><span class="line"></span><br><span class="line">// 获得节点node的某个整形数组属性值</span><br><span class="line">int fdtdec_get_int_array(const void *blob, int node, const char *prop_name, u32 *array, int count)</span><br><span class="line">eg： ret = fdtdec_get_int_array(blob, node, “interrupts”, cell, ARRAY_SIZE(cell));</span><br><span class="line"></span><br><span class="line">// 获得节点node的地址属性值</span><br><span class="line">fdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)</span><br><span class="line">eg：fdtdec_get_addr(blob, node, “reg”);</span><br><span class="line"></span><br><span class="line">// 获得config节点下的整形属性、bool属性、字符串等等</span><br><span class="line">fdtdec_get_config_int、fdtdec_get_config_bool、fdtdec_get_config_string</span><br><span class="line"></span><br><span class="line">// 获得chosen下的name节点的偏移</span><br><span class="line">int fdtdec_get_chosen_node(const void *blob, const char *name)</span><br><span class="line"></span><br><span class="line">// 获得chosen下name属性的值</span><br><span class="line">const char *fdtdec_get_chosen_prop(const void *blob, const char *name)</span><br></pre></td></tr></table></figure><ul><li>定义在lib&#x2F;fdtdec_common.c文件中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获得节点node的某个整形属性值</span><br><span class="line">int fdtdec_get_int(const void *blob, int node, const char *prop_name, int default_val)</span><br><span class="line">eg： bus-&gt;udelay = fdtdec_get_int(blob, node, “i2c-gpio,delay-us”, DEFAULT_UDELAY);</span><br><span class="line"></span><br><span class="line">// 获得节点node的某个无符号整形属性值</span><br><span class="line">fdtdec_get_uint</span><br></pre></td></tr></table></figure><h2 id="fdt-命令"><a href="#fdt-命令" class="headerlink" title="fdt 命令"></a>fdt 命令</h2><p>对于u-boot提供了fdt的相关命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fdt - flattened device tree utility commands</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">fdt addr [-c]  &lt;addr&gt; [&lt;length&gt;]   - Set the [control] fdt location to &lt;addr&gt;</span><br><span class="line">fdt apply &lt;addr&gt;                    - Apply overlay to the DT</span><br><span class="line">fdt move   &lt;fdt&gt; &lt;newaddr&gt; &lt;length&gt; - Copy the fdt to &lt;addr&gt; and make it active</span><br><span class="line">fdt resize [&lt;extrasize&gt;]            - Resize fdt to size + padding to 4k addr + some optional &lt;extrasize&gt; if needed</span><br><span class="line">fdt print  &lt;path&gt; [&lt;prop&gt;]          - Recursive print starting at &lt;path&gt;</span><br><span class="line">fdt list   &lt;path&gt; [&lt;prop&gt;]          - Print one level starting at &lt;path&gt;</span><br><span class="line">fdt get value &lt;var&gt; &lt;path&gt; &lt;prop&gt;   - Get &lt;property&gt; and store in &lt;var&gt;</span><br><span class="line">fdt get name &lt;var&gt; &lt;path&gt; &lt;index&gt;   - Get name of node &lt;index&gt; and store in &lt;var&gt;</span><br><span class="line">fdt get addr &lt;var&gt; &lt;path&gt; &lt;prop&gt;    - Get start address of &lt;property&gt; and store in &lt;var&gt;</span><br><span class="line">fdt get size &lt;var&gt; &lt;path&gt; [&lt;prop&gt;]  - Get size of [&lt;property&gt;] or num nodes and store in &lt;var&gt;</span><br><span class="line">fdt set    &lt;path&gt; &lt;prop&gt; [&lt;val&gt;]    - Set &lt;property&gt; [to &lt;val&gt;]</span><br><span class="line">fdt mknode &lt;path&gt; &lt;node&gt;            - Create a new node after &lt;path&gt;</span><br><span class="line">fdt rm     &lt;path&gt; [&lt;prop&gt;]          - Delete the node or &lt;property&gt;</span><br><span class="line">fdt header                          - Display header info</span><br><span class="line">fdt bootcpu &lt;id&gt;                    - Set boot cpuid</span><br><span class="line">fdt memory &lt;addr&gt; &lt;size&gt;            - Add/Update memory node</span><br><span class="line">fdt rsvmem print                    - Show current mem reserves</span><br><span class="line">fdt rsvmem add &lt;addr&gt; &lt;size&gt;        - Add a mem reserve</span><br><span class="line">fdt rsvmem delete &lt;index&gt;           - Delete a mem reserves</span><br><span class="line">fdt chosen [&lt;start&gt; &lt;end&gt;]          - Add/update the /chosen branch in the tree</span><br><span class="line">                                        &lt;start&gt;/&lt;end&gt; - initrd start/end addr</span><br><span class="line">NOTE: Dereference aliases by omitting the leading &#x27;/&#x27;, e.g. fdt print ethernet0.</span><br></pre></td></tr></table></figure><p>fdt print加path参数，则打path内容，如下(其中&#x2F;memory是path)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">U-Boot&gt; fdt print /memory</span><br><span class="line">memory &#123;</span><br><span class="line">device_type = <span class="string">&quot;memory&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x70000000</span> <span class="number">0x4000000</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">U-Boot&gt; fdt print #不加参数时，打印出整颗树</span><br></pre></td></tr></table></figure><h1 id="二、u-boot-获取GPT分区表"><a href="#二、u-boot-获取GPT分区表" class="headerlink" title="二、u-boot 获取GPT分区表"></a>二、u-boot 获取GPT分区表</h1><p>在uboot中通过命令打印分区表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part list mmc 0</span><br></pre></td></tr></table></figure><h2 id="3588-android-uboot"><a href="#3588-android-uboot" class="headerlink" title="3588-android-uboot"></a>3588-android-uboot</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;command.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android_image.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mmc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memalign.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fdtdec.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PART_MAX_COUNT  128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>LAB_SIZE512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>HEADER_OFFSETLAB_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ENTRY_OFFSET(2 * LAB_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>VAL1_OFFSETsizeof(u64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>VAL2_OFFSET(2 * sizeof(u64))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">get_gpt_blk_cnt_and_print</span><span class="params">(<span class="keyword">struct</span> blk_desc *dev_desc,</span></span><br><span class="line"><span class="params">  gpt_header *gpt_head, gpt_entry **gpt_pte)</span> &#123;</span><br><span class="line"><span class="type">char</span> efi_str[PARTNAME_SZ + <span class="number">1</span>];</span><br><span class="line">u64 gpt_part_size, gpt_blk_cnt = <span class="number">0</span>;</span><br><span class="line">gpt_entry *gpt_e;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">gpt_e = *gpt_pte;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; gpt_head-&gt;num_partition_entries; i++) &#123;</span><br><span class="line"></span><br><span class="line">raite_gpt_convert_efi_name_to_char(efi_str, gpt_e[i].partition_name,</span><br><span class="line">     PARTNAME_SZ + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: part: %2d name - GPT: %16s &quot;</span>,</span><br><span class="line">      __func__, i, efi_str);</span><br><span class="line">gpt_part_size = le64_to_cpu(gpt_e[i].ending_lba) -</span><br><span class="line">le64_to_cpu(gpt_e[i].starting_lba) + <span class="number">1</span>;</span><br><span class="line">gpt_blk_cnt += gpt_part_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(gpt_part_size == <span class="number">1</span>) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size(LBA) - GPT: %8llu &quot;</span>,</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)gpt_part_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start LBA - GPT: %8llu \n&quot;</span>,</span><br><span class="line">      le64_to_cpu(gpt_e[i].starting_lba));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> gpt_blk_cnt + gpt_e[<span class="number">0</span>].starting_lba - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_gpt_meta_data</span><span class="params">(u64 *data_size, <span class="type">void</span> **data)</span></span><br><span class="line">&#123;</span><br><span class="line">    gpt_header *pgpt_head;</span><br><span class="line">gpt_entry *entries;</span><br><span class="line"><span class="type">void</span> *meta_data;</span><br><span class="line">u64 meta_data_size, gpt_entries_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_desc</span> *<span class="title">dev_desc</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmc</span> *<span class="title">mmc</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">u64 blk_size = <span class="number">0</span>;</span><br><span class="line">u64 blk_cnt = <span class="number">0</span>;</span><br><span class="line">u64 tag = <span class="number">0x55AA</span>;</span><br><span class="line"><span class="type">lbaint_t</span> lba;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!data_size || !data) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s *** ERROR: Invalid Argument(s) ***\n&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    mmc = do_returnmmc();</span><br><span class="line"><span class="keyword">if</span> (!mmc)</span><br><span class="line"><span class="keyword">return</span> CMD_RET_FAILURE;</span><br><span class="line">    </span><br><span class="line">    dev_desc = mmc_get_blk_desc(mmc);</span><br><span class="line"><span class="keyword">if</span> (!dev_desc) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s *** ERROR: mmc_get_blk_desc err ***\n&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gpt_entries_size = <span class="keyword">sizeof</span>(gpt_entry) * PART_MAX_COUNT;</span><br><span class="line">meta_data_size = LAB_SIZE + <span class="keyword">sizeof</span>(gpt_header) + gpt_entries_size;</span><br><span class="line">meta_data = <span class="built_in">malloc</span>(meta_data_size);</span><br><span class="line"><span class="keyword">if</span>(!meta_data) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s *** ERROR: malloc memory (gpt meta data) ***\n&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(meta_data, <span class="number">0</span>, meta_data_size);</span><br><span class="line">pgpt_head = (gpt_header *)((<span class="type">char</span> *)meta_data + HEADER_OFFSET);</span><br><span class="line">entries = (gpt_entry *)((<span class="type">char</span> *)meta_data + ENTRY_OFFSET);</span><br><span class="line">ALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, dev_desc-&gt;blksz);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read MBR Header from device */</span></span><br><span class="line">lba = <span class="number">0</span>; <span class="comment">/* MBR is always at 0 */</span></span><br><span class="line">blk_cnt = <span class="number">1</span>; <span class="comment">/* MBR (1 block) */</span></span><br><span class="line"><span class="keyword">if</span> (blk_dread(dev_desc, lba, blk_cnt, (ulong *)mbr) != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*** ERROR: Can&#x27;t read MBR header ***\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> ERROR_OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read GPT Header from device */</span></span><br><span class="line">lba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class="line">blk_cnt = <span class="number">1</span>; <span class="comment">/* GPT Header (1 block) */</span></span><br><span class="line"><span class="keyword">if</span> (blk_dread(dev_desc, lba, blk_cnt, pgpt_head) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s *** ERROR: Can&#x27;t read GPT header ***\n&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">goto</span> ERROR_OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lba = GPT_PRIMARY_PARTITION_TABLE_LBA;</span><br><span class="line"><span class="keyword">if</span> (validate_gpt_header(pgpt_head, lba, dev_desc-&gt;lba)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s *** ERROR: validate_gpt_header GPT header ***\n&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">goto</span> ERROR_OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev_desc-&gt;sig_type == SIG_TYPE_NONE) &#123;</span><br><span class="line"><span class="type">efi_guid_t</span> empty = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(&amp;pgpt_head-&gt;disk_guid, &amp;empty, <span class="keyword">sizeof</span>(empty))) &#123;</span><br><span class="line">dev_desc-&gt;sig_type = SIG_TYPE_GUID;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;dev_desc-&gt;guid_sig, &amp;pgpt_head-&gt;disk_guid,</span><br><span class="line">      <span class="keyword">sizeof</span>(empty));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbr-&gt;unique_mbr_signature != <span class="number">0</span>) &#123;</span><br><span class="line">dev_desc-&gt;sig_type = SIG_TYPE_MBR;</span><br><span class="line">dev_desc-&gt;mbr_sig = mbr-&gt;unique_mbr_signature;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read GPT Entries from device */</span></span><br><span class="line">lba = le64_to_cpu(pgpt_head-&gt;partition_entry_lba);</span><br><span class="line">blk_cnt = BLOCK_CNT((le32_to_cpu(pgpt_head-&gt;num_partition_entries) *</span><br><span class="line">   le32_to_cpu(pgpt_head-&gt;sizeof_partition_entry)),</span><br><span class="line">  dev_desc);</span><br><span class="line"><span class="keyword">if</span> (blk_dread(dev_desc, lba, blk_cnt, entries) != blk_cnt) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s *** ERROR:read entries (lba=%llu) ***\n&quot;</span>,</span><br><span class="line">__func__, pgpt_head-&gt;partition_entry_lba);</span><br><span class="line"><span class="keyword">goto</span> ERROR_OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blk_size = dev_desc-&gt;blksz;</span><br><span class="line">validate_gpt_entries(pgpt_head, entries);</span><br><span class="line"></span><br><span class="line">debug(<span class="string">&quot;%s read entries lba %llu (blk_cnt %llu blk_size=%llu)\n&quot;</span>,</span><br><span class="line">__func__, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(ulong)lba, blk_cnt, blk_size);</span><br><span class="line"></span><br><span class="line">blk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * build info, layout of meta_data:</span></span><br><span class="line"><span class="comment"> * u64 tag | u64 blk_size | u64 blk_cnt | 488 bytes | gpt header | gpt entries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">blk_cnt = get_gpt_blk_cnt(dev_desc, pgpt_head, &amp;entries);</span><br><span class="line"><span class="comment">/*this value makes we known the reserved memory is available*/</span></span><br><span class="line"><span class="built_in">memcpy</span>(meta_data, (<span class="type">void</span> *)&amp;tag, <span class="keyword">sizeof</span>(u64));</span><br><span class="line"><span class="built_in">memcpy</span>(meta_data + VAL1_OFFSET, (<span class="type">void</span> *)&amp;blk_size, <span class="keyword">sizeof</span>(u64));</span><br><span class="line"><span class="built_in">memcpy</span>(meta_data + VAL2_OFFSET, (<span class="type">void</span> *)&amp;blk_cnt, <span class="keyword">sizeof</span>(u64));</span><br><span class="line"></span><br><span class="line">*data_size = meta_data_size;</span><br><span class="line">*data = meta_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ERROR_OUT:</span><br><span class="line"><span class="built_in">free</span>(meta_data);</span><br><span class="line">meta_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://www.wowotech.net/device_model/dt-code-file-struct-parse.html">Device Tree（四）：文件结构解析 (wowotech.net)</a></p><p><a href="https://zhuanlan.zhihu.com/p/376295326">Linux设备树语法分析详解教程(三)u-boot设备树的传递 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/376296222">Linux设备树语法分析详解教程(四)kernel的解析 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/solo666/p/16518154.html">https://www.cnblogs.com/solo666/p/16518154.html</a></p>]]></content>
      
      
      <categories>
          
          <category> uboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fdt </tag>
            
            <tag> GPT </tag>
            
            <tag> rk3588 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-block</title>
      <link href="/2024/05/15/linux-block/"/>
      <url>/2024/05/15/linux-block/</url>
      
        <content type="html"><![CDATA[<h1 id="块设备驱动"><a href="#块设备驱动" class="headerlink" title="块设备驱动"></a>块设备驱动</h1><p>块设备的主要特点是，cpu和总线读写数据所花时间与硬盘硬件的速度不匹配。</p>]]></content>
      
      
      <categories>
          
          <category> driver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpufreq</title>
      <link href="/2024/04/28/cpufreq/"/>
      <url>/2024/04/28/cpufreq/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="cpufreq"><a href="#cpufreq" class="headerlink" title="cpufreq"></a>cpufreq</h1><p>CPUFreq框架是内核的CPU调频框架，整个调频框架由以下几个部分组成：</p><ul><li>cpufreq driver</li><li>cpufreq framework (core)</li><li>cpufreq governor</li></ul><p>一些基本概念：</p><p>P-state: voltage and frequency point</p><p>总体上，CPU Freq主要在sysfs向userspace提供了调频操作和策略设置节点。当使用一些自动调频的governor时，允许governor从系统获取信息，自动触发调频动作。</p><p>另外，还向其他模块提供了qos频率投票，以及调频事件的notifier机制。</p><p>下面分开来看每个部分。</p><h2 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h2><p>Cpufreq Driver主要负责底层调频的操作，核心是实现 <code>cpufreq_dirver</code> 对象，并通过 <code>cpufreq_register_driver</code> 将驱动注册到系统，供core部分使用。</p><p>其中，最核心的几个回调包括：</p><ul><li>online: hotplug callback</li><li>offline: hotplug callback</li><li>target_index: set freq</li><li>set_boost: enter into boost mode</li></ul><p>以 <code>mediatek-cpufreq-hw.c</code> 为例，其freq table保存在硬件寄存器中，driver初始化时，从硬件中读出freq table，并实现相关调频回调，最终注册到core。</p><p>db845c使用的 <code>qcom-cpufreq-hw.c</code> 为例，其freq table保存在dts中，driver使用OPP框架来读取这些配置，并实现cpufreq回调。</p><p>* OPP（Operating Performance Point，提供dts的freq-valt-table配置，及获取接口。</p><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p>Core部分核心文件是 <code>/drivers/cpufreq/cpufreq.c</code></p><p>这个文件主要实现了BOOST，DRIVER，SYSFS，FREQ，NOTIFIER，GOVERNOR，POLICY相关功能的操作接口。</p><p><code>cpufreq_register_driver</code> (cpufreq_driver* cpufreq_driver)</p><p><code>cpufreq_register_governor</code> (cpufreq_governor_list)</p><p><code>cpufreq_register_notifier</code> (cpufreq_transition_notifier_list)</p><p><code>cpufreq_policy_alloc</code> (cpufreq_policy* PERCPU:cpufreq_cpu_data)</p><p><code>cpufreq_policy</code> 是一个调频实体，对应一个调频域（freq domain），一般为一个cluster，这个结构保存了每个调频实体（通常是一个cluster）调频相关的所有私有信息。同时，他作为调频操作的句柄，cpufreq顶层操作接口使用policy来对一个调频实体进行操作。</p><p>每个CPU有一个percpu的指针指向其所属的policy，cluster中的多个CPU共享一个policy。（<code>cpufreq_cpu_data</code>）</p><p>Mainflow：</p><p>1、cpufreq driver注册</p><p>2、governor注册（每个policy初始化自己的governor）</p><p>3、cpu hotplug state: “cpufreq:online”，<code>cpuhp_cpufreq_online</code>、<code>cpuhp_cpufreq_offline</code>，创建出percpu policy，绑定driver、governor</p><p>4、向sysfs创建节点，提供功能</p><p>5、governor开始工作，通过 <code>__cpufreq_driver_target</code> 进行调频。</p><ul><li>Qos是调频投票机制，用来实现max_freq、min_freq limitation。(<code>cpufreq_notifier_min</code> <code>cpufreq_notifier_max</code>)，在其他module有需求投票后，freq constrants会被更新。</li></ul><h2 id="Sysfs"><a href="#Sysfs" class="headerlink" title="Sysfs"></a>Sysfs</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/system/cpu/cpu0/cpufreq/policyX</span><br><span class="line">scaling_driverr# cpufreq driver name</span><br><span class="line">affected_cpusr# cpu</span><br><span class="line">related_cpusr# &lt;?&gt;</span><br><span class="line">scaling_cur_freqrw# cur freq</span><br><span class="line">scaling_min_freqrw# min freq limit</span><br><span class="line">scaling_max_freqrw# max freq limit</span><br><span class="line">scaling_governorrw# selected governor</span><br><span class="line">scaling_available_governorsr# available governors</span><br><span class="line">scaling_setspeedr# &lt;not supported&gt;</span><br><span class="line">cpuinfo_min_freqr# hardware min freq</span><br><span class="line">cpuinfo_max_freqr# hardware max freq</span><br><span class="line">cpuinfo_transition_latencyr# hardware latency</span><br></pre></td></tr></table></figure><h2 id="Governors"><a href="#Governors" class="headerlink" title="Governors"></a>Governors</h2><p>Governor负责从系统收集信息，并触发调频动作。</p><p><strong>powersave</strong></p><p>always lowest frequency</p><p><strong>performance</strong></p><p>always highest frequency</p><p><strong>schedutil</strong></p><p>uses CPU utilization data from scheduler to determine target frequence</p><p>待完成</p><p><strong>userspace</strong></p><p>allow user space set the frequency</p><p><strong>ondemand</strong></p><p>uses CPU load as a CPU frequency selection metric</p><p>it reaches the target by CPU load, 0-&gt;min, 100-&gt;max</p><p><strong>conservative</strong></p><p>uses CPU load as a CPU frequency selection metric</p><p>it reaches the target step by step, up_threshold-&gt;up, down_threshold-&gt;down</p><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- /drivers/cpufreq/cpufreq.c</span><br><span class="line">- /drivers/cpufreq/cpufreq-dt.c</span><br><span class="line">- /drivers/cpufreq/cpufreq_stats.c</span><br><span class="line">- /drivers/cpufreq/cpufreq_conservative.c</span><br><span class="line">- /drivers/cpufreq/cpufreq_governor.c</span><br><span class="line">- /drivers/cpufreq/cpufreq_ondemand.c</span><br><span class="line">- /drivers/cpufreq/cpufreq_powersave.c</span><br><span class="line">- /drivers/cpufreq/cpufreq_performance.c</span><br><span class="line">- /drivers/cpufreq/cpufreq_userspace.c</span><br><span class="line">- /kernel/sched/cpufreq_schedutil.c</span><br><span class="line">- /kernel/power/qos.c</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html">https://www.kernel.org/doc/html/latest/admin-guide/pm/cpufreq.html</a></p><p><a href="https://docs.kernel.org/scheduler/schedutil.html">https://docs.kernel.org/scheduler/schedutil.html</a></p><p><a href="http://www.wowotech.net/pm_subsystem/cpufreq_overview.html">http://www.wowotech.net/pm_subsystem/cpufreq_overview.html</a></p><p><a href="http://www.wowotech.net/pm_subsystem/cpufreq_driver.html">http://www.wowotech.net/pm_subsystem/cpufreq_driver.html</a></p><p><a href="http://www.wowotech.net/pm_subsystem/cpufreq_core.html">http://www.wowotech.net/pm_subsystem/cpufreq_core.html</a></p><p><a href="http://www.wowotech.net/pm_subsystem/cpufreq_governor.html">http://www.wowotech.net/pm_subsystem/cpufreq_governor.html</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> power </tag>
            
            <tag> cpufreq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo在多台电脑上提交和更新</title>
      <link href="/2023/09/13/Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0/"/>
      <url>/2023/09/13/Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-博客搭建"><a href="#1-博客搭建" class="headerlink" title="1.博客搭建"></a>1.博客搭建</h1><p><a href="https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">https://yyheroi.github.io/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</a></p><h1 id="2-创建一个新文件夹new，用于上传hexo博客目录"><a href="#2-创建一个新文件夹new，用于上传hexo博客目录" class="headerlink" title="2.创建一个新文件夹new，用于上传hexo博客目录"></a>2.创建一个新文件夹new，用于上传hexo博客目录</h1><p>将以下目录（除了红色方框的目录）拷贝到新目录中</p><p><img src="/../imgs/image-20230913154437526.png" alt="image-20230913154437526"></p><p>参考：<a href="https://blog.csdn.net/K1052176873/article/details/122879462">https://blog.csdn.net/K1052176873/article/details/122879462</a> </p><h1 id="3-github上创建hexo分支并设置为默认分支"><a href="#3-github上创建hexo分支并设置为默认分支" class="headerlink" title="3.github上创建hexo分支并设置为默认分支"></a>3.github上创建hexo分支并设置为默认分支</h1><h2 id="创建hexo分支"><a href="#创建hexo分支" class="headerlink" title="创建hexo分支"></a>创建hexo分支</h2><p><img src="/../imgs/image-20230913154510439.png" alt="image-20230913154510439"></p><h2 id="将hexo分支设置为默认分支"><a href="#将hexo分支设置为默认分支" class="headerlink" title="将hexo分支设置为默认分支"></a>将hexo分支设置为默认分支</h2><p><img src="/../imgs/image-20230913154524492.png" alt="image-20230913154524492"></p><h1 id="4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支"><a href="#4-进入新建的文件夹中git-clone，再上传相关文件至hexo分支" class="headerlink" title="4.进入新建的文件夹中git clone，再上传相关文件至hexo分支"></a>4.进入新建的文件夹中git clone，再上传相关文件至hexo分支</h1><p>基本原理：github仓库开两个分支，main分支存放的是hexo生成的静态页面，hexo分支存放基本的 Hexo 博客项目的结构和默认配置文件，如文章，主题<br>当需要重新搭建环境时，直接拉取hexo分支中Hexo博客目录以及相关配置文件，当需要更新博客时直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd new</span><br><span class="line">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class="line">git branch    #查看分支，显示 * hexo</span><br></pre></td></tr></table></figure><h2 id="1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下："><a href="#1-clone下来的文件夹内应该有个-gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：" class="headerlink" title="1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下："></a>1.clone下来的文件夹内应该有个.gitignore文件，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><h2 id="2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录"><a href="#2-如果已经clone过主题文件，那么需要把theme主题文件夹里的-git-也删除，我这里已经删除了theme主题的-git目录" class="headerlink" title="2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录"></a>2.如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除，我这里已经删除了theme主题的.git目录</h2><p><img src="/../imgs/image-20230913154559571.png" alt="image-20230913154559571"></p><h2 id="3-送new目录中的相关文件到远程仓库-hexo分支"><a href="#3-送new目录中的相关文件到远程仓库-hexo分支" class="headerlink" title="3.送new目录中的相关文件到远程仓库 hexo分支"></a>3.送new目录中的相关文件到远程仓库 hexo分支</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m add_branch</span><br><span class="line">git push        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-！新环境中快速搭建博客环境！"><a href="#5-！新环境中快速搭建博客环境！" class="headerlink" title="5.！新环境中快速搭建博客环境！"></a>5.！新环境中快速搭建博客环境！</h1><h2 id="1-设置ssh"><a href="#1-设置ssh" class="headerlink" title="1.设置ssh"></a>1.设置ssh</h2><p>参考：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;your_email@gmail.com&quot;</span><br><span class="line">cat ~/.ssh/id_ed25519.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class="line">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class="line">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class="line">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class="line">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure><h2 id="2-安装nodejs和hexo"><a href="#2-安装nodejs和hexo" class="headerlink" title="2.安装nodejs和hexo"></a>2.安装nodejs和hexo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install git</span><br><span class="line"></span><br><span class="line">sudo apt install nodejs</span><br><span class="line">sudo apt install npm  </span><br></pre></td></tr></table></figure><h2 id="3-拉取hexo博客目录"><a href="#3-拉取hexo博客目录" class="headerlink" title="3.拉取hexo博客目录"></a>3.拉取hexo博客目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git #&lt;username&gt; 用户名</span><br><span class="line">git branch    #查看分支，显示 * hexo</span><br><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git        #不需要hexo init这条指令</span><br><span class="line">npm i hexo-renderer-marked</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更新博客 添加新文章 hello-world</span><br><span class="line">hexo new &quot;hello-world&quot;</span><br><span class="line">git add .        #将文章备份至 hexo分支  或者git add source/_posts/hello-world </span><br><span class="line">git commit –m &quot;hello-world&quot;</span><br><span class="line">git push         #或者git push origin hexo</span><br><span class="line"></span><br><span class="line">hexo g        #生成静态页面</span><br><span class="line">hexo s        #启动本地服务器 预览</span><br><span class="line">hexo d        #将生成的博客文件部署到 github main分支，Hexo博客项目配置文件中_config.yml已设置好</span><br></pre></td></tr></table></figure><h1 id="6-遇到的问题"><a href="#6-遇到的问题" class="headerlink" title="6.遇到的问题"></a>6.遇到的问题</h1><h2 id="问题1-nodejs版本过低"><a href="#问题1-nodejs版本过低" class="headerlink" title="问题1.nodejs版本过低"></a>问题1.nodejs版本过低</h2><p>npm WARN notsup Unsupported engine for <a href="mailto:&#104;&#101;&#120;&#x6f;&#x40;&#x36;&#x2e;&#51;&#x2e;&#48;">&#104;&#101;&#120;&#x6f;&#x40;&#x36;&#x2e;&#51;&#x2e;&#48;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href="mailto:&#104;&#101;&#120;&#x6f;&#64;&#x36;&#46;&#x33;&#46;&#48;">&#104;&#101;&#120;&#x6f;&#64;&#x36;&#46;&#x33;&#46;&#48;</a><br>npm WARN notsup Unsupported engine for <a href="mailto:&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#x6f;&#110;&#116;&#45;&#109;&#x61;&#x74;&#116;&#x65;&#114;&#x40;&#x33;&#46;&#48;&#x2e;&#x30;">&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#x6f;&#110;&#116;&#45;&#109;&#x61;&#x74;&#116;&#x65;&#114;&#x40;&#x33;&#46;&#48;&#x2e;&#x30;</a>: wanted: {“node”:”&gt;&#x3D;12.13.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href="mailto:&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#111;&#x6e;&#x74;&#x2d;&#x6d;&#97;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#48;&#46;&#48;">&#104;&#101;&#120;&#111;&#45;&#102;&#x72;&#111;&#x6e;&#x74;&#x2d;&#x6d;&#97;&#116;&#x74;&#x65;&#114;&#64;&#x33;&#x2e;&#48;&#46;&#48;</a><br>npm WARN notsup Unsupported engine for <a href="mailto:&#x68;&#x65;&#120;&#111;&#x2d;&#x63;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#x2e;&#x31;">&#x68;&#x65;&#120;&#111;&#x2d;&#x63;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#x2e;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href="mailto:&#x68;&#x65;&#120;&#111;&#45;&#99;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#46;&#49;">&#x68;&#x65;&#120;&#111;&#45;&#99;&#108;&#x69;&#64;&#52;&#x2e;&#51;&#46;&#49;</a><br>npm WARN notsup Unsupported engine for <a href="mailto:&#x68;&#x65;&#x78;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#64;&#x33;&#x2e;&#x32;&#x2e;&#x30;">&#x68;&#x65;&#x78;&#x6f;&#45;&#x6c;&#x6f;&#x67;&#64;&#x33;&#x2e;&#x32;&#x2e;&#x30;</a>: wanted: {“node”:”&gt;&#x3D;12.4.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href="mailto:&#x68;&#101;&#x78;&#x6f;&#45;&#108;&#x6f;&#103;&#64;&#x33;&#x2e;&#50;&#x2e;&#48;">&#x68;&#101;&#x78;&#x6f;&#45;&#108;&#x6f;&#103;&#64;&#x33;&#x2e;&#50;&#x2e;&#48;</a><br>npm WARN notsup Unsupported engine for <a href="mailto:&#97;&#x62;&#x62;&#114;&#101;&#118;&#64;&#x32;&#x2e;&#48;&#46;&#48;">&#97;&#x62;&#x62;&#114;&#101;&#118;&#64;&#x32;&#x2e;&#48;&#46;&#48;</a>: wanted: {“node”:”^14.17.0 || ^16.13.0 || &gt;&#x3D;18.0.0”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href="mailto:&#x61;&#x62;&#98;&#114;&#101;&#118;&#x40;&#x32;&#x2e;&#x30;&#x2e;&#x30;">&#x61;&#x62;&#98;&#114;&#101;&#118;&#x40;&#x32;&#x2e;&#x30;&#x2e;&#x30;</a><br>npm WARN notsup Unsupported engine for <a href="mailto:&#x68;&#101;&#120;&#x6f;&#45;&#102;&#x73;&#64;&#52;&#x2e;&#49;&#46;&#x31;">&#x68;&#101;&#120;&#x6f;&#45;&#102;&#x73;&#64;&#52;&#x2e;&#49;&#46;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href="mailto:&#x68;&#x65;&#120;&#111;&#45;&#102;&#x73;&#x40;&#x34;&#46;&#x31;&#x2e;&#x31;">&#x68;&#x65;&#120;&#111;&#45;&#102;&#x73;&#x40;&#x34;&#46;&#x31;&#x2e;&#x31;</a><br>npm WARN notsup Unsupported engine for <a href="mailto:&#104;&#101;&#120;&#111;&#x2d;&#x6c;&#111;&#x67;&#x40;&#52;&#x2e;&#x31;&#x2e;&#48;">&#104;&#101;&#120;&#111;&#x2d;&#x6c;&#111;&#x67;&#x40;&#52;&#x2e;&#x31;&#x2e;&#48;</a>: wanted: {“node”:”&gt;&#x3D;14”} (current: {“node”:”10.19.0”,”npm”:”6.14.4”})<br>npm WARN notsup Not compatible with your version of node&#x2F;npm: <a href="mailto:&#104;&#x65;&#120;&#x6f;&#x2d;&#x6c;&#111;&#x67;&#64;&#52;&#46;&#49;&#46;&#48;">&#104;&#x65;&#120;&#x6f;&#x2d;&#x6c;&#111;&#x67;&#64;&#52;&#46;&#49;&#46;&#48;</a><br>npm WARN optional SKIPPING OPTIONAL DEPENDENCY: <a href="mailto:&#x66;&#115;&#101;&#x76;&#101;&#110;&#116;&#115;&#64;&#50;&#x2e;&#51;&#x2e;&#x33;">&#x66;&#115;&#101;&#x76;&#101;&#110;&#116;&#115;&#64;&#50;&#x2e;&#51;&#x2e;&#x33;</a> (node_modules&#x2F;fsevents):<br>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href="mailto:&#102;&#x73;&#x65;&#118;&#101;&#110;&#116;&#115;&#x40;&#x32;&#x2e;&#51;&#x2e;&#x33;">&#102;&#x73;&#x65;&#118;&#101;&#110;&#116;&#115;&#x40;&#x32;&#x2e;&#51;&#x2e;&#x33;</a>: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”linux”,”arch”:”x64”})</p><h2 id="升级nodejs"><a href="#升级nodejs" class="headerlink" title="升级nodejs"></a>升级nodejs</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash         #安装 nvm</span><br><span class="line">source ~/.bashrc            #加载 nvm</span><br><span class="line">nvm install node            #使用 nvm 安装最新版本的 Node.js</span><br><span class="line">node -v                     #验证 Node.js 版本</span><br></pre></td></tr></table></figure><h2 id="问题2-hexo博客图片不显示"><a href="#问题2-hexo博客图片不显示" class="headerlink" title="问题2.hexo博客图片不显示"></a>问题2.hexo博客图片不显示</h2><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/127737904">https://blog.csdn.net/QRLYLETITBE/article/details/127737904</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-marked</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="新建imgs文件夹"><a href="#新建imgs文件夹" class="headerlink" title="新建imgs文件夹"></a>新建imgs文件夹</h2><p><img src="/../imgs/image-20230913161638961.png" alt="image-20230913161638961"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修改图片路径"><a href="#修改图片路径" class="headerlink" title="修改图片路径"></a>修改图片路径</h2><p><img src="/../imgs/image-20230913161842174.png" alt="image-20230913161842174"></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-rust复合类型</title>
      <link href="/2023/08/28/03-rust%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/08/28/03-rust%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-字符串和切片"><a href="#1-字符串和切片" class="headerlink" title="1.字符串和切片"></a>1.字符串和切片</h1><h2 id="什么是字符串"><a href="#什么是字符串" class="headerlink" title="什么是字符串?"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2">什么是字符串?</a></h2><p><strong>Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)</strong></p><p><code>str</code> 类型是硬编码进可执行文件，也无法被修改，但是 <code>String</code> 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，<strong>当 Rust 用户提到字符串时，往往指的就是 <code>String</code> 类型和 <code>&amp;str</code> 字符串切片类型，这两个类型都是 UTF-8 编码</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">let slice = &amp;a[1..3];</span><br><span class="line"></span><br><span class="line">assert_eq!(slice, &amp;[2, 3]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String-与-str-的转换"><a href="#String-与-str-的转换" class="headerlink" title="String 与 &amp;str 的转换"></a><a href="https://course.rs/basic/compound-type/string-slice.html#string-%E4%B8%8E-str-%E7%9A%84%E8%BD%AC%E6%8D%A2">String 与 &amp;str 的转换</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello,world!&quot;);</span><br><span class="line">    say_hello(&amp;s);</span><br><span class="line">    say_hello(&amp;s[..]);</span><br><span class="line">    say_hello(s.as_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn say_hello(s: &amp;str) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95">字符串索引</a></h2><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87">字符串切片</a></h2><p>通过索引区间来访问字符串时，<strong>需要格外的小心</strong>，一不注意，就会导致你程序的崩溃！</p><h2 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2">操作字符串</a></h2><h4 id="追加-Push"><a href="#追加-Push" class="headerlink" title="追加 (Push)"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E8%BF%BD%E5%8A%A0-push">追加 (Push)</a></h4><h4 id="插入-Insert"><a href="#插入-Insert" class="headerlink" title="插入 (Insert)"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E6%8F%92%E5%85%A5-insert">插入 (Insert)</a></h4><h4 id="替换-Replace"><a href="#替换-Replace" class="headerlink" title="替换 (Replace)"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E6%9B%BF%E6%8D%A2-replace">替换 (Replace)</a></h4><h4 id="删除-Delete"><a href="#删除-Delete" class="headerlink" title="删除 (Delete)"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E5%88%A0%E9%99%A4-delete">删除 (Delete)</a></h4><h4 id="连接-Concatenate"><a href="#连接-Concatenate" class="headerlink" title="连接 (Concatenate)"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E8%BF%9E%E6%8E%A5-concatenate">连接 (Concatenate)</a></h4><h2 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89">字符串转义</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, &quot;hello \\x52\\x75\\x73\\x74&quot;);</span><br><span class="line">    let raw_str = r&quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, raw_str);</span><br><span class="line"></span><br><span class="line">    // 如果字符串包含双引号，可以在开头和结尾加 #</span><br><span class="line">    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, quotes);</span><br><span class="line"></span><br><span class="line">    // 如果还是有歧义，可以继续增加，没有限制</span><br><span class="line">    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, longer_delimiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作-UTF-8-字符串"><a href="#操作-UTF-8-字符串" class="headerlink" title="操作 UTF-8 字符串"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2">操作 UTF-8 字符串</a></h2><p><a href="https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">字符串与切片 - Rust语言圣经(Rust Course)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for c in &quot;中国人&quot;.chars() &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a><a href="https://course.rs/basic/compound-type/string-slice.html#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a></h2><blockquote><p>Rust By Practice，支持代码在线编辑和运行，并提供详细的习题解答。</p><ul><li><a href="https://zh.practice.rs/compound-types/string.html">字符串</a><ul><li><a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md">习题解答</a></li></ul></li><li><a href="https://zh.practice.rs/compound-types/slice.html">切片</a><ul><li><a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md">习题解答</a></li></ul></li><li><a href="https://zh.practice.rs/collections/String.html">String</a><ul><li><a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md">习题解答</a></li></ul></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 填空并修复错误</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, 世界&quot;);</span><br><span class="line">    let slice1 = &amp;s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节</span><br><span class="line">    assert_eq!(slice1, &quot;h&quot;);</span><br><span class="line"></span><br><span class="line">    let slice2 = &amp;s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节</span><br><span class="line">    assert_eq!(slice2, &quot;世&quot;);</span><br><span class="line">    </span><br><span class="line">    // 迭代 s 中的所有字符</span><br><span class="line">    for (i, c) in s.chars().enumerate() &#123;</span><br><span class="line">        if i == 7 &#123;</span><br><span class="line">            assert_eq!(c, &#x27;世&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::new();</span><br><span class="line">     s.push_str(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let v = vec![104, 101, 108, 108, 111];</span><br><span class="line"></span><br><span class="line">    // 将字节数组转换成 String</span><br><span class="line">    let s1 = String::from_utf8(v).unwrap();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    assert_eq!(s, s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 填空</span><br><span class="line">use std::mem;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let story = String::from(&quot;Rust By Practice&quot;);</span><br><span class="line"></span><br><span class="line">    // 阻止 String 的数据被自动 drop</span><br><span class="line">    let mut story = mem::ManuallyDrop::new(story);</span><br><span class="line"></span><br><span class="line">    let ptr = story.as_mut_ptr();</span><br><span class="line">    let len = story.len();</span><br><span class="line">    let capacity = story.capacity();</span><br><span class="line"></span><br><span class="line">    assert_eq!(16, len);</span><br><span class="line"></span><br><span class="line">    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. </span><br><span class="line">    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的</span><br><span class="line">    let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;;</span><br><span class="line"></span><br><span class="line">    assert_eq!(*story, s);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-元组"><a href="#2-元组" class="headerlink" title="2.元组"></a>2.<a href="https://course.rs/basic/compound-type/tuple.html#%E5%85%83%E7%BB%84">元组</a></h1><h1 id="3-元组"><a href="#3-元组" class="headerlink" title="3. 元组"></a>3. 元组</h1><h1 id="4-test"><a href="#4-test" class="headerlink" title="4. test"></a>4. test</h1><p>待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> rust复合类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-rust基本类型</title>
      <link href="/2023/08/26/02-rust%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/08/26/02-rust%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Rust基本数据类型"><a href="#Rust基本数据类型" class="headerlink" title="Rust基本数据类型"></a>Rust基本数据类型</h1><p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：</p><ul><li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</li><li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li><li>布尔类型： <code>true</code>和<code>false</code></li><li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li><li>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></li></ul><h2 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1.数值类型"></a>1.数值类型</h2><table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody><tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128 位</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>视架构而定</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p>整形字面量可以用下表的形式书写：</p><table><thead><tr><th>数字字面量</th><th>示例</th></tr></thead><tbody><tr><td>十进制</td><td><code>98_222</code></td></tr><tr><td>十六进制</td><td><code>0xff</code></td></tr><tr><td>八进制</td><td><code>0o77</code></td></tr><tr><td>二进制</td><td><code>0b1111_0000</code></td></tr><tr><td>字节 (仅限于 <code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><h2 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="2.浮点类型"></a>2.<a href="https://course.rs/basic/base-type/numbers.html#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B">浮点类型</a></h2><p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p><p>下面是一个演示浮点数的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-序列-Range"><a href="#3-序列-Range" class="headerlink" title="3.序列(Range)"></a>3.<a href="https://course.rs/basic/base-type/numbers.html#%E5%BA%8F%E5%88%97range">序列(Range)</a></h2><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <strong><code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5</strong> ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终程序输出:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>序列只允许用于数字或字符类型</strong>，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-有理数和复数"><a href="#4-有理数和复数" class="headerlink" title="4.有理数和复数"></a>4.<a href="https://course.rs/basic/base-type/numbers.html#%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E5%A4%8D%E6%95%B0">有理数和复数</a></h2><p>Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：</p><ul><li>有理数和复数</li><li>任意大小的整数和任意精度的浮点数</li><li>固定精度的十进制小数，常用于货币相关的场景</li></ul><p>好在社区已经开发出高质量的 Rust 数值库：<a href="https://crates.io/crates/num">num</a>。</p><p>按照以下步骤来引入 <code>num</code> 库：</p><ol><li>创建新工程 <code>cargo new complex-num &amp;&amp; cd complex-num</code></li><li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = &quot;0.4.0&quot;</code></li><li>将 <code>src/main.rs</code> 文件中的 <code>main</code> 函数替换为下面的代码</li><li>运行 <code>cargo run</code></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> num::complex::Complex;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = Complex &#123; re: <span class="number">2.1</span>, im: -<span class="number">1.2</span> &#125;;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">b</span> = Complex::<span class="title function_ invoke__">new</span>(<span class="number">11.1</span>, <span class="number">22.2</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">result</span> = a + b;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125;i&quot;</span>, result.re, result.im)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://course.rs/basic/base-type/numbers.html#%E6%80%BB%E7%BB%93">总结</a></h4><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p><ul><li><strong>Rust 拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li><li><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</li><li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整：<code>13.14_f32.round()</code>，在这里我们使用了类型后缀，因为编译器需要知道 <code>13.14</code> 的具体类型</li></ul><h2 id="5-函数要点"><a href="#5-函数要点" class="headerlink" title="5.函数要点"></a>5.<a href="https://course.rs/basic/base-type/function.html#%E5%87%BD%E6%95%B0%E8%A6%81%E7%82%B9">函数要点</a></h2><ul><li>函数名和变量名使用<a href="https://course.rs/practice/naming.html">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; &#123;&#125;</code></li><li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li><li>每个函数参数都需要标注类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn add(i: i32, j: i32) -&gt; i32 &#123;</span><br><span class="line">   i + j</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png" alt="img"></p><h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><p>​<a href="https://course.rs/basic/base-type/function.html#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC">无返回值<code>()</code></a></p><ul><li>函数没有返回值，那么返回一个 <code>()</code></li><li>通过 <code>;</code> 结尾的表达式返回一个 <code>()</code></li></ul><p>​    <a href="https://course.rs/basic/base-type/function.html#%E6%B0%B8%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0-">永不返回的发散函数 <code>!</code></a></p><p>​当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p><h2 id="6-练习"><a href="#6-练习" class="headerlink" title="6.练习"></a>6.练习</h2><p><a href="https://zh.practice.rs/basic-types/numbers.html">数值类型 - Rust By Practice( Rust 练习实践 )</a></p><figure class="highlight plaintext"><figcaption><span>填空</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v: u16 = 38_u8 as u16; //从8位无符号整数（u8）到16位无符号整数（u16）的类型转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 修改 `assert_eq!` 让代码工作</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;//i32</span><br><span class="line">    assert_eq!(&quot;i32&quot;.to_string(), type_of(&amp;x)); //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;</span><br><span class="line">fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123;</span><br><span class="line">    format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    assert_eq!(i8::MAX, 127); </span><br><span class="line">    assert_eq!(u8::MAX, 255); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 解决代码中的错误和 `panic`</span><br><span class="line">fn main() &#123;</span><br><span class="line">   let v1 = 251_u8.wrapping_add(8);</span><br><span class="line">   let v2 = match u8::checked_add(251, 8) &#123;</span><br><span class="line">        Some(value) =&gt; value,</span><br><span class="line">        None =&gt; &#123;</span><br><span class="line">            println!(&quot;Overflow occurred.&quot;);</span><br><span class="line">            0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">   println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 1_000.000_1; // f64</span><br><span class="line">    let y: f32 = 0.12; // f32</span><br><span class="line">    let z = 0.01_f64; // f64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#使用两种方法来让下面代码工作</span><br><span class="line">fn <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    assert!(<span class="number">0.1</span>+<span class="number">0.2</span>==<span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"> fn <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     assert!(<span class="number">0.1</span>_f32+<span class="number">0.2</span>_f32==<span class="number">0.3</span>_f32);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//降低精度</span></span><br><span class="line">fn <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    let eps=<span class="number">0.001</span>;</span><br><span class="line">    assert!((<span class="number">0.1</span>_f64+ <span class="number">0.2</span> - <span class="number">0.3</span>).<span class="built_in">abs</span>() &lt; eps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置允许误差</span></span><br></pre></td></tr></table></figure><h3 id="序列Range"><a href="#序列Range" class="headerlink" title="序列Range"></a><a href="https://zh.practice.rs/basic-types/numbers.html#%E5%BA%8F%E5%88%97range">序列Range</a></h3><ol><li>🌟🌟 两个目标: 1. 修改 <code>assert!</code> 让它工作 2. 让 <code>println!</code> 输出: 97 - 122</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut sum = 0;</span><br><span class="line">    for i in -3..2 &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert!(sum == -5);</span><br><span class="line"></span><br><span class="line">    for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,c as u8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>填空</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::&#123;Range, RangeInclusive&#125;;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;);</span><br><span class="line">    assert_eq!((1..=5), RangeInclusive::new(1, 5));</span><br><span class="line">&#125;</span><br><span class="line">///RangeInclusive::new(1, 5) 创建的是一个闭区间，表示从 1 到 5（包括 5）的范围。若 (1..5) 创建的是一个半开区间，表示从 1 到 5（不包括 5）的范围。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use std::mem::size_of_val;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let unit: () = ();</span><br><span class="line">    assert!(size_of_val(&amp;unit) == 0);//单元类型占用的内存大小 0</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a><a href="https://zh.practice.rs/basic-types/statements-expressions.html#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F">语句与表达式</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let v = &#123;</span><br><span class="line">       let mut x = 1;</span><br><span class="line">       x += 2// 没有返回值  </span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   assert_eq!(v, 3);</span><br><span class="line">&#125;</span><br><span class="line">正确的做法</span><br><span class="line">fn main() &#123;</span><br><span class="line">   let v = &#123;</span><br><span class="line">       let mut x = 1;</span><br><span class="line">       x += 2;</span><br><span class="line">       x</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   assert_eq!(v, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let z = &#123;</span><br><span class="line">// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`</span><br><span class="line">2 * x;</span><br><span class="line">&#125;;</span><br><span class="line">fn main() &#123;</span><br><span class="line">   let v = &#123; let x = 3; x&#125;;</span><br><span class="line"></span><br><span class="line">   assert!(v == 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><a href="https://zh.practice.rs/basic-types/functions.html#%E5%87%BD%E6%95%B0">函数</a></h3><h2 id="7-总结："><a href="#7-总结：" class="headerlink" title="7.总结："></a>7.总结：</h2><p>1.<code>let x = 2.0; // f64</code></p><p>2.比较浮点数<code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code></p><p>3.<code>编译器会进行自动推导，给予twenty i32的类型  let twenty = 20;</code></p><p>4.按照补码循环溢出规则处理<code>et b = 255_u8.wrapping_add(20);  // 19</code>  <code>在 u8 的情况下，256 变成 0，257 变成 1，</code></p><p>5.<code>(1..5)  表示从 1 到 5（不包括 5）半开区间的范围</code></p><p>6.<code>(1..=5)  表示从 1 到 5（包括 5）半闭区间的范围</code></p><p>6.<strong>表达式不能包含分号</strong>。<code>表达式总要返回值</code></p><p>7.返回值为！的表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop &#123;&#125;  </span><br><span class="line">panic!(&quot;Never return&quot;);  </span><br><span class="line">todo!();  </span><br><span class="line">unimplemented!();  //未实现的占位符函数</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> rust基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-rust环境搭建</title>
      <link href="/2023/08/26/01-rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/08/26/01-rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>当前环境：win11+wsl+vscode</p><h2 id="1-安装rustup"><a href="#1-安装rustup" class="headerlink" title="1.安装rustup"></a>1.安装rustup</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br><span class="line">sudo apt install build-essential</span><br><span class="line">rustc -V </span><br><span class="line">cargo -V</span><br></pre></td></tr></table></figure><h2 id="2-安装vsocode插件"><a href="#2-安装vsocode插件" class="headerlink" title="2.安装vsocode插件"></a>2.安装vsocode插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rust-analyzer ，Rust 语言插件</span><br><span class="line">Even Better TOML，支持 .toml 文件完整特性</span><br><span class="line">Error Lens, 更好的获得错误展示</span><br><span class="line">One Dark Pro, 非常好看的 VSCode 主题</span><br><span class="line">CodeLLDB, Debugger 程序</span><br></pre></td></tr></table></figure><h2 id="3-运行hello-world"><a href="#3-运行hello-world" class="headerlink" title="3.运行hello world!"></a>3.运行hello world!</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cargo new world_hello</span><br><span class="line">cd world_hello</span><br><span class="line">cargo run</span><br><span class="line">#编译</span><br><span class="line">cargo build</span><br><span class="line">#运行</span><br><span class="line">./target/debug/world_hello</span><br><span class="line">Hello, world!</span><br><span class="line">#快速的检查一下代码能否编译通过</span><br><span class="line">cargo check</span><br></pre></td></tr></table></figure><h2 id="4-修改-Rust-的下载镜像为国内的镜像地址"><a href="#4-修改-Rust-的下载镜像为国内的镜像地址" class="headerlink" title="4.修改 Rust 的下载镜像为国内的镜像地址"></a>4.修改 Rust 的下载镜像为国内的镜像地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#在 $HOME/.cargo/config.toml 添加以下内容：</span><br><span class="line"></span><br><span class="line">[source.crates-io]</span><br><span class="line">replace-with = &#x27;ustc&#x27;</span><br><span class="line"></span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> rust环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00-rust学习网站</title>
      <link href="/2023/08/26/00-rust%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/"/>
      <url>/2023/08/26/00-rust%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h1><p><a href="https://github.com/sunface/rust-course">GitHub-rust</a></p><p><a href="https://course.rs/about-book.html">关于本书 - Rust语言圣经(Rust Course)</a></p>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习网站 </tag>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github+hexo 博客搭建</title>
      <link href="/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/08/25/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>@[toc]<br>环境：win11+wsl</p><h2 id="1-安装Node-js、Git和Hexo"><a href="#1-安装Node-js、Git和Hexo" class="headerlink" title="1.安装Node.js、Git和Hexo"></a>1.安装Node.js、Git和Hexo</h2><p>打开终端安装以下软件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install git</span><br><span class="line"></span><br><span class="line">sudo apt install nodejs</span><br><span class="line">sudo apt install npm        #Node.js 的包管理器</span><br><span class="line">sudo npm install -g hexo-cli        #安装hexo</span><br></pre></td></tr></table></figure><h2 id="2-创建-GitHub-仓库并配置ssh"><a href="#2-创建-GitHub-仓库并配置ssh" class="headerlink" title="2.创建 GitHub 仓库并配置ssh"></a>2.创建 GitHub 仓库并配置ssh</h2><p>登录你的 GitHub 帐号，并创建一个新的仓库，仓库名是 <code>&lt;username&gt;.github.io</code>，其中 <code>&lt;username&gt;</code> 是你的 GitHub 用户名。将该仓库设置为公开仓库。<br>设置ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br><span class="line">cat ~/.ssh/id_rsa.pub  #将里面的内容复制到 github -&gt;settings -&gt;SSH and GPC keys -&gt;SSH keys -&gt;New SSH key中</span><br><span class="line">ssh -T git@github.com  #输入yes之后，行末尾会显示你的用户名（绑定成功邮箱会收到邮件提醒）</span><br><span class="line">#接着在本地绑定与Github的用户名和邮箱（git）</span><br><span class="line">git config --global user.name &quot;&lt;username&gt;&quot;    #自己的用户名</span><br><span class="line">git config --global user.email &#x27;xxx@xxx.com&#x27;  #自己的邮箱</span><br></pre></td></tr></table></figure><h2 id="3-初始化Hexo"><a href="#3-初始化Hexo" class="headerlink" title="3.初始化Hexo"></a>3.初始化Hexo</h2><p>创建一个新的文件夹，用于存储你的博客项目。<br>在终端中，进入该文件夹，并运行以下命令来初始化 Hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir myblog</span><br><span class="line">hexo init    </span><br><span class="line">#或者直接一步到位 </span><br><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><h2 id="4-配置Hexo"><a href="#4-配置Hexo" class="headerlink" title="4.配置Hexo"></a>4.配置Hexo</h2><ul><li>进入你的 Hexo 项目文件夹，找到 _config.yml 文件，使用文本编辑器打开它。</li><li>在 _config.yml 文件中，配置你的博客设置，例如标题、描述、作者等。</li><li>根据需要，你还可以配置主题、插件和其他 Hexo 选项。<br>编辑_config.yml文件，添加如下内容 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">        type: git</span><br><span class="line">        repo: git@github.com: &lt;username&gt;/ &lt;username&gt;.github.io.git  #&lt;username&gt;为自己的用户名</span><br><span class="line">        branch: main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git    #安装 hexo-deployer-git 插件 将部署过程自动化</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-创建博客内容"><a href="#5-创建博客内容" class="headerlink" title="5.创建博客内容"></a>5.创建博客内容</h2><p>在终端中，运行以下命令来创建新的博客文章：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My First Post&quot;</span><br></pre></td></tr></table></figure><p>这将在 Hexo 项目的 source&#x2F;_posts 目录下创建一个新的 Markdown 文件，用于编写你的第一篇博客文章。</p><h2 id="6-部署"><a href="#6-部署" class="headerlink" title="6.部署"></a>6.部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo s    # 预览</span><br><span class="line">#Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">#用浏览器打开 http://localhost:4000/</span><br><span class="line">hexo g #生成静态网站文件</span><br><span class="line">hexo d #将生成的静态网站文件部署到github</span><br></pre></td></tr></table></figure><h2 id="7-查看"><a href="#7-查看" class="headerlink" title="7.查看"></a>7.查看</h2><p>浏览器打开<code>&lt;username&gt;.github.io</code>即可查看</p><h2 id="8-参考："><a href="#8-参考：" class="headerlink" title="8.参考："></a>8.参考：</h2><p><a href="https://blog.csdn.net/qq_62928039/article/details/130248518">https://blog.csdn.net/qq_62928039/article/details/130248518</a></p><h2 id="9-选择主题："><a href="#9-选择主题：" class="headerlink" title="9.选择主题："></a>9.选择主题：</h2><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br><a href="https://github.com/yelog/hexo-theme-3-hexo">https://github.com/yelog/hexo-theme-3-hexo</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在hexo根目录下</span><br><span class="line">git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</span><br><span class="line">#修改hexo根目录的_config.yml，如下</span><br><span class="line">theme: 3-hexo</span><br><span class="line">#博客配置</span><br><span class="line">http://yelog.org/2017/03/23/3-hexo-instruction/</span><br></pre></td></tr></table></figure><p>最终效果：<br><a href="https://yyheroi.github.io/">https://yyheroi.github.io</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/08/25/hello-world/"/>
      <url>/2023/08/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
